[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Embedded AI: Principles, Algorithms, and Applications",
    "section": "",
    "text": "Preface\nIn “Embedded AI: Principles, Algorithms, and Applications”, we will embark on a critical exploration of the rapidly evolving field of artificial intelligence in the context of embedded systems, originally nurtured from the foundational course, tinyML from CS249r.\nThe goal of this book is to bring about a collaborative endeavor with insights and contributions from students, practitioners and the wider community, blossoming into a comprehensive guide that delves into the principles governing embedded AI and its myriad applications.\nAs a living document, this open-source textbook aims to bridge gaps and foster innovation by being globally accessible and continually updated, addressing the pressing need for a centralized resource in this dynamic field. With a rich tapestry of knowledge woven from various expert perspectives, readers can anticipate a guided journey that unveils the intricate dance between cutting-edge algorithms and the principles that ground them, paving the way for the next wave of technological transformation.\n\n\nThe Philosophy Behind the Book\nWe live in a world where technology perpetually reshapes itself, fostering an ecosystem of open collaboration and knowledge sharing stands as the cornerstone of innovation. This philosophy fuels the creation of “Embedded AI: Principles, Algorithms, and Applications.” This is a venture that transcends conventional textbook paradigms to foster a living repository of knowledge. Anchoring its content on principles, algorithms, and applications, the book aims to cultivate a deep-rooted understanding that empowers individuals to navigate the fluid landscape of embedded AI with agility and foresight. By embracing an open approach, we not only democratize learning but also pave avenues for fresh perspectives and iterative enhancements, thus fostering a community where knowledge is not confined but is nurtured to grow, adapt, and illuminate the path of progress in embedded AI technologies globally.\n\n\nPrerequisites\nVenturing into “Embedded AI: Principles, Algorithms, and Applications” does not mandate you to be a maestro in machine learning from the outset. At its core, this resource seeks to nurture learners who bear a fundamental understanding of systems and harbor a curiosity to explore the confluence of disparate, yet interconnected domains: embedded hardware, artificial intelligence, and software. This confluence forms a vibrant nexus where innovations and new knowledge streams emerge, making a basic grounding in system operations a pivotal tool in navigating this dynamic space.\nMoreover, the goal of this book is to delve into the synergies created at the intersection of these fields, fostering a learning environment where the boundaries of traditional disciplines blur to give way to a holistic, integrative approach to modern technological innovations. Your interest in unraveling embedded AI technologies and low-level software mechanics would be guiding you through a rich learning experience.\n\n\nConventions Used in This Book\nPlease follow the conventions listed in Conventions\n\n\nHow to Contact Us\nPlease contact vj@eecs.harvard.edu\n\n\nHow to Contribute\nPlease see instructions at here.\n\n\nContributors\nPlease see Credits."
  },
  {
    "objectID": "acknowledgements.html",
    "href": "acknowledgements.html",
    "title": "Acknowledgements",
    "section": "",
    "text": "To every endeavor, there lies a tapestry of effort, woven with threads of inspiration, dedication, and collaboration. This book, born out of a collective spirit, is no exception.\nFirst and foremost, gratitude must be extended to our ever-expanding community on GitHub. Each contributor, whether through a paragraph, a sentence, or a mere punctuation correction, has imbued this work with a wealth of knowledge and perspective. To each of you, your gift of time and expertise has not gone unnoticed or unappreciated. This book is as much yours as it is any single individual’s.\nSpecial thanks to Professor Vijay Janapa Reddi, whose vision planted the seed for this collaboration. Your unwavering faith in the power of open-source communities and your dedication to guiding this project to fruition have been the guiding star throughout.\nWe are also deeply indebted to the developers and staff at GitHub. Your platform has redefined what is possible in the world of collaboration, allowing disparate voices from across the globe to unite in a harmonious undertaking. This book stands as a testament to what can be achieved when barriers to entry are lowered, and voices are amplified.\nTo every reader who embarks on this journey with us, we hope this work enriches your understanding and inspires your curiosity. Without readers, words would hold no weight. We wrote for you, with the belief that shared knowledge is the keystone to progress.\nLastly, but by no means least, our gratitude extends to friends, families, mentors, and everyone who offered words of encouragement, late-night discussions, and unwavering support as this book transitioned from idea to reality.\nMay this collaborative effort serve as a beacon for what is possible when hearts and minds come together in the name of knowledge and progress."
  },
  {
    "objectID": "copyright.html",
    "href": "copyright.html",
    "title": "Copyright",
    "section": "",
    "text": "This book is open-source and developed collaboratively through GitHub. Unless otherwise stated, this work is licensed under the Creative Commons Attribution-ShareAlike 4.0 International License (CC BY-SA 4.0). You can find the full text of the license here.\nContributors to this project have dedicated their contributions to the public domain or under the same open license as the original project. While the contributions are collaborative, each contributor retains copyright in their respective contributions.\nFor details on authorship, contributions, and how to contribute, please see the project repository on GitHub.\nAll trademarks and registered trademarks mentioned in this book are the property of their respective owners.\nThe information provided in this book is believed to be accurate and reliable. However, the authors, editors, and publishers cannot be held liable for any damages caused or alleged to be caused either directly or indirectly by the information contained in this book."
  },
  {
    "objectID": "about.html#overview",
    "href": "about.html#overview",
    "title": "About",
    "section": "Overview",
    "text": "Overview\nThis book is a collaborative effort started by the CS249r Tiny Machine Learning class at Harvard University. We intend for this book to become a community-driven effort to help educators and learners get started with TinyML. This living document will be continually updated as we continue to learn more about TinyML and how to teach it."
  },
  {
    "objectID": "about.html#topics-covered",
    "href": "about.html#topics-covered",
    "title": "About",
    "section": "Topics Covered",
    "text": "Topics Covered\nThe book covers a wide range of topics related to embedded machine learning, providing a comprehensive understanding of the field. The topics covered include:\n\nOverview and Introduction to Embedded Machine Learning\nData Engineering\nEmbedded Machine Learning Frameworks\nEfficient Model Representation and Compression\nPerformance Metrics and Benchmarking of ML Systems\nLearning on the Edge\nHardware Acceleration for Edge ML: GPUs, TPUs, and FPGAs\nEmbedded MLOps\nSecure and Privacy-Preserving On-Device ML\nResponsible AI\nSustainability at the Edge\nGenerative AI at the Edge\n\nBy the end of this book, you will gain a brief introduction to machine learning and IoT. You will learn about real-world deployments of embedded machine learning systems. We hope you will also gain practical experience through hands-on project assignments."
  },
  {
    "objectID": "about.html#intended-audience",
    "href": "about.html#intended-audience",
    "title": "About",
    "section": "Intended Audience",
    "text": "Intended Audience\n\nEmbedded Systems Engineers: This book is a valuable resource for engineers working in the field of embedded systems. It provides a solid foundation in TinyML, allowing them to design and implement intelligent applications on microcontrollers and other embedded platforms with limited resources.\nComputer Science and Electrical Engineering Students: Students pursuing degrees in computer science and electrical engineering can benefit from this book. It offers an introduction to the concepts, algorithms, and techniques used in TinyML, preparing students to tackle real-world challenges in the emerging field of embedded machine learning.\nResearchers and Academics: Researchers and academics in the field of machine learning, computer vision, and signal processing will find this book useful. It offers insights into the unique challenges of deploying machine learning algorithms on low-power, low-memory devices, enabling them to develop new approaches and advance the field of TinyML.\nIndustry Professionals: Professionals working in industries like IoT, robotics, wearable technology, and smart devices will find this book relevant. It equips them with the knowledge required to integrate machine learning capabilities into their products, enabling intelligent and autonomous behavior."
  },
  {
    "objectID": "about.html#key-features",
    "href": "about.html#key-features",
    "title": "About",
    "section": "Key Features",
    "text": "Key Features\n\nIntroduction to Machine Learning: A fundamental understanding of machine learning concepts, including supervised, unsupervised, and reinforcement learning.\nTinyML Fundamentals: Exploring the challenges and constraints associated with deploying machine learning on small, low-power devices.\nHardware Platforms: Coverage of popular microcontrollers and development boards specifically designed for TinyML applications, along with their architecture and specifications.\nTraining Models: Techniques and tools for training machine learning models suitable for embedded systems, including considerations for model size, accuracy, and resource utilization.\nOptimization Techniques: Strategies for model compression, quantization, and algorithmic optimization to ensure efficient execution on resource-constrained devices.\nReal-world Applications: Practical use cases and examples demonstrating the deployment of TinyML in various domains, such as industrial automation, healthcare, and environmental monitoring.\nChallenges and Future Trends: Discussion on the current challenges in TinyML, potential solutions, and emerging trends in the field.\n\nBy encompassing these aspects, our aim is to make this book a go-to resource for anyone interested in developing intelligent applications on embedded systems."
  },
  {
    "objectID": "about.html#prerequisites",
    "href": "about.html#prerequisites",
    "title": "About",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nBasic Programming Knowledge: It is recommended that readers have some prior experience with programming, preferably in Python. Understanding variables, data types, control structures, and basic programming concepts will facilitate comprehension and engagement with the book.\nFamiliarity with Machine Learning Concepts: While not essential, a basic understanding of machine learning concepts, such as supervised and unsupervised learning, will help readers grasp the material more easily. However, the book provides sufficient explanations to bring readers up to speed if they are new to the field.\nPython Programming Skills (Optional): Readers with some Python programming experience will have an advantage when engaging with the coding portions of the book. Familiarity with libraries such as NumPy, scikit-learn, and TensorFlow will greatly facilitate the implementation and experimentation with machine learning models.\nLearning Mindset: The book has been structured to be accessible to a wide audience, including readers with varying levels of technical expertise. It provides a gradual learning curve, allowing readers to start with general knowledge about the field, progress to coding exercises, and potentially advance to deploying models on embedded devices. However, to fully benefit from the book, readers should be willing to challenge themselves and engage in practical exercises and projects.\nAvailability of Resources: To fully explore the practical aspects of TinyML, readers should have access to the necessary resources. These include a computer with Python and relevant libraries installed, as well as optional access to an embedded development board or microcontroller for experimenting with deploying machine learning models.\n\nBy ensuring that these general requirements are met, readers will have the opportunity to broaden their understanding of TinyML, gain hands-on experience with coding exercises, and even venture into practical implementation on embedded devices, enabling them to push the boundaries of their knowledge and skills."
  },
  {
    "objectID": "dedication.html",
    "href": "dedication.html",
    "title": "Dedication",
    "section": "",
    "text": "This book is a testament to the idea that, in the vast expanse of technology and innovation, it’s not always the largest systems, but the smallest ones, that can change the world."
  },
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "1  Introduction",
    "section": "",
    "text": "Welcome to our comprehensive guide to Tiny Machine Learning (TinyML), where we endeavor to bring a fresh perspective to the rapidly emerging field that straddles the domains of electrical engineering, computer science, and applied data science. This book aims to close the gap between complex machine learning abstractions and real-world applications on small devices, providing both theory enthusiasts and practitioners an end-to-end understanding of TinyML.\nWe begin with an overall introduction to the field of embedd systems and machine learning. We start by elaborating on the key principles of embedded systems, setting the groundwork for embedded machine learning. Then we pivot our attention to deep learning, focusing specifically on deep learning methods given their representation capacity and overall performance in a variety of tasks, especially when applied to small devices.\nThe book goes on to discuss step-by-step workflows in machine learning, data engineering, pre-processing, and advanced model training techniques. It provides comprehensive analyses of several in-use machine learning frameworks, and how they can be employed effectively to develop efficient AI models.\nIn a world where efficiency is key, we also discuss TinyML model optimization and deployment strategies. Special focus is given to on-device learning. How do we train a machine learning model on a tiny device while achieving admirable efficiency? What are the current hardware acceleration techniques? And how can we manage the lifecycle of these models? The reader can expect exhaustive answers to these and many more questions in our dedicated chapters.\nImportantly, we adopt a forward-looking stance, discussing the sustainability and ecological footprint of AI. We explore the location of TinyML within such debates, and how TinyML may contribute to more sustainable and responsible practices.\nFinally, the book ends with a speculative leap into the world of generative AI, outlining its potentials in the TinyML context.\nWhether you are an absolute beginner, a professional in the field, or an academic pursuing rigorous research, this book aims to offer a seamless blend of essential theory and practical insight, triggering stimulating conversations around TinyML. Let’s embark on this thrilling journey to explore the incredible world of TinyML!"
  },
  {
    "objectID": "embedded_sys.html#introduction-to-embedded-systems",
    "href": "embedded_sys.html#introduction-to-embedded-systems",
    "title": "2  Embedded Systems",
    "section": "2.1 Introduction to Embedded Systems",
    "text": "2.1 Introduction to Embedded Systems\n\n2.1.1 Definition and Characteristics\nEmbedded systems are specialized computing systems that do not look like computers. They are dedicated to specific tasks and “embed” as part of a larger device. Unlike general-purpose computers that can run a wide variety of applications, embedded systems perform pre-defined tasks, often with very specific requirements. Since they are task-specific, their design ensures optimized performance and reliability. The characteristics that define these systems are as follows:\n\nDedicated Functionality: They are designed to execute a specific function or a set of closely related functions. This focus on specific tasks allows them to be optimized, offering faster performance and reliability.\nReal-Time Operation: Many embedded systems operate in real-time, which means they are required to respond to inputs or changes in the environment immediately or within a predetermined time frame.\nIntegration with Physical Hardware: Embedded systems are closely integrated with physical hardware, making them more mechanically inclined compared to general-purpose computing systems.\nLong Lifecycle: These systems typically have a long lifecycle and can continue to function for many years after their initial deployment.\nResource Constraints: Embedded systems are often resource-constrained, operating with limited computational power and memory. This necessitates the development of efficient algorithms and software.\n\n\n\n2.1.2 Historical Background\nEmbedded systems have a rich history, with their roots tracing back to the 1960s when the first microprocessor, the Figure 2.1, made its debut. This paved the way for the creation of the first embedded system which was used in the Apollo Guidance Computer, the primary navigation system of the Apollo spacecraft. Over the years, the field has evolved dramatically, finding applications in various domains including automotive electronics, consumer electronics, telecommunications, and healthcare, among others.\n\n\n\nFigure 2.1: Intel 4004\n\n\n\n\n2.1.3 Importance in tinyML\nIn the context of tinyML, embedded systems represent a significant frontier. The incorporation of machine learning models directly onto these systems facilitates intelligent decision-making at the edge, reducing latency and enhancing security. Here are several reasons why embedded systems are critical in the tinyML landscape:\n\nEdge Computing: By bringing computation closer to the data source, embedded systems enhance efficiency and reduce the necessity for constant communication with centralized data centers.\nLow Power Consumption: Embedded systems in tinyML are designed to consume minimal power, a critical requirement for battery-operated devices and IoT applications.\nReal-Time Analysis and Decision Making: Embedded systems can facilitate real-time data analysis, allowing for immediate decision-making based on the insights generated.\nSecurity and Privacy: Processing data locally on embedded systems ensures better security and privacy, as it reduces the chances of data interception during transmission.\nCost-Effective: Implementing ML models on embedded systems can be cost-effective, especially in scenarios where data transmission and storage in cloud servers might incur significant costs.\n\nAs we venture deeper into this chapter, we will unveil the intricacies that govern the functioning of embedded systems and explore how they form the bedrock upon which tinyML stands, promising a future of integrated, intelligent, and efficient devices and systems."
  },
  {
    "objectID": "embedded_sys.html#architecture-of-embedded-systems",
    "href": "embedded_sys.html#architecture-of-embedded-systems",
    "title": "2  Embedded Systems",
    "section": "2.2 Architecture of Embedded Systems",
    "text": "2.2 Architecture of Embedded Systems\nThe architecture of embedded systems forms the blueprint that delineates the structure and functioning of these specialized systems. It provides insights into how different components within an embedded system interact and collaborate to achieve specific functionalities. This section dissects the integral components of the architecture - microcontrollers, microprocessors, different memory types and their management, and the intricacies of System on Chip (SoC).\n\n2.2.1 Microcontrollers vs Microprocessors\nUnderstanding the difference between microcontrollers and microprocessors is pivotal to grasping the fundamentals of embedded system architecture. Here, we delve into the characteristics of both:\n\nMicrocontrollers\nMicrocontrollers are compact, integrated circuits designed to govern specific operations in an embedded system. They house a processor, memory, and input/output peripherals in a single unit as shown in Figure 2.2, facilitating simplicity and ease of operation. Microcontrollers are typically used in products where the computational requirements are not highly demanding, and cost-effectiveness is a priority.\nCharacteristics:\n\nSingle-chip solution\nOn-chip memory and peripherals\nLow power consumption\nIdeal for control-oriented applications\n\n\n\n\n\nFigure 2.2: Microcontrollers\n\n\n\nMicroprocessors\nOn the other hand, microprocessors are more complex, forming the central processing unit within a system, lacking the integrated memory and I/O peripherals found in microcontrollers. They are usually found in systems that demand higher computational power and flexibility. These are used in devices where substantial processing power is required, and the tasks are more data-intensive.\nCharacteristics:\n\nRequires external components such as memory and I/O peripherals\nHigher processing power compared to microcontrollers\nMore flexible in terms of connectivity with various components\nIdeal for data-intensive applications\n\n\n\n\n2.2.2 Memory Types and Management\nEmbedded systems leverage various types of memory, each serving distinct purposes. Effective memory management is crucial to optimize performance and resource utilization. Below we discuss different memory types and how they are managed in an embedded system environment:\n\nROM (Read-Only Memory): This is non-volatile memory where data is written during manufacturing and remains unchanged throughout the device’s life. It stores the firmware and boot-up instructions.\nRAM (Random Access Memory): A volatile memory used to store temporary data generated during the system’s operation. It is faster and allows read-write operations, but data is lost once power is turned off.\nFlash Memory: A non-volatile memory type that can be electrically erased and reprogrammed. It finds applications in storing firmware or data that needs to persist between reboots.\n\nMemory Management:\n\nStatic Memory Allocation: Memory is allocated before runtime, and the allocation does not change during the system’s operation.\nDynamic Memory Allocation: Memory is allocated at runtime, allowing flexibility but at the cost of increased complexity and potential memory leaks.\n\n\n\n2.2.3 System on Chip (SoC)\nMost embedded systems are SoCs. A System on Chip (SoC) represents an advanced integration technology where most of the components required to build a complete system are integrated onto a single chip. It usually contains a microprocessor or microcontroller, memory blocks, peripheral interfaces, and other components required for a fully functioning system. Here’s a deeper look at its characteristics and applications:\n\nIntegration of Multiple Components: SoCs house multiple components, including CPUs, memory, and peripherals, in a single chip, promoting higher integration levels and minimizing the need for external components.\nPower Efficiency: Due to the high level of integration, SoCs are often more power-efficient compared to systems built using separate chips.\nCost-Effectiveness: The integration leads to reduced manufacturing costs, as fewer separate components are required.\nApplications: SoCs find applications in a variety of domains, including mobile computing, automotive electronics, and IoT devices, where compact size and power efficiency are prized.\n\nHere are some examples of widely used SoCs that you may recognize given that they have found substantial applications across various domains:\n\nQualcomm Snapdragon: Predominantly found in smartphones and tablets, they offer a combination of processing power, graphics, and connectivity solutions.\nApple A-series: Custom SoCs developed by Apple, utilized in their range of iPhones, iPads, and even in some versions of Apple TV and HomePod. Notable examples include the A14 Bionic and A15 Bionic chips.\nSamsung Exynos: Developed by Samsung, these are utilized extensively in their range of smartphones, tablets, and other electronic devices.\nNVIDIA Tegra: Initially designed for mobile devices, they have found substantial applications in automotive and gaming consoles, like the Nintendo Switch. You can see a picture of it below in Figure 2.3.\nIntel Atom: These are used in a wide variety of systems including netbooks, smartphones, and even embedded systems owing to their power efficiency.\nMediaTek Helio: Popular in budget to mid-range smartphones, these chips offer a good balance of power efficiency and performance.\nBroadcom SoCs: Used extensively in networking equipment, Broadcom offers a range of SoCs with different functionalities including those optimized for wireless communications and data processing.\nTexas Instruments (TI) OMAP: These were popular in smartphones and tablets, offering a range of functionalities including multimedia processing and connectivity.\nXilinx Zynq: Predominantly used in embedded systems for industrial automation and for applications demanding high levels of data processing, such as advanced driver-assistance systems (ADAS).\nAltera SoC FPGA: Now under Intel, these SoCs integrate FPGA technology with ARM cores, offering flexibility and performance for various applications including automotive and industrial systems.\n\n\n\n\nFigure 2.3: NVIDIA’s Tegra 2 combines two ARM Cortex-A9 cores with an ARM7 for SoC management tasks.\n\n\nEach of these SoCs presents a unique set of features and capabilities, catering to the diverse needs of the rapidly evolving technology landscape. They integrate multiple components into a single chip, offering power efficiency, cost-effectiveness, and compact solutions for modern electronic devices."
  },
  {
    "objectID": "embedded_sys.html#embedded-systems-programming",
    "href": "embedded_sys.html#embedded-systems-programming",
    "title": "2  Embedded Systems",
    "section": "2.3 Embedded Systems Programming",
    "text": "2.3 Embedded Systems Programming\nEmbedded systems programming diverges considerably from traditional software development, specifically honed to navigate the limited resources and the real-time requirements frequently associated with embedded hardware. This section will illuminate the nuances of the different programming languages utilized, delve into the intricacies of firmware development, and explore the critical role of Real-time Operating Systems (RTOS) in this specialized field.\n\n2.3.1 Programming Languages: C, C++, Python, etc.\nThe selection of appropriate programming languages is crucial in embedded systems, often prioritizing direct hardware interaction and optimization of memory usage. Let us explore the specifics of these languages and how they stand apart from those typically utilized in more conventional systems:\n\nC: Traditionally the cornerstone of embedded systems programming, the C language facilitates direct interaction with hardware components, offering capabilities for bit-wise operations and manipulating memory addresses. Its procedural approach and low-level capabilities make it the favored choice for constrained environments, focusing on firmware development.\nC++: Building on the foundation laid by C, C++ integrates object-oriented principles, fostering organized and modular code development. Despite its inherent complexity, it is embraced in scenarios where higher-level abstractions do not compromise the granular control provided by C.\nPython: While not a classic choice for embedded systems due to its relative memory consumption and runtime delays, Python is finding its place in the embedded domain, especially in systems where resource constraints are less stringent. In recent times, a variant known as MicroPython has emerged, specifically tailored for microcontrollers. MicroPython retains the simplicity and ease of use of Python while being optimized for embedded environments, offering a flexible programming paradigm that facilitates rapid prototyping and development. For instance, the code snipped below shows how we can use MicroPython to interface with the pins on a PyBoard.\n\nimport pyb # Package from PyBoard\n\n# turn on an LED\npyb.LED(1).on()\n\n# print some text to the serial console\nprint('Hello MicroPython!')\nComparison with Traditional Systems: In stark contrast to conventional systems, where languages like Java, Python, or JavaScript are celebrated for their development ease and comprehensive libraries, embedded systems are geared towards languages that offer refined control over hardware components and potential optimization opportunities, carefully navigating the limited resources at their disposal.\n\n\n2.3.2 Firmware Development\nThe realm of firmware development within embedded systems encompasses crafting programs permanently stored in the non-volatile memory of hardware, thus ensuring persistent operation. Here, we delineate how it distinguishes itself from software development for traditional systems:\n\nResource Optimization: The necessity for constant optimization is paramount, enabling the code to function within the confines of restricted memory and processing capacities.\nHardware Interaction: Firmware typically exhibits a close-knit relationship with hardware, necessitating a profound comprehension of the hardware components and their functionalities.\nLifecycle Management: Firmware updates are less frequent compared to software updates in traditional systems, mandating rigorous testing procedures to avert failures that could culminate in hardware malfunctions.\nSecurity Concerns: Given its integral role, firmware is a potential target for security breaches, warranting meticulous scrutiny towards security elements, including secure coding practices and encryption protocols.\n\n\n\n2.3.3 Real-time Operating Systems (RTOS)\nRTOS serve as the backbone for real-time systems, orchestrating task execution in a predictable, deterministic manner. This is a sharp deviation from the operating systems in mainstream computing environments, as delineated below:\n\nDeterministic Timing: RTOS are structured to respond to inputs or events within a well-defined timeframe, meeting the critical time-sensitive requisites of many embedded systems.\nTask Prioritization: They facilitate task prioritization, where critical tasks are accorded precedence in processing time allocation over less vital tasks.\nMicrokernel Architecture: A substantial number of RTOS leverage a microkernel architecture, epitomizing minimalism and efficiency by focusing only on the necessary functionalities to facilitate their operations.\nMemory Management: Memory management in RTOS is often more streamlined compared to their counterparts in traditional operating systems, aiding in swift response times and operational efficacy.\n\nExamples of RTOS: Notable examples in this category include FreeRTOS, RTEMS, and VxWorks, each offering unique features tailored to meet the diverse requirements of various embedded systems applications."
  },
  {
    "objectID": "embedded_sys.html#interfaces-and-peripherals",
    "href": "embedded_sys.html#interfaces-and-peripherals",
    "title": "2  Embedded Systems",
    "section": "2.4 Interfaces and Peripherals",
    "text": "2.4 Interfaces and Peripherals\nEmbedded systems interact with the external world through various interfaces and peripherals, which are distinctly streamlined and specialized compared to general-purpose systems. Let’s delve into the specifics:\n\n2.4.1 Digital I/O\nDigital Input/Output (I/O) interfaces are foundational in embedded systems, allowing them to interact with other devices and components. For example, a digital I/O pin can be used to read a binary signal (0 or 1) from sensors or to control actuators.\nIn embedded systems, these I/O ports often need to function under strict timing constraints, something which is less prevalent in general-purpose computing systems. Furthermore, these systems are usually programmed to perform specific, optimized operations on digital signals, sometimes needing to work in real time or near-real-time environments.\n\n\n2.4.2 Analog Interfaces\nAnalog interfaces in embedded systems are crucial for interacting with a world that largely communicates in analog signals. These interfaces can include components like Analog-to-Digital Converters (ADCs) and Digital-to-Analog Converters (DACs). ADCs, for instance, can be used to read sensor data from environmental sensors like temperature or humidity sensors, translating real-world analog data into a digital format that can be processed by the microcontroller.\nCompared to general-purpose systems, embedded systems might employ analog interfaces in a more direct and frequent manner, especially in applications involving sensor integrations, which necessitate the conversion of a wide variety of analog signals to digital data for processing and analysis.\nIf you look closely enough in Figure 2.4, you will see there are indications of I/O pinouts for analog, digital, as well as communication layouts.\n\n\n\nFigure 2.4: Nicla Vision pinout\n\n\n\n\n2.4.3 Communication Protocols (SPI, I2C, UART, etc.)\nCommunication protocols serve as the conduits for facilitating communication between various components within or connected to an embedded system. Let’s explore a few widely adopted ones:\n\nSPI (Serial Peripheral Interface): This is a synchronous serial communication protocol, which is used for short-distance communication primarily in embedded systems. For example, it is often utilized in SD card and TFT display communications.\nI2C (Inter-Integrated Circuit): This is a multi-master, multi-slave, packet switched, single-ended, serial communication bus, which is used widely in embedded systems to connect low-speed peripherals to a motherboard, embedded system, or cellphone. It’s known for its simplicity and low pin count.\nUART (Universal Asynchronous Receiver-Transmitter): This communication protocol allows for asynchronous serial communication between devices. It’s widely used in embedded systems to transmit data between devices over a serial port, facilitating the transmission of data logs from a sensor node to a computer, for instance.\n\nCompared to general-purpose systems, communication protocols in embedded systems are often more optimized for speed and reliability, as they may be used in critical applications where data transmission integrity is paramount. Moreover, they might be directly integrated into the microcontroller, emphasizing a more harmonized and seamless interaction between components, which is typically not observed in general-purpose systems."
  },
  {
    "objectID": "embedded_sys.html#power-management-in-embedded-systems",
    "href": "embedded_sys.html#power-management-in-embedded-systems",
    "title": "2  Embedded Systems",
    "section": "2.5 Power Management in Embedded Systems",
    "text": "2.5 Power Management in Embedded Systems\nWhen engineering embedded systems, power management emerges as a pivotal focus area, shaping not only the system’s efficiency but also its viability in real-world applications. The sheer diversity in the deployment of embedded systems, ranging from handheld devices to industrial machinery, underscores the imperative to optimize power management meticulously. Let’s delve into this critical facet of embedded systems:\n\n2.5.1 Power Consumption Considerations\nIn embedded systems, power consumption is a vital parameter that governs the system’s performance and lifespan. Typically, microcontrollers in these systems operate in the range of 1.8V to 5V, with current consumption being in the microampere (μA) to milliampere (mA) range during active modes. In sleep or standby modes, the current consumption can plummet to nanoamperes (nA), ensuring battery longevity.\nComparatively, general-purpose computing systems, like personal computers, consume power in the order of tens to hundreds of watts, which is several orders of magnitude higher. This stark contrast delineates the necessity for meticulous power management in embedded systems, where the available power budget is often significantly restrained.\nThe intricacies of managing power consumption hinge on a variety of factors including the operating voltage, clock frequency, and the specific tasks being performed by the system. Often, engineers find themselves navigating a complex trade-off landscape, balancing power consumption against system performance and responsiveness.\n\n\n2.5.2 Energy-Efficient Design\nEmbedding energy efficiency into the design phase is integral to the successful deployment of embedded systems. Engineers often employ techniques such as dynamic voltage and frequency scaling (DVFS), which allows the system to adjust the voltage and frequency dynamically based on the processing requirements, thereby optimizing power consumption.\nAdditionally, leveraging low-power modes where non-essential peripherals are turned off or clock frequencies are reduced can significantly conserve power. For instance, utilizing deep sleep modes where the system consumes as little as 100 nA can dramatically enhance battery life, especially in battery-powered embedded systems.\nIn embedded systems, energy-efficient design isn’t confined to just power-saving modes and techniques like Dynamic Voltage and Frequency Scaling (DVFS); it extends fundamentally to the architecture of the microcontroller itself, particularly in its instruction set architecture (ISA).\nThe microcontroller instruction set architecture (ISA) in embedded systems is often highly specialized, stripped of any unnecessary complexities that might add to power consumption. This specialization facilitates executing operations using a smaller number of cycles compared to general-purpose processors, which, in turn, reduces the power consumption per operation. Moreover, these specialized ISAs are crafted to efficiently execute the specific types of tasks that the embedded system is designed to perform, optimizing the execution path and thereby conserving energy.\nFurthermore, it’s not uncommon to find RISC (Reduced Instruction Set Computer) architectures in embedded systems. These architectures utilize a smaller set of simple instructions compared to Complex Instruction Set Computer (CISC) architectures found in traditional general-purpose systems. This design choice significantly reduces the power consumed per instruction, making these microcontrollers inherently more energy-efficient.\nApart from ISAs, embedded microcontrollers are often integrated with peripherals and components that are tailored to exhibit minimal energy expenditure, further reinforcing the emphasis on energy efficiency. Through careful design, engineers can craft systems that harmoniously integrate performance requirements with power management strategies, crafting solutions that stand as testimony to innovation and sustainability in the field of embedded systems. This meticulous approach to design, focusing on both macro and micro-level optimizations, forms the bedrock of energy efficiency in embedded systems, differentiating them from their general-purpose counterparts which are often characterized by higher power consumption and a broader range of functionalities.\nBy focusing on these elements, engineers can forge pathways to create systems that not only fulfill their functional roles but do so with an acumen that reflects a deep understanding of the broader impacts of technology on society and the environment.\n\n\n2.5.3 Battery Management\nBattery management constitutes a vital part of power management strategies in embedded systems. The objective here is to maximize battery life without compromising system performance. Battery-powered embedded systems often employ lithium-ion or lithium-polymer batteries due to their high energy density and rechargeable nature. These batteries usually have a voltage range of 3.7V to 4.2V per cell. For instance, the Nicla Vision uses 3.7V battery as shown in Figure 2.5.\n\n\n\nFigure 2.5: Nicla Vision battery.\n\n\nEngineers need to incorporate strategies like efficient charge management, overvoltage protection, and temperature monitoring to safeguard the battery’s health and prolong its lifespan. Moreover, developing systems that can harvest energy from the environment, like solar or vibrational energy, can supplement battery power and create sustainable, long-lasting solutions.\nThe focus on power management stems from the necessity to optimize resource utilization, extend battery life, and reduce operational costs. In deployments where systems are remote or inaccessible, efficient power management can significantly reduce the need for maintenance interventions, thereby ensuring sustained, uninterrupted operation.\nOne could say that power management in embedded systems is not just a technical requirement but a critical enabler that can dictate the success or failure of a deployment. Engineers invest significantly in optimizing power management strategies to craft systems that are not only efficient but also sustainable, showcasing a deep-seated commitment to innovation and excellence in the embedded systems domain."
  },
  {
    "objectID": "embedded_sys.html#real-time-characteristics",
    "href": "embedded_sys.html#real-time-characteristics",
    "title": "2  Embedded Systems",
    "section": "2.6 Real-Time Characteristics",
    "text": "2.6 Real-Time Characteristics\nIn the intricate fabric of embedded systems, the real-time characteristics stand as defining threads, weaving together components and tasks into a coherent, responsive entity. This facet, which is often unique to embedded systems, holds a critical place in the architecture and operation of these systems, providing them with the agility and precision to interact with their environment in a timely manner. Let’s explore the intricacies that underline the real-time characteristics of embedded systems:\n\n2.6.1 Real-time Clocks\nReal-time clocks (RTCs) play a pivotal role in embedded systems, providing a precise time reference that governs the operations of the system. These clocks often have battery backups to ensure consistent timekeeping even when the main power source is unavailable. The utilization of RTCs is far more prevalent and critical in embedded systems compared to general-purpose computing systems, where timekeeping, although necessary, often doesn’t dictate the system’s core functionality.\nFor instance, in industrial automation systems, RTCs help in coordinating tasks with high precision, ensuring that processes occur in sync and without delay. They find significant applications in systems where time-stamped data logging is necessary, such as in environmental monitoring systems where data accuracy and time correlation are vital.\n\n\n2.6.2 Timing and Synchronization\nTiming and synchronization are hallmarks of embedded systems, where multiple components and processes need to work in harmony. The very essence of a real-time embedded system is dictated by its ability to perform tasks within a defined time frame. These systems usually have stringent timing requirements, demanding synchronization mechanisms that are both robust and precise.\nFor example, in automotive control systems, the timely and synchronized functioning of various sensors and actuators is non-negotiable to ensure safety and optimal performance. This is a stark contrast to general-purpose systems, where timing, although managed, doesn’t often have immediate and critical repercussions.\n\n\n2.6.3 Task Management and Scheduling\nIn embedded systems, task management and scheduling are critical to ensuring that the system can respond to real-time events effectively. Task schedulers in these systems might employ strategies such as priority scheduling, where tasks are assigned priority levels, and higher-priority tasks are allowed to pre-empt lower-priority tasks. This is particularly vital in systems where certain operations have a higher criticality.\nFor instance, in medical devices like pacemakers, the timely delivery of electrical pulses is a critical task, and the scheduling mechanism must prioritize this above all other tasks to ensure the patient’s safety. This finely tuned scheduling and task management is quite unique to embedded systems, distinguishing them markedly from the more flexible and less deterministic scheduling observed in general-purpose systems.\n\n\n2.6.4 Error Handling and Fault Tolerance\nTo further bolster their real-time characteristics, embedded systems often feature mechanisms for error handling and fault tolerance. These are designed to quickly identify and correct errors, or to maintain system operation even in the face of faults. In aviation control systems, for example, real-time fault tolerance is crucial to maintain flight stability and safety in drones. This level of meticulous error handling is somewhat distinctive to embedded systems compared to general-purpose systems, highlighting the critical nature of many embedded system applications.\nThe real-time characteristics of embedded systems set them apart, crafting a landscape where precision, synchrony, and timely responses are not just desired but mandatory. These characteristics find resonance in myriad applications, from automotive control systems to industrial automation and healthcare devices, underscoring the embedded systems’ role as silent, yet powerful, orchestrators of a technologically harmonized world. Through their real-time attributes, embedded systems are able to deliver solutions that not only meet the functional requirements but do so with a level of precision and reliability that is both remarkable and indispensable in the contemporary world. ## Security and Reliability\nIn a world that is ever-increasingly connected and reliant on technology, the topics of security and reliability have vaulted to the forefront of concerns in system design. Particularly in the realm of embedded systems, where these units are often integral parts in critical infrastructures and applications, the stakes are exponentially higher. Let’s delve into the vital aspects that uphold the fortress of security and reliability in embedded systems:"
  },
  {
    "objectID": "embedded_sys.html#security-and-reliability",
    "href": "embedded_sys.html#security-and-reliability",
    "title": "2  Embedded Systems",
    "section": "2.7 Security and Reliability",
    "text": "2.7 Security and Reliability\n\n2.7.1 Secure Boot and Root of Trust\nAs embedded systems find themselves at the heart of numerous critical applications, ensuring the authenticity and integrity of the system right from the moment of booting is paramount. The secure boot process is a cornerstone in this security paradigm, allowing the system to only execute code that is verified and trusted. This mechanism is often complemented by a “Root of Trust,” an immutable and trusted environment, usually hardware-based, that validates the initial firmware and subsequent software layers during the boot process.\nFor instance, in financial transactions using Point-of-Sale (POS) terminals, a secure boot process ensures that the firmware is unaltered and secure, thwarting attempts of malicious firmware alterations which can potentially lead to significant data breaches. Similarly, in home automation systems, a robust secure boot process prevents unauthorized access, safeguarding user privacy and data.\n\n\n2.7.2 Fault Tolerance\nFault tolerance is an indispensable attribute in embedded systems, bestowing the system with the resilience to continue operations even in the presence of faults or failures. This is achieved through various mechanisms like redundancy, where critical components are duplicated to take over in case of a failure, or through advanced error detection and correction techniques.\nIn applications such as aerospace and aviation, fault tolerance is not just a desirable feature but a mandatory requirement. Aircraft control systems, for instance, employ multiple redundant systems operating in parallel, ensuring continuous operation even in the case of a component failure. This level of fault tolerance ensures a high degree of reliability, making sure that the system can withstand failures without catastrophic consequences, a characteristic quite unique and elevated compared to traditional computing systems.\n\n\n2.7.3 Safety-Critical Systems\nSafety-critical systems are those where a failure could result in loss of life, significant property damage, or environmental harm. These systems require meticulous design to ensure the utmost reliability and safety. Embedded systems in this category often adhere to strict development standards and undergo rigorous testing to validate their reliability and safety characteristics.\nFor example, in automotive safety systems like Anti-lock Braking Systems (ABS) and Electronic Stability Control (ESC), embedded controllers play a pivotal role. These controllers are developed following stringent standards such as ISO 26262, ensuring that they meet the high reliability and safety requirements necessary to protect lives. In healthcare, devices like pacemakers and infusion pumps fall under this category, where the reliability of embedded systems can literally be a matter of life and death.\nThe emphasis on security and reliability in embedded systems cannot be overstated and I would state that these are often overlooked topics by most. As these systems intertwine deeper into the fabric of our daily lives and critical infrastructures, the doctrines of security and reliability stand as the beacon guiding the development and deployment of embedded systems. Through mechanisms like secure boot processes and fault tolerance techniques, these systems promise not only functional efficacy but also a shield of trust and safety, offering a robust and secure harbor in a sea of technological advancements and innovations. It’s these foundational principles that shape the embedded systems of today, sculpting them into reliable guardians and efficient executors in various critical spheres of modern society."
  },
  {
    "objectID": "embedded_sys.html#future-trends-and-challenges",
    "href": "embedded_sys.html#future-trends-and-challenges",
    "title": "2  Embedded Systems",
    "section": "2.8 Future Trends and Challenges",
    "text": "2.8 Future Trends and Challenges\nArm, the largest manufacturer of microcontrollers, has shipped (either directly or indirectly through partners) a record 8.0 billion chips, taking total shipped to date to more than a quarter of a trillion or 250 billion (ARM.com)!\nWe stand on the cusp of an era of unprecedented growth in the field of embedded systems, it is both exciting and crucial to cast a discerning eye on the possible future trends and challenges that await us. From the burgeoning realms of edge computing to the demands of scalability, the landscape is set to evolve, bringing forth new vistas of opportunities and trials. Let’s venture into the dynamic frontier that the future holds for embedded systems:\n\n2.8.1 Edge Computing and IoT\nWith the proliferation of the Internet of Things (IoT), the role of edge computing is becoming increasingly vital. Edge computing essentially allows data processing at the source, reducing latency and the load on central data centers. This paradigm shift is expected to redefine embedded systems, imbuing them with greater processing capabilities and intelligence to execute complex tasks locally.\nMoreover, with the IoT expected to encompass billions of devices globally, embedded systems will play a central role in facilitating seamless connectivity and interoperability among a diverse array of devices. This ecosystem would foster real-time analytics and decision-making, paving the way for smarter cities, industries, and homes. The challenge here lies in developing systems that are secure, energy-efficient, and capable of handling the surge in data volumes efficiently.\n\n\n2.8.2 Scalability and Upgradation\nAs embedded systems continue to evolve, the need for scalability and easy upgradation will become a focal point. Systems will be expected to adapt to changing technologies and user requirements without substantial overhauls. This calls for modular designs and open standards that allow for seamless integration of new features and functionalities.\nFurthermore, with the rapid advancements in technology, embedded systems will need to be equipped with mechanisms for remote upgrades and maintenance, ensuring their longevity and relevance in a fast-paced technological landscape. The onus will be on developers and manufacturers to create systems that not only meet the current demands but are also primed for future expansions, thereby ensuring a sustainable and progressive development trajectory.\n\n\n2.8.3 Market Opportunities\nThe market dynamics surrounding embedded systems are poised for exciting shifts. As industries increasingly adopt automation and digital transformation, the demand for sophisticated embedded systems is expected to soar. AI and ML are set to integrate deeper into embedded systems, offering unprecedented levels of intelligence and automation.\nSimultaneously, there is a burgeoning market for embedded systems in consumer electronics, automotive, healthcare, and industrial applications, presenting vast opportunities for innovation and growth. However, this expansion also brings forth challenges, including increased competition and the need for compliance with evolving regulatory standards. Companies venturing into this space will need to be agile, innovative, and responsive to the changing market dynamics to carve a niche for themselves.\n\n\n2.8.4 Conclusion\nAs we look into the horizon, it’s evident that the world of embedded systems is on the brink of a transformative phase, marked by innovations, opportunities, and challenges. The future beckons with promises of greater connectivity, intelligence, and efficiency, forging a path where embedded systems will be at the helm, steering the technological advancements of society. The journey ahead is one of exploration and adaptation, where the marriage of technology and ingenuity will craft a future that is not only technologically enriched but also responsive to the complex and ever-evolving demands of a dynamic world. It is a landscape ripe with potential, beckoning pioneers to venture forth and shape the contours of a promising and vibrant future.\n\n\n\n\nARM.com. “The Future Is Being Built on Arm: Market Diversification Continues to Drive Strong Royalty and Licensing Growth as Ecosystem Reaches Quarter of a Trillion Chips Milestone – Arm®.” https://www.arm.com/company/news/2023/02/arm-announces-q3-fy22-results."
  },
  {
    "objectID": "embedded_ml.html#cloudml",
    "href": "embedded_ml.html#cloudml",
    "title": "3  Embedded ML",
    "section": "3.1 CloudML",
    "text": "3.1 CloudML"
  },
  {
    "objectID": "embedded_ml.html#edgeml",
    "href": "embedded_ml.html#edgeml",
    "title": "3  Embedded ML",
    "section": "3.2 EdgeML",
    "text": "3.2 EdgeML"
  },
  {
    "objectID": "embedded_ml.html#tinyml",
    "href": "embedded_ml.html#tinyml",
    "title": "3  Embedded ML",
    "section": "3.3 TinyML",
    "text": "3.3 TinyML\n\n3.3.1 TinyML for IoT Systems\n\n\n3.3.2 How does TinyML Work\n\n\n3.3.3 Resources are Limited, but so is the Competition"
  },
  {
    "objectID": "embedded_ml.html#exercises",
    "href": "embedded_ml.html#exercises",
    "title": "3  Embedded ML",
    "section": "3.4 Exercises",
    "text": "3.4 Exercises"
  },
  {
    "objectID": "mlworkflow.html#data-collection",
    "href": "mlworkflow.html#data-collection",
    "title": "4  ML Workflow",
    "section": "4.1 Data Collection",
    "text": "4.1 Data Collection"
  },
  {
    "objectID": "mlworkflow.html#pre-processing",
    "href": "mlworkflow.html#pre-processing",
    "title": "4  ML Workflow",
    "section": "4.2 Pre-Processing",
    "text": "4.2 Pre-Processing"
  },
  {
    "objectID": "mlworkflow.html#training",
    "href": "mlworkflow.html#training",
    "title": "4  ML Workflow",
    "section": "4.3 Training",
    "text": "4.3 Training"
  },
  {
    "objectID": "mlworkflow.html#optimization",
    "href": "mlworkflow.html#optimization",
    "title": "4  ML Workflow",
    "section": "4.4 Optimization",
    "text": "4.4 Optimization"
  },
  {
    "objectID": "mlworkflow.html#deployment",
    "href": "mlworkflow.html#deployment",
    "title": "4  ML Workflow",
    "section": "4.5 Deployment",
    "text": "4.5 Deployment"
  },
  {
    "objectID": "mlworkflow.html#evaluation",
    "href": "mlworkflow.html#evaluation",
    "title": "4  ML Workflow",
    "section": "4.6 Evaluation",
    "text": "4.6 Evaluation"
  },
  {
    "objectID": "mlworkflow.html#quiz",
    "href": "mlworkflow.html#quiz",
    "title": "4  ML Workflow",
    "section": "4.7 Quiz",
    "text": "4.7 Quiz"
  },
  {
    "objectID": "data_engineering.html#data-sources",
    "href": "data_engineering.html#data-sources",
    "title": "5  Data Engineering",
    "section": "5.1 Data Sources",
    "text": "5.1 Data Sources"
  },
  {
    "objectID": "data_engineering.html#training-data",
    "href": "data_engineering.html#training-data",
    "title": "5  Data Engineering",
    "section": "5.2 Training Data",
    "text": "5.2 Training Data"
  },
  {
    "objectID": "data_engineering.html#training-data-splits",
    "href": "data_engineering.html#training-data-splits",
    "title": "5  Data Engineering",
    "section": "5.3 Training Data Splits",
    "text": "5.3 Training Data Splits"
  },
  {
    "objectID": "data_engineering.html#data-labeling",
    "href": "data_engineering.html#data-labeling",
    "title": "5  Data Engineering",
    "section": "5.4 Data Labeling",
    "text": "5.4 Data Labeling"
  },
  {
    "objectID": "data_engineering.html#types-of-data",
    "href": "data_engineering.html#types-of-data",
    "title": "5  Data Engineering",
    "section": "5.5 Types of Data",
    "text": "5.5 Types of Data"
  },
  {
    "objectID": "preprocessing.html#what-is-data-pre-processing",
    "href": "preprocessing.html#what-is-data-pre-processing",
    "title": "6  Pre-processing",
    "section": "6.1 What is Data Pre-processing?",
    "text": "6.1 What is Data Pre-processing?"
  },
  {
    "objectID": "preprocessing.html#whats-involved-with-data-pre-processing",
    "href": "preprocessing.html#whats-involved-with-data-pre-processing",
    "title": "6  Pre-processing",
    "section": "6.2 What’s Involved with Data Pre-processing?",
    "text": "6.2 What’s Involved with Data Pre-processing?"
  },
  {
    "objectID": "preprocessing.html#whats-the-importance-of-data-pre-processing",
    "href": "preprocessing.html#whats-the-importance-of-data-pre-processing",
    "title": "6  Pre-processing",
    "section": "6.3 What’s The Importance Of Data Pre-Processing?",
    "text": "6.3 What’s The Importance Of Data Pre-Processing?"
  },
  {
    "objectID": "frameworks.html",
    "href": "frameworks.html",
    "title": "7  ML Frameworks",
    "section": "",
    "text": "coming soon."
  },
  {
    "objectID": "training.html#selecting-a-training-dataset",
    "href": "training.html#selecting-a-training-dataset",
    "title": "8  Model Training",
    "section": "8.1 Selecting a Training Dataset",
    "text": "8.1 Selecting a Training Dataset"
  },
  {
    "objectID": "training.html#neural-network-architectures",
    "href": "training.html#neural-network-architectures",
    "title": "8  Model Training",
    "section": "8.2 Neural Network Architectures",
    "text": "8.2 Neural Network Architectures\n\n8.2.1 Multilayer Perceptron (MLP)\n\n\n8.2.2 Convolutional Neural Networks\n\n\n8.2.3 Recurrent Neural Networks\n\n\n8.2.4 Transformers"
  },
  {
    "objectID": "training.html#back-propagation",
    "href": "training.html#back-propagation",
    "title": "8  Model Training",
    "section": "8.3 Back Propagation",
    "text": "8.3 Back Propagation"
  },
  {
    "objectID": "training.html#convergence",
    "href": "training.html#convergence",
    "title": "8  Model Training",
    "section": "8.4 Convergence",
    "text": "8.4 Convergence"
  },
  {
    "objectID": "training.html#overfitting-and-underfitting",
    "href": "training.html#overfitting-and-underfitting",
    "title": "8  Model Training",
    "section": "8.5 Overfitting and Underfitting",
    "text": "8.5 Overfitting and Underfitting"
  },
  {
    "objectID": "training.html#hyperparameters",
    "href": "training.html#hyperparameters",
    "title": "8  Model Training",
    "section": "8.6 Hyperparameters",
    "text": "8.6 Hyperparameters\n\n8.6.1 Epochs\n\n\n8.6.2 Learning Rate"
  },
  {
    "objectID": "training.html#transfer-learning",
    "href": "training.html#transfer-learning",
    "title": "8  Model Training",
    "section": "8.7 Transfer Learning",
    "text": "8.7 Transfer Learning\n\n8.7.1 Optimizer"
  },
  {
    "objectID": "training.html#summary",
    "href": "training.html#summary",
    "title": "8  Model Training",
    "section": "8.8 Summary",
    "text": "8.8 Summary"
  },
  {
    "objectID": "training.html#quiz",
    "href": "training.html#quiz",
    "title": "8  Model Training",
    "section": "8.9 Quiz",
    "text": "8.9 Quiz"
  },
  {
    "objectID": "efficient_ai.html",
    "href": "efficient_ai.html",
    "title": "9  Efficient AI",
    "section": "",
    "text": "This is an efficient test of a forked repo."
  },
  {
    "objectID": "optimizations.html#software-optimizations",
    "href": "optimizations.html#software-optimizations",
    "title": "10  Optimizations",
    "section": "10.1 Software Optimizations",
    "text": "10.1 Software Optimizations\n\n10.1.1 Compression\n\n\n10.1.2 Quantization\n\n\n10.1.3 Weight Pruning\n\n\n10.1.4 Knowledge Distillation"
  },
  {
    "objectID": "optimizations.html#hardware-optimizations",
    "href": "optimizations.html#hardware-optimizations",
    "title": "10  Optimizations",
    "section": "10.2 Hardware Optimizations",
    "text": "10.2 Hardware Optimizations\n\n10.2.1 GPUs\n\n\n10.2.2 TPUs\n\n\n10.2.3 NPUs"
  },
  {
    "objectID": "ondevice_learning.html#federated-learning",
    "href": "ondevice_learning.html#federated-learning",
    "title": "12  On-Device Learning",
    "section": "12.1 Federated Learning",
    "text": "12.1 Federated Learning"
  },
  {
    "objectID": "ondevice_learning.html#on-device-training",
    "href": "ondevice_learning.html#on-device-training",
    "title": "12  On-Device Learning",
    "section": "12.2 On-Device Training",
    "text": "12.2 On-Device Training\ncoming soon."
  },
  {
    "objectID": "hw_acceleration.html",
    "href": "hw_acceleration.html",
    "title": "13  Hardware Acceleration",
    "section": "",
    "text": "coming soon."
  },
  {
    "objectID": "privacy_security.html",
    "href": "privacy_security.html",
    "title": "15  Privacy and Security",
    "section": "",
    "text": "coming soon."
  },
  {
    "objectID": "sustainable_ai.html",
    "href": "sustainable_ai.html",
    "title": "16  AI Sustainability",
    "section": "",
    "text": "coming soon."
  },
  {
    "objectID": "responsible_ai.html",
    "href": "responsible_ai.html",
    "title": "17  Responsible AI",
    "section": "",
    "text": "coming soon."
  },
  {
    "objectID": "generative_ai.html",
    "href": "generative_ai.html",
    "title": "18  Generative AI",
    "section": "",
    "text": "coming soon."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "ARM.com. “The Future Is Being Built on Arm: Market Diversification\nContinues to Drive Strong Royalty and Licensing Growth as Ecosystem\nReaches Quarter of a Trillion Chips Milestone – Arm®.” https://www.arm.com/company/news/2023/02/arm-announces-q3-fy22-results."
  }
]