<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ML Systems Textbook</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../contents/core/robust_ai/robust_ai.html" rel="next">
<link href="../../../contents/core/ondevice_learning/ondevice_learning.html" rel="prev">
<link href="../../../assets/images/icons/favicon.png" rel="icon" type="image/png">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-92151ed919028c7172e396588fd5eb2d.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-dark-92151ed919028c7172e396588fd5eb2d.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-92151ed919028c7172e396588fd5eb2d.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-05e89e679d74be0ec03b4dfad47f0489.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/bootstrap/bootstrap-dark-b37cd2072f26f54614d6b324860e7473.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/bootstrap/bootstrap-05e89e679d74be0ec03b4dfad47f0489.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/quarto-contrib/foldbox/foldbox.css" rel="stylesheet">
<script src="../../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "/"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-M21L0CBCVN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-M21L0CBCVN', { 'anonymize_ip': true});
</script>
<script type="application/json" class="js-hypothesis-config">
{
  "theme": "clean",
  "openSidebar": false
}
</script>
<script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&amp;family=JetBrains+Mono:wght@400;500&amp;display=swap" rel="stylesheet">
<link rel="manifest" href="../../../site.webmanifest">
<link rel="apple-touch-icon" href="../../../assets/images/icons/favicon.png">
<meta name="theme-color" content="#A51C30">

<script type="module" src="../../../tools/scripts/socratiQ/bundle.js" defer=""></script>
<script src="../../../assets/scripts/sidebar-auto-collapse.js" defer=""></script>
<script src="../../../assets/scripts/version-link.js" defer=""></script>
<script src="../../../assets/scripts/subscribe-modal.js" defer=""></script>
<style>
.callout-chapter-connection {
  --color1: #FDF2F7;
  --color2: #A51C30;
}
.callout-resource-exercises {
  --color1: #E0F2F1;
  --color2: #20B2AA;
}
.callout-definition {
  --color1: #F0F4F8;
  --color2: #1B4F72;
}
.callout-resource-slides {
  --color1: #E0F2F1;
  --color2: #20B2AA;
}
.callout-resource-videos {
  --color1: #E0F2F1;
  --color2: #20B2AA;
}
.callout-code {
  --color1: #F2F4F8;
  --color2: #D1D7E0;
}
.callout-quiz-question {
  --color1: #F0F0F8;
  --color2: #5B4B8A;
}
.callout-colab {
  --color1: #FFF5E6;
  --color2: #FF6B35;
}
.callout-quiz-answer {
  --color1: #E8F2EA;
  --color2: #4a7c59;
}
.callout-example {
  --color1: #F0F8F6;
  --color2: #148F77;
}
</style>
<style>
details.callout-chapter-connection > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout_chapter_connection.png");
}
details.callout-resource-exercises > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout_resource_exercises.png");
}
details.callout-definition > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout_definition.png");
}
details.callout-resource-slides > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout_resource_slides.png");
}
details.callout-resource-videos > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout_resource_videos.png");
}
details.callout-code > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout_code.png");
}
details.callout-quiz-question > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout_quiz_question.png");
}
details.callout-colab > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout_colab.png");
}
details.callout-quiz-answer > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout_quiz_answer.png");
}
details.callout-example > summary::before {
  background-image: url("../../../assets/images/icons/callouts/icon_callout_example.png");
}
</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="ML Systems Textbook">
<meta property="og:image" content="https://mlsysbook.ai/book/contents/core/privacy_security/assets/images/covers/cover-hardcover-book.png">
<meta property="og:site_name" content="Machine Learning Systems">
<meta property="og:locale" content="en_US">
<meta name="twitter:title" content="ML Systems Textbook">
<meta name="twitter:image" content="https://mlsysbook.ai/book/contents/core/privacy_security/assets/images/covers/cover-hardcover-book.png">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar floating nav-fixed slimcontent quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const queryPrefersDark = window.matchMedia('(prefers-color-scheme: dark)');
    const darkModeDefault = queryPrefersDark.matches;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    queryPrefersDark.addEventListener("change", e => {
      if(window.localStorage.getItem("quarto-color-scheme") !== null)
        return;
      const alternate = e.matches
      toggleColorMode(alternate);
      localAlternateSentinel = e.matches ? 'alternate' : 'default'; // this is used alongside local storage!
      toggleGiscusIfUsed(alternate, darkModeDefault);
    });
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../assets/images/icons/favicon.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Machine Learning Systems</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-textbook" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Textbook</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-textbook">    
        <li>
    <a class="dropdown-item" href="../../../../book/"><i class="bi bi-book-half" role="img">
</i> 
 <span class="dropdown-text">Textbook</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../../tinytorch/"><i class="bi bi-fire" role="img">
</i> 
 <span class="dropdown-text">TinyTorch</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../../kits/"><i class="bi bi-cpu" role="img">
</i> 
 <span class="dropdown-text">Hardware Kits</span></a>
  </li>  
        <li><hr class="dropdown-divider"></li>
        <li>
    <a class="dropdown-item" href="../../../../labs/"><i class="bi bi-lightbulb" role="img">
</i> 
 <span class="dropdown-text">Labs (Coming 2026)</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-downloads" role="link" data-bs-toggle="dropdown" aria-expanded="false">
      <i class="bi bi-download" role="img">
</i> 
 <span class="menu-text">Downloads</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-downloads">    
        <li>
    <a class="dropdown-item" href="../../../assets/downloads/Machine-Learning-Systems.pdf" target="_blank"><i class="bi bi-file-pdf" role="img">
</i> 
 <span class="dropdown-text">Textbook PDF</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../assets/downloads/Machine-Learning-Systems.epub" target="_blank"><i class="bi bi-journal-text" role="img">
</i> 
 <span class="dropdown-text">Textbook EPUB</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="https://github.com/harvard-edge/cs249r_book#support-this-work" target="_blank"> <i class="bi bi-star" role="img">
</i> 
<span class="menu-text">Star</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://opencollective.com/mlsysbook" target="_blank"> <i class="bi bi-heart" role="img">
</i> 
<span class="menu-text">Support</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../#subscribe"> <i class="bi bi-envelope" role="img">
</i> 
<span class="menu-text">Subscribe</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-github" role="link" data-bs-toggle="dropdown" aria-expanded="false">
      <i class="bi bi-github" role="img">
</i> 
 <span class="menu-text">GitHub</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-github">    
        <li>
    <a class="dropdown-item" href="https://github.com/harvard-edge/cs249r_book" target="_blank"><i class="bi bi-pencil" role="img">
</i> 
 <span class="dropdown-text">Edit this page</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://github.com/harvard-edge/cs249r_book/issues/new" target="_blank"><i class="bi bi-bug" role="img">
</i> 
 <span class="dropdown-text">Report an issue</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://github.com/harvard-edge/cs249r_book/discussions" target="_blank"><i class="bi bi-chat" role="img">
</i> 
 <span class="dropdown-text">Discussions</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://github.com/harvard-edge/cs249r_book" target="_blank"><i class="bi bi-code" role="img">
</i> 
 <span class="dropdown-text">View source</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../contents/core/ops/ops.html">Robust Deployment</a></li><li class="breadcrumb-item"><a href="../../../contents/core/privacy_security/privacy_security.html">Security &amp; Privacy</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
  <div id="quarto-announcement" data-announcement-id="b43e2aeb169c88acb08fe42121c141fd" class="alert alert-primary hidden"><i class="bi bi-megaphone quarto-announcement-icon"></i><div class="quarto-announcement-content">
<p>ðŸŽ‰ <strong>Happy New Year!</strong> New navbar with dropdown menus. Try them out!<br> ðŸ”¥ <strong>TinyTorch:</strong> Build your own ML framework from scratch. <a href="https://mlsysbook.ai/tinytorch">Start â†’</a><br> ðŸ“¦ <strong>Hardware Kits:</strong> Arduino, Seeed &amp; Raspberry Pi labs. <a href="https://mlsysbook.ai/kits">Explore â†’</a><br> ðŸ“¬ <strong>Newsletter:</strong> ML Systems insights &amp; updates. <a href="#subscribe">Subscribe â†’</a></p>
</div><i class="bi bi-x-lg quarto-announcement-action"></i></div>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Homepage</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/foreword.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Foreword</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/about/about.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About the Book</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/acknowledgements/acknowledgements.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Acknowledgements</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/socratiq/socratiq.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">SocratiQ AI</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Systems Foundations</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/introduction/introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ml_systems/ml_systems.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">ML Systems</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/dl_primer/dl_primer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">DL Primer</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/dnn_architectures/dnn_architectures.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">DNN Architectures</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Design Principles</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/workflow/workflow.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">AI Workflow</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/data_engineering/data_engineering.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Data Engineering</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/frameworks/frameworks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">AI Frameworks</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/training/training.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">AI Training</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Performance Engineering</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/efficient_ai/efficient_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Efficient AI</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/optimizations/optimizations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Model Optimizations</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/hw_acceleration/hw_acceleration.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">AI Acceleration</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/benchmarking/benchmarking.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Benchmarking AI</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true">
 <span class="menu-text">Robust Deployment</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ops/ops.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">ML Operations</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ondevice_learning/ondevice_learning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">On-Device Learning</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/privacy_security/privacy_security.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Security &amp; Privacy</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/robust_ai/robust_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Robust AI</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true">
 <span class="menu-text">Trustworthy Systems</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/responsible_ai/responsible_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Responsible AI</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/sustainable_ai/sustainable_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Sustainable AI</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ai_for_good/ai_for_good.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">AI for Good</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true">
 <span class="menu-text">Frontiers of ML Systems</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/frontiers/frontiers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">AGI Systems</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/conclusion/conclusion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Conclusion</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="true">
 <span class="menu-text">Glossary</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/backmatter/glossary/glossary.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Complete Glossary</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="99">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#sec-security-privacy" id="toc-sec-security-privacy" class="nav-link active" data-scroll-target="#sec-security-privacy">Security &amp; Privacy</a>
  <ul>
  <li><a href="#purpose" id="toc-purpose" class="nav-link" data-scroll-target="#purpose">Purpose</a></li>
  <li><a href="#sec-security-privacy-security-privacy-ml-systems-0b1e" id="toc-sec-security-privacy-security-privacy-ml-systems-0b1e" class="nav-link" data-scroll-target="#sec-security-privacy-security-privacy-ml-systems-0b1e">Security and Privacy in ML Systems</a></li>
  <li><a href="#sec-security-privacy-foundational-concepts-definitions-d529" id="toc-sec-security-privacy-foundational-concepts-definitions-d529" class="nav-link" data-scroll-target="#sec-security-privacy-foundational-concepts-definitions-d529">Foundational Concepts and Definitions</a>
  <ul class="collapse">
  <li><a href="#sec-security-privacy-security-defined-1129" id="toc-sec-security-privacy-security-defined-1129" class="nav-link" data-scroll-target="#sec-security-privacy-security-defined-1129">Security Defined</a></li>
  <li><a href="#sec-security-privacy-privacy-defined-da84" id="toc-sec-security-privacy-privacy-defined-da84" class="nav-link" data-scroll-target="#sec-security-privacy-privacy-defined-da84">Privacy Defined</a></li>
  <li><a href="#sec-security-privacy-security-versus-privacy-e0b8" id="toc-sec-security-privacy-security-versus-privacy-e0b8" class="nav-link" data-scroll-target="#sec-security-privacy-security-versus-privacy-e0b8">Security versus Privacy</a></li>
  <li><a href="#sec-security-privacy-securityprivacy-interactions-tradeoffs-d153" id="toc-sec-security-privacy-securityprivacy-interactions-tradeoffs-d153" class="nav-link" data-scroll-target="#sec-security-privacy-securityprivacy-interactions-tradeoffs-d153">Security-Privacy Interactions and Trade-offs</a></li>
  </ul></li>
  <li><a href="#sec-security-privacy-learning-security-breaches-6719" id="toc-sec-security-privacy-learning-security-breaches-6719" class="nav-link" data-scroll-target="#sec-security-privacy-learning-security-breaches-6719">Learning from Security Breaches</a>
  <ul class="collapse">
  <li><a href="#sec-security-privacy-supply-chain-compromise-stuxnet-8a4b" id="toc-sec-security-privacy-supply-chain-compromise-stuxnet-8a4b" class="nav-link" data-scroll-target="#sec-security-privacy-supply-chain-compromise-stuxnet-8a4b">Supply Chain Compromise: Stuxnet</a></li>
  <li><a href="#sec-security-privacy-insufficient-isolation-jeep-cherokee-hack-6a7c" id="toc-sec-security-privacy-insufficient-isolation-jeep-cherokee-hack-6a7c" class="nav-link" data-scroll-target="#sec-security-privacy-insufficient-isolation-jeep-cherokee-hack-6a7c">Insufficient Isolation: Jeep Cherokee Hack</a></li>
  <li><a href="#sec-security-privacy-weaponized-endpoints-mirai-botnet-931c" id="toc-sec-security-privacy-weaponized-endpoints-mirai-botnet-931c" class="nav-link" data-scroll-target="#sec-security-privacy-weaponized-endpoints-mirai-botnet-931c">Weaponized Endpoints: Mirai Botnet</a></li>
  </ul></li>
  <li><a href="#sec-security-privacy-systematic-threat-analysis-risk-assessment-3ef1" id="toc-sec-security-privacy-systematic-threat-analysis-risk-assessment-3ef1" class="nav-link" data-scroll-target="#sec-security-privacy-systematic-threat-analysis-risk-assessment-3ef1">Systematic Threat Analysis and Risk Assessment</a>
  <ul class="collapse">
  <li><a href="#sec-security-privacy-threat-prioritization-framework-f2d5" id="toc-sec-security-privacy-threat-prioritization-framework-f2d5" class="nav-link" data-scroll-target="#sec-security-privacy-threat-prioritization-framework-f2d5">Threat Prioritization Framework</a></li>
  </ul></li>
  <li><a href="#sec-security-privacy-modelspecific-attack-vectors-0575" id="toc-sec-security-privacy-modelspecific-attack-vectors-0575" class="nav-link" data-scroll-target="#sec-security-privacy-modelspecific-attack-vectors-0575">Model-Specific Attack Vectors</a>
  <ul class="collapse">
  <li><a href="#sec-security-privacy-model-theft-1879" id="toc-sec-security-privacy-model-theft-1879" class="nav-link" data-scroll-target="#sec-security-privacy-model-theft-1879">Model Theft</a>
  <ul class="collapse">
  <li><a href="#sec-security-privacy-exact-model-theft-b738" id="toc-sec-security-privacy-exact-model-theft-b738" class="nav-link" data-scroll-target="#sec-security-privacy-exact-model-theft-b738">Exact Model Theft</a></li>
  <li><a href="#sec-security-privacy-approximate-model-theft-1155" id="toc-sec-security-privacy-approximate-model-theft-1155" class="nav-link" data-scroll-target="#sec-security-privacy-approximate-model-theft-1155">Approximate Model Theft</a></li>
  <li><a href="#sec-security-privacy-case-study-tesla-ip-theft-9d78" id="toc-sec-security-privacy-case-study-tesla-ip-theft-9d78" class="nav-link" data-scroll-target="#sec-security-privacy-case-study-tesla-ip-theft-9d78">Case Study: Tesla IP Theft</a></li>
  </ul></li>
  <li><a href="#sec-security-privacy-data-poisoning-351f" id="toc-sec-security-privacy-data-poisoning-351f" class="nav-link" data-scroll-target="#sec-security-privacy-data-poisoning-351f">Data Poisoning</a></li>
  <li><a href="#sec-security-privacy-adversarial-attacks-9f84" id="toc-sec-security-privacy-adversarial-attacks-9f84" class="nav-link" data-scroll-target="#sec-security-privacy-adversarial-attacks-9f84">Adversarial Attacks</a></li>
  <li><a href="#sec-security-privacy-case-study-traffic-sign-attack-6e93" id="toc-sec-security-privacy-case-study-traffic-sign-attack-6e93" class="nav-link" data-scroll-target="#sec-security-privacy-case-study-traffic-sign-attack-6e93">Case Study: Traffic Sign Attack</a></li>
  </ul></li>
  <li><a href="#sec-security-privacy-hardwarelevel-security-vulnerabilities-1ab4" id="toc-sec-security-privacy-hardwarelevel-security-vulnerabilities-1ab4" class="nav-link" data-scroll-target="#sec-security-privacy-hardwarelevel-security-vulnerabilities-1ab4">Hardware-Level Security Vulnerabilities</a>
  <ul class="collapse">
  <li><a href="#sec-security-privacy-hardware-bugs-9efc" id="toc-sec-security-privacy-hardware-bugs-9efc" class="nav-link" data-scroll-target="#sec-security-privacy-hardware-bugs-9efc">Hardware Bugs</a></li>
  <li><a href="#sec-security-privacy-physical-attacks-095a" id="toc-sec-security-privacy-physical-attacks-095a" class="nav-link" data-scroll-target="#sec-security-privacy-physical-attacks-095a">Physical Attacks</a></li>
  <li><a href="#sec-security-privacy-fault-injection-attacks-8c52" id="toc-sec-security-privacy-fault-injection-attacks-8c52" class="nav-link" data-scroll-target="#sec-security-privacy-fault-injection-attacks-8c52">Fault Injection Attacks</a></li>
  <li><a href="#sec-security-privacy-sidechannel-attacks-cdfd" id="toc-sec-security-privacy-sidechannel-attacks-cdfd" class="nav-link" data-scroll-target="#sec-security-privacy-sidechannel-attacks-cdfd">Side-Channel Attacks</a></li>
  <li><a href="#sec-security-privacy-leaky-interfaces-9206" id="toc-sec-security-privacy-leaky-interfaces-9206" class="nav-link" data-scroll-target="#sec-security-privacy-leaky-interfaces-9206">Leaky Interfaces</a></li>
  <li><a href="#sec-security-privacy-counterfeit-hardware-36fd" id="toc-sec-security-privacy-counterfeit-hardware-36fd" class="nav-link" data-scroll-target="#sec-security-privacy-counterfeit-hardware-36fd">Counterfeit Hardware</a></li>
  <li><a href="#sec-security-privacy-supply-chain-risks-c99c" id="toc-sec-security-privacy-supply-chain-risks-c99c" class="nav-link" data-scroll-target="#sec-security-privacy-supply-chain-risks-c99c">Supply Chain Risks</a></li>
  <li><a href="#sec-security-privacy-case-study-supermicro-controversy-72b7" id="toc-sec-security-privacy-case-study-supermicro-controversy-72b7" class="nav-link" data-scroll-target="#sec-security-privacy-case-study-supermicro-controversy-72b7">Case Study: Supermicro Controversy</a></li>
  </ul></li>
  <li><a href="#sec-security-privacy-ml-systems-become-attack-tools-2f34" id="toc-sec-security-privacy-ml-systems-become-attack-tools-2f34" class="nav-link" data-scroll-target="#sec-security-privacy-ml-systems-become-attack-tools-2f34">When ML Systems Become Attack Tools</a>
  <ul class="collapse">
  <li><a href="#sec-security-privacy-case-study-deep-learning-sca-b0b3" id="toc-sec-security-privacy-case-study-deep-learning-sca-b0b3" class="nav-link" data-scroll-target="#sec-security-privacy-case-study-deep-learning-sca-b0b3">Case Study: Deep Learning for SCA</a></li>
  </ul></li>
  <li><a href="#sec-security-privacy-comprehensive-defense-architectures-48ab" id="toc-sec-security-privacy-comprehensive-defense-architectures-48ab" class="nav-link" data-scroll-target="#sec-security-privacy-comprehensive-defense-architectures-48ab">Comprehensive Defense Architectures</a>
  <ul class="collapse">
  <li><a href="#sec-security-privacy-layered-defense-principle-8706" id="toc-sec-security-privacy-layered-defense-principle-8706" class="nav-link" data-scroll-target="#sec-security-privacy-layered-defense-principle-8706">The Layered Defense Principle</a></li>
  <li><a href="#sec-security-privacy-privacypreserving-data-techniques-64f8" id="toc-sec-security-privacy-privacypreserving-data-techniques-64f8" class="nav-link" data-scroll-target="#sec-security-privacy-privacypreserving-data-techniques-64f8">Privacy-Preserving Data Techniques</a>
  <ul class="collapse">
  <li><a href="#sec-security-privacy-differential-privacy-8c2b" id="toc-sec-security-privacy-differential-privacy-8c2b" class="nav-link" data-scroll-target="#sec-security-privacy-differential-privacy-8c2b">Differential Privacy</a></li>
  <li><a href="#sec-security-privacy-federated-learning-3834" id="toc-sec-security-privacy-federated-learning-3834" class="nav-link" data-scroll-target="#sec-security-privacy-federated-learning-3834">Federated Learning</a></li>
  <li><a href="#sec-security-privacy-synthetic-data-generation-4349" id="toc-sec-security-privacy-synthetic-data-generation-4349" class="nav-link" data-scroll-target="#sec-security-privacy-synthetic-data-generation-4349">Synthetic Data Generation</a></li>
  <li><a href="#sec-security-privacy-comparative-properties-9ca5" id="toc-sec-security-privacy-comparative-properties-9ca5" class="nav-link" data-scroll-target="#sec-security-privacy-comparative-properties-9ca5">Comparative Properties</a></li>
  </ul></li>
  <li><a href="#sec-security-privacy-case-study-gpt3-data-extraction-attack-5126" id="toc-sec-security-privacy-case-study-gpt3-data-extraction-attack-5126" class="nav-link" data-scroll-target="#sec-security-privacy-case-study-gpt3-data-extraction-attack-5126">Case Study: GPT-3 Data Extraction Attack</a></li>
  <li><a href="#sec-security-privacy-secure-model-design-69a6" id="toc-sec-security-privacy-secure-model-design-69a6" class="nav-link" data-scroll-target="#sec-security-privacy-secure-model-design-69a6">Secure Model Design</a></li>
  <li><a href="#sec-security-privacy-secure-model-deployment-e08c" id="toc-sec-security-privacy-secure-model-deployment-e08c" class="nav-link" data-scroll-target="#sec-security-privacy-secure-model-deployment-e08c">Secure Model Deployment</a></li>
  <li><a href="#sec-security-privacy-runtime-system-monitoring-a71c" id="toc-sec-security-privacy-runtime-system-monitoring-a71c" class="nav-link" data-scroll-target="#sec-security-privacy-runtime-system-monitoring-a71c">Runtime System Monitoring</a>
  <ul class="collapse">
  <li><a href="#sec-security-privacy-input-validation-c96f" id="toc-sec-security-privacy-input-validation-c96f" class="nav-link" data-scroll-target="#sec-security-privacy-input-validation-c96f">Input Validation</a></li>
  <li><a href="#sec-security-privacy-output-monitoring-cf37" id="toc-sec-security-privacy-output-monitoring-cf37" class="nav-link" data-scroll-target="#sec-security-privacy-output-monitoring-cf37">Output Monitoring</a></li>
  <li><a href="#sec-security-privacy-integrity-checks-2989" id="toc-sec-security-privacy-integrity-checks-2989" class="nav-link" data-scroll-target="#sec-security-privacy-integrity-checks-2989">Integrity Checks</a></li>
  <li><a href="#sec-security-privacy-response-rollback-1792" id="toc-sec-security-privacy-response-rollback-1792" class="nav-link" data-scroll-target="#sec-security-privacy-response-rollback-1792">Response and Rollback</a></li>
  </ul></li>
  <li><a href="#sec-security-privacy-hardware-security-foundations-f5e8" id="toc-sec-security-privacy-hardware-security-foundations-f5e8" class="nav-link" data-scroll-target="#sec-security-privacy-hardware-security-foundations-f5e8">Hardware Security Foundations</a>
  <ul class="collapse">
  <li><a href="#sec-security-privacy-hardwaresoftware-codesign-bed2" id="toc-sec-security-privacy-hardwaresoftware-codesign-bed2" class="nav-link" data-scroll-target="#sec-security-privacy-hardwaresoftware-codesign-bed2">Hardware-Software Co-Design</a></li>
  <li><a href="#sec-security-privacy-trusted-execution-environments-80ed" id="toc-sec-security-privacy-trusted-execution-environments-80ed" class="nav-link" data-scroll-target="#sec-security-privacy-trusted-execution-environments-80ed">Trusted Execution Environments</a></li>
  <li><a href="#sec-security-privacy-secure-boot-5242" id="toc-sec-security-privacy-secure-boot-5242" class="nav-link" data-scroll-target="#sec-security-privacy-secure-boot-5242">Secure Boot</a></li>
  <li><a href="#sec-security-privacy-hardware-security-modules-4377" id="toc-sec-security-privacy-hardware-security-modules-4377" class="nav-link" data-scroll-target="#sec-security-privacy-hardware-security-modules-4377">Hardware Security Modules</a></li>
  <li><a href="#sec-security-privacy-physical-unclonable-functions-6533" id="toc-sec-security-privacy-physical-unclonable-functions-6533" class="nav-link" data-scroll-target="#sec-security-privacy-physical-unclonable-functions-6533">Physical Unclonable Functions</a></li>
  <li><a href="#sec-security-privacy-mechanisms-comparison-2dcb" id="toc-sec-security-privacy-mechanisms-comparison-2dcb" class="nav-link" data-scroll-target="#sec-security-privacy-mechanisms-comparison-2dcb">Mechanisms Comparison</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec-security-privacy-practical-roadmap-8f3a" id="toc-sec-security-privacy-practical-roadmap-8f3a" class="nav-link" data-scroll-target="#sec-security-privacy-practical-roadmap-8f3a">Practical Implementation Roadmap</a>
  <ul class="collapse">
  <li><a href="#sec-security-privacy-phase1-baseline-foundation-2d9c" id="toc-sec-security-privacy-phase1-baseline-foundation-2d9c" class="nav-link" data-scroll-target="#sec-security-privacy-phase1-baseline-foundation-2d9c">Phase 1: Foundation Security Controls</a></li>
  <li><a href="#sec-security-privacy-phase2-privacy-model-protection-7a8b" id="toc-sec-security-privacy-phase2-privacy-model-protection-7a8b" class="nav-link" data-scroll-target="#sec-security-privacy-phase2-privacy-model-protection-7a8b">Phase 2: Privacy Controls and Model Protection</a></li>
  <li><a href="#sec-security-privacy-phase3-advanced-defenses-runtime-8c2d" id="toc-sec-security-privacy-phase3-advanced-defenses-runtime-8c2d" class="nav-link" data-scroll-target="#sec-security-privacy-phase3-advanced-defenses-runtime-8c2d">Phase 3: Advanced Threat Defense</a></li>
  <li><a href="#sec-security-privacy-implementation-considerations-9f4e" id="toc-sec-security-privacy-implementation-considerations-9f4e" class="nav-link" data-scroll-target="#sec-security-privacy-implementation-considerations-9f4e">Implementation Considerations</a></li>
  </ul></li>
  <li><a href="#sec-security-privacy-fallacies-pitfalls-0c20" id="toc-sec-security-privacy-fallacies-pitfalls-0c20" class="nav-link" data-scroll-target="#sec-security-privacy-fallacies-pitfalls-0c20">Fallacies and Pitfalls</a></li>
  <li><a href="#sec-security-privacy-summary-831c" id="toc-sec-security-privacy-summary-831c" class="nav-link" data-scroll-target="#sec-security-privacy-summary-831c">Summary</a></li>
  <li><a href="#self-check-answers" id="toc-self-check-answers" class="nav-link" data-scroll-target="#self-check-answers">Self-Check Answers</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../contents/core/ops/ops.html">Robust Deployment</a></li><li class="breadcrumb-item"><a href="../../../contents/core/privacy_security/privacy_security.html">Security &amp; Privacy</a></li></ol></nav></header>





<section id="sec-security-privacy" class="level1 page-columns page-full">
<h1>Security &amp; Privacy</h1>
<div class="{layout-narrow} page-columns page-full">

<div class="no-row-height column-margin column-container"><div class="">
<p><em>DALLÂ·E 3 Prompt: An illustration on privacy and security in machine learning systems. The image shows a digital landscape with a network of interconnected nodes and data streams, symbolizing machine learning algorithms. In the foreground, thereâ€™s a large lock superimposed over the network, representing privacy and security. The lock is semi-transparent, allowing the underlying network to be partially visible. The background features binary code and digital encryption symbols, emphasizing the theme of cybersecurity. The color scheme is a mix of blues, greens, and grays, suggesting a high-tech, digital environment.</em></p>
</div></div><p> <img src="images/png/cover_security_privacy.png" class="img-fluid"></p>
</div>
<section id="purpose" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="purpose">Purpose</h2>
<p><em>Why do privacy and security determine whether machine learning systems achieve widespread adoption and societal trust?</em></p>
<p>Machine learning systems require unprecedented access to personal data, institutional knowledge, and behavioral patterns to function effectively, creating tension between utility and protection that determines societal acceptance. Unlike traditional software that processes data transiently, ML systems learn from sensitive information and embed patterns into persistent models that can inadvertently reveal private details. This capability creates systemic risks extending beyond individual privacy violations to threaten institutional trust, competitive advantages, and democratic governance. Success of machine learning deployment across critical domains (healthcare, finance, education, and public services) depends entirely on establishing robust security and privacy foundations enabling beneficial use while preventing harmful exposure. Without these protections, even the most capable systems remain unused due to legal, ethical, and practical concerns. Understanding privacy and security principles enables engineers to design systems achieving both technical excellence and societal acceptance.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Learning Objectives">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Learning Objectives
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><p>Distinguish between security and privacy concerns in machine learning systems using formal definitions and threat models</p></li>
<li><p>Analyze historical security incidents to extract principles applicable to ML system vulnerabilities</p></li>
<li><p>Classify ML threats across model, data, and hardware attack surfaces</p></li>
<li><p>Evaluate privacy-preserving techniques including differential privacy, federated learning, and synthetic data generation for specific use cases</p></li>
<li><p>Design layered defense architectures that integrate data protection, model security, and hardware trust mechanisms</p></li>
<li><p>Implement basic security controls including access management, encryption, and input validation for ML systems</p></li>
<li><p>Assess trade-offs between security measures and system performance using quantitative cost-benefit analysis</p></li>
<li><p>Apply the three-phase security roadmap to prioritize defenses based on organizational threat models and risk tolerance</p></li>
</ul>
</div>
</div>
</section>
<section id="sec-security-privacy-security-privacy-ml-systems-0b1e" class="level2">
<h2 class="anchored" data-anchor-id="sec-security-privacy-security-privacy-ml-systems-0b1e">Security and Privacy in ML Systems</h2>
<p>The shift from centralized training architectures to distributed, adaptive machine learning systems has altered the threat landscape and security requirements for modern ML infrastructure. Contemporary machine learning systems, as examined in <strong><a href="../ondevice_learning/ondevice_learning.html#sec-ondevice-learning">Chapter 14: On-Device Learning</a></strong>, increasingly operate across heterogeneous computational environments spanning edge devices, federated networks, and hybrid cloud deployments. This architectural evolution enables new capabilities in adaptive intelligence but introduces attack vectors and privacy vulnerabilities that traditional cybersecurity frameworks cannot adequately address.</p>
<p>Machine learning systems exhibit different security characteristics compared to conventional software applications. Traditional software systems process data transiently and deterministically, whereas machine learning systems extract and encode patterns from training data into persistent model parameters. This learned knowledge representation creates unique vulnerabilities where sensitive information can be inadvertently memorized and later exposed through model outputs or systematic interrogation. Such risks manifest across domains from healthcare systems that may leak patient information to proprietary models that can be reverse-engineered through strategic query patterns, threatening both individual privacy and organizational intellectual property.</p>
<p>The architectural complexity of machine learning systems, as detailed in <strong><a href="../ml_systems/ml_systems.html#sec-ml-systems">Chapter 2: ML Systems</a></strong>, compounds these security challenges through multi-layered attack surfaces. Contemporary ML deployments include data ingestion pipelines, distributed training infrastructure, model serving systems, and continuous monitoring frameworks. Each architectural component introduces distinct vulnerabilities while privacy concerns affect the entire computational stack. The distributed nature of modern deployments, with continuous adaptation at edge nodes and federated coordination protocols, expands the attack surface while complicating comprehensive security implementation.</p>
<p>Addressing these challenges requires systematic approaches that integrate security and privacy considerations throughout the machine learning system lifecycle. This chapter establishes the foundations and methodologies necessary for engineering ML systems that achieve both computational effectiveness and trustworthy operation. We examine the application of established security principles to machine learning contexts, identify threat models specific to learning systems, and present comprehensive defense strategies that include data protection mechanisms, secure model architectures, and hardware-based security implementations.</p>
<p>Our investigation proceeds through four interconnected frameworks. We begin by establishing distinctions between security and privacy within machine learning contexts, then examine evidence from historical security incidents to inform contemporary threat assessment. We analyze vulnerabilities that emerge from the learning process itself, before presenting layered defense architectures that span cryptographic data protection, adversarial-robust model design, and hardware security mechanisms. Throughout this analysis, we emphasize implementation guidance that enables practitioners to develop systems meeting both technical performance requirements and the trust standards necessary for societal deployment.</p>
<div id="quiz-question-sec-security-privacy-security-privacy-ml-systems-0b1e" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.1</strong></summary><div>
<ol type="1">
<li><p>How do machine learning systems differ from traditional software applications in terms of data processing?</p>
<ol type="a">
<li>ML systems process data transiently and deterministically.</li>
<li>Traditional software systems operate across heterogeneous environments.</li>
<li>Traditional software systems learn patterns from data and store them persistently.</li>
<li>ML systems encode patterns from data into persistent model parameters.</li>
</ol></li>
<li><p>True or False: The distributed nature of modern ML deployments reduces the attack surface for potential security threats.</p></li>
<li><p>Explain why traditional cybersecurity frameworks may not adequately address the security needs of modern ML systems.</p></li>
<li><p>Which of the following is a potential vulnerability specific to machine learning systems?</p>
<ol type="a">
<li>Data is processed transiently and deterministically.</li>
<li>Sensitive information can be memorized and exposed through model outputs.</li>
<li>Models operate only in centralized environments.</li>
<li>There are no privacy concerns in ML systems.</li>
</ol></li>
</ol>
<p><a href="#quiz-answer-sec-security-privacy-security-privacy-ml-systems-0b1e" class="question-label">See Answers â†’</a></p>
</div></details>
</div>
</section>
<section id="sec-security-privacy-foundational-concepts-definitions-d529" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-security-privacy-foundational-concepts-definitions-d529">Foundational Concepts and Definitions</h2>
<p>Security and privacy are core concerns in machine learning system design, but they are often misunderstood or conflated. Both aim to protect systems and data, yet they do so in different ways, address different threat models, and require distinct technical responses. For ML systems, distinguishing between the two helps guide the design of robust and responsible infrastructure.</p>
<section id="sec-security-privacy-security-defined-1129" class="level3">
<h3 class="anchored" data-anchor-id="sec-security-privacy-security-defined-1129">Security Defined</h3>
<p>Security in machine learning focuses on defending systems from adversarial behavior. This includes protecting model parameters, training pipelines, deployment infrastructure, and data access pathways from manipulation or misuse.</p>
<div id="callout-definition*-1.1" class="callout callout-definition" title="Security">
<p></p><details class="callout-definition fbx-default closebutton" open=""><summary><strong>Definition: </strong>Security</summary><div><strong><em>Security</em></strong> is the protection of ML system <em>data</em>, <em>models</em>, and <em>infrastructure</em> from <em>unauthorized access</em>, <em>manipulation</em>, and <em>disruption</em> through <em>defensive mechanisms</em> spanning development, deployment, and operational environments.<p></p>
</div></details>
</div>
<p><em>Example</em>: A facial recognition system deployed in public transit infrastructure may be targeted with adversarial inputs that cause it to misidentify individuals or fail entirely. This is a runtime security vulnerability that threatens both accuracy and system availability.</p>
</section>
<section id="sec-security-privacy-privacy-defined-da84" class="level3">
<h3 class="anchored" data-anchor-id="sec-security-privacy-privacy-defined-da84">Privacy Defined</h3>
<p>While security addresses adversarial threats, privacy focuses on limiting the exposure and misuse of sensitive information within ML systems. This includes protecting training data, inference inputs, and model outputs from leaking personal or proprietary information, even when systems operate correctly and no explicit attack is taking place.</p>
<div id="callout-definition*-1.2" class="callout callout-definition" title="Privacy">
<p></p><details class="callout-definition fbx-default closebutton" open=""><summary><strong>Definition: </strong>Privacy</summary><div><strong><em>Privacy</em></strong> is the protection of <em>sensitive information</em> from <em>unauthorized disclosure</em>, <em>inference</em>, and <em>misuse</em> through methods that preserve <em>confidentiality</em> and <em>control over data usage</em> across ML system environments.<p></p>
</div></details>
</div>
<p><em>Example</em>: A language model trained on medical transcripts may inadvertently memorize snippets of patient conversations. If a user later triggers this content through a public-facing chatbot, it represents a privacy failure, even in the absence of an attacker.</p>
</section>
<section id="sec-security-privacy-security-versus-privacy-e0b8" class="level3">
<h3 class="anchored" data-anchor-id="sec-security-privacy-security-versus-privacy-e0b8">Security versus Privacy</h3>
<p>Although they intersect in some areas (encrypted storage supports both), security and privacy differ in their objectives, threat models, and typical mitigation strategies. <a href="#tbl-security-privacy-comparison" class="quarto-xref">Table&nbsp;1</a> below summarizes these distinctions in the context of machine learning systems.</p>
<div id="tbl-security-privacy-comparison" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-security-privacy-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: <strong>Security-Privacy Distinctions</strong>: Machine learning systems require distinct approaches to security and privacy; security mitigates adversarial threats targeting system functionality, while privacy protects sensitive information from both intentional and unintentional exposure through data leakage or re-identification. This table clarifies how differing goals and threat models shape the specific concerns and mitigation strategies for each domain.
</figcaption>
<div aria-describedby="tbl-security-privacy-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 24%">
<col style="width: 36%">
<col style="width: 38%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Aspect</strong></th>
<th style="text-align: left;"><strong>Security</strong></th>
<th style="text-align: left;"><strong>Privacy</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Primary Goal</strong></td>
<td style="text-align: left;">Prevent unauthorized access or disruption</td>
<td style="text-align: left;">Limit exposure of sensitive information</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Threat Model</strong></td>
<td style="text-align: left;">Adversarial actors (external or internal)</td>
<td style="text-align: left;">Honest-but-curious observers or passive leaks</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Typical Concerns</strong></td>
<td style="text-align: left;">Model theft, poisoning, evasion attacks</td>
<td style="text-align: left;">Data leakage, re-identification, memorization</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Example Attack</strong></td>
<td style="text-align: left;">Adversarial inputs cause misclassification</td>
<td style="text-align: left;">Model inversion reveals training data</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Representative Defenses</strong></td>
<td style="text-align: left;">Access control, adversarial training</td>
<td style="text-align: left;">Differential privacy, federated learning</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Relevance to Regulation</strong></td>
<td style="text-align: left;">Emphasized in cybersecurity standards</td>
<td style="text-align: left;">Central to data protection laws (e.g., GDPR)</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</section>
<section id="sec-security-privacy-securityprivacy-interactions-tradeoffs-d153" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-security-privacy-securityprivacy-interactions-tradeoffs-d153">Security-Privacy Interactions and Trade-offs</h3>
<p>Security and privacy are deeply interrelated but not interchangeable. A secure system helps maintain privacy by restricting unauthorized access to models and data. Privacy-preserving designs can improve security by reducing the attack surface, for example, minimizing the retention of sensitive data reduces the risk of exposure if a system is compromised.</p>
<p>However, they can also be in tension. Techniques like differential privacy<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> reduce memorization risks but may lower model utility. Similarly, encryption enhances security but may obscure transparency and auditability, complicating privacy compliance. In machine learning systems, designers must reason about these trade-offs holistically. Systems that serve sensitive domains, including healthcare, finance, and public safety, must simultaneously protect against both misuse (security) and overexposure (privacy). Understanding the boundaries between these concerns is essential for building systems that are performant, trustworthy, and legally compliant.</p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;<strong>Differential Privacy Origins</strong>: Cynthia Dwork coined the term differential privacy at Microsoft Research in 2006, but the concept emerged from her frustration with the â€œanonymization mythâ€ (the false belief that removing names from data guaranteed privacy). Her groundbreaking insight was that privacy should be mathematically provable, not just plausible, leading to the rigorous framework that now protects billions of usersâ€™ data in products from Apple to Google.</p></div></div><div id="quiz-question-sec-security-privacy-foundational-concepts-definitions-d529" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.2</strong></summary><div>
<ol type="1">
<li><p>Which of the following best describes the primary goal of security in machine learning systems?</p>
<ol type="a">
<li>Limit exposure of sensitive information</li>
<li>Prevent unauthorized access or disruption</li>
<li>Enhance model performance and accuracy</li>
<li>Ensure compliance with data protection laws</li>
</ol></li>
<li><p>True or False: Privacy in machine learning systems is primarily concerned with preventing adversarial attacks.</p></li>
<li><p>Explain how security and privacy can be in tension within a machine learning system.</p></li>
<li><p>In the context of machine learning systems, which of the following is an example of a privacy failure?</p>
<ol type="a">
<li>Adversarial inputs causing misclassification</li>
<li>Data poisoning during training</li>
<li>Unauthorized access to model parameters</li>
<li>Model inversion revealing training data</li>
</ol></li>
</ol>
<p><a href="#quiz-answer-sec-security-privacy-foundational-concepts-definitions-d529" class="question-label">See Answers â†’</a></p>
</div></details>
</div>
</section>
</section>
<section id="sec-security-privacy-learning-security-breaches-6719" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-security-privacy-learning-security-breaches-6719">Learning from Security Breaches</h2>
<p>Having established the conceptual foundations of security and privacy, we now examine how these principles manifest in real-world systems through landmark security incidents. These historical cases provide concrete illustrations of the abstract concepts weâ€™ve defined, showing how security vulnerabilities emerge and propagate through complex systems. More importantly, they reveal universal patterns (supply chain compromise, insufficient isolation, and weaponized endpoints) that directly apply to modern machine learning deployments.</p>
<p>Valuable lessons can be drawn from well-known security breaches across a range of computing systems. Understanding how these patterns apply to modern ML deployments, which increasingly operate across cloud, edge, and embedded environments, provides important lessons for securing machine learning systems. These incidents demonstrate how weaknesses in system design can lead to widespread, and sometimes physical, consequences. Although the examples discussed in this section do not all involve machine learning directly, they provide important insights into designing secure systems. These lessons apply to machine learning applications deployed across cloud, edge, and embedded environments.</p>
<section id="sec-security-privacy-supply-chain-compromise-stuxnet-8a4b" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-security-privacy-supply-chain-compromise-stuxnet-8a4b">Supply Chain Compromise: Stuxnet</h3>
<p>In 2010, security researchers discovered a highly sophisticated computer worm later named <a href="https://www.research-collection.ethz.ch/bitstream/handle/20.500.11850/200661/Cyber-Reports-2017-04.pdf">Stuxnet</a><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, which targeted industrial control systems used in Iranâ€™s Natanz nuclear facility <span class="citation" data-cites="farwell2011stuxnet">(<a href="#ref-farwell2011stuxnet" role="doc-biblioref">Farwell and Rohozinski 2011</a>)</span>. Stuxnet exploited four previously unknown â€œ<a href="https://en.wikipedia.org/wiki/Zero-day_%28computing%29">zero-day</a>â€<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> vulnerabilities in Microsoft Windows, allowing it to spread undetected through networked and isolated systems.</p>
<div class="no-row-height column-margin column-container"><div id="fn2"><p><sup>2</sup>&nbsp;<strong>Stuxnet Discovery</strong>: Stuxnet was first detected by VirusBokNok, a small Belarusian antivirus company, when their client computers began crashing unexpectedly. What seemed like a routine malware investigation turned into one of the most significant cybersecurity discoveries in history: the first confirmed cyberweapon designed to cause physical destruction.</p></div><div id="fn3"><p><sup>3</sup>&nbsp;<strong>Zero-Day Term Origin</strong>: The term â€œzero-dayâ€ originated in software piracy circles, referring to the â€œzero daysâ€ since a programâ€™s release when pirated copies appeared. In security, it describes the â€œzero daysâ€ defenders have to patch a vulnerability before attackers exploit it, representing the ultimate race between attack and defense.</p></div><div id="fn4"><p><sup>4</sup>&nbsp;<strong>Air-Gapped Systems</strong>: Air-gapped systems are networks physically isolated from external connections, originally developed for military systems in the 1960s. Despite seeming impenetrable, studies show 90% of air-gapped systems can be breached through supply chain compromise, infected removable media, or hidden channels (acoustic, electromagnetic, thermal) <span class="citation" data-cites="farwell2011stuxnet">(<a href="#ref-farwell2011stuxnet" role="doc-biblioref">Farwell and Rohozinski 2011</a>)</span>.</p></div><div id="fn5"><p><sup>5</sup>&nbsp;<strong>USB Attacks</strong>: USB interfaces, introduced in 1996, became a primary attack vector for crossing air gaps. The 2008 Operation Olympic Games reportedly used infected USB drives to penetrate secure facilities, with some estimates suggesting 60% of organizations remain vulnerable to USB-based attacks <span class="citation" data-cites="farwell2011stuxnet">(<a href="#ref-farwell2011stuxnet" role="doc-biblioref">Farwell and Rohozinski 2011</a>)</span>.</p><div id="ref-farwell2011stuxnet" class="csl-entry" role="listitem">
Farwell, James P., and Rafal Rohozinski. 2011. <span>â€œStuxnet and the Future of Cyber War.â€</span> <em>Survival</em> 53 (1): 23â€“40. <a href="https://doi.org/10.1080/00396338.2011.555586">https://doi.org/10.1080/00396338.2011.555586</a>.
</div></div></div><p>Unlike typical malware designed to steal information or perform espionage, Stuxnet was engineered to cause physical damage. Its objective was to disrupt uranium enrichment by sabotaging the centrifuges used in the process. Despite the facility being air-gapped<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> from external networks, the malware is believed to have entered the system via an infected USB device<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>, demonstrating how physical access can compromise isolated environments.</p>
<p>The worm specifically targeted programmable logic controllers (PLCs), industrial computers that automate electromechanical processes such as controlling the speed of centrifuges. By exploiting vulnerabilities in the Windows operating system and the Siemens Step7 software used to program the PLCs, Stuxnet achieved highly targeted, real-world disruption. This represents a landmark in cybersecurity, demonstrating how malicious software can bridge the digital and physical worlds to manipulate industrial infrastructure.</p>
<p>The lessons from Stuxnet directly apply to modern ML systems. Training pipelines and model repositories face persistent supply chain risks analogous to those exploited by Stuxnet. Just as Stuxnet compromised industrial systems through infected USB devices and software vulnerabilities, modern ML systems face multiple attack vectors: compromised dependencies (malicious packages in PyPI/conda repositories), malicious training data (poisoned datasets on HuggingFace, Kaggle), backdoored model weights (trojan models in model repositories), and tampered hardware drivers (compromised NVIDIA CUDA libraries, firmware backdoors in AI accelerators).</p>
<p>A concrete ML attack scenario illustrates these risks: an attacker uploads a backdoored image classification model to a popular model repository, trained to misclassify specific patterns while maintaining normal accuracy on clean data. When deployed in autonomous vehicles, this backdoored model correctly identifies most objects but fails to detect pedestrians wearing specific patterns, creating safety risks. The attack propagates through automated model deployment pipelines, affecting thousands of vehicles before detection.</p>
<p>Defending against such supply chain attacks requires end-to-end security measures: (1) cryptographic verification to sign all model artifacts, datasets, and dependencies with cryptographic signatures; (2) provenance tracking to maintain immutable logs of all training data sources, code versions, and infrastructure used; (3) integrity validation to implement automated scanning for model backdoors, dependency vulnerabilities, and dataset poisoning before deployment; (4) air-gapped training to isolate sensitive model training in secure environments with controlled dependency management. <a href="#fig-stuxnet" class="quarto-xref">Figure&nbsp;1</a> illustrates how these supply chain compromise patterns apply across both industrial and ML systems.</p>
<div id="fig-stuxnet" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-stuxnet-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="091f49589d1bee79e2fe72702b5a7cc2ab134490.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Figure&nbsp;1: Stuxnet: Targets PLCs by exploiting Windows and Siemens software vulnerabilities, demonstrating supply chain compromise that enabled digital malware to cause physical infrastructure damage. Modern ML systems face analogous risks through compromised training data, backdoored dependencies, and tampered model weights. Figure&nbsp;1"><img src="privacy_security_files/mediabag/091f49589d1bee79e2fe72702b5a7cc2ab134490.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-stuxnet-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: <strong>Stuxnet</strong>: Targets PLCs by exploiting Windows and Siemens software vulnerabilities, demonstrating supply chain compromise that enabled digital malware to cause physical infrastructure damage. Modern ML systems face analogous risks through compromised training data, backdoored dependencies, and tampered model weights. <a href="#fig-stuxnet" class="quarto-xref">Figure&nbsp;1</a>
</figcaption>
</figure>
</div>
</section>
<section id="sec-security-privacy-insufficient-isolation-jeep-cherokee-hack-6a7c" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-security-privacy-insufficient-isolation-jeep-cherokee-hack-6a7c">Insufficient Isolation: Jeep Cherokee Hack</h3>
<p>The 2015 Jeep Cherokee hack demonstrated how connectivity in everyday products creates new vulnerabilities. Security researchers publicly demonstrated a remote cyberattack on a Jeep Cherokee that exposed important vulnerabilities in automotive system design <span class="citation" data-cites="miller2015remote miller2019lessons">(<a href="#ref-miller2015remote" role="doc-biblioref">Miller and Valasek 2015</a>; <a href="#ref-miller2019lessons" role="doc-biblioref">Miller 2019</a>)</span>. Conducted as a controlled experiment, the researchers exploited a vulnerability in the vehicleâ€™s Uconnect entertainment system, which was connected to the internet via a cellular network. By gaining remote access to this system, they sent commands that affected the vehicleâ€™s engine, transmission, and braking systems without physical access to the car.</p>
<div class="no-row-height column-margin column-container"><div id="ref-miller2015remote" class="csl-entry" role="listitem">
Miller, Charlie, and Chris Valasek. 2015. <span>â€œThe Antivirus Hackerâ€™s Handbook.â€</span> <em>Black Hat USA</em>. Wiley. <a href="https://doi.org/10.1002/9781119183525.ch15">https://doi.org/10.1002/9781119183525.ch15</a>.
</div><div id="ref-miller2019lessons" class="csl-entry" role="listitem">
Miller, Charlie. 2019. <span>â€œLessons Learned from Hacking a Car.â€</span> <em>IEEE Design &amp;Amp; Test</em> 36 (6): 7â€“9. <a href="https://doi.org/10.1109/mdat.2018.2863106">https://doi.org/10.1109/mdat.2018.2863106</a>.
</div></div><p>This demonstration served as a wake-up call for the automotive industry, highlighting the risks posed by the growing connectivity of modern vehicles. Traditionally isolated automotive control systems, such as those managing steering and braking, were shown to be vulnerable when exposed through externally accessible software interfaces. The ability to remotely manipulate safety-critical functions raised serious concerns about passenger safety, regulatory oversight, and industry best practices.</p>
<p>The incident also led to a recall of over 1.4 million vehicles to patch the vulnerability<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>, highlighting the need for manufacturers to prioritize cybersecurity in their designs. The National Highway Traffic Safety Administration (NHTSA)<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> issued guidelines for automakers to improve vehicle cybersecurity, including recommendations for secure software development practices and incident response protocols.</p>
<div class="no-row-height column-margin column-container"><div id="fn6"><p><sup>6</sup>&nbsp;<strong>Automotive Cybersecurity Recalls</strong>: The Jeep Cherokee hack triggered the first-ever automotive cybersecurity recall in 2015. Since then, cybersecurity recalls have affected over 15 million vehicles globally, costing manufacturers an estimated $2.4 billion in remediation efforts and spurring new regulations.</p></div><div id="fn7"><p><sup>7</sup>&nbsp;<strong>NHTSA Cybersecurity Guidance</strong>: NHTSA, established in 1970, issued its first cybersecurity guidance in 2016 following the Jeep hack. The agency now mandates that connected vehicles include cybersecurity by design, affecting 99% of new vehicles sold in the US that contain 100+ onboard computers.</p></div></div><p>The Jeep Cherokee hack offers critical lessons for ML system security. Connected ML systems require strict isolation between external interfaces and safety-critical components, as this incident dramatically illustrated. The architectural flaw (allowing external interfaces to reach safety-critical functions) directly threatens modern ML deployments where inference APIs often connect to physical actuators or critical systems.</p>
<p>Modern ML attack vectors exploit these same isolation failures across multiple domains: (1) Autonomous vehicles where compromised infotainment system ML APIs (voice recognition, navigation) gain access to perception models controlling steering and braking; (2) Smart home systems where exploited voice assistant wake-word detection models provide backdoor access to security systems, door locks, and cameras; (3) Industrial IoT where compromised edge ML inference endpoints (predictive maintenance, anomaly detection) manipulate actuator control logic in manufacturing systems; (4) Medical devices where attacked diagnostic ML models influence treatment recommendations and drug delivery systems.</p>
<p>Consider a concrete attack scenario: a smart home voice assistant processes user commands through cloud-based NLP models. An attacker exploits a vulnerability in the voice processing API to inject malicious commands that bypass authentication. Through insufficient network segmentation, the compromised voice system gains access to the home security ML model responsible for facial recognition door unlocking, allowing unauthorized physical access.</p>
<p>Effective defense requires comprehensive isolation architecture: (1) network segmentation to isolate ML inference networks from actuator control networks using firewalls and VPNs; (2) API authentication requiring cryptographic authentication for all ML API calls with rate limiting and anomaly detection; (3) privilege separation to run inference models in sandboxed environments with minimal system permissions; (4) fail-safe defaults that design actuator control logic to revert to safe states (locked doors, stopped motors) when ML systems detect anomalies or lose connectivity; (5) monitoring that implements real-time logging and alerting for suspicious ML API usage patterns.</p>
</section>
<section id="sec-security-privacy-weaponized-endpoints-mirai-botnet-931c" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-security-privacy-weaponized-endpoints-mirai-botnet-931c">Weaponized Endpoints: Mirai Botnet</h3>
<p>While the Jeep Cherokee hack demonstrated targeted exploitation of connected systems, the Mirai botnet revealed how poor security practices could be weaponized at massive scale. In 2016, the <a href="https://www.cloudflare.com/learning/ddos/what-is-a-ddos-attack/">Mirai botnet</a><a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> emerged as one of the most disruptive distributed denial-of-service (DDoS)<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> attacks in internet history <span class="citation" data-cites="antonakakis2017understanding">(<a href="#ref-antonakakis2017understanding" role="doc-biblioref">Antonakakis et al. 2017</a>)</span>. The botnet infected thousands of networked devices, including digital cameras, DVRs, and other consumer electronics. These devices, often deployed with factory-default usernames and passwords, were easily compromised by the Mirai malware and enlisted into a large-scale attack network.</p>
<div class="no-row-height column-margin column-container"><div id="fn8"><p><sup>8</sup>&nbsp;<strong>Mirai Botnet Scale</strong>: At its peak, Mirai controlled over 600,000 infected IoT devices, generating peak attacks of 1.2 Tbps (1,200 Gbps) against OVH hosting provider, making it one of the first terabit-scale DDoS attacks. The attack revealed that IoT devices with default credentials (admin/admin, root/12345) could be weaponized at unprecedented scale.</p></div><div id="fn9"><p><sup>9</sup>&nbsp;<strong>DDoS Attacks</strong>: Distributed Denial-of-Service (DDoS) attacks overwhelm targets with traffic from multiple sources, first demonstrated in 1999. Modern DDoS attacks can exceed 3.47 Tbps (terabits per second), enough to take down entire internet infrastructures and costing businesses $2.3 million per incident on average.</p></div><div id="ref-antonakakis2017understanding" class="csl-entry" role="listitem">
Antonakakis, Manos, Tim April, Michael Bailey, Matt Bernhard, Elie Bursztein, Jaime Cochran, Zakir Durumeric, et al. 2017. <span>â€œUnderstanding the Mirai Botnet.â€</span> In <em>26th USENIX Security Symposium (USENIX Security 17)</em>, 16:1093â€“1110.
</div></div><p>The Mirai botnet was used to overwhelm major internet infrastructure providers, disrupting access to popular online services across the United States and beyond. The scale of the attack demonstrated how vulnerable consumer and industrial devices can become a platform for widespread disruption when security is not prioritized in their design and deployment.</p>
<p>The Mirai botnetâ€™s lessons apply directly to modern ML deployments. Edge-deployed ML devices with weak authentication become weaponized attack infrastructure at unprecedented scale, precisely as the Mirai botnet demonstrated with traditional IoT devices. Modern ML edge devices (smart cameras running object detection, voice assistants performing wake-word detection, autonomous drones with navigation models, industrial IoT sensors with anomaly detection algorithms) face identical vulnerability patterns but with amplified consequences due to their AI capabilities and access to sensitive data.</p>
<p>The attack escalation with ML devices differs significantly from traditional IoT compromises. Unlike simple IoT devices that provided only computing power for DDoS attacks, compromised ML devices offer sophisticated capabilities: (1) Data exfiltration where smart cameras leak facial recognition databases, voice assistants extract conversation transcripts, and health monitors steal biometric data; (2) Model weaponization where hijacked autonomous drones coordinate swarm attacks and compromised traffic cameras misreport vehicle counts to manipulate traffic systems; (3) AI-powered reconnaissance where compromised edge ML devices use their trained models to identify high-value targets (facial recognition for VIP identification, voice analysis for emotion detection) and coordinate sophisticated multi-stage attacks.</p>
<p>Consider a concrete attack scenario where attackers compromise 50,000 smart security cameras with default passwords, each running ML object detection models. Rather than traditional DDoS attacks, they use the compromised cameras to: (1) extract facial recognition databases from residential and commercial buildings; (2) coordinate physical surveillance of targeted individuals using distributed camera networks; (3) inject false object detection alerts to trigger emergency responses and create chaos; (4) use the camerasâ€™ computing power to train adversarial examples against other security systems.</p>
<p>Comprehensive defense against such weaponization requires zero-trust edge security: (1) Secure manufacturing that eliminates default credentials, implements hardware security modules (HSMs) for device-unique keys, and enables secure boot with cryptographic verification; (2) Encrypted communications that mandate TLS 1.3+ for all ML API communications with certificate pinning and mutual authentication; (3) Behavioral monitoring that deploys anomaly detection systems to identify unusual inference patterns, unexpected network traffic, and suspicious computational loads; (4) Automated response that implements kill switches to disable compromised devices remotely and quarantine them from networks; (5) Update security that enforces cryptographically signed firmware updates with automatic security patching and version rollback capabilities.</p>
<div id="quiz-question-sec-security-privacy-learning-security-breaches-6719" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.3</strong></summary><div>
<ol type="1">
<li><p>What was the primary objective of the Stuxnet worm?</p>
<ol type="a">
<li>To steal sensitive information from industrial systems.</li>
<li>To disrupt internet services globally.</li>
<li>To perform espionage on government networks.</li>
<li>To cause physical damage to industrial infrastructure.</li>
</ol></li>
<li><p>Explain how the Jeep Cherokee hack illustrates the importance of isolation in connected systems.</p></li>
<li><p>Which of the following measures would NOT effectively defend against supply chain attacks in ML systems?</p>
<ol type="a">
<li>Cryptographic verification of all model artifacts.</li>
<li>Disabling all network connections to ML systems.</li>
<li>Provenance tracking of training data sources.</li>
<li>Integrity validation of model dependencies.</li>
</ol></li>
<li><p>How might lessons from the Mirai botnet be applied to securing modern ML edge devices?</p></li>
</ol>
<p><a href="#quiz-answer-sec-security-privacy-learning-security-breaches-6719" class="question-label">See Answers â†’</a></p>
</div></details>
</div>
</section>
</section>
<section id="sec-security-privacy-systematic-threat-analysis-risk-assessment-3ef1" class="level2">
<h2 class="anchored" data-anchor-id="sec-security-privacy-systematic-threat-analysis-risk-assessment-3ef1">Systematic Threat Analysis and Risk Assessment</h2>
<p>The historical incidents demonstrate how fundamental security failures manifest across different computing paradigms. Supply chain vulnerabilities enable persistent compromise, insufficient isolation allows privilege escalation, and weaponized endpoints create attack infrastructure at scale. These patterns directly apply to machine learning deployments: compromised training pipelines and model repositories inherit supply chain risks, external interfaces to safety-critical ML components require strict isolation, and compromised ML edge devices can exfiltrate inference data or participate in coordinated attacks.</p>
<p>These historical incidents reveal universal security patterns that translate directly to ML system vulnerabilities. Supply chain compromise, as demonstrated by Stuxnet, manifests in ML through training data poisoning and backdoored model repositories. Insufficient isolation, exemplified by the Jeep Cherokee hack, appears in ML API access to safety-critical systems and compromised inference endpoints. Weaponized endpoints, illustrated by the Mirai botnet, emerge through hijacked ML edge devices capable of coordinated AI-powered attacks.</p>
<p>The key insight is that traditional cybersecurity patterns amplify in ML systems because models learn from data and make autonomous decisions. While Stuxnet required sophisticated malware to manipulate industrial controllers, ML systems can be compromised through data poisoning that appears statistically normal but embeds hidden behaviors. This characteristic makes ML systems both more vulnerable to subtle attacks and more dangerous when compromised, as they can make decisions affecting physical systems autonomously. Understanding these historical patterns helps recognize how familiar attack vectors manifest in ML contexts, while the unique properties of learning systems (statistical learning, decision autonomy, and data dependency) create new attack surfaces requiring specialized defenses.</p>
<p>Machine learning systems introduce attack vectors that extend beyond traditional computing vulnerabilities. The data-driven nature of learning creates new opportunities for adversaries: training data can be manipulated to embed backdoors, input perturbations can exploit learned decision boundaries, and systematic API queries can extract proprietary model knowledge. These ML-specific threats require specialized defenses that account for the statistical and probabilistic foundations of learning systems, complementing traditional infrastructure hardening.</p>
<section id="sec-security-privacy-threat-prioritization-framework-f2d5" class="level3">
<h3 class="anchored" data-anchor-id="sec-security-privacy-threat-prioritization-framework-f2d5">Threat Prioritization Framework</h3>
<p>With the wide range of potential threats facing ML systems, practitioners need a framework to prioritize their defensive efforts effectively. Not all threats are equally likely or impactful, and security resources are always constrained. A simple prioritization matrix based on likelihood and impact helps focus attention where it matters most.</p>
<p>Consider these threat priority categories:</p>
<ul>
<li><p><strong>High Likelihood / High Impact</strong>: Data poisoning in federated learning systems where training data comes from untrusted sources. These attacks are relatively easy to execute but can severely compromise model behavior.</p></li>
<li><p><strong>High Likelihood / Medium Impact</strong>: Model extraction attacks against public APIs. These are common and technically simple but may only affect competitive advantage rather than safety or privacy.</p></li>
<li><p><strong>Low Likelihood / High Impact</strong>: Hardware side-channel attacks on cloud-deployed models. These require sophisticated adversaries and physical access but could expose all model parameters and user data.</p></li>
<li><p><strong>Medium Likelihood / Medium Impact</strong>: Membership inference attacks against models trained on sensitive data. These require some technical skill but mainly threaten individual privacy rather than system integrity.</p></li>
</ul>
<p>This framework guides resource allocation throughout this chapter. We begin with the most common and accessible threats (model theft, data poisoning, and adversarial attacks) before examining more specialized hardware and infrastructure vulnerabilities. Understanding these priority levels helps practitioners implement defenses in a logical sequence that maximizes security benefit per invested effort.</p>
<div id="quiz-question-sec-security-privacy-systematic-threat-analysis-risk-assessment-3ef1" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.4</strong></summary><div>
<ol type="1">
<li><p>Which historical security incident is most similar to data poisoning attacks in ML systems?</p>
<ol type="a">
<li>Heartbleed</li>
<li>Jeep Cherokee hack</li>
<li>Mirai botnet</li>
<li>Stuxnet</li>
</ol></li>
<li><p>Explain why ML systems are particularly vulnerable to subtle attacks compared to traditional systems.</p></li>
<li><p>In the context of ML-specific threats, which of the following requires specialized defenses beyond traditional infrastructure hardening?</p>
<ol type="a">
<li>Supply chain vulnerabilities</li>
<li>Network intrusion</li>
<li>Data poisoning</li>
<li>Physical theft</li>
</ol></li>
<li><p>Order the following threat priority categories from highest to lowest based on their likelihood and impact: (1) High Likelihood / High Impact, (2) High Likelihood / Medium Impact, (3) Low Likelihood / High Impact, (4) Medium Likelihood / Medium Impact.</p></li>
</ol>
<p><a href="#quiz-answer-sec-security-privacy-systematic-threat-analysis-risk-assessment-3ef1" class="question-label">See Answers â†’</a></p>
</div></details>
</div>
</section>
</section>
<section id="sec-security-privacy-modelspecific-attack-vectors-0575" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-security-privacy-modelspecific-attack-vectors-0575">Model-Specific Attack Vectors</h2>
<p>Machine learning systems face threats spanning the entire ML lifecycle, from training-time manipulations to inference-time evasion. These threats fall into three broad categories: threats to model confidentiality (model theft), threats to training integrity (data poisoning<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>), and threats to inference robustness (adversarial examples<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>). Each category targets different vulnerabilities and requires distinct defensive strategies.</p>
<div class="no-row-height column-margin column-container"><div id="fn10"><p><sup>10</sup>&nbsp;<strong>Data Poisoning Attacks</strong>: Data poisoning is an attack technique where adversaries inject malicious data during training, first formalized in 2012 <span class="citation" data-cites="biggio2012poisoning">(<a href="#ref-biggio2012poisoning" role="doc-biblioref">Biggio, Nelson, and Laskov 2012</a>)</span>. Studies show that poisoning just 0.1% of training data can reduce model accuracy by 10-50%, making it a highly efficient attack vector against ML systems.</p></div><div id="fn11"><p><sup>11</sup>&nbsp;<strong>Adversarial Examples</strong>: Adversarial examples are inputs crafted to deceive ML models, discovered by Szegedy et al. <span class="citation" data-cites="szegedy2014intriguing">(<a href="#ref-szegedy2014intriguing" role="doc-biblioref">Szegedy et al. 2013</a>)</span>. These attacks can fool state-of-the-art image classifiers with perturbations invisible to humans (changing &lt;0.01% of pixel values), affecting 99%+ of deep learning models.</p><div id="ref-szegedy2014intriguing" class="csl-entry" role="listitem">
Szegedy, Christian, Wojciech Zaremba, Ilya Sutskever, Joan Bruna, Dumitru Erhan, Ian Goodfellow, and Rob Fergus. 2013. <span>â€œIntriguing Properties of Neural Networks.â€</span> <em>ICLR</em>, December. <a href="http://arxiv.org/abs/1312.6199v4">http://arxiv.org/abs/1312.6199v4</a>.
</div></div></div><p>Understanding when and where different attacks occur in the ML lifecycle helps prioritize defenses and understand attacker motivations. <a href="#fig-ml-lifecycle-threats" class="quarto-xref">Figure&nbsp;2</a> maps the primary attack vectors to their target stages in the machine learning pipeline, revealing how adversaries exploit different system vulnerabilities at different times.</p>
<ul>
<li><p><strong>During Data Collection</strong>: Attackers can inject malicious samples or manipulate labels in training datasets, particularly in federated learning or crowdsourced data scenarios where data sources are less controlled.</p></li>
<li><p><strong>During Training</strong>: This stage faces backdoor insertion attacks, where adversaries embed hidden behaviors that activate only under specific trigger conditions, and label manipulation attacks that systematically corrupt the learning process.</p></li>
<li><p><strong>During Deployment</strong>: Model theft attacks target this stage because trained models become accessible through APIs, file downloads, or reverse engineering of mobile applications. This is where intellectual property is most vulnerable.</p></li>
<li><p><strong>During Inference</strong>: Adversarial attacks occur at runtime, where attackers craft inputs designed to fool deployed models into making incorrect predictions while appearing normal to human observers.</p></li>
</ul>
<p>This lifecycle perspective reveals that different threats require different defensive strategies. Data validation protects the collection phase, secure training environments protect the training phase, access controls and API design protect deployment, and input validation protects inference. By understanding which attacks target which lifecycle stages, security teams can implement appropriate defenses at the right architectural layers.</p>
<div id="fig-ml-lifecycle-threats" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ml-lifecycle-threats-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="5e5e69715fe10b656edf1b02f3ecbf8047e9d96f.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Figure&nbsp;2: ML Lifecycle Threats: Model theft, data poisoning, and adversarial attacks target distinct stages of the machine learning lifecycle (from data ingestion to model deployment and inference), creating unique vulnerabilities at each step. Understanding these lifecycle positions clarifies attack surfaces and guides the development of targeted defense strategies for robust AI systems."><img src="privacy_security_files/mediabag/5e5e69715fe10b656edf1b02f3ecbf8047e9d96f.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ml-lifecycle-threats-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: <strong>ML Lifecycle Threats</strong>: Model theft, data poisoning, and adversarial attacks target distinct stages of the machine learning lifecycle (from data ingestion to model deployment and inference), creating unique vulnerabilities at each step. Understanding these lifecycle positions clarifies attack surfaces and guides the development of targeted defense strategies for robust AI systems.
</figcaption>
</figure>
</div>
<p>Machine learning models are not solely passive victims of attack; in some cases, they can be employed as components of an attack strategy. Pretrained models, particularly large generative or discriminative networks, may be adapted to automate tasks such as adversarial example generation, phishing content synthesis<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a>, or protocol subversion. Open-source or publicly accessible models can be fine-tuned for malicious purposes, including impersonation, surveillance, or reverse-engineering of secure systems.</p>
<div class="no-row-height column-margin column-container"><div id="fn12"><p><sup>12</sup>&nbsp;<strong>AI-Generated Phishing</strong>: Large language models can generate convincing phishing emails with 99%+ grammatical accuracy, compared to 19% for traditional phishing. Security firms report dramatic increases in AI-generated phishing attacks since 2022, with some studies citing 1,265% growth (though methodologies and baselines vary significantly), with some campaigns achieving 30%+ success rates. This dual-use potential necessitates a broader security perspective that considers models not only as assets to defend but also as possible instruments of attack.</p></div></div><section id="sec-security-privacy-model-theft-1879" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-security-privacy-model-theft-1879">Model Theft</h3>
<p>The first category of model-specific threats targets confidentiality. Threats to model confidentiality arise when adversaries gain access to a trained modelâ€™s parameters, architecture, or output behavior. These attacks can undermine the economic value of machine learning systems, allow competitors to replicate proprietary functionality, or expose private information encoded in model weights.</p>
<p>Such threats arise across a range of deployment settings, including public APIs<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>, cloud-hosted services, on-device inference engines, and shared model repositories<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a>. Machine learning models may be vulnerable due to exposed interfaces, insecure serialization formats<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a>, or insufficient access controls, factors that create opportunities for unauthorized extraction or replication <span class="citation" data-cites="ateniese2015hacking">(<a href="#ref-ateniese2015hacking" role="doc-biblioref">Ateniese et al. 2015</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="fn13"><p><sup>13</sup>&nbsp;<strong>Machine Learning APIs</strong>: Machine learning APIs (Application Programming Interfaces) were popularized by Googleâ€™s Prediction API (2010). Todayâ€™s ML APIs handle billions of requests daily, with major providers processing billions of tokens monthly, creating vast attack surfaces for model extraction.</p></div><div id="fn14"><p><sup>14</sup>&nbsp;<strong>Model Repositories</strong>: Model repositories are centralized platforms for sharing ML models, led by Hugging Face (2016) which hosts 500,000+ models. While democratizing AI access, these repositories have become targets for supply chain attacks, with researchers finding malicious models in 5% of popular repositories <span class="citation" data-cites="oliynyk2023know">(<a href="#ref-oliynyk2023know" role="doc-biblioref">Oliynyk, Mayer, and Rauber 2023</a>)</span>.</p><div id="ref-oliynyk2023know" class="csl-entry" role="listitem">
Oliynyk, Daryna, Rudolf Mayer, and Andreas Rauber. 2023. <span>â€œI Know What You Trained Last Summer: A Survey on Stealing Machine Learning Models and Defences.â€</span> <em>ACM Computing Surveys</em> 55 (14s): 1â€“41. <a href="https://doi.org/10.1145/3595292">https://doi.org/10.1145/3595292</a>.
</div></div><div id="fn15"><p><sup>15</sup>&nbsp;<strong>Model Serialization</strong>: Model serialization is the process of converting trained models into portable formats like ONNX (2017), TensorFlow SavedModel (2016), or PyTorchâ€™s .pth files. Insecure serialization can expose model weights and enable arbitrary code execution, affecting 80%+ of deployed ML systems <span class="citation" data-cites="ateniese2015hacking tramer2016stealing">(<a href="#ref-ateniese2015hacking" role="doc-biblioref">Ateniese et al. 2015</a>; <a href="#ref-tramer2016stealing" role="doc-biblioref">TramÃ¨r et al. 2016</a>)</span>.</p><div id="ref-ateniese2015hacking" class="csl-entry" role="listitem">
Ateniese, Giuseppe, Luigi V. Mancini, Angelo Spognardi, Antonio Villani, Domenico Vitali, and Giovanni Felici. 2015. <span>â€œHacking Smart Machines with Smarter Ones: How to Extract Meaningful Data from Machine Learning Classifiers.â€</span> <em>International Journal of Security and Networks</em> 10 (3): 137. <a href="https://doi.org/10.1504/ijsn.2015.071829">https://doi.org/10.1504/ijsn.2015.071829</a>.
</div><div id="ref-tramer2016stealing" class="csl-entry" role="listitem">
TramÃ¨r, Florian, Fan Zhang, Ari Juels, Michael K Reiter, and Thomas Ristenpart. 2016. <span>â€œStealing Machine Learning Models via Prediction APIs.â€</span> In <em>25th USENIX Security Symposium (USENIX Security 16)</em>, 601â€“18.
</div></div></div><p>The severity of these threats is underscored by high-profile legal cases that have highlighted the strategic and economic value of machine learning models. For example, former Google engineer Anthony Levandowski was accused of <a href="https://www.nytimes.com/2017/02/23/technology/google-self-driving-waymo-uber-otto-lawsuit.html">stealing proprietary designs from Waymo</a>, including critical components of its autonomous vehicle technology, before founding a competing startup. Such cases illustrate the potential for insider threats to bypass technical protections and gain access to sensitive intellectual property.</p>
<p>The consequences of model theft extend beyond economic loss. Stolen models can be used to extract sensitive information, replicate proprietary algorithms, or enable further attacks. The economic impact can be substantial: research estimates suggest that aspects of large language models can be approximated through systematic API queries at costs orders of magnitude lower than original training, though full model replication remains economically and technically challenging <span class="citation" data-cites="tramer2016stealing carlini2024stealing">(<a href="#ref-tramer2016stealing" role="doc-biblioref">TramÃ¨r et al. 2016</a>; <a href="#ref-carlini2024stealing" role="doc-biblioref">Carlini et al. 2024</a>)</span>. For instance, a competitor who obtains a stolen recommendation model from an e-commerce platform might gain insights into customer behavior, business analytics, and embedded trade secrets. This knowledge can also be used to conduct model inversion attacks<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a>, where an attacker attempts to infer private details about the modelâ€™s training data <span class="citation" data-cites="fredrikson2015model">(<a href="#ref-fredrikson2015model" role="doc-biblioref">Fredrikson, Jha, and Ristenpart 2015</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="fn16"><p><sup>16</sup>&nbsp;<strong>Model Inversion Attacks</strong>: Model inversion attacks were first demonstrated in 2015 against face recognition systems, when researchers reconstructed recognizable faces from neural network outputs using only confidence scores. The attack revealed that models trained on 40 individuals could leak identifiable facial features, proving that â€œblack-boxâ€ API access isnâ€™t sufficient privacy protection.</p></div><div id="ref-fredrikson2015model" class="csl-entry" role="listitem">
Fredrikson, Matt, Somesh Jha, and Thomas Ristenpart. 2015. <span>â€œModel Inversion Attacks That Exploit Confidence Information and Basic Countermeasures.â€</span> In <em>Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security</em>, 1322â€“33. ACM. <a href="https://doi.org/10.1145/2810103.2813677">https://doi.org/10.1145/2810103.2813677</a>.
</div><div id="fn17"><p><sup>17</sup>&nbsp;<strong>Netflix Deanonymization</strong>: In 2008, researchers re-identified Netflix users by correlating the â€œanonymousâ€ Prize dataset with public IMDb ratings. Using as few as 8 movie ratings with dates, they identified 99% of users, leading Netflix to cancel a second competition and highlighting the futility of naive anonymization.</p></div><div id="ref-narayanan2006break" class="csl-entry" role="listitem">
Narayanan, Arvind, and Vitaly Shmatikov. 2006. <span>â€œHow to Break Anonymity of the Netflix Prize Dataset.â€</span> <em>CoRR</em>. <a href="http://arxiv.org/abs/cs/0610105">http://arxiv.org/abs/cs/0610105</a>.
</div></div><p>In a model inversion attack, the adversary queries the model through a legitimate interface, such as a public API, and observes its outputs. By analyzing confidence scores or output probabilities, the attacker can optimize inputs to reconstruct data resembling the modelâ€™s training set. For example, a facial recognition model used for secure access could be manipulated to reveal statistical properties of the employee photos on which it was trained. Similar vulnerabilities have been demonstrated in studies on the Netflix Prize dataset<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a>, where researchers inferred individual movie preferences from anonymized data <span class="citation" data-cites="narayanan2006break">(<a href="#ref-narayanan2006break" role="doc-biblioref">Narayanan and Shmatikov 2006</a>)</span>.</p>
<p>Model theft can target two distinct objectives: extracting exact model properties, such as architecture and parameters, or replicating approximate model behavior to produce similar outputs without direct access to internal representations. Understanding neural network architectures helps recognize which architectural patterns are most vulnerable to extraction attacks. The specific architectural vulnerabilities vary by model type, as discussed in <strong><a href="../dnn_architectures/dnn_architectures.html#sec-dnn-architectures">Chapter 4: DNN Architectures</a></strong>. Both forms of theft undermine the security and value of machine learning systems, as explored in the following subsections.</p>
<p>These two attack paths are illustrated in <a href="#fig-model-theft-types" class="quarto-xref">Figure&nbsp;3</a>. In exact model theft, the attacker gains access to the modelâ€™s internal components, including serialized files, weights, and architecture definitions, and reproduces the model directly. In contrast, approximate model theft relies on observing the modelâ€™s input-output behavior, typically through a public API. By repeatedly querying the model and collecting responses, the attacker trains a surrogate that mimics the original modelâ€™s functionality. The first approach compromises the modelâ€™s internal design and training investment, while the second threatens its predictive value and can facilitate further attacks such as adversarial example transfer or model inversion.</p>
<div id="fig-model-theft-types" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-model-theft-types-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="87ec315deb382f5bf7e0e18f79ccd7bb168f9c33.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="Figure&nbsp;3: Model Theft Strategies: Attackers can target either a modelâ€™s internal parameters or its external behavior to create a stolen copy. Direct theft extracts model weights and architecture, while approximate theft trains a surrogate model by querying the originalâ€™s input-output behavior, potentially enabling further attacks despite lacking direct access to internal components."><img src="privacy_security_files/mediabag/87ec315deb382f5bf7e0e18f79ccd7bb168f9c33.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-model-theft-types-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: <strong>Model Theft Strategies</strong>: Attackers can target either a modelâ€™s internal parameters or its external behavior to create a stolen copy. Direct theft extracts model weights and architecture, while approximate theft trains a surrogate model by querying the originalâ€™s input-output behavior, potentially enabling further attacks despite lacking direct access to internal components.
</figcaption>
</figure>
</div>
<section id="sec-security-privacy-exact-model-theft-b738" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-security-privacy-exact-model-theft-b738">Exact Model Theft</h4>
<p>Exact model property theft refers to attacks aimed at extracting the internal structure and learned parameters of a machine learning model. These attacks often target deployed models that are exposed through APIs, embedded in on-device inference engines, or shared as downloadable model files on collaboration platforms. Exploiting weak access control, insecure model packaging, or unprotected deployment interfaces, attackers can recover proprietary model assets without requiring full control of the underlying infrastructure.</p>
<p>These attacks typically seek three types of information. The first is the modelâ€™s learned parameters, such as weights and biases. By extracting these parameters, attackers can replicate the modelâ€™s functionality without incurring the cost of training. This replication allows them to benefit from the modelâ€™s performance while bypassing the original development effort.</p>
<p>The second target is the modelâ€™s fine-tuned hyperparameters, including training configurations such as learning rate, batch size, and regularization settings. These hyperparameters significantly influence model performance, and stealing them allows attackers to reproduce high-quality results with minimal additional experimentation.</p>
<p>Finally, attackers may seek to reconstruct the modelâ€™s architecture. This includes the sequence and types of layers, activation functions, and connectivity patterns that define the modelâ€™s behavior. Architecture theft may be accomplished through side-channel attacks<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a>, reverse engineering, or analysis of observable model behavior.</p>
<div class="no-row-height column-margin column-container"><div id="fn18"><p><sup>18</sup>&nbsp;<strong>ML Side-Channel Attacks</strong>: Side-channel attacks on ML were first demonstrated against neural networks in 2018, when researchers showed that power consumption patterns during inference could reveal sensitive model information. This extended traditional cryptographic side-channel attacks into the ML domain, creating new vulnerabilities for edge AI devices.</p></div></div><p>Revealing the architecture not only compromises intellectual property but also gives competitors strategic insights into the design choices that provide competitive advantage.</p>
<p>System designers must account for these risks by securing model serialization formats, restricting access to runtime APIs, and hardening deployment pipelines. Protecting models requires a combination of software engineering practices, including access control, encryption, and obfuscation techniques, to reduce the risk of unauthorized extraction <span class="citation" data-cites="tramer2016stealing">(<a href="#ref-tramer2016stealing" role="doc-biblioref">TramÃ¨r et al. 2016</a>)</span>.</p>
<div class="no-row-height column-margin column-container"></div></section>
<section id="sec-security-privacy-approximate-model-theft-1155" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-security-privacy-approximate-model-theft-1155">Approximate Model Theft</h4>
<p>While some attackers seek to extract a modelâ€™s exact internal properties, others focus on replicating its external behavior. Approximate model behavior theft refers to attacks that attempt to recreate a modelâ€™s decision-making capabilities without directly accessing its parameters or architecture. Instead, attackers observe the modelâ€™s inputs and outputs to build a substitute model that performs similarly on the same tasks.</p>
<p>This type of theft often targets models deployed as services, where the model is exposed through an API or embedded in a user-facing application. By repeatedly querying the model and recording its responses, an attacker can train their own model to mimic the behavior of the original. This process, often called model distillation<a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a> or knockoff modeling, allows attackers to achieve comparable functionality without access to the original modelâ€™s proprietary internals <span class="citation" data-cites="orekondy2019knockoff">(<a href="#ref-orekondy2019knockoff" role="doc-biblioref">Orekondy, Schiele, and Fritz 2019</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="fn19"><p><sup>19</sup>&nbsp;<strong>Model Distillation</strong>: Model distillation is a knowledge transfer technique developed by <span class="citation" data-cites="hinton2015distilling">(<a href="#ref-hinton2015distilling" role="doc-biblioref">Hinton, Vinyals, and Dean 2015</a>)</span> where a smaller â€œstudentâ€ model learns from a larger â€œteacherâ€ model. While designed for model compression, attackers exploit this to create stolen models with 95%+ accuracy using only 1% of the original training data.</p><div id="ref-hinton2015distilling" class="csl-entry" role="listitem">
Hinton, Geoffrey, Oriol Vinyals, and Jeff Dean. 2015. <span>â€œDistilling the Knowledge in a Neural Network.â€</span> <em>arXiv Preprint arXiv:1503.02531</em>, March. <a href="http://arxiv.org/abs/1503.02531v1">http://arxiv.org/abs/1503.02531v1</a>.
</div></div><div id="ref-orekondy2019knockoff" class="csl-entry" role="listitem">
Orekondy, Tribhuvanesh, Bernt Schiele, and Mario Fritz. 2019. <span>â€œKnockoff Nets: Stealing Functionality of Black-Box Models.â€</span> In <em>2019 IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR)</em>, 4949â€“58. IEEE. <a href="https://doi.org/10.1109/cvpr.2019.00509">https://doi.org/10.1109/cvpr.2019.00509</a>.
</div></div><p>Attackers may evaluate the success of behavior replication in two ways. The first is by measuring the level of effectiveness of the substitute model. This involves assessing whether the cloned model achieves similar accuracy, precision, recall, or other performance metrics on benchmark tasks. By aligning the substituteâ€™s performance with that of the original, attackers can build a model that is practically indistinguishable in effectiveness, even if its internal structure differs.</p>
<p>The second is by testing prediction consistency. This involves checking whether the substitute model produces the same outputs as the original model when presented with the same inputs. Matching not only correct predictions but also the original modelâ€™s mistakes can provide attackers with a high-fidelity reproduction of the target modelâ€™s behavior. This poses particular concern in applications such as natural language processing, where attackers might replicate sentiment analysis models to gain competitive insights or bypass proprietary systems.</p>
<p>Approximate behavior theft proves challenging to defend against in open-access deployment settings, such as public APIs or consumer-facing applications. Limiting the rate of queries, detecting automated extraction patterns, and watermarking model outputs are among the techniques that can help mitigate this risk. However, these defenses must be balanced with usability and performance considerations, especially in production environments.</p>
<p>One demonstration of approximate model theft extracts internal components of black-box language models via public APIs. In their paper, <span class="citation" data-cites="carlini2024stealing">Carlini et al. (<a href="#ref-carlini2024stealing" role="doc-biblioref">2024</a>)</span>, researchers show how to reconstruct the final embedding projection matrix of several OpenAI models, including <code>ada</code>, <code>babbage</code>, and <code>gpt-3.5-turbo</code>, using only public API access. By exploiting the low-rank structure of the output projection layer and making carefully crafted queries, they recover the modelâ€™s hidden dimensionality and replicate the weight matrix up to affine transformations.</p>
<div class="no-row-height column-margin column-container"></div><p>The attack does not reconstruct the full model, but reveals internal architecture parameters and sets a precedent for future, deeper extractions. This work demonstrated that even partial model theft poses risks to confidentiality and competitive advantage, especially when model behavior can be probed through rich API responses such as logit bias and log-probabilities.</p>
<div id="tbl-openai-theft" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-tbl figure page-columns page-full">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-openai-theft-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;2: <strong>Model Stealing Costs</strong>: Attackers can extract model weights with a relatively low query cost using publicly available apis; the table quantifies this threat for OpenAIâ€™s ada and babbage models, showing that extracting weights achieves low root mean squared error (RMSE) with fewer than (4 ^6) queries. Estimated costs for weight extraction range from $1 to $12, demonstrating the economic feasibility of model stealing attacks despite API rate limits and associated expenses. Source: <span class="citation" data-cites="carlini2024stealing">Carlini et al. (<a href="#ref-carlini2024stealing" role="doc-biblioref">2024</a>)</span>.
</figcaption>
<div class="no-row-height column-margin column-container"><div id="ref-carlini2024stealing" class="csl-entry" role="listitem">
Carlini, Nicholas, Daniel Paleka, Krishnamurthy Dj Dvijotham, Thomas Steinke, Jonathan Hayase, A. Feder Cooper, Katherine Lee, et al. 2024. <span>â€œStealing Part of a Production Language Model.â€</span> <em>arXiv Preprint arXiv:2403.06634</em>, March. <a href="http://arxiv.org/abs/2403.06634v2">http://arxiv.org/abs/2403.06634v2</a>.
</div></div><div aria-describedby="tbl-openai-theft-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 23%">
<col style="width: 19%">
<col style="width: 14%">
<col style="width: 21%">
<col style="width: 19%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Model</strong></th>
<th style="text-align: left;"><strong>Size</strong> <strong>(Dimension Extraction)</strong></th>
<th style="text-align: right;"><strong>Number of</strong> <strong>Queries</strong></th>
<th style="text-align: left;"><strong>RMS</strong> <strong>(Weight Matrix Extraction)</strong></th>
<th style="text-align: right;"><strong>Cost (USD)</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>OpenAI ada</strong></td>
<td style="text-align: left;">1024 âœ“</td>
<td style="text-align: right;">&lt; 2 ^6$</td>
<td style="text-align: left;"><span class="math inline">\(5 \cdot 10^{-4}\)</span></td>
<td style="text-align: right;">$1 / $4</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>OpenAI babbage</strong></td>
<td style="text-align: left;">2048 âœ“</td>
<td style="text-align: right;">&lt; 4 ^6$</td>
<td style="text-align: left;"><span class="math inline">\(7 \cdot 10^{-4}\)</span></td>
<td style="text-align: right;">$2 / $12</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>OpenAI babbage-002</strong></td>
<td style="text-align: left;">1536 âœ“</td>
<td style="text-align: right;">&lt; 4 ^6$</td>
<td style="text-align: left;">Not implemented</td>
<td style="text-align: right;">$2 / $12</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>OpenAI gpt-3.5-turbo-instruct</strong></td>
<td style="text-align: left;">Not disclosed</td>
<td style="text-align: right;">&lt; 4 ^7$</td>
<td style="text-align: left;">Not implemented</td>
<td style="text-align: right;">$200 / ~$2,000 (estimated)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>OpenAI gpt-3.5-turbo-1106</strong></td>
<td style="text-align: left;">Not disclosed</td>
<td style="text-align: right;">&lt; 4 ^7$</td>
<td style="text-align: left;">Not implemented</td>
<td style="text-align: right;">$800 / ~$8,000 (estimated)</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>As shown in their empirical evaluation, reproduced in <a href="#tbl-openai-theft" class="quarto-xref">Table&nbsp;2</a>, model parameters could be extracted with root mean square errors as low as <span class="math inline">\(10^{-4}\)</span>, confirming that high-fidelity approximation is achievable at scale. These findings raise important implications for system design, suggesting that innocuous API features, like returning top-k logits, can serve as significant leakage vectors if not tightly controlled.</p>
</section>
<section id="sec-security-privacy-case-study-tesla-ip-theft-9d78" class="level4">
<h4 class="anchored" data-anchor-id="sec-security-privacy-case-study-tesla-ip-theft-9d78">Case Study: Tesla IP Theft</h4>
<p>In 2018, Tesla filed a <a href="https://storage.courtlistener.com/recap/gov.uscourts.nvd.131251/gov.uscourts.nvd.131251.1.0_1.pdf">lawsuit</a> against the self-driving car startup <a href="https://zoox.com/">Zoox</a>, alleging that former Tesla employees had stolen proprietary data and trade secrets related to Teslaâ€™s autonomous driving technology. According to the lawsuit, several employees transferred over 10 gigabytes of confidential files, including machine learning models and source code, before leaving Tesla to join Zoox.</p>
<p>Among the stolen materials was a key image recognition model used for object detection in Teslaâ€™s self-driving system. By obtaining this model, Zoox could have bypassed years of research and development, giving the company a competitive advantage. Beyond the economic implications, there were concerns that the stolen model could expose Tesla to further security risks, such as model inversion attacks aimed at extracting sensitive data from the modelâ€™s training set.</p>
<p>The Zoox employees denied any wrongdoing, and the case was ultimately settled out of court. The incident highlights the real-world risks of model theft, especially in industries where machine learning models represent significant intellectual property. The theft of models not only undermines competitive advantage but also raises broader concerns about privacy, safety, and the potential for downstream exploitation.</p>
<p>This case demonstrates that model theft is not limited to theoretical attacks conducted over APIs or public interfaces. Insider threats, supply chain vulnerabilities, and unauthorized access to development infrastructure pose equally serious risks to machine learning systems deployed in commercial environments.</p>
</section>
</section>
<section id="sec-security-privacy-data-poisoning-351f" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-security-privacy-data-poisoning-351f">Data Poisoning</h3>
<p>While model theft targets confidentiality, the second category of threats focuses on training integrity. Training integrity threats stem from the manipulation of data used to train machine learning models. These attacks aim to corrupt the learning process by introducing examples that appear benign but induce harmful or biased behavior in the final model.</p>
<p>Data poisoning attacks are a prominent example, in which adversaries inject carefully crafted data points into the training set to influence model behavior in targeted or systemic ways <span class="citation" data-cites="biggio2012poisoning">(<a href="#ref-biggio2012poisoning" role="doc-biblioref">Biggio, Nelson, and Laskov 2012</a>)</span>. Poisoned data may cause a model to make incorrect predictions, degrade its generalization ability, or embed failure modes that remain dormant until triggered post-deployment.</p>
<div class="no-row-height column-margin column-container"><div id="fn20"><p><sup>20</sup>&nbsp;<strong>Crowdsourcing Risks</strong>: Platforms like Amazon Mechanical Turk (2005) and Prolific democratized data labeling but introduced poisoning risks. Studies show 15-30% of crowdsourced labels contain errors or bias <span class="citation" data-cites="biggio2012poisoning oprea2022poisoning">(<a href="#ref-biggio2012poisoning" role="doc-biblioref">Biggio, Nelson, and Laskov 2012</a>; <a href="#ref-oprea2022poisoning" role="doc-biblioref">Oprea, Singhal, and Vassilev 2022</a>)</span>, with coordinated attacks capable of poisoning entire datasets at costs under $1,000.</p><div id="ref-biggio2012poisoning" class="csl-entry" role="listitem">
Biggio, Battista, Blaine Nelson, and Pavel Laskov. 2012. <span>â€œPoisoning Attacks Against Support Vector Machines.â€</span> In <em>Proceedings of the 29th International Conference on Machine Learning, ICML 2012, Edinburgh, Scotland, UK, June 26 - July 1, 2012</em>. icml.cc / Omnipress. <a href="http://icml.cc/2012/papers/880.pdf">http://icml.cc/2012/papers/880.pdf</a>.
</div><div id="ref-oprea2022poisoning" class="csl-entry" role="listitem">
Oprea, Alina, Anoop Singhal, and Apostol Vassilev. 2022. <span>â€œPoisoning Attacks Against Machine Learning: Can Machine Learning Be Trustworthy?â€</span> <em>Computer</em> 55 (11): 94â€“99. <a href="https://doi.org/10.1109/mc.2022.3190787">https://doi.org/10.1109/mc.2022.3190787</a>.
</div></div></div><p>Data poisoning is a security threat because it involves intentional manipulation of the training data by an adversary, with the goal of embedding vulnerabilities or subverting model behavior. These attacks pose concern in applications where models retrain on data collected from external sources, including user interactions, crowdsourced annotations<a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a>, and online scraping, since attackers can inject poisoned data without direct access to the training pipeline.</p>
<p>These attacks occur across diverse threat models. From a security perspective, poisoning attacks vary depending on the attackerâ€™s level of access and knowledge. In white-box scenarios, the adversary may have detailed insight into the model architecture or training process, enabling more precise manipulation. In contrast, black-box or limited-access attacks exploit open data submission channels or indirect injection vectors. Poisoning can target different stages of the ML pipeline, ranging from data collection and preprocessing to labeling and storage, making the attack surface both broad and system-dependent. The relative priority of data poisoning threats varies by deployment context as analyzed in <a href="#sec-security-privacy-threat-prioritization-framework-f2d5" class="quarto-xref">Section&nbsp;1.4.1</a>.</p>
<p>Poisoning attacks typically follow a three-stage process. First, the attacker injects malicious data into the training set. These examples are often designed to appear legitimate but introduce subtle distortions that alter the modelâ€™s learning process. Second, the model trains on this compromised data, embedding the attackerâ€™s intended behavior. Finally, once the model is deployed, the attacker may exploit the altered behavior to cause mispredictions, bypass safety checks, or degrade overall reliability.</p>
<p>To understand these attack mechanisms precisely, data poisoning can be viewed as a bilevel optimization problem, where the attacker seeks to select poisoning data <span class="math inline">\(D_p\)</span> that maximizes the modelâ€™s loss on a validation or target dataset <span class="math inline">\(D_{\text{test}}\)</span>. Let <span class="math inline">\(D\)</span> represent the original training data. The attackerâ€™s objective is to solve: <span class="math display">\[
\max_{D_p} \ \mathcal{L}(f_{D \cup D_p}, D_{\text{test}})
\]</span> where <span class="math inline">\(f_{D \cup D_p}\)</span> represents the model trained on the combined dataset of original and poisoned data. For targeted attacks, this objective can be refined to focus on specific inputs <span class="math inline">\(x_t\)</span> and target labels <span class="math inline">\(y_t\)</span>: <span class="math display">\[
\max_{D_p} \ \mathcal{L}(f_{D \cup D_p}, x_t, y_t)
\]</span></p>
<p>This formulation captures the adversaryâ€™s goal of introducing carefully crafted data points to manipulate the modelâ€™s decision boundaries.</p>
<p>For example, consider a traffic sign classification model trained to distinguish between stop signs and speed limit signs. An attacker might inject a small number of stop sign images labeled as speed limit signs into the training data. The attackerâ€™s goal is to subtly shift the modelâ€™s decision boundary so that future stop signs are misclassified as speed limit signs. In this case, the poisoning data <span class="math inline">\(D_p\)</span> consists of mislabeled stop sign images, and the attackerâ€™s objective is to maximize the misclassification of legitimate stop signs <span class="math inline">\(x_t\)</span> as speed limit signs <span class="math inline">\(y_t\)</span>, following the targeted attack formulation above. Even if the model performs well on other types of signs, the poisoned training process creates a predictable and exploitable vulnerability.</p>
<p>Data poisoning attacks can be classified based on their objectives and scope of impact. Availability attacks degrade overall model performance by introducing noise or label flips that reduce accuracy across tasks. Targeted attacks manipulate a specific input or class, leaving general performance intact but causing consistent misclassification in select cases. Backdoor attacks<a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a> embed hidden triggers, which are often imperceptible patterns, that elicit malicious behavior only when the trigger is present. Subpopulation attacks degrade performance on a specific group defined by shared features, making them particularly dangerous in fairness-sensitive applications.</p>
<div class="no-row-height column-margin column-container"><div id="fn21"><p><sup>21</sup>&nbsp;<strong>Backdoor Attacks</strong>: Backdoor attacks involve hidden triggers embedded in ML models during training, first demonstrated in 2017. These attacks achieve 99%+ success rates while maintaining normal accuracy, with triggers as subtle as single-pixel modifications. BadNets, the seminal backdoor attack, affected 100% of tested models.</p></div><div id="fn22"><p><sup>22</sup>&nbsp;<strong>Perspective API</strong>: Googleâ€™s Perspective API is a toxicity detection model launched in 2017, now processing 500+ million comments daily across platforms like The New York Times and Wikipedia. Despite sophisticated training, the API demonstrates how even billion-parameter models remain vulnerable to targeted poisoning attacks.</p></div><div id="ref-hosseini2017deceiving" class="csl-entry" role="listitem">
Hosseini, Hossein, Sreeram Kannan, Baosen Zhang, and Radha Poovendran. 2017. <span>â€œDeceiving Googleâ€™s Perspective API Built for Detecting Toxic Comments.â€</span> <em>ArXiv Preprint</em> abs/1702.08138 (February). <a href="http://arxiv.org/abs/1702.08138v1">http://arxiv.org/abs/1702.08138v1</a>.
</div><div id="fn23"><p><sup>23</sup>&nbsp;<strong>Perspective Vulnerability</strong>: After retraining, the poisoned model exhibited a significantly higher false negative rate, allowing offensive language to bypass filters. This demonstrates how poisoned data can exploit feedback loops in user-generated content systems, creating long-term vulnerabilities in content moderation pipelines.</p></div></div><p>A notable real-world example of a targeted poisoning attack was demonstrated against Perspective, Googleâ€™s widely-used online toxicity detection model<a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a> that helps platforms identify harmful content <span class="citation" data-cites="hosseini2017deceiving">(<a href="#ref-hosseini2017deceiving" role="doc-biblioref">Hosseini et al. 2017</a>)</span>. By injecting synthetically generated toxic comments with subtle misspellings and grammatical errors into the modelâ€™s training set, researchers degraded its ability to detect harmful content<a href="#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a>.</p>
<p>Mitigating data poisoning threats requires end-to-end security of the data pipeline, encompassing collection, storage, labeling, and training. Preventative measures include input validation checks, integrity verification of training datasets, and anomaly detection to flag suspicious patterns. In parallel, robust training algorithms can limit the influence of mislabeled or manipulated data by down-weighting or filtering out anomalous instances. While no single technique guarantees immunity, combining proactive data governance, automated monitoring, and robust learning practices is important for maintaining model integrity in real-world deployments.</p>
</section>
<section id="sec-security-privacy-adversarial-attacks-9f84" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-security-privacy-adversarial-attacks-9f84">Adversarial Attacks</h3>
<p>Moving from training-time to inference-time threats, the third category targets model robustness during deployment. Inference robustness threats occur when attackers manipulate inputs at test time to induce incorrect predictions. Unlike data poisoning, which compromises the training process, these attacks exploit vulnerabilities in the modelâ€™s decision surface during inference.</p>
<p>A central class of such threats is adversarial attacks, where carefully constructed inputs are designed to cause incorrect predictions while remaining nearly indistinguishable from legitimate data. As detailed in <strong><a href="../robust_ai/robust_ai.html#sec-robust-ai">Chapter 16: Robust AI</a></strong>, these attacks highlight vulnerabilities in ML modelsâ€™ sensitivity to small, targeted perturbations that can drastically alter output confidence or classification results.</p>
<p>These attacks create significant real-world risks in domains such as autonomous driving, biometric authentication, and content moderation. The effectiveness can be striking: research demonstrates that adversarial examples can achieve 99%+ attack success rates against state-of-the-art image classifiers while modifying less than 0.01% of pixel values, changes virtually imperceptible to humans <span class="citation" data-cites="szegedy2014intriguing goodfellow2015explaining">(<a href="#ref-szegedy2014intriguing" role="doc-biblioref">Szegedy et al. 2013</a>; <a href="#ref-goodfellow2015explaining" role="doc-biblioref">Goodfellow, Shlens, and Szegedy 2014</a>)</span>. In physical-world attacks, printed adversarial patches as small as 2% of an image can cause autonomous vehicles to misclassify stop signs as speed limit signs with 80%+ success rates under varying lighting conditions <span class="citation" data-cites="eykholt2018robust">(<a href="#ref-eykholt2018robust" role="doc-biblioref">Eykholt et al. 2017</a>)</span>.</p>
<div class="no-row-height column-margin column-container"></div><p>Unlike data poisoning, which corrupts the model during training, adversarial attacks manipulate the modelâ€™s behavior at test time, often without requiring any access to the training data or model internals. The attack surface thus shifts from upstream data pipelines to real-time interaction, demanding robust defense mechanisms capable of detecting or mitigating malicious inputs at the point of inference.</p>
<p>The mathematical foundations of adversarial example generation and comprehensive taxonomies of attack algorithms, including gradient-based, optimization-based, and transfer-based techniques, are covered in detail in <strong><a href="../robust_ai/robust_ai.html#sec-robust-ai">Chapter 16: Robust AI</a></strong>, which explores robust approaches to building adversarially resistant systems.</p>
<p>Adversarial attacks vary based on the attackerâ€™s level of access to the model. In white-box attacks, the adversary has full knowledge of the modelâ€™s architecture, parameters, and training data, allowing them to craft highly effective adversarial examples. In black-box attacks, the adversary has no internal knowledge and must rely on querying the model and observing its outputs. Grey-box attacks fall between these extremes, with the adversary possessing partial information, such as access to the model architecture but not its parameters.</p>
<p>These attacker models can be summarized along a spectrum of knowledge levels. <a href="#tbl-adversary-knowledge-spectrum" class="quarto-xref">Table&nbsp;3</a> highlights the differences in model access, data access, typical attack strategies, and common deployment scenarios. Such distinctions help characterize the practical challenges of securing ML systems across different deployment environments.</p>
<p>Common attack strategies include surrogate model construction, transfer attacks exploiting adversarial transferability, and GAN-based perturbation generation. The technical details of these approaches and their mathematical formulations are thoroughly covered in <strong><a href="../robust_ai/robust_ai.html#sec-robust-ai">Chapter 16: Robust AI</a></strong>.</p>
<div id="tbl-adversary-knowledge-spectrum" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-adversary-knowledge-spectrum-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;3: <strong>Adversarial Knowledge Spectrum</strong>: Varying levels of attacker access to model details and training data define distinct threat models, influencing the feasibility and sophistication of adversarial attacks and impacting deployment security strategies. The table categorizes these models by access level, typical attack methods, and common deployment scenarios, clarifying the practical challenges of securing machine learning systems.
</figcaption>
<div aria-describedby="tbl-adversary-knowledge-spectrum-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 23%">
<col style="width: 13%">
<col style="width: 24%">
<col style="width: 22%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Adversary Knowledge Level</strong></th>
<th style="text-align: left;"><strong>Model Access</strong></th>
<th style="text-align: left;"><strong>Training Data Access</strong></th>
<th style="text-align: left;"><strong>Attack Example</strong></th>
<th style="text-align: left;"><strong>Common Scenario</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>White-box</strong></td>
<td style="text-align: left;">Full access to architecture and parameters</td>
<td style="text-align: left;">Full access</td>
<td style="text-align: left;">Crafting adversarial examples using gradients</td>
<td style="text-align: left;">Insider threats, open-source model reuse</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Grey-box</strong></td>
<td style="text-align: left;">Partial access (e.g., architecture only)</td>
<td style="text-align: left;">Limited or no access</td>
<td style="text-align: left;">Attacks based on surrogate model approximation</td>
<td style="text-align: left;">Known model family, unknown fine-tuning</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Black-box</strong></td>
<td style="text-align: left;">No internal access; only query-response view</td>
<td style="text-align: left;">No access</td>
<td style="text-align: left;">Query-based surrogate model training and transfer attacks</td>
<td style="text-align: left;">Public APIs, model-as-a-service deployments</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>One illustrative example involves the manipulation of traffic sign recognition systems <span class="citation" data-cites="eykholt2018robust">(<a href="#ref-eykholt2018robust" role="doc-biblioref">Eykholt et al. 2017</a>)</span>. Researchers demonstrated that placing small stickers on stop signs could cause machine learning models to misclassify them as speed limit signs. While the altered signs remained easily recognizable to humans, the model consistently misinterpreted them. Such attacks pose serious risks in applications like autonomous driving, where reliable perception is important for safety.</p>
<div class="no-row-height column-margin column-container"></div><p>Adversarial attacks highlight the need for robust defenses that go beyond improving model accuracy. Securing ML systems against adversarial threats requires runtime defenses such as input validation, anomaly detection, and monitoring for abnormal patterns during inference. Training-time robustness methods (e.g., adversarial training) complement these strategies and are explored in <strong><a href="../robust_ai/robust_ai.html#sec-robust-ai">Chapter 16: Robust AI</a></strong>. The training methodologies that support robust model development are detailed in <strong><a href="../training/training.html#sec-ai-training">Chapter 8: AI Training</a></strong>. These defenses aim to enhance model resilience against adversarial examples, ensuring that machine learning systems can operate reliably even in the presence of malicious inputs.</p>
</section>
<section id="sec-security-privacy-case-study-traffic-sign-attack-6e93" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-security-privacy-case-study-traffic-sign-attack-6e93">Case Study: Traffic Sign Attack</h3>
<p>In 2017, researchers conducted experiments by placing small black and white stickers on stop signs <span class="citation" data-cites="eykholt2018robust">(<a href="#ref-eykholt2018robust" role="doc-biblioref">Eykholt et al. 2017</a>)</span>. As shown in <a href="#fig-adversarial-stickers" class="quarto-xref">Figure&nbsp;4</a>, these stickers were designed to be nearly imperceptible to the human eye, yet they significantly altered the appearance of the stop sign when viewed by machine learning models. When viewed by a normal human eye, the stickers did not obscure the sign or prevent interpretability. However, when images of the stickers stop signs were fed into standard traffic sign classification ML models, they were misclassified as speed limit signs over 85% of the time.</p>
<div class="no-row-height column-margin column-container"></div><div id="fig-adversarial-stickers" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-adversarial-stickers-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="./images/png/stop_signs.png" class="lightbox" data-gallery="quarto-lightbox-gallery-4" title="Figure&nbsp;4: Adversarial Stickers: Nearly imperceptible stickers can trick machine learning models into misclassifying stop signs as speed limit signs over 85% of the time. This emphasizes the vulnerability of ML systems to adversarial attacks. Source: @eykholt2018robust."><img src="./images/png/stop_signs.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-adversarial-stickers-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: <strong>Adversarial Stickers</strong>: Nearly imperceptible stickers can trick machine learning models into misclassifying stop signs as speed limit signs over 85% of the time. This emphasizes the vulnerability of ML systems to adversarial attacks. Source: <span class="citation" data-cites="eykholt2018robust">Eykholt et al. (<a href="#ref-eykholt2018robust" role="doc-biblioref">2017</a>)</span>.
</figcaption>
<div class="no-row-height column-margin column-container"><div id="ref-eykholt2018robust" class="csl-entry" role="listitem">
Eykholt, Kevin, Ivan Evtimov, Earlence Fernandes, Bo Li, Amir Rahmati, Chaowei Xiao, Atul Prakash, Tadayoshi Kohno, and Dawn Song. 2017. <span>â€œRobust Physical-World Attacks on Deep Learning Models.â€</span> <em>ArXiv Preprint</em> abs/1707.08945 (July). <a href="http://arxiv.org/abs/1707.08945v5">http://arxiv.org/abs/1707.08945v5</a>.
</div></div></figure>
</div>
<p>This demonstration showed how simple adversarial stickers could trick ML systems into misreading important road signs. If deployed realistically, these attacks could endanger public safety, causing autonomous vehicles to misinterpret stop signs as speed limits. Researchers warned this could potentially cause dangerous rolling stops or acceleration into intersections.</p>
<p>This case study provides a concrete illustration of how adversarial examples exploit the pattern recognition mechanisms of ML models. By subtly altering the input data, attackers can induce incorrect predictions and pose significant risks to safety-important applications like self-driving cars. The attackâ€™s simplicity demonstrates how even minor, imperceptible changes can lead models astray. Consequently, developers must implement robust defenses against such threats.</p>
<p>These threat types span different stages of the ML lifecycle and demand distinct defensive strategies. <a href="#tbl-threats-models-summary" class="quarto-xref">Table&nbsp;4</a> below summarizes their key characteristics.</p>
<div id="tbl-threats-models-summary" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-threats-models-summary-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;4: <strong>Threat Landscape</strong>: Machine learning systems face diverse threats throughout their lifecycle, ranging from data manipulation during training to model theft post-deployment. The table categorizes these threats by lifecycle stage and attack vector, clarifying how vulnerabilities manifest and enabling targeted mitigation strategies.
</figcaption>
<div aria-describedby="tbl-threats-models-summary-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 17%">
<col style="width: 22%">
<col style="width: 38%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Threat Type</strong></th>
<th style="text-align: left;"><strong>Lifecycle Stage</strong></th>
<th style="text-align: left;"><strong>Attack Vector</strong></th>
<th style="text-align: left;"><strong>Example Impact</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Model Theft</strong></td>
<td style="text-align: left;">Deployment</td>
<td style="text-align: left;">API access, insider leaks</td>
<td style="text-align: left;">Stolen IP, model inversion, behavioral clone</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Data Poisoning</strong></td>
<td style="text-align: left;">Training</td>
<td style="text-align: left;">Label flipping, backdoors</td>
<td style="text-align: left;">Targeted misclassification, degraded accuracy</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Adversarial Attacks</strong></td>
<td style="text-align: left;">Inference</td>
<td style="text-align: left;">Input perturbation</td>
<td style="text-align: left;">Real-time misclassification, safety failure</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>The appropriate defense for a given threat depends on its type, attack vector, and where it occurs in the ML lifecycle. <a href="#fig-threat-mitigation-flow" class="quarto-xref">Figure&nbsp;5</a> provides a simplified decision flow that connects common threat categories, such as model theft, data poisoning, and adversarial examples, to corresponding defensive strategies. While real-world deployments may require more nuanced combinations of defenses as discussed in our layered defense framework, this flowchart serves as a conceptual guide for aligning threat models with practical mitigation techniques.</p>
<div id="fig-threat-mitigation-flow" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-env="figure" data-fig-pos="H">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-threat-mitigation-flow-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="0b35cfecccda265c5203d430a67ee64ab3a9377e.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-5" title="Figure&nbsp;5: Threat Mitigation Flow: This diagram maps common machine learning threats to corresponding defense strategies, guiding selection based on attack vector and lifecycle stage. By following this flow, practitioners can align threat models with practical mitigation techniques, such as secure model access and data sanitization, to build more robust AI systems."><img src="privacy_security_files/mediabag/0b35cfecccda265c5203d430a67ee64ab3a9377e.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-threat-mitigation-flow-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: <strong>Threat Mitigation Flow</strong>: This diagram maps common machine learning threats to corresponding defense strategies, guiding selection based on attack vector and lifecycle stage. By following this flow, practitioners can align threat models with practical mitigation techniques, such as secure model access and data sanitization, to build more robust AI systems.
</figcaption>
</figure>
</div>
<p>While ML models themselves present important attack surfaces, they ultimately run on hardware that can introduce vulnerabilities beyond the modelâ€™s control. The transition from software-based threats to hardware-based vulnerabilities represents a significant shift in the security landscape. Where software attacks target code logic and data flows, hardware attacks exploit the physical properties of the computing substrate itself.</p>
<p>The specialized computing infrastructure that powers machine learning workloads creates a layered attack surface that extends far beyond traditional software vulnerabilities. This includes the processors that execute instructions, the memory systems that store data, and the interconnects that move information between components. Understanding these hardware-level risks is essential because they can bypass conventional software security mechanisms and remain difficult to detect. These risks are addressed through the hardware-based security mechanisms detailed in <a href="#sec-security-privacy-hardware-security-foundations-f5e8" class="quarto-xref">Section&nbsp;1.8.7</a>.</p>
<p>In the next section, we examine how adversaries can target the physical infrastructure that executes machine learning workloads through hardware bugs, physical tampering, side channels, and supply chain risks.</p>
<div id="quiz-question-sec-security-privacy-modelspecific-attack-vectors-0575" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.5</strong></summary><div>
<ol type="1">
<li><p>Which of the following best describes a data poisoning attack in machine learning systems?</p>
<ol type="a">
<li>Stealing model weights and architecture through API queries.</li>
<li>Injecting malicious data during training to alter model behavior.</li>
<li>Crafting inputs to deceive models at inference time.</li>
<li>Exploiting hardware vulnerabilities to access model data.</li>
</ol></li>
<li><p>True or False: Adversarial examples are primarily a threat during the training phase of the ML lifecycle.</p></li>
<li><p>Explain how model theft could impact a companyâ€™s competitive advantage and suggest one defensive measure.</p></li>
<li><p>Order the following stages of the ML lifecycle in terms of when they are typically targeted by threats: (1) Data Collection, (2) Training, (3) Deployment, (4) Inference.</p></li>
<li><p>In a production system, which defense strategy is most appropriate for protecting against adversarial attacks?</p>
<ol type="a">
<li>Encrypting model files.</li>
<li>Restricting API access.</li>
<li>Implementing input validation and anomaly detection.</li>
<li>Using robust training methods.</li>
</ol></li>
</ol>
<p><a href="#quiz-answer-sec-security-privacy-modelspecific-attack-vectors-0575" class="question-label">See Answers â†’</a></p>
</div></details>
</div>
</section>
</section>
<section id="sec-security-privacy-hardwarelevel-security-vulnerabilities-1ab4" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-security-privacy-hardwarelevel-security-vulnerabilities-1ab4">Hardware-Level Security Vulnerabilities</h2>
<p>As machine learning systems move from research prototypes to large-scale, real-world deployments, their security depends on the hardware platforms they run on. Whether deployed in data centers, on edge devices, or in embedded systems, machine learning applications rely on a layered stack of processors, accelerators, memory, and communication interfaces. These hardware components, while essential for enabling efficient computation, introduce unique security risks that go beyond traditional software-based vulnerabilities.</p>
<p>Unlike general-purpose software systems, machine learning workflows often process high-value models and sensitive data in performance-constrained environments. This makes them attractive targets not only for software attacks but also for hardware-level exploitation. Vulnerabilities in hardware can expose models to theft, leak user data, disrupt system reliability, or allow adversaries to manipulate inference results. Because hardware operates below the software stack, such attacks can bypass conventional security mechanisms and remain difficult to detect.</p>
<p>Understanding hardware security threats requires considering how computing substrates implement machine learning operations. At the hardware level, CPU components like arithmetic logic units, registers, and caches execute the instructions that drive model inference and training. Memory hierarchies determine how quickly models can access parameters and intermediate results. The hardware-software interface, mediated by firmware and bootloaders, establishes the initial trust foundation for system operation. The physical properties of computationâ€”including power consumption, timing characteristics, and electromagnetic emissionsâ€”create observable signals that attackers can exploit to extract sensitive information.</p>
<p>Hardware threats arise from multiple sources that span the entire system lifecycle. Design flaws in processor architectures, exemplified by vulnerabilities like Meltdown and Spectre, can compromise security guarantees. Physical tampering enables direct manipulation of components and data flows. Side-channel attacks exploit unintended information leakage through power traces, timing variations, and electromagnetic radiation. Supply chain compromises introduce malicious components or modifications during manufacturing and distribution. Together, these threats form a critical attack surface that must be addressed to build trustworthy machine learning systems. For readers focusing on practical deployment, the key lessons center on supply chain verification, physical access controls, and hardware trust anchors, while the defensive strategies in <a href="#sec-security-privacy-comprehensive-defense-architectures-48ab" class="quarto-xref">Section&nbsp;1.8</a> provide actionable guidance regardless of deep architectural expertise.</p>
<p><a href="#tbl-threat_types" class="quarto-xref">Table&nbsp;5</a> summarizes the major categories of hardware security threats, describing their origins, methods, and implications for machine learning system design and deployment.</p>
<div id="tbl-threat_types" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-threat_types-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;5: <strong>Hardware Threat Landscape</strong>: Machine learning systems face diverse hardware threats ranging from intrinsic design flaws to physical attacks and supply chain vulnerabilities. Understanding these threats, and their relevance to ML hardware, is essential for building secure and trustworthy AI deployments.
</figcaption>
<div aria-describedby="tbl-threat_types-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 55%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Threat Type</strong></th>
<th style="text-align: left;"><strong>Description</strong></th>
<th style="text-align: left;"><strong>Relevance to ML Hardware Security</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Hardware Bugs</strong></td>
<td style="text-align: left;">Intrinsic flaws in hardware designs that can compromise system integrity.</td>
<td style="text-align: left;">Foundation of hardware vulnerability.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Physical Attacks</strong></td>
<td style="text-align: left;">Direct exploitation of hardware through physical access or manipulation.</td>
<td style="text-align: left;">Basic and overt threat model.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Fault-injection Attacks</strong></td>
<td style="text-align: left;">Induction of faults to cause errors in hardware operation, leading to potential system crashes.</td>
<td style="text-align: left;">Systematic manipulation leading to failure.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Side-Channel Attacks</strong></td>
<td style="text-align: left;">Exploitation of leaked information from hardware operation to extract sensitive data.</td>
<td style="text-align: left;">Indirect attack via environmental observation.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Leaky Interfaces</strong></td>
<td style="text-align: left;">Vulnerabilities arising from interfaces that expose data unintentionally.</td>
<td style="text-align: left;">Data exposure through communication channels.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Counterfeit Hardware</strong></td>
<td style="text-align: left;">Use of unauthorized hardware components that may have security flaws.</td>
<td style="text-align: left;">Compounded vulnerability issues.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Supply Chain Risks</strong></td>
<td style="text-align: left;">Risks introduced through the hardware lifecycle, from production to deployment.</td>
<td style="text-align: left;">Cumulative &amp; multifaceted security challenges.</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<section id="sec-security-privacy-hardware-bugs-9efc" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-security-privacy-hardware-bugs-9efc">Hardware Bugs</h3>
<p>The first category of hardware threats stems from design vulnerabilities. Hardware is not immune to the pervasive issue of design flaws or bugs. Attackers can exploit these vulnerabilities to access, manipulate, or extract sensitive data, breaching the confidentiality and integrity that users and services depend on. One of the most notable examples came with the discovery of <a href="https://meltdownattack.com/">Meltdown and Spectre</a><a href="#fn24" class="footnote-ref" id="fnref24" role="doc-noteref"><sup>24</sup></a>â€”two vulnerabilities in modern processors that allow malicious programs to bypass memory isolation and read the data of other applications and the operating system <span class="citation" data-cites="Lipp2018meltdown Kocher2018spectre">(<a href="#ref-Lipp2018meltdown" role="doc-biblioref">Kocher et al. 2019a</a>, <a href="#ref-Kocher2018spectre" role="doc-biblioref">2019b</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="fn24"><p><sup>24</sup>&nbsp;<strong>Meltdown/Spectre Impact</strong>: Disclosed in January 2018, these vulnerabilities affected virtually every processor made since 1995 (billions of devices). The disclosure triggered emergency patches across all major operating systems, causing 5-30% performance degradation in some workloads, and led to a core rethinking of processor security.</p></div><div id="ref-Lipp2018meltdown" class="csl-entry" role="listitem">
â€”â€”â€”, et al. 2019a. <span>â€œSpectre Attacks: Exploiting Speculative Execution.â€</span> In <em>2019 IEEE Symposium on Security and Privacy (SP)</em>, 1â€“19. IEEE. <a href="https://doi.org/10.1109/sp.2019.00002">https://doi.org/10.1109/sp.2019.00002</a>.
</div><div id="ref-Kocher2018spectre" class="csl-entry" role="listitem">
Kocher, Paul, Jann Horn, Anders Fogh, Daniel Genkin, Daniel Gruss, Werner Haas, Mike Hamburg, et al. 2019b. <span>â€œSpectre Attacks: Exploiting Speculative Execution.â€</span> In <em>2019 IEEE Symposium on Security and Privacy (SP)</em>, 1â€“19. IEEE. <a href="https://doi.org/10.1109/sp.2019.00002">https://doi.org/10.1109/sp.2019.00002</a>.
</div><div id="fn25"><p><sup>25</sup>&nbsp;<strong>Speculative Execution</strong>: Introduced in the Intel Pentium Pro (1995), this technique executes instructions before confirming theyâ€™re needed, improving performance by 10-25%. However, it creates a 20+ year attack window where speculated operations leak data through cache timing, affecting ML accelerators that rely on similar optimizations.</p></div></div><p>These attacks exploit speculative execution<a href="#fn25" class="footnote-ref" id="fnref25" role="doc-noteref"><sup>25</sup></a>, a performance optimization in CPUs that executes instructions out of order before safety checks are complete. While improving computational speed, this optimization inadvertently exposes sensitive data through microarchitectural side channels, such as CPU caches. The technical sophistication of these attacks highlights the difficulty of eliminating vulnerabilities even with extensive hardware validation.</p>
<p>Further research has revealed that these were not isolated incidents. Variants such as Foreshadow, ZombieLoad, and RIDL target different microarchitectural elements, ranging from secure enclaves to CPU internal buffers, demonstrating that speculative execution flaws are a systemic hardware risk. This systemic nature means that while these attacks were first demonstrated on general-purpose CPUs, their implications extend to machine learning accelerators and specialized hardware. ML systems often rely on heterogeneous compute platforms that combine CPUs with GPUs, TPUs, FPGAs, or custom accelerators. These components process sensitive data such as personal information, medical records, or proprietary models. Vulnerabilities in any part of this stack could expose such data to attackers.</p>
<p>For example, an edge device like a smart camera running a face recognition model on an accelerator could be vulnerable if the hardware lacks proper cache isolation. An attacker might exploit this weakness to extract intermediate computations, model parameters, or user data. Similar risks exist in cloud inference services, where hardware multi-tenancy increases the chances of cross-tenant data leakage.</p>
<p>Such vulnerabilities pose concern in privacy-sensitive domains like healthcare, where ML systems routinely handle patient data. A breach could violate privacy regulations such as the <a href="https://www.cdc.gov/phlp/php/resources/health-insurance-portability-and-accountability-act-of-1996-hipaa.html">Health Insurance Portability and Accountability Act (HIPAA)</a><a href="#fn26" class="footnote-ref" id="fnref26" role="doc-noteref"><sup>26</sup></a>, leading to significant legal and ethical consequences. Similar regulatory risks apply globally, with GDPR<a href="#fn27" class="footnote-ref" id="fnref27" role="doc-noteref"><sup>27</sup></a> imposing fines up to 4% of global revenue for organizations that fail to implement appropriate technical measures to protect EU citizensâ€™ data.</p>
<div class="no-row-height column-margin column-container"><div id="fn26"><p><sup>26</sup>&nbsp;<strong>HIPAA Violations</strong>: Since enforcement began in 2003, HIPAA has generated over $130 million in fines, with individual penalties reaching $16 million. The largest healthcare data breach affected 78.8 million patients at Anthem Inc.&nbsp;in 2015, highlighting the massive scale of exposure when ML systems handling medical data are compromised.</p></div><div id="fn27"><p><sup>27</sup>&nbsp;<strong>General Data Protection Regulation (GDPR)</strong>: Enacted by the EU in 2018, GDPR imposes fines up to 4% of global revenue (â‚¬20+ million) for privacy violations. Since enforcement began, over â‚¬4.5 billion in fines have been levied, including â‚¬746 million against Amazon in 2021, driving massive investment in privacy-preserving ML technologies.</p></div></div><p>These examples illustrate that hardware security is not solely about preventing physical tampering. It also requires architectural safeguards to prevent data leakage through the hardware itself. As new vulnerabilities continue to emerge across processors, accelerators, and memory systems, addressing these risks requires continuous mitigation efforts, often involving performance trade-offs, especially in compute- and memory-intensive ML workloads. Proactive solutions, such as confidential computing and trusted execution environments (TEEs), offer promising architectural defenses. However, achieving robust hardware security requires attention at every stage of the system lifecycle, from design to deployment.</p>
</section>
<section id="sec-security-privacy-physical-attacks-095a" class="level3">
<h3 class="anchored" data-anchor-id="sec-security-privacy-physical-attacks-095a">Physical Attacks</h3>
<p>Beyond design flaws, the second category involves direct physical manipulation. Physical tampering refers to the direct, unauthorized manipulation of computing hardware to undermine the integrity of machine learning systems. This type of attack is particularly concerning because it bypasses traditional software security defenses, directly targeting the physical components on which machine learning depends. ML systems are especially vulnerable to such attacks because they rely on hardware sensors, accelerators, and storage to process large volumes of data and produce reliable outcomes in real-world environments.</p>
<p>While software security measures, including encryption, authentication, and access control, protect ML systems against remote attacks, they offer little defense against adversaries with physical access to devices. Physical tampering can range from simple actions, like inserting a malicious USB device into an edge server, to highly sophisticated manipulations such as embedding hardware trojans during chip manufacturing. These threats are particularly relevant for machine learning systems deployed at the edge or in physically exposed environments, where attackers may have opportunities to interfere with the hardware directly.</p>
<p>To understand how such attacks affect ML systems in practice, consider the example of an ML-powered drone used for environmental mapping or infrastructure inspection. The droneâ€™s navigation depends on machine learning models that process data from GPS, cameras, and inertial measurement units. If an attacker gains physical access to the drone, they could replace or modify its navigation module, embedding a hidden backdoor that alters flight behavior or reroutes data collection. Such manipulation not only compromises the systemâ€™s reliability but also opens the door to misuse, such as surveillance or smuggling operations.</p>
<p>These threats extend across application domains. Physical attacks are not limited to mobility systems. Biometric access control systems, which rely on ML models to process face or fingerprint data, are also vulnerable. These systems typically use embedded hardware to capture and process biometric inputs. An attacker could physically replace a biometric sensor with a modified component designed to capture and transmit personal identification data to an unauthorized receiver. This creates multiple vulnerabilities including unauthorized data access and enabling future impersonation attacks.</p>
<p>In addition to tampering with external sensors, attackers may target internal hardware subsystems. For example, the sensors used in autonomous vehicles, including cameras, LiDAR, and radar, are important for ML models that interpret the surrounding environment. A malicious actor could physically misalign or obstruct these sensors, degrading the modelâ€™s perception capabilities and creating safety hazards.</p>
<p>Hardware trojans pose another serious risk. Malicious modifications introduced during chip fabrication or assembly can embed dormant circuits in ML accelerators or inference chips. These trojans may remain inactive under normal conditions but trigger malicious behavior when specific inputs are processed or system states are reached. Such hidden vulnerabilities can disrupt computations, leak model outputs, or degrade system performance in ways that are extremely difficult to diagnose post-deployment.</p>
<p>Memory subsystems are also attractive targets. Attackers with physical access to edge devices or embedded ML accelerators could manipulate memory chips to extract encrypted model parameters or training data. Fault injection techniques, including voltage manipulation and electromagnetic interference, can further degrade system reliability by corrupting model weights or forcing incorrect computations during inference.</p>
<p>Physical access threats extend to data center and cloud environments as well. Attackers with sufficient access could install hardware implants, such as keyloggers or data interceptors, to capture administrative credentials or monitor data streams. Such implants can provide persistent backdoor access, enabling long-term surveillance or data exfiltration from ML training and inference pipelines.</p>
<p>In summary, physical attacks on machine learning systems threaten both security and reliability across a wide range of deployment environments. Addressing these risks requires a combination of hardware-level protections, tamper detection mechanisms, and supply chain integrity checks. Without these safeguards, even the most secure software defenses may be undermined by vulnerabilities introduced through direct physical manipulation.</p>
</section>
<section id="sec-security-privacy-fault-injection-attacks-8c52" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-security-privacy-fault-injection-attacks-8c52">Fault Injection Attacks</h3>
<p>Building on physical tampering techniques, fault injection represents a more sophisticated approach to hardware exploitation. Fault injection is a powerful class of physical attacks that deliberately disrupts hardware operations to induce errors in computation. These induced faults can compromise the integrity of machine learning models by causing them to produce incorrect outputs, degrade reliability, or leak sensitive information. For ML systems, such faults not only disrupt inference but also expose models to deeper exploitation, including reverse engineering and bypass of security protocols <span class="citation" data-cites="joye2012fault">(<a href="#ref-joye2012fault" role="doc-biblioref">Joye and Tunstall 2012</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-joye2012fault" class="csl-entry" role="listitem">
Joye, Marc, and Michael Tunstall. 2012. <em>Fault Analysis in Cryptography</em>. Springer Berlin Heidelberg. <a href="https://doi.org/10.1007/978-3-642-29656-7">https://doi.org/10.1007/978-3-642-29656-7</a>.
</div><div id="ref-barenghi2010low" class="csl-entry" role="listitem">
Barenghi, Alessandro, Guido M. Bertoni, Luca Breveglieri, Mauro Pellicioli, and Gerardo Pelosi. 2010. <span>â€œLow Voltage Fault Attacks to AES.â€</span> In <em>2010 IEEE International Symposium on Hardware-Oriented Security and Trust (HOST)</em>, 7â€“12. IEEE; IEEE. <a href="https://doi.org/10.1109/hst.2010.5513121">https://doi.org/10.1109/hst.2010.5513121</a>.
</div><div id="ref-hutter2009contact" class="csl-entry" role="listitem">
Hutter, Michael, Jorn-Marc Schmidt, and Thomas Plos. 2009. <span>â€œContact-Based Fault Injections and Power Analysis on RFID Tags.â€</span> In <em>2009 European Conference on Circuit Theory and Design</em>, 409â€“12. IEEE; IEEE. <a href="https://doi.org/10.1109/ecctd.2009.5275012">https://doi.org/10.1109/ecctd.2009.5275012</a>.
</div><div id="ref-amiel2006fault" class="csl-entry" role="listitem">
Amiel, Frederic, Christophe Clavier, and Michael Tunstall. 2006. <span>â€œFault Analysis of DPA-Resistant Algorithms.â€</span> In <em>Fault Diagnosis and Tolerance in Cryptography</em>, 223â€“36. Springer; Springer Berlin Heidelberg. <a href="https://doi.org/10.1007/11889700\_20">https://doi.org/10.1007/11889700\_20</a>.
</div><div id="ref-agrawal2003side" class="csl-entry" role="listitem">
Agrawal, Dakshi, Selcuk Baktir, Deniz Karakoyunlu, Pankaj Rohatgi, and Berk Sunar. 2007. <span>â€œTrojan Detection Using IC Fingerprinting.â€</span> In <em>2007 IEEE Symposium on Security and Privacy (SP â€™07)</em>, 296â€“310. Springer; IEEE. <a href="https://doi.org/10.1109/sp.2007.36">https://doi.org/10.1109/sp.2007.36</a>.
</div><div id="ref-skorobogatov2009local" class="csl-entry" role="listitem">
Skorobogatov, Sergei. 2009. <span>â€œLocal Heating Attacks on Flash Memory Devices.â€</span> In <em>2009 IEEE International Workshop on Hardware-Oriented Security and Trust</em>, 1â€“6. IEEE; IEEE. <a href="https://doi.org/10.1109/hst.2009.5225028">https://doi.org/10.1109/hst.2009.5225028</a>.
</div><div id="ref-skorobogatov2003optical" class="csl-entry" role="listitem">
Skorobogatov, Sergei P., and Ross J. Anderson. 2003. <span>â€œOptical Fault Induction Attacks.â€</span> In <em>Cryptographic Hardware and Embedded Systems - CHES 2002</em>, 2â€“12. Springer; Springer Berlin Heidelberg. <a href="https://doi.org/10.1007/3-540-36400-5\_2">https://doi.org/10.1007/3-540-36400-5\_2</a>.
</div></div><p>Attackers achieve fault injection by applying precisely timed physical or electrical disturbances to the hardware while it is executing computations. Techniques such as low-voltage manipulation <span class="citation" data-cites="barenghi2010low">(<a href="#ref-barenghi2010low" role="doc-biblioref">Barenghi et al. 2010</a>)</span>, power spikes <span class="citation" data-cites="hutter2009contact">(<a href="#ref-hutter2009contact" role="doc-biblioref">Hutter, Schmidt, and Plos 2009</a>)</span>, clock glitches <span class="citation" data-cites="amiel2006fault">(<a href="#ref-amiel2006fault" role="doc-biblioref">Amiel, Clavier, and Tunstall 2006</a>)</span>, electromagnetic pulses <span class="citation" data-cites="agrawal2003side">(<a href="#ref-agrawal2003side" role="doc-biblioref">Agrawal et al. 2007</a>)</span>, temperature variations <span class="citation" data-cites="skorobogatov2009local">(<a href="#ref-skorobogatov2009local" role="doc-biblioref">S. Skorobogatov 2009</a>)</span>, and even laser strikes <span class="citation" data-cites="skorobogatov2003optical">(<a href="#ref-skorobogatov2003optical" role="doc-biblioref">S. P. Skorobogatov and Anderson 2003</a>)</span> have been demonstrated to corrupt specific parts of a programâ€™s execution. These disturbances can cause effects such as bit flips, skipped instructions, or corrupted memory states, which adversaries can exploit to alter ML model behavior or extract sensitive information.</p>
<p>For machine learning systems, these attacks pose several concrete risks. Fault injection can degrade model accuracy, force incorrect classifications, trigger denial of service, or even leak internal model parameters. For example, attackers could inject faults into an embedded ML model running on a microcontroller, forcing it to misclassify inputs in safety-important applications such as autonomous navigation or medical diagnostics. More sophisticated attackers may target memory or control logic to steal intellectual property, such as proprietary model weights or architecture details.</p>
<p>The practical viability of these attacks has been demonstrated through controlled experiments. One notable example is the work by <span class="citation" data-cites="breier2018deeplaser">Breier et al. (<a href="#ref-breier2018deeplaser" role="doc-biblioref">2018</a>)</span>, where researchers successfully used a laser fault injection attack on a deep neural network deployed on a microcontroller. By heating specific transistors, as shown in <a href="#fig-laser-bitflip" class="quarto-xref">Figure&nbsp;6</a>. they forced the hardware to skip execution steps, including a ReLU activation function.</p>
<div class="no-row-height column-margin column-container"></div><div id="fig-laser-bitflip" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-fig-pos="t!">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-laser-bitflip-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/png/laser_bitflip.png" class="lightbox" data-gallery="quarto-lightbox-gallery-6" title="Figure&nbsp;6: Laser Fault Injection: Focused laser pulses induce bit flips within microcontroller memory, enabling attackers to manipulate model execution and compromise system integrity. Researchers utilize this technique to simulate hardware errors, revealing vulnerabilities in embedded machine learning systems and informing the development of fault-tolerant designs. Source: [@breier2018deeplaser]."><img src="images/png/laser_bitflip.png" class="img-fluid figure-img" data-fig-pos="t!"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-laser-bitflip-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: <strong>Laser Fault Injection</strong>: Focused laser pulses induce bit flips within microcontroller memory, enabling attackers to manipulate model execution and compromise system integrity. Researchers utilize this technique to simulate hardware errors, revealing vulnerabilities in embedded machine learning systems and informing the development of fault-tolerant designs. Source: <span class="citation" data-cites="breier2018deeplaser">(<a href="#ref-breier2018deeplaser" role="doc-biblioref">Breier et al. 2018</a>)</span>.
</figcaption>
<div class="no-row-height column-margin column-container"></div></figure>
</div>
<p>This manipulation is illustrated in <a href="#fig-injection" class="quarto-xref">Figure&nbsp;7</a>, which shows a segment of assembly code implementing the ReLU activation function. Normally, the code compares the most significant bit (MSB) of the accumulator to zero and uses a brge (branch if greater or equal) instruction to skip the assignment if the value is non-positive. However, the fault injection suppresses the branch, causing the processor to always execute the â€œelseâ€ block. As a result, the neuronâ€™s output is forcibly zeroed out, regardless of the input value.</p>
<div id="fig-injection" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-fig-pos="b!">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-injection-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/png/fault-injection_demonstrated_with_assembly_code.png" class="lightbox" data-gallery="quarto-lightbox-gallery-7" title="Figure&nbsp;7: Fault Injection Attack: Manipulating assembly code bypasses safety checks, forcing a neuronâ€™s output to zero regardless of input and demonstrating a hardware vulnerability in machine learning systems. Source: [@breier2018deeplaser]."><img src="images/png/fault-injection_demonstrated_with_assembly_code.png" class="img-fluid figure-img" style="width:75.0%" data-fig-pos="b!"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-injection-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7: <strong>Fault Injection Attack</strong>: Manipulating assembly code bypasses safety checks, forcing a neuronâ€™s output to zero regardless of input and demonstrating a hardware vulnerability in machine learning systems. Source: <span class="citation" data-cites="breier2018deeplaser">(<a href="#ref-breier2018deeplaser" role="doc-biblioref">Breier et al. 2018</a>)</span>.
</figcaption>
<div class="no-row-height column-margin column-container"><div id="ref-breier2018deeplaser" class="csl-entry" role="listitem">
Breier, Jakub, Xiaolu Hou, Dirmanto Jap, Lei Ma, Shivam Bhasin, and Yang Liu. 2018. <span>â€œDeepLaser: Practical Fault Attack on Deep Neural Networks.â€</span> <em>ArXiv Preprint</em> abs/1806.05859 (June): 619â€“33. <a href="http://arxiv.org/abs/1806.05859v2">http://arxiv.org/abs/1806.05859v2</a>.
</div></div></figure>
</div>
<p>Fault injection attacks can also be combined with side-channel analysis, where attackers first observe power or timing characteristics to infer model structure or data flow. This reconnaissance allows them to target specific layers or operations, such as activation functions or final decision layers, maximizing the impact of the injected faults.</p>
<p>Embedded and edge ML systems are particularly vulnerable because they often lack physical hardening and operate under resource constraints that limit runtime defenses. Without tamper-resistant packaging or secure hardware enclaves, attackers may gain direct access to system buses and memory, enabling precise fault manipulation. Many embedded ML models are designed to be lightweight, leaving them with little redundancy or error correction to recover from induced faults.</p>
<p>Mitigating fault injection requires multiple complementary protections. Physical protections, such as tamper-proof enclosures and design obfuscation, help limit physical access. Anomaly detection techniques can monitor sensor inputs or model outputs for signs of fault-induced inconsistencies <span class="citation" data-cites="hsiao2023mavfi">(<a href="#ref-hsiao2023mavfi" role="doc-biblioref">Hsiao et al. 2023</a>)</span>. Error-correcting memories and secure firmware can reduce the likelihood of silent corruption. Techniques such as model watermarking may provide traceability if stolen models are later deployed by an adversary.</p>
<div class="no-row-height column-margin column-container"><div id="ref-hsiao2023mavfi" class="csl-entry" role="listitem">
Hsiao, Yu-Shun, Zishen Wan, Tianyu Jia, Radhika Ghosal, Abdulrahman Mahmoud, Arijit Raychowdhury, David Brooks, Gu-Yeon Wei, and Vijay Janapa Reddi. 2023. <span>â€œMAVFI: An End-to-End Fault Analysis Framework with Anomaly Detection and Recovery for Micro Aerial Vehicles.â€</span> In <em>2023 Design, Automation &amp;Amp; Test in Europe Conference &amp;Amp; Exhibition (DATE)</em>, 1â€“6. IEEE; IEEE. <a href="https://doi.org/10.23919/date56975.2023.10137246">https://doi.org/10.23919/date56975.2023.10137246</a>.
</div></div><p>These protections are difficult to implement in cost- and power-constrained environments, where adding cryptographic hardware or redundancy may not be feasible. Achieving resilience to fault injection requires cross-layer design considerations that span electrical, firmware, software, and system architecture levels. Without such holistic design practices, ML systems deployed in the field may remain exposed to these low-cost yet highly effective physical attacks.</p>
</section>
<section id="sec-security-privacy-sidechannel-attacks-cdfd" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-security-privacy-sidechannel-attacks-cdfd">Side-Channel Attacks</h3>
<p>Moving from direct fault injection to indirect information leakage, side-channel attacks constitute a class of security breaches that exploit information inadvertently revealed through the physical implementation of computing systems. In contrast to direct attacks that target software or network vulnerabilities, these attacks use the systemâ€™s hardware characteristics, including power consumption, electromagnetic emissions, or timing behavior, to extract sensitive information.</p>
<p>The core premise of a side-channel attack is that a deviceâ€™s operation can leak information through observable physical signals. Such leaks may originate from the electrical power the device consumes <span class="citation" data-cites="kocher1999differential">(<a href="#ref-kocher1999differential" role="doc-biblioref">Kocher, Jaffe, and Jun 1999</a>)</span>, the electromagnetic fields it emits <span class="citation" data-cites="gandolfi2001electromagnetic">(<a href="#ref-gandolfi2001electromagnetic" role="doc-biblioref">Gandolfi, Mourtel, and Olivier 2001</a>)</span>, the time required to complete computations, or even the acoustic noise it produces. By carefully measuring and analyzing these signals, attackers can infer internal system states or recover secret data.</p>
<div class="no-row-height column-margin column-container"><div id="ref-kocher1999differential" class="csl-entry" role="listitem">
Kocher, Paul, Joshua Jaffe, and Benjamin Jun. 1999. <span>â€œDifferential Power Analysis.â€</span> In <em>Advances in Cryptology â€” CRYPTOâ€™ 99</em>, 388â€“97. Springer; Springer Berlin Heidelberg. <a href="https://doi.org/10.1007/3-540-48405-1\_25">https://doi.org/10.1007/3-540-48405-1\_25</a>.
</div><div id="ref-gandolfi2001electromagnetic" class="csl-entry" role="listitem">
Gandolfi, Karine, Christophe Mourtel, and Francis Olivier. 2001. <span>â€œElectromagnetic Analysis: Concrete Results.â€</span> In <em>Cryptographic Hardware and Embedded Systems â€” CHES 2001</em>, 251â€“61. Springer; Springer Berlin Heidelberg. <a href="https://doi.org/10.1007/3-540-44709-1\_21">https://doi.org/10.1007/3-540-44709-1\_21</a>.
</div></div><p>Although these techniques are commonly discussed in cryptography, they are equally relevant to machine learning systems. ML models deployed on hardware accelerators, embedded devices, or edge systems often process sensitive data. Even when these models are protected by secure algorithms or encryption, their physical execution may leak side-channel signals that can be exploited by adversaries.</p>
<p>One of the most widely studied examples involves Advanced Encryption Standard (AES)<a href="#fn28" class="footnote-ref" id="fnref28" role="doc-noteref"><sup>28</sup></a> implementations. While AES is mathematically secure, the physical process of computing its encryption functions leaks measurable signals.</p>
<div class="no-row-height column-margin column-container"><div id="fn28"><p><sup>28</sup>&nbsp;<strong>Advanced Encryption Standard (AES)</strong>: Adopted by NIST in 2001 as the US government encryption standard, AES replaced DES after 24 years. Despite being mathematically secure with 2^128 possible keys for AES-128, physical implementations remain vulnerable to side-channel attacks that can extract keys in minutes. Techniques such as Differential Power Analysis (DPA), Differential Electromagnetic Analysis (DEMA), and Correlation Power Analysis (CPA) exploit these physical signals to recover secret keys.</p></div></div><p>A useful example of this attack technique can be seen in a power analysis of a password authentication process. Consider a device that verifies a 5-byte passwordâ€”in this case, <code>0x61, 0x52, 0x77, 0x6A, 0x73</code>. During authentication, the device receives each byte sequentially over a serial interface, and its power consumption pattern reveals how the system responds as it processes these inputs.</p>
<p><a href="#fig-encryption" class="quarto-xref">Figure&nbsp;8</a> shows the deviceâ€™s behavior when the correct password is entered. The red waveform captures the serial data stream, marking each byte as it is received. The blue curve records the deviceâ€™s power consumption over time. When the full, correct password is supplied, the power profile remains stable and consistent across all five bytes, providing a clear baseline for comparison with failed attempts.</p>
<div id="fig-encryption" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-encryption-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/png/power_analysis_of_an_encryption_device_with_a_correct_password.png" class="lightbox" data-gallery="quarto-lightbox-gallery-8" title="Figure&nbsp;8: Power Profile: The deviceâ€™s power consumption remains stable during authentication when the correct password is entered, setting a baseline for comparison in subsequent figures through This figure. Source: colin oâ€™flynn."><img src="images/png/power_analysis_of_an_encryption_device_with_a_correct_password.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-encryption-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8: <strong>Power Profile</strong>: The deviceâ€™s power consumption remains stable during authentication when the correct password is entered, setting a baseline for comparison in subsequent figures through This figure. Source: colin oâ€™flynn.
</figcaption>
</figure>
</div>
<p>When an incorrect password is entered, the power analysis chart changes as shown in <a href="#fig-encryption2" class="quarto-xref">Figure&nbsp;9</a>. In this case, the first three bytes (<code>0x61, 0x52, 0x77</code>) are correct, so the power patterns closely match the correct password up to that point. However, when the fourth byte (<code>0x42</code>) is processed and found to be incorrect, the device halts authentication. This change is reflected in the sudden jump in the blue power line, indicating that the device has stopped processing and entered an error state.</p>
<div id="fig-encryption2" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-encryption2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/png/power_analysis_of_an_encryption_device_with_a_partially_wrong_password.png" class="lightbox" data-gallery="quarto-lightbox-gallery-9" title="Figure&nbsp;9: Side-Channel Attack Vulnerability: Power consumption patterns reveal cryptographic key information during authentication; consistent power usage indicates correct password bytes, while abrupt changes signal incorrect input and halted processing. Even without knowing the password, an attacker can infer it by analyzing the deviceâ€™s power usage during authentication attempts via this figure. Source: Colin Oâ€™Flynn."><img src="images/png/power_analysis_of_an_encryption_device_with_a_partially_wrong_password.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-encryption2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9: <strong>Side-Channel Attack Vulnerability</strong>: Power consumption patterns reveal cryptographic key information during authentication; consistent power usage indicates correct password bytes, while abrupt changes signal incorrect input and halted processing. Even without knowing the password, an attacker can infer it by analyzing the deviceâ€™s power usage during authentication attempts via this figure. Source: Colin Oâ€™Flynn.
</figcaption>
</figure>
</div>
<p><a href="#fig-encryption3" class="quarto-xref">Figure&nbsp;10</a> shows the case where the password is entirely incorrect (<code>0x30, 0x30, 0x30, 0x30, 0x30</code>). Here, the device detects the mismatch immediately after the first byte and halts processing much earlier. This is again visible in the power profile, where the blue line exhibits a sharp jump following the first byte, reflecting the deviceâ€™s early termination of authentication.</p>
<div id="fig-encryption3" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-encryption3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/png/power_analysis_of_an_encryption_device_with_a_wrong_password.png" class="lightbox" data-gallery="quarto-lightbox-gallery-10" title="Figure&nbsp;10: Power Consumption Jump: The blue lineâ€™s sharp increase after processing the first byte indicates immediate authentication failure, highlighting how incorrect passwords are quickly detected through power usage. Source: Colin Oâ€™Flynn."><img src="images/png/power_analysis_of_an_encryption_device_with_a_wrong_password.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-encryption3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10: <strong>Power Consumption Jump</strong>: The blue lineâ€™s sharp increase after processing the first byte indicates immediate authentication failure, highlighting how incorrect passwords are quickly detected through power usage. Source: Colin Oâ€™Flynn.
</figcaption>
</figure>
</div>
<p>These examples demonstrate how attackers can exploit observable power consumption differences to reduce the search space and eventually recover secret data through brute-force analysis. By systematically measuring power consumption patterns and correlating them with different inputs, attackers can extract sensitive information that should remain hidden.</p>
<p>The scope of these vulnerabilities extends beyond cryptographic applications. Machine learning applications face similar risks. For example, an ML-based speech recognition system processing voice commands on a local device could leak timing or power signals that reveal which commands are being processed. Even subtle acoustic or electromagnetic emissions may expose operational patterns that an adversary could exploit to infer user behavior.</p>
<p>Historically, side-channel attacks have been used to bypass even the most secure cryptographic systems. In the 1960s, British intelligence agency MI5 famously exploited acoustic emissions from a cipher machine in the Egyptian Embassy <span class="citation" data-cites="Burnet1989Spycatcher">(<a href="#ref-Burnet1989Spycatcher" role="doc-biblioref">Burnet and Thomas 1989</a>)</span>. By capturing the mechanical clicks of the machineâ€™s rotors, MI5 analysts were able to dramatically reduce the complexity of breaking encrypted messages. This early example illustrates that side-channel vulnerabilities are not confined to the digital age but are rooted in the physical nature of computation.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Burnet1989Spycatcher" class="csl-entry" role="listitem">
Burnet, David, and Richard Thomas. 1989. <span>â€œSpycatcher: The Commodification of Truth.â€</span> <em>Journal of Law and Society</em> 16 (2): 210. <a href="https://doi.org/10.2307/1410360">https://doi.org/10.2307/1410360</a>.
</div><div id="ref-Asonov2004Keyboard" class="csl-entry" role="listitem">
Asonov, D., and R. Agrawal. n.d. <span>â€œKeyboard Acoustic Emanations.â€</span> In <em>IEEE Symposium on Security and Privacy, 2004. Proceedings. 2004</em>, 3â€“11. IEEE; IEEE. <a href="https://doi.org/10.1109/secpri.2004.1301311">https://doi.org/10.1109/secpri.2004.1301311</a>.
</div><div id="ref-gnad2017voltage" class="csl-entry" role="listitem">
Gnad, Dennis R. E., Fabian Oboril, and Mehdi B. Tahoori. 2017. <span>â€œVoltage Drop-Based Fault Attacks on FPGAs Using Valid Bitstreams.â€</span> In <em>2017 27th International Conference on Field Programmable Logic and Applications (FPL)</em>, 1â€“7. IEEE; IEEE. <a href="https://doi.org/10.23919/fpl.2017.8056840">https://doi.org/10.23919/fpl.2017.8056840</a>.
</div><div id="ref-zhao2018fpga" class="csl-entry" role="listitem">
Zhao, Mark, and G. Edward Suh. 2018. <span>â€œFPGA-Based Remote Power Side-Channel Attacks.â€</span> In <em>2018 IEEE Symposium on Security and Privacy (SP)</em>, 229â€“44. IEEE; IEEE. <a href="https://doi.org/10.1109/sp.2018.00049">https://doi.org/10.1109/sp.2018.00049</a>.
</div></div><p>Today, these techniques have advanced to include attacks such as keyboard eavesdropping <span class="citation" data-cites="Asonov2004Keyboard">(<a href="#ref-Asonov2004Keyboard" role="doc-biblioref">Asonov and Agrawal, n.d.</a>)</span>, power analysis on cryptographic hardware <span class="citation" data-cites="gnad2017voltage">(<a href="#ref-gnad2017voltage" role="doc-biblioref">Gnad, Oboril, and Tahoori 2017</a>)</span>, and voltage-based attacks on ML accelerators <span class="citation" data-cites="zhao2018fpga">(<a href="#ref-zhao2018fpga" role="doc-biblioref">Zhao and Suh 2018</a>)</span>. Timing attacks, electromagnetic leakage, and thermal emissions continue to provide adversaries with indirect channels for observing system behavior.</p>
<p>Machine learning systems deployed on specialized accelerators or embedded platforms are especially at risk. Attackers may exploit side-channel signals to infer model structure, steal parameters, or reconstruct private training data. As ML becomes increasingly deployed in cloud, edge, and embedded environments, these side-channel vulnerabilities pose significant challenges to system security.</p>
<p>Understanding the persistence and evolution of side-channel attacks is important for building resilient machine learning systems. By recognizing that where there is a signal, there is potential for exploitation, system designers can begin to address these risks through a combination of hardware shielding, algorithmic defenses, and operational safeguards.</p>
</section>
<section id="sec-security-privacy-leaky-interfaces-9206" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-security-privacy-leaky-interfaces-9206">Leaky Interfaces</h3>
<p>While side-channel attacks exploit unintended physical signals, leaky interfaces represent a different category of vulnerability involving exposed communication channels. Interfaces in computing systems are important for enabling communication, diagnostics, and updates. However, these same interfaces can become significant security vulnerabilities when they unintentionally expose sensitive information or accept unverified inputs. Such leaky interfaces often go unnoticed during system design, yet they provide attackers with powerful entry points to extract data, manipulate functionality, or introduce malicious code.</p>
<p>A leaky interface is any access point that reveals more information than intended, often because of weak authentication, lack of encryption, or inadequate isolation. These issues have been widely demonstrated across consumer, medical, and industrial systems.</p>
<p>For example, many WiFi-enabled baby monitors have been found to expose unsecured remote access ports<a href="#fn29" class="footnote-ref" id="fnref29" role="doc-noteref"><sup>29</sup></a>, allowing attackers to intercept live audio and video feeds from inside private homes. Similarly, researchers have identified wireless vulnerabilities in pacemakers<a href="#fn30" class="footnote-ref" id="fnref30" role="doc-noteref"><sup>30</sup></a> that could allow attackers to manipulate cardiac functions if exploited, raising life-threatening safety concerns.</p>
<div class="no-row-height column-margin column-container"><div id="fn29"><p><sup>29</sup>&nbsp;<strong>IoT Device Vulnerabilities</strong>: Studies reveal 70-80% of IoT devices contain serious security flaws, with baby monitors among the worst offenders. Security firm Rapid7 found that popular baby monitor brands exposed unencrypted video streams, affecting millions of households globally.</p></div><div id="fn30"><p><sup>30</sup>&nbsp;<strong>Medical Device Security</strong>: FDA reports show 53% of medical devices contain known vulnerabilities, with pacemakers and insulin pumps most at risk. The average medical device contains 6.2 vulnerabilities, some dating back over a decade, affecting 2.4 billion medical devices worldwide.</p></div><div id="fn31"><p><sup>31</sup>&nbsp;<strong>Debug Port Vulnerabilities</strong>: Hardware debug interfaces like JTAG (1990) and SWD (2006) are essential for development but often left accessible in production. Security researchers estimate that 60-70% of embedded devices ship with unsecured debug ports, creating backdoors for attackers.</p></div></div><p>A notable case involving smart lightbulbs demonstrated that accessible debug ports<a href="#fn31" class="footnote-ref" id="fnref31" role="doc-noteref"><sup>31</sup></a> left on production devices leaked unencrypted WiFi credentials. This security oversight provided attackers with a pathway to infiltrate home networks without needing to bypass standard security mechanisms.</p>
<p>These examples reveal vulnerability patterns that directly apply to machine learning deployments. While these examples do not target machine learning systems directly, they illustrate architectural patterns that are highly relevant to ML-allowd devices. Consider a smart home security system that uses machine learning to detect user routines and automate responses. Such a system may include a maintenance or debug interface for software updates. If this interface lacks proper authentication or transmits data unencrypted, attackers on the same network could gain unauthorized access. This intrusion could expose user behavior patterns, compromise model integrity, or disable security features altogether.</p>
<p>Leaky interfaces in ML systems can also expose training data, model parameters, or intermediate outputs. Such exposure can allow attackers to craft adversarial examples, steal proprietary models, or reverse-engineer system behavior. Worse still, these interfaces may allow attackers to tamper with firmware, introducing malicious code that disables devices or recruits them into botnets.</p>
<p>Mitigating these risks requires coordinated protections across technical and organizational domains. Technical safeguards such as strong authentication, encrypted communications, and runtime anomaly detection are important. Organizational practices such as interface inventories, access control policies, and ongoing audits are equally important. Adopting a zero-trust architecture, where no interface is trusted by default, further reduces exposure by limiting access to only what is strictly necessary.</p>
<p>For designers of ML-powered systems, securing interfaces must be a first-class concern alongside algorithmic and data-centric design. Whether the system operates in the cloud, on the edge, or in embedded environments, failure to secure these access points risks undermining the entire systemâ€™s trustworthiness.</p>
</section>
<section id="sec-security-privacy-counterfeit-hardware-36fd" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-security-privacy-counterfeit-hardware-36fd">Counterfeit Hardware</h3>
<p>Beyond vulnerabilities in legitimate hardware, another significant threat emerges from the supply chain itself. Machine learning systems depend on the reliability and security of the hardware on which they run. Yet, in todayâ€™s globalized hardware ecosystem, the risk of counterfeit or cloned hardware has emerged as a serious threat to system integrity. Counterfeit components refer to unauthorized reproductions of genuine parts, designed to closely imitate their appearance and functionality. These components can enter machine learning systems through complex procurement and manufacturing processes that span multiple vendors and regions.</p>
<p>A single lapse in component sourcing can introduce counterfeit hardware into important systems. For example, a facial recognition system deployed for secure facility access might unknowingly rely on counterfeit processors. These unauthorized components could fail to process biometric data correctly or introduce hidden vulnerabilities that allow attackers to bypass authentication controls.</p>
<p>The risks posed by counterfeit hardware are multifaceted. From a reliability perspective, such components often degrade faster, perform unpredictably, or fail under load due to substandard manufacturing. From a security perspective, counterfeit hardware may include hidden backdoors or malicious circuitry, providing attackers with undetectable pathways to compromise machine learning systems. A cloned network router installed in a data center, for instance, could silently intercept model predictions or user data, creating systemic vulnerabilities across the entire infrastructure.</p>
<p>Legal and regulatory risks further compound the problem. Organizations that unknowingly integrate counterfeit components into their ML systems may face serious legal consequences, including penalties for violating safety, privacy, or cybersecurity regulations<a href="#fn32" class="footnote-ref" id="fnref32" role="doc-noteref"><sup>32</sup></a>. This is particularly concerning in sectors such as healthcare and finance, where compliance with industry standards is non-negotiable. Healthcare organizations must demonstrate HIPAA compliance throughout their technology stack, while organizations handling EU citizensâ€™ data must meet GDPRâ€™s requirements for technical and organizational measures, including supply chain integrity.</p>
<div class="no-row-height column-margin column-container"><div id="fn32"><p><sup>32</sup>&nbsp;<strong>Cybersecurity Regulations</strong>: Global cybersecurity compliance costs exceed $150 billion annually, with frameworks like SOC 2, ISO 27001, PCI DSS, and sector-specific rules governing ML systems. Financial services face additional requirements under regulations like SOX, while healthcare must comply with HIPAA, creating complex multi-regulatory environments.</p></div></div><p>Economic pressures often incentivize sourcing from lower-cost suppliers without rigorous verification, increasing the likelihood of counterfeit parts entering production systems. Detection is especially challenging, as counterfeit components are designed to mimic legitimate ones. Identifying them may require specialized equipment or forensic analysis, making prevention far more practical than remediation.</p>
<p>The stakes are particularly high in machine learning applications that require high reliability and low latency, such as real-time decision-making in autonomous vehicles, industrial automation, or important healthcare diagnostics. Hardware failure in these contexts can lead not only to system downtime but also to significant safety risks. Consequently, as machine learning continues to expand into safety-important and high-value applications, counterfeit hardware presents a growing risk that must be recognized and addressed. Organizations must treat hardware trustworthiness as a core design requirement, on par with algorithmic accuracy and data security, to ensure that ML systems can operate reliably and securely in the real world.</p>
</section>
<section id="sec-security-privacy-supply-chain-risks-c99c" class="level3">
<h3 class="anchored" data-anchor-id="sec-security-privacy-supply-chain-risks-c99c">Supply Chain Risks</h3>
<p>Counterfeit hardware exemplifies a broader systemic challenge. While counterfeit hardware presents a serious challenge, it is only one part of the larger problem of securing the global hardware supply chain. Machine learning systems are built from components that pass through complex supply networks involving design, fabrication, assembly, distribution, and integration. Each of these stages presents opportunities for tampering, substitution, or counterfeitingâ€”often without the knowledge of those deploying the final system.</p>
<p>Malicious actors can exploit these vulnerabilities in various ways. A contracted manufacturer might unknowingly receive recycled electronic waste that has been relabeled as new components. A distributor might deliberately mix cloned parts into otherwise legitimate shipments. Insiders at manufacturing facilities might embed hardware Trojans that are nearly impossible to detect once the system is deployed. Advanced counterfeits can be particularly deceptive, with refurbished or repackaged components designed to pass visual inspection while concealing inferior or malicious internals.</p>
<p>Identifying such compromises typically requires sophisticated analysis, including micrography, X-ray screening, and functional testing. However, these methods are costly and impractical for large-scale procurement. As a result, many organizations deploy systems without fully verifying the authenticity and security of every component.</p>
<p>The risks extend beyond individual devices. Machine learning systems often rely on heterogeneous hardware platforms, integrating CPUs, GPUs, memory, and specialized accelerators sourced from a global supply base. Any compromise in one part of this chain can undermine the security of the entire system. These risks are further amplified when systems operate in shared or multi-tenant environments, such as cloud data centers or federated edge networks, where hardware-level isolation is important to preventing cross-tenant attacks.</p>
<p>The 2018 Bloomberg Businessweek report alleging that Chinese state actors inserted spy chips into Supermicro server motherboards brought these risks to mainstream attention. While the claims remain disputed, the story underscored the industryâ€™s limited visibility into its own hardware supply chains. Companies often rely on complex, opaque manufacturing and distribution networks, leaving them vulnerable to hidden compromises. Over-reliance on single manufacturers or regions, including the semiconductor industryâ€™s reliance on TSMC, further concentrates this risk. This recognition has driven policy responses like the U.S. <a href="https://bidenwhitehouse.archives.gov/briefing-room/statements-releases/2024/08/09/fact-sheet-two-years-after-the-chips-and-science-act-biden-%E2%81%A0harris-administration-celebrates-historic-achievements-in-bringing-semiconductor-supply-chains-home-creating-jobs-supporting-inn/">CHIPS and Science Act</a>, which aims to bring semiconductor production onshore and strengthen supply chain resilience.</p>
<p>Securing machine learning systems requires moving beyond trust-by-default models toward zero-trust supply chain practices. This includes screening suppliers, validating component provenance, implementing tamper-evident protections, and continuously monitoring system behavior for signs of compromise. Building fault-tolerant architectures that detect and contain failures provides an additional layer of defense.</p>
<p>Ultimately, supply chain risks must be treated as a first-class concern in ML system design. Trust in the computational models and data pipelines that power machine learning depends corely on the trustworthiness of the hardware on which they run. Without securing the hardware foundation, even the most sophisticated models remain vulnerable to compromise.</p>
</section>
<section id="sec-security-privacy-case-study-supermicro-controversy-72b7" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-security-privacy-case-study-supermicro-controversy-72b7">Case Study: Supermicro Controversy</h3>
<p>The abstract nature of supply chain risks became concrete in a high-profile controversy that captured industry attention. In 2018, Bloomberg Businessweek published a widely discussed report alleging that Chinese state-sponsored actors had secretly implanted tiny surveillance chips on server motherboards manufactured by Supermicro <span class="citation" data-cites="TheBigHa77">(<a href="#ref-TheBigHa77" role="doc-biblioref">Robertson and Riley 2018</a>)</span>. These compromised servers were reportedly deployed by more than 30 major companies, including Apple and Amazon. The chips, described as no larger than a grain of rice, were said to provide attackers with backdoor access to sensitive data and systems.</p>
<div class="no-row-height column-margin column-container"><div id="ref-TheBigHa77" class="csl-entry" role="listitem">
Robertson, J., and M. Riley. 2018. <span>â€œThe Big Hack: How China Used a Tiny Chip to Infiltrate u.s. Companies - Bloomberg.â€</span><a href="
    https://www.bloomberg.com/news/features/2018-10-04/the-big-hack-how-china-used-a-tiny-chip-to-infiltrate-america-s-top-companies
  ">https://www.bloomberg.com/news/features/2018-10-04/the-big-hack-how-china-used-a-tiny-chip-to-infiltrate-america-s-top-companies </a>.
</div></div><p>The allegations sparked immediate concern across the technology industry, raising questions about the security of global supply chains and the potential for state-level hardware manipulation. However, the companies named in the report publicly denied the claims. Apple, Amazon, and Supermicro stated that they had found no evidence of the alleged implants after conducting thorough internal investigations. Industry experts and government agencies also expressed skepticism, noting the lack of verifiable technical evidence presented in the report.</p>
<p>Despite these denials, the story had a lasting impact on how organizations and policymakers view hardware supply chain security. Whether or not the specific claims were accurate, the report highlighted the real and growing concern that hardware supply chains are difficult to fully audit and secure. It underscored how geopolitical tensions, manufacturing outsourcing, and the complexity of modern hardware ecosystems make it increasingly challenging to guarantee the integrity of hardware components.</p>
<p>The Supermicro case illustrates a broader truth: once a product enters a complex global supply chain, it becomes difficult to ensure that every component is free from tampering or unauthorized modification. This risk is particularly acute for machine learning systems, which depend on a wide range of hardware accelerators, memory modules, and processing units sourced from multiple vendors across the globe.</p>
<p>In response to these risks, both industry and government stakeholders have begun to invest in supply chain security initiatives. The U.S. governmentâ€™s CHIPS and Science Act is one such effort, aiming to bring semiconductor manufacturing back onshore to improve transparency and reduce dependency on foreign suppliers. While these efforts are valuable, they do not fully eliminate supply chain risks. They must be complemented by technical safeguards, such as component validation, runtime monitoring, and fault-tolerant system design.</p>
<p>The Supermicro controversy serves as a cautionary tale for the machine learning community. It demonstrates that hardware security cannot be taken for granted, even when working with reputable suppliers. Ensuring the integrity of ML systems requires rigorous attention to the entire hardware lifecycleâ€”from design and fabrication to deployment and maintenance. This case reinforces the need for organizations to adopt comprehensive supply chain security practices as a foundational element of trustworthy ML system design.</p>
<div id="quiz-question-sec-security-privacy-hardwarelevel-security-vulnerabilities-1ab4" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.6</strong></summary><div>
<ol type="1">
<li><p>Which of the following best describes a side-channel attack in the context of machine learning hardware?</p>
<ol type="a">
<li>A direct attack on the software interface to extract data.</li>
<li>An attack exploiting physical signals to infer sensitive information.</li>
<li>A network-based attack targeting data transmission.</li>
<li>A physical tampering of hardware components.</li>
</ol></li>
<li><p>Explain how speculative execution vulnerabilities like Meltdown and Spectre pose a threat to machine learning hardware security.</p></li>
<li><p>Order the following hardware threats based on their potential impact on ML system security: (1) Side-Channel Attacks, (2) Physical Attacks, (3) Supply Chain Risks.</p></li>
<li><p>In a production ML system, which strategy is most effective for mitigating the risk of counterfeit hardware?</p>
<ol type="a">
<li>Implementing strong encryption protocols.</li>
<li>Conducting regular software updates.</li>
<li>Increasing network bandwidth.</li>
<li>Performing thorough supplier verification and component testing.</li>
</ol></li>
</ol>
<p><a href="#quiz-answer-sec-security-privacy-hardwarelevel-security-vulnerabilities-1ab4" class="question-label">See Answers â†’</a></p>
</div></details>
</div>
</section>
</section>
<section id="sec-security-privacy-ml-systems-become-attack-tools-2f34" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-security-privacy-ml-systems-become-attack-tools-2f34">When ML Systems Become Attack Tools</h2>
<p>The threats examined thus farâ€”model theft, data poisoning, adversarial attacks, hardware vulnerabilitiesâ€”represent attacks targeting machine learning systems. However, a complete threat model must also account for the inverse: machine learning as an attack amplifier. The same capabilities that make ML powerful for beneficial applications also enhance adversarial operations, transforming machine learning from passive target to active weapon.</p>
<p>While machine learning systems are often treated as assets to protect, they may also serve as tools for launching attacks. In adversarial settings, the same models used to enhance productivity, automate perception, or assist decision-making can be repurposed to execute or amplify offensive operations. This dual-use characteristic of machine learning, its capacity to secure systems as well as to subvert them, marks a core shift in how ML must be considered within system-level threat models.</p>
<p>An offensive use of machine learning refers to any scenario in which a machine learning model is employed to facilitate the compromise of another system. In such cases, the model itself is not the object under attack, but the mechanism through which an adversary advances their objectives. These applications may involve reconnaissance, inference, subversion, impersonation, or the automation of exploit strategies that would otherwise require manual execution.</p>
<p>Importantly, such offensive applications are not speculative. Attackers are already integrating machine learning into their toolchains across a wide range of activities, from spam filtering evasion to model-driven malware generation. What distinguishes these scenarios is the deliberate use of learning-based systems to extract, manipulate, or generate information in ways that undermine the confidentiality, integrity, or availability of targeted components.</p>
<p>To clarify the diversity and structure of these applications, <a href="#tbl-offensive-ml-use-cases" class="quarto-xref">Table&nbsp;6</a> summarizes several representative use cases. For each, the table identifies the type of machine learning model typically employed, the underlying system vulnerability it exploits, and the primary advantage conferred by the use of machine learning.</p>
<p>These documented cases illustrate how machine learning models can serve as amplifiers of adversarial capability. For example, language models allow more convincing and adaptable phishing attacks, while clustering and classification algorithms facilitate reconnaissance by learning system-level behavioral patterns. The generative AI capabilities of large language models particularly amplify these offensive applications. Similarly, adversarial example generators and inference models systematically uncover weaknesses in decision boundaries or data privacy protections, often requiring only limited external access to deployed systems. In hardware contexts, as discussed in the next section, deep neural networks trained on side-channel data can automate the extraction of cryptographic secrets from physical measurementsâ€”transforming an expert-driven process into a learnable pattern recognition task. The deep learning foundations from <strong><a href="../dl_primer/dl_primer.html#sec-dl-primer">Chapter 3: Deep Learning Primer</a></strong>â€”convolutional neural networks for spatial pattern recognition, recurrent architectures for temporal dependencies, and gradient-based optimizationâ€”enable attackers to apply these techniques across various hardware platforms discussed in <strong><a href="../hw_acceleration/hw_acceleration.html#sec-ai-acceleration">Chapter 11: AI Acceleration</a></strong>, from GPUs and TPUs in cloud environments to edge accelerators with constrained resources.</p>
<div id="tbl-offensive-ml-use-cases" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-offensive-ml-use-cases-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;6: <strong>Offensive ML Use Cases</strong>: This table categorizes how machine learning amplifies cyberattacks by enabling automated content generation, exploiting system vulnerabilities, and increasing attack sophistication; it details the typical ML model, targeted weakness, and resulting advantage for each offensive application. Understanding these use cases is important for developing effective defenses against increasingly intelligent threats.
</figcaption>
<div aria-describedby="tbl-offensive-ml-use-cases-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 21%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Offensive Use Case</strong></th>
<th style="text-align: left;"><strong>ML Model Type</strong></th>
<th style="text-align: left;"><strong>Targeted System Vulnerability</strong></th>
<th style="text-align: left;"><strong>Advantage of ML</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Phishing and Social Engineering</strong></td>
<td style="text-align: left;">Large Language Models (LLMs)</td>
<td style="text-align: left;">Human perception and communication systems</td>
<td style="text-align: left;">Personalized, context-aware message crafting</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Reconnaissance and Fingerprinting</strong></td>
<td style="text-align: left;">Supervised classifiers, clustering models</td>
<td style="text-align: left;">System configuration, network behavior</td>
<td style="text-align: left;">Scalable, automated profiling of system behavior</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Exploit Generation</strong></td>
<td style="text-align: left;">Code generation models, fine-tuned transformers</td>
<td style="text-align: left;">Software bugs, insecure code patterns</td>
<td style="text-align: left;">Automated discovery of candidate exploits</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Data Extraction (Inference Attacks)</strong></td>
<td style="text-align: left;">Classification models, inversion models</td>
<td style="text-align: left;">Privacy leakage through model outputs</td>
<td style="text-align: left;">Inference with limited or black-box access</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Evasion of Detection Systems</strong></td>
<td style="text-align: left;">Adversarial input generators</td>
<td style="text-align: left;">Detection boundaries in deployed ML systems</td>
<td style="text-align: left;">Crafting minimally perturbed inputs to evade filters</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Hardware-Level Attacks</strong></td>
<td style="text-align: left;">Deep learning models</td>
<td style="text-align: left;">Physical side-channels (e.g., power, timing, EM)</td>
<td style="text-align: left;">Learning leakage patterns directly from raw signals</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Although these applications differ in technical implementation, they share a common foundation: the adversary replaces a static exploit with a learned model capable of approximating or adapting to the targetâ€™s vulnerable behavior. This shift increases flexibility, reduces manual overhead, and improves robustness in the face of evolving or partially obscured defenses.</p>
<p>What makes this class of threats particularly significant is their favorable scaling behavior. Just as accuracy in computer vision or language modeling improves with additional data, larger architectures, and greater compute resources, so too does the performance of attack-oriented machine learning models. A model trained on larger corpora of phishing attempts or power traces, for instance, may generalize more effectively, evade more detectors, or require fewer inputs to succeed. The same ecosystem that drives innovation in beneficial AI, including public datasets, open-source tooling, and scalable infrastructure, also lowers the barrier to developing effective offensive models.</p>
<p>This dynamic creates an asymmetry between attacker and defender. While defensive measures are bounded by deployment constraints, latency budgets, and regulatory requirements, attackers can scale training pipelines with minimal marginal cost. The widespread availability of pretrained models and public ML platforms further reduces the expertise required to develop high-impact attacks.</p>
<p>Examining these offensive capabilities serves a crucial defensive purpose. Security professionals have long recognized that effective defense requires understanding attack methodologiesâ€”this principle underlies penetration testing<a href="#fn33" class="footnote-ref" id="fnref33" role="doc-noteref"><sup>33</sup></a>, red team exercises<a href="#fn34" class="footnote-ref" id="fnref34" role="doc-noteref"><sup>34</sup></a>, and threat modeling throughout the cybersecurity industry.</p>
<div class="no-row-height column-margin column-container"><div id="fn33"><p><sup>33</sup>&nbsp;<strong>Penetration Testing</strong>: Authorized simulated cyberattacks to evaluate system security, formalized in the 1960s for military computer systems. The global penetration testing market reached $1.7 billion in 2022, with 89% of organizations conducting annual pen tests to identify vulnerabilities before attackers do.</p></div><div id="fn34"><p><sup>34</sup>&nbsp;<strong>Red Team Exercises</strong>: Adversarial security simulations where specialized teams emulate real attackers to test organizational defenses, originated from military war games in the 1960s. Unlike penetration testing, red teams use social engineering, physical access, and advanced persistent threat techniques, with exercises lasting weeks or months to simulate sophisticated nation-state attacks. The phrase â€œknow your enemyâ€ reflects this core security principle.</p></div></div><p>In the machine learning domain, this understanding becomes essential because ML amplifies both defensive and offensive capabilities. The same computational advantages that make ML powerful for legitimate applicationsâ€”pattern recognition, automation, and scalabilityâ€”also enhance adversarial capabilities. By examining how machine learning can be weaponized, security professionals can anticipate attack vectors, design more robust defenses, and develop detection mechanisms.</p>
<p>As a result, any comprehensive treatment of machine learning system security must consider not only the vulnerabilities of ML systems themselves but also the ways in which machine learning can be used to compromise other componentsâ€”whether software, data, or hardware. Understanding the offensive potential of machine-learned systems is essential for designing resilient, trustworthy, and forward-looking defenses.</p>
<section id="sec-security-privacy-case-study-deep-learning-sca-b0b3" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-security-privacy-case-study-deep-learning-sca-b0b3">Case Study: Deep Learning for SCA</h3>
<p>To illustrate these offensive capabilities concretely, we examine a specific case where machine learning transforms traditional attack methodologies. One of the most well-known and reproducible demonstrations of deep-learning-assisted SCA is the SCAAML framework (Side-Channel Attacks Assisted with Machine Learning) <span class="citation" data-cites="scaaml_2019">(<a href="#ref-scaaml_2019" role="doc-biblioref">Bursztein et al. 2024a</a>)</span>. Developed by researchers at Google, SCAAML provides a practical implementation of the attack pipeline described above.</p>
<div class="no-row-height column-margin column-container"></div><div id="fig-side-channel-curves" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-side-channel-curves-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="3b93b1c212e7f67d62b09b8afe46909303ea5019.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-11" title="Figure&nbsp;11: Power Traces: Cryptographic computations reveal subtle, data-dependent variations in power consumption that reflect internal states during specific operations."><img src="privacy_security_files/mediabag/3b93b1c212e7f67d62b09b8afe46909303ea5019.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-side-channel-curves-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;11: <strong>Power Traces</strong>: Cryptographic computations reveal subtle, data-dependent variations in power consumption that reflect internal states during specific operations.
</figcaption>
</figure>
</div>
<p>As shown in <a href="#fig-side-channel-curves" class="quarto-xref">Figure&nbsp;11</a>, cryptographic computations exhibit data-dependent variations in their power consumption. These variations, while subtle, are measurable and reflect the internal state of the algorithm at specific points in time.</p>
<p>In traditional side-channel attacks, experts rely on statistical techniques to extract these differences. However, a neural network can learn to associate the shape of these signals with the specific data values being processed, effectively learning to decode the signal in a manner that mimics expert-crafted models, yet with enhanced flexibility and generalization. The model is trained on labeled examples of power traces and their corresponding intermediate values (e.g., output of an S-box operation). Over time, it learns to associate patterns in the trace, similar to those depicted in <a href="#fig-side-channel-curves" class="quarto-xref">Figure&nbsp;11</a>, with secret-dependent computational behavior. This transforms the key recovery task into a classification problem, where the goal is to infer the correct key byte based on trace shape alone.</p>
<p>In their study, <span class="citation" data-cites="scaaml_2019">Bursztein et al. (<a href="#ref-scaaml_2019" role="doc-biblioref">2024a</a>)</span> trained a convolutional neural network to extract AES keys from power traces collected on an STM32F415 microcontroller running the open-source TinyAES implementation. The model was trained to predict intermediate values of the AES algorithm, such as the output of the S-box in the first round, directly from raw power traces. The trained model recovered the full 128-bit key using only a small number of traces per byte.</p>
<div class="no-row-height column-margin column-container"></div><p>The traces were collected using a ChipWhisperer setup with a custom STM32F target board, shown in <a href="#fig-stm32f-board" class="quarto-xref">Figure&nbsp;12</a>. This board executes AES operations while allowing external equipment to monitor power consumption with high temporal precision. The experimental setup captures how even inexpensive, low-power embedded devices can leak information through side channelsâ€”information that modern machine learning models can learn to exploit.</p>
<div id="fig-stm32f-board" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-stm32f-board-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/png/stm32f_board.png" class="lightbox" data-gallery="quarto-lightbox-gallery-12" title="Figure&nbsp;12: STM32F415 Target Board: Enables monitoring of power consumption during AES operations on the microcontroller, highlighting side-channel vulnerabilities that can be exploited by machine learning models. Source: @scaaml_2019."><img src="images/png/stm32f_board.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-stm32f-board-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;12: <strong>STM32F415 Target Board</strong>: Enables monitoring of power consumption during AES operations on the microcontroller, highlighting side-channel vulnerabilities that can be exploited by machine learning models. Source: <span class="citation" data-cites="scaaml_2019">Bursztein et al. (<a href="#ref-scaaml_2019" role="doc-biblioref">2024a</a>)</span>.
</figcaption>
<div class="no-row-height column-margin column-container"><div id="ref-scaaml_2019" class="csl-entry" role="listitem">
â€”â€”â€”. 2024a. <span>â€œGeneralized Power Attacks Against Crypto Hardware Using Long-Range Deep Learning.â€</span> <em>IACR Transactions on Cryptographic Hardware and Embedded Systems</em> 2024 (3): 472â€“99. <a href="https://doi.org/10.46586/tches.v2024.i3.472-499">https://doi.org/10.46586/tches.v2024.i3.472-499</a>.
</div></div></figure>
</div>
<p>Subsequent work expanded on this approach by introducing long-range models capable of leveraging broader temporal dependencies in the traces, improving performance even under noise and desynchronization <span class="citation" data-cites="bursztein2023generic">(<a href="#ref-bursztein2023generic" role="doc-biblioref">Bursztein et al. 2024b</a>)</span>. These developments highlight the potential for machine learning models to serve as offensive cryptanalysis tools, especially in the analysis of secure hardware.</p>
<div class="no-row-height column-margin column-container"><div id="ref-bursztein2023generic" class="csl-entry" role="listitem">
Bursztein, Elie, Luca Invernizzi, Karel KrÃ¡l, Daniel Moghimi, Jean-Michel Picod, and Marina Zhang. 2024b. <span>â€œGeneralized Power Attacks Against Crypto Hardware Using Long-Range Deep Learning.â€</span> <em>IACR Transactions on Cryptographic Hardware and Embedded Systems</em> 2024 (3): 472â€“99. <a href="https://doi.org/10.46586/tches.v2024.i3.472-499">https://doi.org/10.46586/tches.v2024.i3.472-499</a>.
</div></div><p>The implications extend beyond academic interest. As deep learning models continue to scale, their application to side-channel contexts is likely to lower the cost, skill threshold, and trace requirements of hardware-level attacksâ€”posing a growing challenge for the secure deployment of embedded machine learning systems, cryptographic modules, and trusted execution environments.</p>
<div id="quiz-question-sec-security-privacy-ml-systems-become-attack-tools-2f34" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.7</strong></summary><div>
<ol type="1">
<li><p>Which of the following best describes the dual-use nature of machine learning in security contexts?</p>
<ol type="a">
<li>ML can only be used for defensive purposes.</li>
<li>ML can be used both to protect systems and to launch attacks.</li>
<li>ML can only be used for offensive purposes.</li>
<li>ML is not relevant to security contexts.</li>
</ol></li>
<li><p>Explain how machine learning models can be used offensively in cyberattacks.</p></li>
<li><p>In the context of offensive ML applications, what advantage does using ML models provide to attackers?</p>
<ol type="a">
<li>ML models are slower than manual methods.</li>
<li>ML models require more expertise than traditional methods.</li>
<li>ML models are less effective than traditional methods.</li>
<li>ML models can automate and scale attack strategies.</li>
</ol></li>
<li><p>The use of machine learning to evade detection systems by crafting minimally perturbed inputs is known as ______.</p></li>
<li><p>How might understanding offensive ML capabilities help in designing better defenses?</p></li>
</ol>
<p><a href="#quiz-answer-sec-security-privacy-ml-systems-become-attack-tools-2f34" class="question-label">See Answers â†’</a></p>
</div></details>
</div>
</section>
</section>
<section id="sec-security-privacy-comprehensive-defense-architectures-48ab" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="sec-security-privacy-comprehensive-defense-architectures-48ab">Comprehensive Defense Architectures</h2>
<p>Having examined threats against ML systems and threats enabled by ML capabilities, we now turn to comprehensive defensive strategies. Designing secure and privacy-preserving machine learning systems requires more than identifying individual threats. It demands a layered defense strategy that integrates protections across multiple system levels to create comprehensive resilience.</p>
<p>This section progresses systematically through four layers of defense: Data Layer protections including differential privacy and secure computation that safeguard sensitive information during training; Model Layer defenses such as adversarial training and secure deployment that protect the models themselves; Runtime Layer measures including input validation and output monitoring that secure inference operations; and Hardware Layer foundations such as trusted execution environments that provide the trust anchor for all other protections. We conclude with practical frameworks for selecting and implementing these defenses based on your deployment context.</p>
<section id="sec-security-privacy-layered-defense-principle-8706" class="level3">
<h3 class="anchored" data-anchor-id="sec-security-privacy-layered-defense-principle-8706">The Layered Defense Principle</h3>
<p>Layered defense (also known as defense-in-depth) represents a core security architecture principle where multiple independent defensive mechanisms work together to protect against diverse threat vectors. In machine learning systems, this approach becomes essential due to the unique attack surfaces introduced by data dependencies, model exposures, and inference patterns. Unlike traditional software systems that primarily face code-based vulnerabilities, ML systems are vulnerable to input manipulation, data leakage, model extraction, and runtime abuse, all amplified by tight coupling between data, model behavior, and infrastructure.</p>
<p>The layered approach recognizes that no single defensive mechanism can address all possible threats. Instead, security emerges from the interaction of complementary protections: data-layer techniques like differential privacy and federated learning; model-layer defenses including robustness techniques and secure deployment; runtime-layer measures such as input validation and output monitoring; and hardware-layer solutions including trusted execution environments and secure boot. Each layer contributes to the systemâ€™s overall resilience while compensating for potential weaknesses in other layers.</p>
<p>This section presents a structured framework implementing layered defense for ML systems, progressing from data-centric protections to infrastructure-level enforcement. The framework builds upon data protection practices in <strong><a href="../data_engineering/data_engineering.html#sec-data-engineering">Chapter 6: Data Engineering</a></strong> and connects forward to operational security measures detailed in <strong><a href="../ops/ops.html#sec-ml-operations">Chapter 13: ML Operations</a></strong>. By integrating safeguards across layers, organizations can build ML systems that not only perform reliably but also withstand adversarial pressure in production environments.</p>
<p>The layered approach is visualized in <a href="#fig-defense-stack" class="quarto-xref">Figure&nbsp;13</a>, which shows how defensive mechanisms progress from foundational hardware-based security to runtime system protections, model-level controls, and privacy-preserving techniques at the data level. Each layer builds on the trust guarantees of the layer below it, forming an end-to-end strategy for deploying ML systems securely.</p>
<div id="fig-defense-stack" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-defense-stack-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="9fccd386f219e9fb6c40bbc5e1f113f94df5dab3.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-13" title="Figure&nbsp;13: Layered Defense Stack: Machine learning systems require multi-faceted security strategies that progress from foundational hardware protections to data-centric privacy techniques, building trust across all layers. This architecture integrates safeguards at the data, model, runtime, and infrastructure levels to mitigate threats and ensure robust deployment in production environments."><img src="privacy_security_files/mediabag/9fccd386f219e9fb6c40bbc5e1f113f94df5dab3.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-defense-stack-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;13: <strong>Layered Defense Stack</strong>: Machine learning systems require multi-faceted security strategies that progress from foundational hardware protections to data-centric privacy techniques, building trust across all layers. This architecture integrates safeguards at the data, model, runtime, and infrastructure levels to mitigate threats and ensure robust deployment in production environments.
</figcaption>
</figure>
</div>
</section>
<section id="sec-security-privacy-privacypreserving-data-techniques-64f8" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-security-privacy-privacypreserving-data-techniques-64f8">Privacy-Preserving Data Techniques</h3>
<p>At the highest level of our defense stack, we begin with data privacy techniques. Protecting the privacy of individuals whose data fuels machine learning systems is a foundational requirement for trustworthy AI. Unlike traditional systems where data is often masked or anonymized before processing, ML workflows typically rely on access to raw, high-fidelity data to train effective models. This tension between utility and privacy has motivated a diverse set of techniques aimed at minimizing data exposure while preserving learning performance.</p>
<section id="sec-security-privacy-differential-privacy-8c2b" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-security-privacy-differential-privacy-8c2b">Differential Privacy</h4>
<p>One of the most widely adopted frameworks for formalizing privacy guarantees is differential privacy (DP). DP provides a rigorous mathematical definition of privacy loss, ensuring that the inclusion or exclusion of a single individualâ€™s data has a provably limited effect on the modelâ€™s output.</p>
<p>To understand the need for differential privacy, consider this challenge: how can we quantify privacy loss when learning from data? Traditional privacy approaches focus on removing identifying information (names, addresses, social security numbers) or applying statistical disclosure controls. However, these methods fail against sophisticated adversaries who can re-identify individuals through auxiliary data, statistical correlation attacks, or inference from model outputs.</p>
<p>Differential privacy takes a different approach by focusing on algorithmic behavior rather than data content. The key insight is that privacy protection should be measurable and should limit what can be learned about any individual, regardless of what external information an adversary possesses.</p>
<p>To build intuition for this concept, imagine you want to find the average salary of a group of people, but no one wants to reveal their actual salary. With differential privacy, you could ask everyone to write their salary on a piece of paper, but before they hand it in, they add or subtract a random number from a known distribution. When you average all the papers, the random noise tends to cancel out, giving you a very close estimate of the true average. However, if you pull out any single piece of paper, you cannot know the personâ€™s real salary because you do not know what random number they added. This is the core idea: learn aggregate patterns while making it impossible to be sure about any single individual.</p>
<p>Differential privacy formalizes this intuition through a comparison of algorithm behavior on similar datasets. Consider two adjacent datasets that differ only in the presence or absence of a single individualâ€™s record. Differential privacy ensures that the probability distributions of algorithm outputs remain statistically similar regardless of whether that individualâ€™s data is included. This protection is achieved through carefully calibrated noise that masks individual contributions while preserving the aggregate statistical patterns necessary for machine learning.</p>
<p>To make this intuition mathematically precise, differential privacy introduces a quantitative measure of privacy loss. The mathematical framework uses probability ratios to bound how much an algorithmâ€™s behavior can change when a single individualâ€™s data is added or removed. This approach allows us to prove privacy guarantees rather than simply assume them.</p>
<p>A randomized algorithm <span class="math inline">\(\mathcal{A}\)</span> is said to be <span class="math inline">\(\epsilon\)</span>-differentially private if, for all adjacent datasets <span class="math inline">\(D\)</span> and <span class="math inline">\(D'\)</span> differing in one record, and for all outputs <span class="math inline">\(S \subseteq \text{Range}(\mathcal{A})\)</span>, the following holds: <span class="math display">\[
\Pr[\mathcal{A}(D) \in S] \leq e^{\epsilon} \Pr[\mathcal{A}(D') \in S]
\]</span></p>
<p>The parameter <span class="math inline">\(\epsilon\)</span> quantifies the privacy budget, representing the maximum allowable privacy loss. Smaller values of <span class="math inline">\(\epsilon\)</span> provide stronger privacy guarantees through increased noise injection, but may reduce model utility. Typical values include <span class="math inline">\(\epsilon = 0.1\)</span> for strong privacy protection, <span class="math inline">\(\epsilon = 1.0\)</span> for moderate protection, and <span class="math inline">\(\epsilon = 10\)</span> for weaker but utility-preserving guarantees. The multiplicative factor <span class="math inline">\(e^{\epsilon}\)</span> bounds the likelihood ratio between algorithm outputs on adjacent datasets, constraining how much an individualâ€™s participation can influence any particular result.</p>
<p>This bound ensures that the algorithmâ€™s behavior remains statistically indistinguishable regardless of whether any individualâ€™s data is present, thereby limiting the information that can be inferred about that individual. In practice, DP is implemented by adding calibrated noise to model updates or query responses, using mechanisms such as the Laplace or Gaussian mechanism. Training techniques like differentially private stochastic gradient descent<a href="#fn35" class="footnote-ref" id="fnref35" role="doc-noteref"><sup>35</sup></a> integrate calibrated noise into training computations, ensuring that individual data points cannot be distinguished from the modelâ€™s learned behavior.</p>
<div class="no-row-height column-margin column-container"><div id="fn35"><p><sup>35</sup>&nbsp;<strong>DP-SGD Industry Adoption</strong>: Apple was the first major company to deploy differential privacy at scale in 2016, protecting 1+ billion usersâ€™ data in iOS. Their implementation adds noise to emoji usage, Safari crashes, and QuickType suggestions, balancing privacy (Îµ=4-16) with utility for improving user experience across their ecosystem.</p></div><div id="fn36"><p><sup>36</sup>&nbsp;<strong>Privacy-Utility Tension</strong>: This core tradeoff was formalized by Dwork and McSherry, who proved that perfect privacy (infinite noise) yields no utility, while perfect utility (no noise) provides no privacy. The â€œprivacy budgetâ€ concept emerged from this insightâ€”you can only spend privacy once, making every query a strategic decision.</p></div></div><p>While differential privacy offers strong theoretical assurances, it introduces a trade-off between privacy and utility<a href="#fn36" class="footnote-ref" id="fnref36" role="doc-noteref"><sup>36</sup></a> that has measurable computational and accuracy costs.</p>
<p>Practical DP deployment requires careful consideration of computational trade-offs, privacy budget management, and implementation challenges, as detailed in <a href="#tbl-privacy-technique-comparison" class="quarto-xref">Table&nbsp;7</a>.</p>
<p>Increasing the noise to reduce <span class="math inline">\(\epsilon\)</span> may degrade model accuracy, especially in low-data regimes or fine-grained classification tasks. Consequently, DP is often applied selectivelyâ€”either during training on sensitive datasets or at inference when returning aggregate statisticsâ€”to balance privacy with performance goals <span class="citation" data-cites="dwork2014algorithmic">(<a href="#ref-dwork2014algorithmic" role="doc-biblioref">Dwork and Roth 2013</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-dwork2014algorithmic" class="csl-entry" role="listitem">
Dwork, Cynthia, and Aaron Roth. 2013. <span>â€œThe Algorithmic Foundations of Differential Privacy.â€</span> <em>Foundations and Trends in Theoretical Computer Science</em> 9 (3-4): 211â€“407. <a href="https://doi.org/10.1561/0400000042">https://doi.org/10.1561/0400000042</a>.
</div></div></section>
<section id="sec-security-privacy-federated-learning-3834" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-security-privacy-federated-learning-3834">Federated Learning</h4>
<p>While differential privacy adds mathematical guarantees to data processing, federated learning (FL) offers a complementary approach that reduces privacy risks by restructuring the learning process itself. This technique directly addresses the privacy challenges of on-device learning explored in <strong><a href="../ondevice_learning/ondevice_learning.html#sec-ondevice-learning">Chapter 14: On-Device Learning</a></strong>, where models must adapt to local data patterns without exposing sensitive user information. Rather than aggregating raw data at a central location, FL distributes the training across a set of client devices, each holding local data <span class="citation" data-cites="mcmahan2017communicationefficient">(<a href="#ref-mcmahan2017communicationefficient" role="doc-biblioref">McMahan et al. 2017</a>)</span>. This distributed training paradigm, which builds on the adaptive deployment concepts from on-device learning, requires careful coordination of security measures across multiple participants and infrastructure providers. Clients compute model updates locally and share only parameter deltas with a central server for aggregation: <span class="math display">\[
\theta_{t+1} \leftarrow \sum_{k=1}^{K} \frac{n_k}{n} \cdot \theta_{t}^{(k)}
\]</span></p>
<div class="no-row-height column-margin column-container"><div id="ref-mcmahan2017communicationefficient" class="csl-entry" role="listitem">
McMahan, Brendan, Eider Moore, Daniel Ramage, Seth Hampson, and Blaise AgÃ¼era y Arcas. 2017. <span>â€œCommunication-Efficient Learning of Deep Networks from Decentralized Data.â€</span> In <em>Proceedings of the 20th International Conference on Artificial Intelligence and Statistics (AISTATS)</em>, 1273â€“82. PMLR. <a href="http://proceedings.mlr.press/v54/mcmahan17a.html">http://proceedings.mlr.press/v54/mcmahan17a.html</a>.
</div></div><p>Here, <span class="math inline">\(\theta_{t}^{(k)}\)</span> represents the model update from client <span class="math inline">\(k\)</span>, <span class="math inline">\(n_k\)</span> the number of samples held by that client, and <span class="math inline">\(n\)</span> the total number of samples across all clients. This weighted aggregation allows the global model to learn from distributed data without direct access to it. FL reduces the exposure of raw data, but still leaks information through gradients, motivating the use of DP, secure aggregation, and hardware-based protections in federated settings.</p>
<div class="callout callout-style-default callout-note no-icon callout-titled" title="Real-World Example: Google Gboard Federated Learning">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Real-World Example: Google Gboard Federated Learning
</div>
</div>
<div class="callout-body-container callout-body">
<p>Googleâ€™s Gboard keyboard uses federated learning to improve next-word prediction across 1+ billion Android devices without collecting typing data. The system works as follows:</p>
<ol type="1">
<li>Local Training: Each device trains a small update to the language model using the userâ€™s recent typing (typically 100-1000 words)</li>
<li>Secure Aggregation: Devices upload encrypted model updates (not raw text) to Googleâ€™s servers</li>
<li>Global Update: The server aggregates thousands of updates, computing an improved global model</li>
<li>Distribution: The updated model is pushed back to devices in the next app update</li>
</ol>
<p><strong>Privacy Properties:</strong> Individual typing data never leaves the device. Even Googleâ€™s servers cannot decrypt individual updates, seeing only the aggregated result. The system combines FL with differential privacy <span class="math inline">\((\varepsilon\approx 6)\)</span> and secure aggregation protocols.</p>
<p><strong>Performance:</strong> FL achieves 92% of the accuracy of centralized training while eliminating raw data collection. Communication efficiency optimizations (gradient compression, selective participation) reduce bandwidth to ~100 KB per device per day.</p>
<p><strong>Trade-offs:</strong> FL requires 10-100x more communication rounds than centralized training and introduces 2-5% accuracy degradation. However, for privacy-sensitive applications, these costs are acceptable compared to the alternative of not training at all.</p>
</div>
</div>
<p>To address scenarios requiring computation on encrypted data, homomorphic encryption (HE)<a href="#fn37" class="footnote-ref" id="fnref37" role="doc-noteref"><sup>37</sup></a> and secure multiparty computation (SMPC) allow models to perform inference or training over encrypted inputs. The computational overhead of homomorphic operations often requires the efficiency optimization techniques covered in <strong><a href="../efficient_ai/efficient_ai.html#sec-efficient-ai">Chapter 9: Efficient AI</a></strong>â€”including model compression (quantization reduces precision requirements for encrypted operations), architectural optimization (depthwise separable convolutions minimize encrypted multiplications), and hardware acceleration (specialized cryptographic accelerators)â€”to maintain practical performance.</p>
<div class="no-row-height column-margin column-container"><div id="fn37"><p><sup>37</sup>&nbsp;<strong>Homomorphic Encryption Breakthrough</strong>: Considered the â€œholy grailâ€ of cryptography since the 1970s, fully homomorphic encryption remained theoretical until Craig Gentryâ€™s 2009 PhD thesis. His breakthrough was realizing that â€œnoisyâ€ ciphertexts could support unlimited operations if periodically â€œrefreshed,â€ solving a decades-old puzzle that allows computation on encrypted data.</p></div></div><p>In the case of HE, operations on ciphertexts correspond to operations on plaintexts, enabling encrypted inference: <span class="math display">\[
\text{Enc}(f(x)) = f(\text{Enc}(x))
\]</span></p>
<p>This property supports privacy-preserving computation in untrusted environments, such as cloud inference over sensitive health or financial records. The computational cost of HE remains high, making it more suitable for fixed-function models and low-latency batch tasks. SMPC<a href="#fn38" class="footnote-ref" id="fnref38" role="doc-noteref"><sup>38</sup></a>, by contrast, distributes the computation across multiple parties such that no single party learns the complete input or output. This is particularly useful in joint training across institutions with strict data-use policies, such as hospitals or banks<a href="#fn39" class="footnote-ref" id="fnref39" role="doc-noteref"><sup>39</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn38"><p><sup>38</sup>&nbsp;<strong>SMPC Performance</strong>: Secure multi-party computation typically incurs 1000-10,000x computational overhead compared to plaintext operations. A simple neural network inference that takes milliseconds on GPU requires hours using SMPC, limiting practical applications to small models and offline scenarios.</p></div><div id="fn39"><p><sup>39</sup>&nbsp;<strong>Secure Multi-Party Computation (SMPC)</strong>: Cryptographic framework enabling multiple parties to jointly compute functions over their private inputs without revealing those inputs, first formalized in 1982 by Andrew Yao. Todayâ€™s implementations allow hospitals to collaboratively train medical AI models without sharing patient records, achieving 99%+ accuracy while maintaining strict privacy compliance.</p></div></div></section>
<section id="sec-security-privacy-synthetic-data-generation-4349" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-security-privacy-synthetic-data-generation-4349">Synthetic Data Generation</h4>
<p>Beyond cryptographic approaches like homomorphic encryption, a more pragmatic and increasingly popular alternative involves the use of synthetic data generation<a href="#fn40" class="footnote-ref" id="fnref40" role="doc-noteref"><sup>40</sup></a>. This approach offers an intuitive solution to privacy protection: if we can create artificial data that looks statistically similar to real data, we can train models without ever exposing sensitive information.</p>
<div class="no-row-height column-margin column-container"><div id="fn40"><p><sup>40</sup>&nbsp;<strong>Synthetic Data Growth</strong>: The synthetic data market grew from $110 million in 2019 to $1.1 billion in 2023, driven by privacy regulations and data scarcity. Companies like Uber use synthetic trip data to protect user privacy while maintaining ML model performance, with some synthetic datasets achieving 95%+ statistical fidelity.</p></div></div><p>Synthetic data generation works by training a generative model (such as a GAN, VAE, or diffusion model) on the original sensitive dataset, then using this trained generator to produce new artificial samples. The key insight is that the generative model learns the underlying patterns and distributions in the data without memorizing specific individuals. When properly implemented, the synthetic data preserves statistical properties necessary for machine learning while removing personally identifiable information.</p>
<p>The generation typically follows three stages. First, distribution learning trains a generative model <span class="math inline">\(G_\theta\)</span> on real data <span class="math inline">\(D_{\text{real}} = \{x_1, x_2,\ldots, x_n\}\)</span> to learn the data distribution <span class="math inline">\(p(x)\)</span>. Second, synthetic sampling generates new samples <span class="math inline">\(D_{\text{synthetic}} = \{G_\theta(z_1), G_\theta(z_2),\ldots, G_\theta(z_m)\}\)</span> by sampling from random noise <span class="math inline">\(z_i \sim \mathcal{N}(0,I)\)</span>. Third, validation verifies that <span class="math inline">\(D_{\text{synthetic}}\)</span> maintains statistical fidelity to <span class="math inline">\(D_{\text{real}}\)</span> while avoiding memorization of specific records. By training generative models on real datasets and sampling new instances from the learned distribution, organizations can create datasets that approximate the statistical properties of the original data without retaining identifiable details <span class="citation" data-cites="goncalves2020generation">(<a href="#ref-goncalves2020generation" role="doc-biblioref">Goncalves et al. 2020</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-goncalves2020generation" class="csl-entry" role="listitem">
Goncalves, Andre, Priyadip Ray, Braden Soper, Jennifer Stevens, Linda Coyle, and Ana Paula Sales. 2020. <span>â€œGeneration and Evaluation of Synthetic Patient Data.â€</span> <em>BMC Medical Research Methodology</em> 20 (1): 1â€“40. <a href="https://doi.org/10.1186/s12874-020-00977-1">https://doi.org/10.1186/s12874-020-00977-1</a>.
</div></div><p>While appealing, synthetic data generation faces important limitations. Generative models can suffer from mode collapse, failing to capture rare but important patterns in the original data. More critically, sophisticated adversaries can potentially extract information about the original training data through generative model inversion attacks or membership inference. The privacy protection depends heavily on the generative model architecture, training procedure, and hyperparameter choicesâ€”making it difficult to provide formal privacy guarantees without additional mechanisms like differential privacy.</p>
<p>Consider a practical example where a hospital wants to share patient data for ML research while protecting privacy. They train a generative adversarial network (GAN) on 10,000 real patient records containing demographics, lab results, and diagnoses. The GAN learns to generate synthetic patients with realistic combinations of features (e.g., diabetic patients typically have elevated glucose levels). The synthetic dataset of 50,000 artificial patients maintains clinical correlations necessary for training diagnostic models while containing no real patient information. However, the hospital also applies differential privacy during GAN training (Îµ = 1.0) to prevent the model from memorizing specific patients, trading a 5% reduction in statistical fidelity for formal privacy guarantees.</p>
<p>Together, these techniques reflect a shift from isolating data as the sole path to privacy toward embedding privacy-preserving mechanisms into the learning process itself. Each method offers distinct guarantees and trade-offs depending on the application context, threat model, and regulatory constraints. Effective system design often combines multiple approaches, such as applying differential privacy within a federated learning setup, or employing homomorphic encryption for important inference stages, to build ML systems that are both useful and respectful of user privacy.</p>
</section>
<section id="sec-security-privacy-comparative-properties-9ca5" class="level4">
<h4 class="anchored" data-anchor-id="sec-security-privacy-comparative-properties-9ca5">Comparative Properties</h4>
<p>Having examined individual techniques, it becomes clear that these privacy-preserving approaches differ not only in the guarantees they offer but also in their system-level implications. For practitioners, the choice of mechanism depends on factors such as computational constraints, deployment architecture, and regulatory requirements.</p>
<p><a href="#tbl-privacy-technique-comparison" class="quarto-xref">Table&nbsp;7</a> summarizes the comparative properties of these methods, focusing on privacy strength, runtime overhead, maturity, and common use cases. Understanding these trade-offs is important for designing privacy-aware machine learning systems that operate under real-world constraints.</p>
<div id="tbl-privacy-technique-comparison" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-privacy-technique-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;7: <strong>Privacy-Accuracy Trade-Offs</strong>: Data privacy techniques impose varying computational costs and offer different levels of formal privacy guarantees, requiring practitioners to balance privacy strength with model utility and deployment constraints. The table summarizes key propertiesâ€”privacy guarantees, computational overhead, maturity, typical use cases, and trade-offsâ€”to guide informed decisions when designing privacy-aware machine learning systems.
</figcaption>
<div aria-describedby="tbl-privacy-technique-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 11%">
<col style="width: 14%">
<col style="width: 12%">
<col style="width: 15%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Technique</strong></th>
<th style="text-align: left;"><strong>Privacy Guarantee</strong></th>
<th style="text-align: left;"><strong>Computational Overhead</strong></th>
<th style="text-align: left;"><strong>Deployment Maturity</strong></th>
<th style="text-align: left;"><strong>Typical Use Case</strong></th>
<th style="text-align: left;"><strong>Trade-offs</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Differential Privacy</strong></td>
<td style="text-align: left;">Formal (Îµ-DP)</td>
<td style="text-align: left;">Moderate to High</td>
<td style="text-align: left;">Production</td>
<td style="text-align: left;">Training with sensitive or regulated data</td>
<td style="text-align: left;">Reduced accuracy; careful tuning of Îµ/noise required to balance utility and protection</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Federated Learning</strong></td>
<td style="text-align: left;">Structural</td>
<td style="text-align: left;">Moderate</td>
<td style="text-align: left;">Production</td>
<td style="text-align: left;">Cross-device or cross-org collaborative learning</td>
<td style="text-align: left;">Gradient leakage risk; requires secure aggregation and orchestration infrastructure</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Homomorphic Encryption</strong></td>
<td style="text-align: left;">Strong (Encrypted)</td>
<td style="text-align: left;">High</td>
<td style="text-align: left;">Experimental</td>
<td style="text-align: left;">Inference in untrusted cloud environments</td>
<td style="text-align: left;">High latency and memory usage; suitable for limited-scope inference on fixed-function models</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Secure MPC</strong></td>
<td style="text-align: left;">Strong (Distributed)</td>
<td style="text-align: left;">Very High</td>
<td style="text-align: left;">Experimental</td>
<td style="text-align: left;">Joint training across mutually untrusted parties</td>
<td style="text-align: left;">Expensive communication; challenging to scale to many participants or deep models</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Synthetic Data</strong></td>
<td style="text-align: left;">Weak (if standalone)</td>
<td style="text-align: left;">Low to Moderate</td>
<td style="text-align: left;">Emerging</td>
<td style="text-align: left;">Data sharing, benchmarking without direct access to raw data</td>
<td style="text-align: left;">May leak sensitive patterns if training process is not differentially private or audited for fidelity</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</section>
</section>
<section id="sec-security-privacy-case-study-gpt3-data-extraction-attack-5126" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-security-privacy-case-study-gpt3-data-extraction-attack-5126">Case Study: GPT-3 Data Extraction Attack</h3>
<p>In 2020, researchers conducted a groundbreaking study demonstrating that large language models could leak sensitive training data through carefully crafted prompts <span class="citation" data-cites="carlini2021extracting">(<a href="#ref-carlini2021extracting" role="doc-biblioref">Carlini et al. 2021</a>)</span>. The research team systematically queried OpenAIâ€™s GPT-3 model to extract verbatim content from its training dataset, revealing privacy vulnerabilities in large-scale language models.</p>
<div class="no-row-height column-margin column-container"></div><p>The attack proved remarkably successful at extracting sensitive information directly from the modelâ€™s outputs. By repeatedly querying the model with prompts like â€œMy name isâ€ followed by attempts to continue famous quotes or repeated phrases, researchers successfully extracted personal information including email addresses and phone numbers from the training data, verbatim passages from copyrighted books, private data that should have been filtered during training, and personally identifiable information from millions of individuals.</p>
<p>The technical approach exploited GPT-3â€™s memorization of rare or repeated text sequences. The researchers used prompt engineering to craft inputs that triggered memorized sequences, continuation attacks that used partial quotes or names to extract full sensitive information, statistical analysis to identify patterns in model outputs indicating verbatim memorization, and verification methods that cross-referenced extracted data with known public sources to confirm accuracy. Out of 600,000 attempts, they successfully extracted over 16,000 unique instances of memorized training data.</p>
<p>This attack challenged assumptions about training data privacy. The results demonstrated that large language models can act as unintentional databases, storing and retrieving sensitive information from their training data. This violated privacy expectations that training data would be â€œforgottenâ€ after model training, revealing that scale amplifies privacy risk as larger models (175B parameters) memorize more training data than smaller models.</p>
<p>The research revealed that common data protection measures proved insufficient. Even after data deduplication, models still memorized sensitive information, highlighting the tension between model utility and privacy protection. Techniques to prevent memorization such as differential privacy and aggressive data filtering reduce model quality, creating challenging trade-offs for practitioners.</p>
<p>The industry response was swift and comprehensive. Organizations began widespread adoption of differential privacy in large model training, enhanced data filtering and PII removal processes, development of membership inference defenses, new research into machine unlearning techniques, and regulatory discussions about training data rights and model transparency. Modern organizations now commonly implement differential privacy during training (Îµ â‰¤ 8), aggressive PII filtering using automated detection tools, regular auditing for data memorization using extraction attacks, and legal frameworks for handling training data containing personal information <span class="citation" data-cites="carlini2021extracting">(<a href="#ref-carlini2021extracting" role="doc-biblioref">Carlini et al. 2021</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-carlini2021extracting" class="csl-entry" role="listitem">
Carlini, Nicholas, Florian Tramer, Eric Wallace, Matthew Jagielski, Ariel Herbert-Voss, Katherine Lee, Adam Roberts, et al. 2021. <span>â€œExtracting Training Data from Large Language Models.â€</span> In <em>30th USENIX Security Symposium (USENIX Security 21)</em>, 2633â€“50. USENIX Association. <a href="https://www.usenix.org/conference/usenixsecurity21/presentation/carlini-extracting">https://www.usenix.org/conference/usenixsecurity21/presentation/carlini-extracting</a>.
</div></div></section>
<section id="sec-security-privacy-secure-model-design-69a6" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-security-privacy-secure-model-design-69a6">Secure Model Design</h3>
<p>Moving from data-level protections to model-level security, we address how security considerations shape the model development process. Security begins at the design phase of a machine learning system. While downstream mechanisms such as access control and encryption protect models once deployed, many vulnerabilities can be mitigated earlierâ€”through architectural choices, defensive training strategies, and mechanisms that embed resilience directly into the modelâ€™s structure or behavior. By considering security as a design constraint, system developers can reduce the modelâ€™s exposure to attacks, limit its ability to leak sensitive information, and provide verifiable ownership protection.</p>
<p>One important design strategy is to build robust-by-construction models that reduce the risk of exploitation at inference time. For instance, models with confidence calibration or abstention mechanisms can be trained to avoid making predictions when input uncertainty is high. These techniques can help prevent overconfident misclassifications in response to adversarial or out-of-distribution inputs. Models may also employ output smoothing, regularizing the output distribution to reduce sharp decision boundaries that are especially susceptible to adversarial perturbations.</p>
<p>Certain application contexts may also benefit from choosing simpler or compressed architectures. Limiting model capacity can reduce opportunities for memorization of sensitive training data and complicate efforts to reverse-engineer the model from output behavior. For embedded or on-device settings, smaller models are also easier to secure, as they typically require less memory and compute, lowering the likelihood of side-channel leakage or runtime manipulation.</p>
<p>Another design-stage consideration is the use of model watermarking<a href="#fn41" class="footnote-ref" id="fnref41" role="doc-noteref"><sup>41</sup></a>, a technique for embedding verifiable ownership signatures directly into the modelâ€™s parameters or output behavior <span class="citation" data-cites="adi2018turning">(<a href="#ref-adi2018turning" role="doc-biblioref">Adi et al. 2018</a>)</span>. A watermark might be implemented, for example, as a hidden response pattern triggered by specific inputs, or as a parameter-space perturbation that does not affect accuracy but is statistically identifiable.</p>
<div class="no-row-height column-margin column-container"><div id="fn41"><p><sup>41</sup>&nbsp;<strong>Model Watermarking</strong>: Technique for proving model ownership developed in 2017, analogous to digital image watermarks. Modern watermarking can embed signatures in less than 0.01% of model parameters while maintaining 99%+ accuracy, helping prove IP theft in courts where billions of dollars in AI assets are at stake.</p></div><div id="ref-adi2018turning" class="csl-entry" role="listitem">
Adi, Yossi, Carsten Baum, Moustapha Cisse, Benny Pinkas, and Joseph Keshet. 2018. <span>â€œTurning Your Weakness into a Strength: Watermarking Deep Neural Networks by Backdooring.â€</span> In <em>27th USENIX Security Symposium (USENIX Security 18)</em>, 1615â€“31.
</div></div><p>For example, in a keyword spotting system deployed on embedded hardware for voice activation (e.g., â€œHey Alexaâ€ or â€œOK Googleâ€), a secure design might use a lightweight convolutional neural network with confidence calibration to avoid false activations on uncertain audio. The model might also include an abstention threshold, below which it produces no activation at all. To protect intellectual property, a designer could embed a watermark by training the model to respond with a unique label only when presented with a specific, unused audio trigger known only to the developer. These design choices not only improve robustness and accountability, but also support future verification in case of IP disputes or performance failures in the field.</p>
<p>In high-risk applications, such as medical diagnosis, autonomous vehicles, or financial decision systems, designers may also prioritize interpretable model architectures, such as decision trees, rule-based classifiers, or sparsified networks, to enhance system auditability. These models are often easier to understand and explain, making it simpler to identify potential vulnerabilities or biases. Using interpretable models allows developers to provide clearer insights into how the system arrived at a particular decision, which is important for building trust with users and regulators.</p>
<p>Model design choices often reflect trade-offs between accuracy, robustness, transparency, and system complexity. When viewed from a systems perspective, early-stage design decisions yield the highest value for long-term security. They shape what the model can learn, how it behaves under uncertainty, and what guarantees can be made about its provenance, interpretability, and resilience.</p>
</section>
<section id="sec-security-privacy-secure-model-deployment-e08c" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-security-privacy-secure-model-deployment-e08c">Secure Model Deployment</h3>
<p>While secure design establishes a foundation of robustness, protection extends beyond the model itself to how it is packaged and deployed. Protecting machine learning models from theft, abuse, and unauthorized manipulation requires security considerations throughout both the design and deployment phases. A modelâ€™s vulnerability is not solely determined by its training procedure or architecture, but also by how it is serialized, packaged, deployed, and accessed during inference. As models are increasingly embedded into edge devices, served through public APIs, or integrated into multi-tenant platforms, robust security practices are important to ensure the integrity, confidentiality, and availability of model behavior.</p>
<p>This section addresses security mechanisms across three key stages: model design, secure packaging and serialization, and deployment and access control. These practices complement the model optimization techniques discussed in <strong><a href="../optimizations/optimizations.html#sec-model-optimizations">Chapter 10: Model Optimizations</a></strong>, where performance improvements must not compromise security properties.</p>
<p>From a design perspective, architectural choices can reduce a modelâ€™s exposure to adversarial manipulation and unauthorized use. For example, models can incorporate confidence calibration or abstention mechanisms that allow them to reject uncertain or anomalous inputs rather than producing potentially misleading outputs. Designing models with simpler or compressed architectures can also reduce the risk of reverse engineering or information leakage through side-channel analysis. In some cases, model designers may embed imperceptible watermarks, which are unique signatures embedded in the parameters or behavior of the model, that can later be used to demonstrate ownership in cases of misappropriation <span class="citation" data-cites="uchida2017embedding">(<a href="#ref-uchida2017embedding" role="doc-biblioref">Uchida et al. 2017</a>)</span>. These design-time protections are essential for commercially valuable models, where intellectual property rights are at stake.</p>
<div class="no-row-height column-margin column-container"><div id="ref-uchida2017embedding" class="csl-entry" role="listitem">
Uchida, Yusuke, Yuki Nagai, Shigeyuki Sakazawa, and Shinâ€™ichi Satoh. 2017. <span>â€œEmbedding Watermarks into Deep Neural Networks.â€</span> In <em>Proceedings of the 2017 ACM on International Conference on Multimedia Retrieval</em>, 269â€“77. ACM; ACM. <a href="https://doi.org/10.1145/3078971.3078974">https://doi.org/10.1145/3078971.3078974</a>.
</div></div><p>Once training is complete, the model must be securely packaged for deployment. Storing models in plaintext formats, including unencrypted ONNX or PyTorch checkpoint files, can expose internal structures and parameters to attackers with access to the file system or memory. To mitigate this risk, models should be encrypted, obfuscated, or wrapped in secure containers. Decryption keys should be made available only at runtime and only within trusted environments. Additional mechanisms, such as quantization-aware encryption or integrity-checking wrappers, can prevent tampering and offline model theft.</p>
<p>Deployment environments must also enforce strong access control policies to ensure that only authorized users and services can interact with inference endpoints. Authentication protocols, including OAuth<a href="#fn42" class="footnote-ref" id="fnref42" role="doc-noteref"><sup>42</sup></a> tokens, mutual TLS<a href="#fn43" class="footnote-ref" id="fnref43" role="doc-noteref"><sup>43</sup></a>, or API keys<a href="#fn44" class="footnote-ref" id="fnref44" role="doc-noteref"><sup>44</sup></a>, should be combined with role-based access control (RBAC)<a href="#fn45" class="footnote-ref" id="fnref45" role="doc-noteref"><sup>45</sup></a> to restrict access according to user roles and operational context. For instance, OpenAIâ€™s hosted model APIs require users to include an OPENAI_API_KEY when submitting inference requests.</p>
<div class="no-row-height column-margin column-container"><div id="fn42"><p><sup>42</sup>&nbsp;<strong>OAuth Protocol</strong>: Open Authorization standard developed in 2006, now used by 3+ billion users across Google, Facebook, and Microsoft services. OAuth 2.0 (2012) enables secure API access without exposing user credentials, processing trillions of authentication requests annually for ML API access.</p></div><div id="fn43"><p><sup>43</sup>&nbsp;<strong>Mutual TLS (mTLS)</strong>: Enhanced Transport Layer Security where both client and server authenticate each other using certificates, introduced in 1999. mTLS provides 99.9%+ secure communication but increases latency by 15-30ms, making it suitable for high-security ML API endpoints requiring end-to-end authentication.</p></div><div id="fn44"><p><sup>44</sup>&nbsp;<strong>API Keys</strong>: Simple authentication tokens first popularized by Google Maps API (2005), now ubiquitous in ML services. While convenient, API keys in URL parameters or headers can be logged or exposed, with studies showing 10-15% of GitHub repositories accidentally contain leaked API keys worth millions in compute credits.</p></div><div id="fn45"><p><sup>45</sup>&nbsp;<strong>Role-Based Access Control (RBAC)</strong>: Access control model developed by NIST in the 1990s, now mandatory for government systems. RBAC reduces security administration overhead by 90%+ compared to individual permissions, with modern ML platforms supporting thousands of roles governing model access, data permissions, and compute resources.</p></div></div><p>This key authenticates the client and allows the backend to enforce usage policies, monitor for abuse, and log access patterns. Secure implementations retrieve API keys from environment variables rather than hardcoding them into source code, preventing credential exposure in version control systems or application logs. Such key-based access control mechanisms are simple to implement but require careful key management and monitoring to prevent misuse, unauthorized access, or model extraction. Additional security measures in production deployments typically include model integrity verification through SHA-256 hash checking, rate limiting to prevent abuse, input validation for size and format constraints, and comprehensive logging for security event tracking.</p>
<p>The secure deployment patterns established here integrate naturally with the development workflows explored in <strong><a href="../workflow/workflow.html#sec-ai-workflow">Chapter 5: AI Workflow</a></strong>, ensuring security becomes part of standard engineering practice rather than an afterthought. Runtime monitoring (<a href="#sec-security-privacy-runtime-system-monitoring-a71c" class="quarto-xref">Section&nbsp;1.8.6</a>) extends these protections to operational environments.</p>
</section>
<section id="sec-security-privacy-runtime-system-monitoring-a71c" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-security-privacy-runtime-system-monitoring-a71c">Runtime System Monitoring</h3>
<p>While secure design and deployment establish strong foundations, protection must extend to runtime operations. Even with robust design and deployment safeguards, machine learning systems remain vulnerable to runtime threats. Attackers may craft inputs that bypass validation, exploit model behavior, or target system-level infrastructure.</p>
<p>Production ML systems face diverse deployment contextsâ€”from cloud services to edge devices to embedded systems. Each environment presents unique monitoring challenges and opportunities, as the system architectures from <strong><a href="../ml_systems/ml_systems.html#sec-ml-systems">Chapter 2: ML Systems</a></strong> demonstrate. Defensive strategies must extend beyond static protection to include real-time monitoring, threat detection, and incident response. This section outlines operational defenses that maintain system trust under adversarial conditions, connecting forward to the comprehensive MLOps practices detailed in <strong><a href="../ops/ops.html#sec-ml-operations">Chapter 13: ML Operations</a></strong>.</p>
<p>Runtime monitoring encompasses a range of techniques for observing system behavior, detecting anomalies, and triggering mitigation. These techniques can be grouped into three categories: input validation, output monitoring, and system integrity checks.</p>
<section id="sec-security-privacy-input-validation-c96f" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-security-privacy-input-validation-c96f">Input Validation</h4>
<p>Input validation is the first line of defense at runtime. It ensures that incoming data conforms to expected formats, statistical properties, or semantic constraints before it is passed to a machine learning model. Without these safeguards, models are vulnerable to adversarial inputs, which are crafted examples designed to trigger incorrect predictions, or to malformed inputs that cause unexpected behavior in preprocessing or inference.</p>
<p>Machine learning models, unlike traditional rule-based systems, often do not fail safely. Small, carefully chosen changes to input data can cause models to make high-confidence but incorrect predictions. Input validation helps detect and reject such inputs early in the pipeline <span class="citation" data-cites="goodfellow2015explaining">(<a href="#ref-goodfellow2015explaining" role="doc-biblioref">Goodfellow, Shlens, and Szegedy 2014</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-goodfellow2015explaining" class="csl-entry" role="listitem">
Goodfellow, Ian J., Jonathon Shlens, and Christian Szegedy. 2014. <span>â€œExplaining and Harnessing Adversarial Examples.â€</span> <em>ICLR</em>, December. <a href="http://arxiv.org/abs/1412.6572v3">http://arxiv.org/abs/1412.6572v3</a>.
</div><div id="fn46"><p><sup>46</sup>&nbsp;<strong>Speech Activity Detector (SAD)</strong>: Algorithm that distinguishes speech from silence, noise, or music in audio streams, essential for voice interfaces since the 1990s. Modern neural SADs achieve 95%+ accuracy and operate in &lt;10ms latency, enabling real-time filtering before expensive speech recognition processing.</p></div></div><p>Validation techniques range from low-level checks (e.g., input size, type, and value ranges) to semantic filters (e.g., verifying whether an image contains a recognizable object or whether a voice recording includes speech). For example, a facial recognition system might validate that the uploaded image is within a certain resolution range (e.g., 224Ã—224 to 1024Ã—1024 pixels), contains RGB channels, and passes a lightweight face detection filter. This prevents inputs like blank images, text screenshots, or synthetic adversarial patterns from reaching the model. Similarly, a voice assistant might require that incoming audio files be between 1 and 5 seconds long, have a valid sampling rate (e.g., 16kHz), and contain detectable human speech using a speech activity detector (SAD)<a href="#fn46" class="footnote-ref" id="fnref46" role="doc-noteref"><sup>46</sup></a>. This ensures that empty recordings, music clips, or noise bursts are filtered before model inference.</p>
<p>In generative systems such as DALLÂ·E, Stable Diffusion, or Sora, input validation often involves prompt filtering. This includes scanning the userâ€™s text prompt for banned terms, brand names, profanity, or misleading medical claims. For example, a user prompt like â€œGenerate an image of a medication bottle labeled with Pfizerâ€™s logoâ€ might be rejected or rewritten due to trademark concerns. Filters may operate using keyword lists, regular expressions, or lightweight classifiers that assess prompt intent. These filters prevent the generative model from being used to produce harmful, illegal, or misleading contentâ€”even before sampling begins.</p>
<p>In some applications, distributional checks are also used. These assess whether the incoming data statistically resembles what the model saw during training. For instance, a computer vision pipeline might compare the color histogram of the input image to a baseline distribution, flagging outliers for manual review or rejection.</p>
<p>These validations can be lightweight (heuristics or threshold rules) or learned (small models trained to detect distribution shift or adversarial artifacts). In either case, input validation serves as a important pre-inference firewallâ€”reducing exposure to adversarial behavior, improving system stability, and increasing trust in downstream model decisions.</p>
</section>
<section id="sec-security-privacy-output-monitoring-cf37" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-security-privacy-output-monitoring-cf37">Output Monitoring</h4>
<p>Even when inputs pass validation, adversarial or unexpected behavior may still emerge at the modelâ€™s output. Output monitoring helps detect such anomalies by analyzing model predictions in real time. These mechanisms observe how the model behaves across inputs, by tracking its confidence, prediction entropy, class distribution, or response patterns, to flag deviations from expected behavior.</p>
<p>A key target for monitoring is prediction confidence. For example, if a classification model begins assigning high confidence to low-frequency or previously rare classes, this may indicate the presence of adversarial inputs or a shift in the underlying data distribution. Monitoring the entropy of the output distribution can similarly reveal when the model is overly certain in ambiguous contextsâ€”an early signal of possible manipulation.</p>
<p>In content moderation systems, a model that normally outputs neutral or â€œsafeâ€ labels may suddenly begin producing high-confidence â€œsafeâ€ labels for inputs containing offensive or restricted content. Output monitoring can detect this mismatch by comparing predictions against auxiliary signals or known-safe reference sets. When deviations are detected, the system may trigger a fallback policyâ€”such as escalating the content for human review or switching to a conservative baseline model.</p>
<p>Time-series models also benefit from output monitoring. For instance, an anomaly detection model used in fraud detection might track predicted fraud scores for sequences of financial transactions. A sudden drop in fraud scores, especially during periods of high transaction volume, may indicate model tampering, label leakage, or evasion attempts. Monitoring the temporal evolution of predictions provides a broader perspective than static, pointwise classification.</p>
<p>Generative models, such as text-to-image systems, introduce unique output monitoring challenges. These models can produce high-fidelity imagery that may inadvertently violate content safety policies, platform guidelines, or user expectations. To mitigate these risks, post-generation classifiers are commonly employed to assess generated content for objectionable characteristics such as violence, nudity, or brand misuse. These classifiers operate downstream of the generative model and can suppress, blur, or reject outputs based on predefined thresholds. Some systems also inspect internal representations (e.g., attention maps<a href="#fn47" class="footnote-ref" id="fnref47" role="doc-noteref"><sup>47</sup></a> or latent embeddings) to anticipate potential misuse before content is rendered.</p>
<div class="no-row-height column-margin column-container"><div id="fn47"><p><sup>47</sup>&nbsp;<strong>Attention Maps</strong>: Visualization technique for understanding transformer model focus, introduced with the attention mechanism in 2015. Attention maps reveal which input tokens influence outputs most strongly, helping detect potential bias or manipulation in models processing 175+ billion parameters like GPT-3.</p></div></div><p>However, prompt filtering alone is insufficient for safety. Research has shown that text-to-image systems can be manipulated through implicitly adversarial prompts, which are queries that appear benign but lead to policy-violating outputs. The Adversarial Nibbler project introduces an open red teaming methodology that identifies such prompts and demonstrates how models like Stable Diffusion can produce unintended content despite the absence of explicit trigger phrases <span class="citation" data-cites="quaye2024adversarial">(<a href="#ref-quaye2024adversarial" role="doc-biblioref">Quaye et al. 2024</a>)</span>. These failure cases often bypass prompt filters because their risk arises from model behavior during generation, not from syntactic or lexical cues.</p>
<div id="fig-adversarial-nibbler" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-adversarial-nibbler-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/png/adversarial_nibbler_example.png" class="lightbox" data-gallery="quarto-lightbox-gallery-14" title="Figure&nbsp;14: Adversarial Prompt Evasion: Implicitly adversarial prompts bypass typical content filters by triggering unintended generations, revealing limitations of solely relying on pre-generation safety checks. these examples underscore the necessity of post-hoc content analysis as a complementary defense layer for robust generative AI systems. Source: [@quaye2024adversarial.]."><img src="images/png/adversarial_nibbler_example.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-adversarial-nibbler-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;14: <strong>Adversarial Prompt Evasion</strong>: Implicitly adversarial prompts bypass typical content filters by triggering unintended generations, revealing limitations of solely relying on pre-generation safety checks. these examples underscore the necessity of post-hoc content analysis as a complementary defense layer for robust generative AI systems. Source: <span class="citation" data-cites="quaye2024adversarial">(<a href="#ref-quaye2024adversarial" role="doc-biblioref">Quaye et al. 2024</a>.)</span>.
</figcaption>
<div class="no-row-height column-margin column-container"><div id="ref-quaye2024adversarial" class="csl-entry" role="listitem">
Quaye, Jessica, Alicia Parrish, Oana Inel, Charvi Rastogi, Hannah Rose Kirk, Minsuk Kahng, Erin Van Liemt, et al. 2024. <span>â€œAdversarial Nibbler: An Open Red-Teaming Method for Identifying Diverse Harms in Text-to-Image Generation.â€</span> In <em>The 2024 ACM Conference on Fairness, Accountability, and Transparency</em>, 388â€“406. ACM. <a href="https://doi.org/10.1145/3630106.3658913">https://doi.org/10.1145/3630106.3658913</a>.
</div></div></figure>
</div>
<p>As shown in <a href="#fig-adversarial-nibbler" class="quarto-xref">Figure&nbsp;14</a>, even prompts that appear innocuous can trigger unsafe generations. Such examples highlight the limitations of pre-generation safety checks and reinforce the necessity of output-based monitoring as a second line of defense. This two-stage pipelineâ€”consisting of prompt filtering followed by post-hoc content analysis important for ensuring the safe deployment of generative models in open-ended or user-facing environments.</p>
<p>In the domain of language generation, output monitoring plays a different but equally important role. Here, the goal is often to detect toxicity, hallucinated claims, or off-distribution responses. For example, a customer support chatbot may be monitored for keyword presence, tonal alignment, or semantic coherence. If a response contains profanity, unsupported assertions, or syntactically malformed text, the system may trigger a rephrasing, initiate a fallback to scripted templates, or halt the response altogether.</p>
<p>Effective output monitoring combines rule-based heuristics with learned detectors trained on historical outputs. These detectors are deployed to flag deviations in real time and feed alerts into incident response pipelines. In contrast to model-centric defenses like adversarial training, which aim to improve model robustness, output monitoring emphasizes containment and remediation. Its role is not to prevent exploitation but to detect its symptoms and initiate appropriate countermeasures <span class="citation" data-cites="savas2022ml">(<a href="#ref-savas2022ml" role="doc-biblioref">Savas et al. 2022</a>)</span>. In safety-important or policy-sensitive applications, such mechanisms form a important layer of operational resilience.</p>
<div class="no-row-height column-margin column-container"><div id="ref-savas2022ml" class="csl-entry" role="listitem">
Savas, Esra, Reza Shokri, Lalith Singaravelu, Nithya Swamy, and Mitali Bafna. 2022. <span>â€œML-ExRay: Visibility and Explainability for Monitoring ML Model Behavior.â€</span> In <em>Proceedings of the 2022 IEEE Symposium on Security and Privacy (SP)</em>, 1352â€“69. IEEE.
</div><div id="ref-lee2023llmguard" class="csl-entry" role="listitem">
Inan, Hakan, Kartikeya Upasani, Jianfeng Chi, Rashi Rungta, Krithika Iyer, Yuning Mao, Michael Tontchev, et al. 2023. <span>â€œLlama Guard: LLM-Based Input-Output Safeguard for Human-AI Conversations,â€</span> December. <a href="http://arxiv.org/abs/2312.06674v1">http://arxiv.org/abs/2312.06674v1</a>.
</div></div><p>These principles have been implemented in recent output filtering frameworks. For example, LLM Guard combines transformer-based classifiers with safety dimensions such as toxicity, misinformation, and illegal content to assess and reject prompts or completions in instruction-tuned LLMs <span class="citation" data-cites="lee2023llmguard">(<a href="#ref-lee2023llmguard" role="doc-biblioref">Inan et al. 2023</a>)</span>. Similarly, <a href="https://ai.google.dev/gemma/docs/shieldgemma">ShieldGemma</a>, developed as part of Googleâ€™s open Gemma model release, applies configurable scoring functions to detect and filter undesired outputs during inference. Both systems exemplify how safety classifiers and output monitors are being integrated into the runtime stack to support scalable, policy-aligned deployment of generative language models.</p>
</section>
<section id="sec-security-privacy-integrity-checks-2989" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-security-privacy-integrity-checks-2989">Integrity Checks</h4>
<p>While input and output monitoring focus on model behavior, system integrity checks ensure that the underlying model files, execution environment, and serving infrastructure remain untampered throughout deployment. These checks detect unauthorized modifications, verify that the model running in production is authentic, and alert operators to suspicious system-level activity.</p>
<p>One of the most common integrity mechanisms is cryptographic model verification. Before a model is loaded into memory, the system can compute a cryptographic hash (e.g., SHA-256)<a href="#fn48" class="footnote-ref" id="fnref48" role="doc-noteref"><sup>48</sup></a> of the model file and compare it against a known-good signature.</p>
<div class="no-row-height column-margin column-container"><div id="fn48"><p><sup>48</sup>&nbsp;<strong>SHA-256</strong>: Cryptographic hash function producing 256-bit digests, part of the SHA-2 family designed by the NSA in 2001. Despite processing trillions of hashes daily across Bitcoin mining and digital signatures, no practical collision attacks exist after 20+ years, making it the gold standard for file integrity verification.</p></div></div><p>Access control and audit logging complement cryptographic checks. ML systems should restrict access to model files using role-based permissions and monitor file access patterns. For instance, repeated attempts to read model checkpoints from a non-standard path, or inference requests from unauthorized IP ranges, may indicate tampering, privilege escalation, or insider threats.</p>
<p>In cloud environments, container- or VM-based isolation<a href="#fn49" class="footnote-ref" id="fnref49" role="doc-noteref"><sup>49</sup></a> helps enforce process and memory boundaries, but these protections can erode over time due to misconfiguration or supply chain vulnerabilities.</p>
<div class="no-row-height column-margin column-container"><div id="fn49"><p><sup>49</sup>&nbsp;<strong>Container/VM Isolation</strong>: Virtualization technologies that provide process and memory separationâ€”containers (Docker, 2013) offer lightweight OS-level isolation with typically 0-5% overhead for CPU-bound workloads and 2-10% for I/O-intensive operations, while VMs provide stronger hardware-level isolation with 10-15% overhead. In ML deployments, containerization is widely adopted for model serving, with industry surveys suggesting 80-90% adoption in cloud environments, though VMs remain preferred for sensitive models requiring stronger isolation guarantees.</p></div><div id="fn50"><p><sup>50</sup>&nbsp;<strong>Healthcare ML Compliance</strong>: FDA has approved 500+ AI-based medical devices since 2016, requiring strict validation under 21 CFR Part 820 quality systems. Healthcare ML systems must demonstrate safety, efficacy, and bias mitigation, with some approvals taking 2-5 years and costing $50+ million in clinical trials.</p></div><div id="fn51"><p><sup>51</sup>&nbsp;<strong>HIPAA ML Requirements</strong>: The Health Insurance Portability and Accountability Act (1996) imposes strict data protection rules affecting 600+ million patient records in the US. For ML systems, HIPAA requires encryption of data at rest and in transit, audit logs for all data access, and business associate agreements for cloud ML services, with violations carrying fines up to $1.5 million per incident.</p></div></div><p>For example, in a regulated healthcare ML deployment<a href="#fn50" class="footnote-ref" id="fnref50" role="doc-noteref"><sup>50</sup></a>, integrity checks might include: verifying the model hash against a signed manifest, validating that the runtime environment uses only approved Python packages, and checking that inference occurs inside a signed and attested virtual machine. These checks ensure compliance with regulations like HIPAA<a href="#fn51" class="footnote-ref" id="fnref51" role="doc-noteref"><sup>51</sup></a>â€™s integrity requirements and GDPRâ€™s accountability principle, limit the risk of silent failures, and create a forensic trail in case of audit or breach.</p>
<p>Some systems also implement runtime memory verification, such as scanning for unexpected model parameter changes or checking that memory-mapped model weights remain unaltered during execution. While more common in high-assurance systems, such checks are becoming more feasible with the adoption of secure enclaves and trusted runtimes.</p>
<p>Taken together, system integrity checks play a important role in protecting machine learning systems from low-level attacks that bypass the model interface. When coupled with input/output monitoring, they provide layered assurance that both the model and its execution environment remain trustworthy under adversarial conditions.</p>
</section>
<section id="sec-security-privacy-response-rollback-1792" class="level4">
<h4 class="anchored" data-anchor-id="sec-security-privacy-response-rollback-1792">Response and Rollback</h4>
<p>When a security breach, anomaly, or performance degradation is detected in a deployed machine learning system, rapid and structured incident response is important to minimizing impact. The goal is not only to contain the issue but to restore system integrity and ensure that future deployments benefit from the insights gained. Unlike traditional software systems, ML responses may require handling model state, data drift, or inference behavior, making recovery more complex.</p>
<p>The first step is to define incident detection thresholds that trigger escalation. These thresholds may come from input validation (e.g., invalid input rates), output monitoring (e.g., drop in prediction confidence), or system integrity checks (e.g., failed model signature verification). When a threshold is crossed, the system should initiate an automated or semi-automated response protocol.</p>
<p>One common strategy is model rollback, where the system reverts to a previously verified version of the model. For instance, if a newly deployed fraud detection model begins misclassifying transactions, the system may fall back to the last known-good checkpoint, restoring service while the affected version is quarantined. Rollback mechanisms require version-controlled model storage, typically supported by MLOps platforms such as MLflow, TFX, or SageMaker.</p>
<p>In high-availability environments, model isolation may be used to contain failures. The affected model instance can be removed from load balancers or shadowed in a canary deployment setup. This allows continued service with unaffected replicas while maintaining forensic access to the compromised model for analysis.</p>
<p>Traffic throttling is another immediate response tool. If an adversarial actor is probing a public inference API at high volume, the system can rate-limit or temporarily block offending IP ranges while continuing to serve trusted clients. This containment technique helps prevent abuse without requiring full system shutdown.</p>
<p>Once immediate containment is in place, investigation and recovery can begin. This may include forensic analysis of input logs, parameter deltas between model versions, or memory snapshots from inference containers. In regulated environments, organizations may also need to notify users or auditors, particularly if personal or safety-important data was affected.</p>
<p>Recovery typically involves retraining or patching the model. This must occur through a secure update process, using signed artifacts, trusted build pipelines, and validated data. To prevent recurrence, the incident should feed back into model evaluation pipelinesâ€”updating tests, refining monitoring thresholds, or hardening input defenses. For example, if a prompt injection attack bypassed a content filter in a generative model, retraining might include adversarially crafted prompts, and the prompt validation logic would be updated to reflect newly discovered patterns.</p>
<p>Finally, organizations should establish post-incident review practices. This includes documenting root causes, identifying gaps in detection or response, and updating policies and playbooks. Incident reviews help translate operational failures into actionable improvements across the design-deploy-monitor lifecycle.</p>
</section>
</section>
<section id="sec-security-privacy-hardware-security-foundations-f5e8" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="sec-security-privacy-hardware-security-foundations-f5e8">Hardware Security Foundations</h3>
<p>The software-layer defenses weâ€™ve exploredâ€”input validation, output monitoring, and integrity checksâ€”establish important protections, but they ultimately depend on the underlying hardware and firmware being trustworthy. If an attacker compromises the operating system, gains physical access to the device, or exploits vulnerabilities in the processor itself, these software defenses can be bypassed or disabled entirely. This limitation motivates hardware-based security mechanisms that operate below the software layer, creating a hardware root of trust that remains secure even when higher-level systems are compromised.</p>
<p>At the foundational level of our defensive framework, hardware-based security mechanisms provide the trust anchor for all higher-layer protections. Machine learning systems deployed in edge devices, embedded systems, and untrusted cloud infrastructure increasingly rely on hardware-based security features to establish this foundation. The hardware acceleration platforms discussed in <strong><a href="../hw_acceleration/hw_acceleration.html#sec-ai-acceleration">Chapter 11: AI Acceleration</a></strong>â€”including GPUs, TPUs, and specialized ML acceleratorsâ€”often incorporate these security features (secure enclaves, trusted execution environments, hardware cryptographic units), while edge deployment scenarios from <strong><a href="../ondevice_learning/ondevice_learning.html#sec-ondevice-learning">Chapter 14: On-Device Learning</a></strong> present unique security challenges.</p>
<p>These hardware security mechanisms become particularly crucial when systems must meet regulatory compliance requirements. Healthcare ML systems handling protected health information under HIPAA must implement â€œappropriate technical safeguardsâ€ including access controls and encryption. Systems processing EU citizensâ€™ data under GDPR must demonstrate â€œappropriate technical and organizational measuresâ€ with privacy by design principles embedded at the hardware level.</p>
<p>To understand how hardware security protects ML systems, imagine building a secure fortress for your most valuable assets. Each hardware security primitive serves a distinct defensive role:</p>
<div id="tbl-hardware-security-mechanisms" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-hardware-security-mechanisms-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;8: <strong>Hardware Security Mechanisms</strong>: Each primitive provides distinct defensive capabilities that work together to create comprehensive protection from hardware-level threats.
</figcaption>
<div aria-describedby="tbl-hardware-security-mechanisms-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 74%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Mechanism</strong></th>
<th style="text-align: left;"><strong>Fortress Analogy and Function</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Secure Boot</strong></td>
<td style="text-align: left;">Functions like a trusted gatekeeper checking credentials of everyone entering the fortress at dawn. Before your system runs any code, Secure Boot cryptographically verifies that the firmware and operating system havenâ€™t been tampered with.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Trusted Execution</strong></td>
<td style="text-align: left;">Create secure, windowless rooms deep inside the fortress where you</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Environments</strong></td>
<td style="text-align: left;">handle your most sensitive operations. When your ML model processes</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>(TEEs)</strong></td>
<td style="text-align: left;">private medical data or proprietary algorithms, the TEE isolates these computations from the rest of the system.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Hardware Security</strong></td>
<td style="text-align: left;">Serve as specialized, impenetrable vaults designed specifically for</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Modules (HSMs)</strong></td>
<td style="text-align: left;">storing and using your most valuable cryptographic keys. Rather than keeping encryption keys in regular computer memory where they might be stolen, HSMs provide tamper-resistant storage.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Physical</strong></td>
<td style="text-align: left;">Give each device a unique biometric fingerprint at the silicon</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Unclonable</strong></td>
<td style="text-align: left;">level. Just as human fingerprints cannot be perfectly replicated,</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Functions (PUFs)</strong></td>
<td style="text-align: left;">PUFs exploit tiny manufacturing variations in each chip to create device-unique identifiers that cannot be cloned.</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>These mechanisms work together to create comprehensive protection that begins in hardware and extends through all software layers.</p>
<p>This section explores how these four complementary hardware primitives work together to create comprehensive protection (<a href="#tbl-hardware-security-mechanisms" class="quarto-xref">Table&nbsp;8</a>). Each mechanism addresses different security challenges but works most effectively when combined: secure boot establishes initial trust, TEEs provide runtime isolation, HSMs handle cryptographic operations, and PUFs enable device-unique authentication. We begin with Trusted Execution Environments (TEEs), which provide isolated runtime environments for sensitive computations. Secure Boot ensures system integrity from power-on, creating the trusted foundation that TEEs depend upon. Hardware Security Modules (HSMs) offer specialized cryptographic processing and tamper-resistant key storage, often required for regulatory compliance. Finally, Physical Unclonable Functions (PUFs) provide device-unique identities that enable lightweight authentication and cannot be cloned or extracted.</p>
<p>Each mechanism addresses different aspects of the security challenge, working most effectively when deployed together across hardware, firmware, and software boundaries.</p>
<section id="sec-security-privacy-hardwaresoftware-codesign-bed2" class="level4">
<h4 class="anchored" data-anchor-id="sec-security-privacy-hardwaresoftware-codesign-bed2">Hardware-Software Co-Design</h4>
<p>Modern ML systems require holistic analysis of security trade-offs across the entire hardware-software stack, similar to how we analyze compute-memory-energy trade-offs in performance optimization. The interdependence between hardware security features and software defenses creates both opportunities and constraints that must be understood quantitatively.</p>
<p>Hardware security mechanisms introduce measurable overhead that must be factored into system design. ARM TrustZone world-switching adds approximately 300-1000 cycles depending on processor generation and cache state (0.6-2.0Î¼s at 500MHz) of latency per transition between secure and non-secure worlds. Cryptographic operations in secure mode typically consume 15-30% additional power compared to normal execution, impacting battery life in mobile ML applications. Intel SGX context switching imposes 15-30Î¼s overhead per inference, representing 2% energy overhead for typical edge ML workloads.</p>
<p>Security features scale differently than computational resources. TEE memory limitations constrain model size regardless of available system memory. A quantized ResNet-18 model (47MB) can operate within ARM TrustZone constraints, while ResNet-50 (176MB) requires careful memory management or model partitioning. These constraints create architectural decisions that must be made early in system design.</p>
<p>Different threat models and protection levels require quantitative trade-off analysis. For ML workloads requiring cryptographic verification, AES-256 operations add 0.1-0.5ms per inference depending on model size and hardware acceleration availability. Homomorphic encryption operations impose 100-100,000x computational overhead, with fully homomorphic encryption (FHE) at the higher end and somewhat homomorphic encryption (SHE) at the lower end, making them viable only for small models or offline scenarios where strong privacy guarantees justify the performance cost.</p>
</section>
<section id="sec-security-privacy-trusted-execution-environments-80ed" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-security-privacy-trusted-execution-environments-80ed">Trusted Execution Environments</h4>
<p>A Trusted Execution Environment (TEE)<a href="#fn52" class="footnote-ref" id="fnref52" role="doc-noteref"><sup>52</sup></a> is a hardware-isolated region within a processor designed to protect sensitive computations and data from potentially compromised software. TEEs enforce confidentiality, integrity, and runtime isolation, ensuring that even if the host operating system or application layer is attacked, sensitive operations within the TEE remain secure.</p>
<div class="no-row-height column-margin column-container"><div id="fn52"><p><sup>52</sup>&nbsp;<strong>TEE Concept Origins</strong>: The idea emerged from ARMâ€™s TrustZone development in the early 2000s, inspired by the military concept of â€œcompartmentalized information.â€ ARM realized that mobile devices needed secure and non-secure â€œworldsâ€ running on the same processorâ€”leading to hardware-enforced isolation that became the template for all modern TEEs.]</p></div></div><p>In the context of machine learning, TEEs are increasingly important for preserving the confidentiality of models, securing sensitive user data during inference, and ensuring that model outputs remain trustworthy. For example, a TEE can protect model parameters from being extracted by malicious software running on the same device, or ensure that computations involving biometric inputs, including facial data or fingerprint data, are performed securely. This capability is essential in applications where model integrity, user privacy, or regulatory compliance are non-negotiable.</p>
<p>One widely deployed example is <a href="https://support.apple.com/guide/security/secure-enclave-sec59b0b31ff/web">Appleâ€™s Secure Enclave</a>, which provides isolated execution and secure key storage for iOS devices. By separating cryptographic operations and biometric data from the main processor, the Secure Enclave ensures that user credentials and Face ID features remain protected, even in the event of a broader system compromise.</p>
<p>Trusted Execution Environments are important across a range of industries with high security requirements. In telecommunications, TEEs are used to safeguard encryption keys and secure important 5G control-plane operations. In finance, they allow secure mobile payments and protect PIN-based authentication workflows. In healthcare, TEEs help enforce patient data confidentiality during edge-based ML inference on wearable or diagnostic devices. In the automotive industry, they are deployed in advanced driver-assistance systems (ADAS) to ensure that safety-important perception and decision-making modules operate on verified software.</p>
<p>In machine learning systems, TEEs can provide several important protections. They secure the execution of model inference or training, shielding intermediate computations and final predictions from system-level observation. They protect the confidentiality of sensitive inputs, including biometric or clinical signals, used in personal identification or risk scoring tasks. TEEs also serve to prevent reverse engineering of deployed models by restricting access to weights and architecture internals. When models are updated, TEEs ensure the authenticity of new parameters and block unauthorized tampering. In distributed ML settings, TEEs can protect data exchanged between components by enabling encrypted and attested communication channels.</p>
<p>The core security properties of a TEE are achieved through four mechanisms: isolated execution, secure storage, integrity protection, and in-TEE data encryption. Code that runs inside the TEE is executed in a separate processor mode, inaccessible to the normal-world operating system. Sensitive assets such as cryptographic keys or authentication tokens are stored in memory that only the TEE can access. Code and data can be verified for integrity before execution using hardware-anchored hashes or signatures. Finally, data processed inside the TEE can be encrypted, ensuring that even intermediate results are inaccessible without appropriate keys, which are also managed internally by the TEE.</p>
<p>Several commercial platforms provide TEE functionality tailored for different deployment contexts. <a href="https://www.arm.com/technologies/trustzone-for-cortex-m">ARM TrustZone</a><a href="#fn53" class="footnote-ref" id="fnref53" role="doc-noteref"><sup>53</sup></a> offers secure and normal world execution on ARM-based systems and is widely used in mobile and IoT applications. <a href="https://www.intel.com/content/www/us/en/architecture-and-technology/software-guard-extensions.html">Intel SGX</a><a href="#fn54" class="footnote-ref" id="fnref54" role="doc-noteref"><sup>54</sup></a> implements enclave-based security for cloud and desktop systems, enabling secure computation even on untrusted infrastructure. <a href="https://www.qualcomm.com/products/features/mobile-security-solutions">Qualcommâ€™s Secure Execution Environment</a> supports secure mobile transactions and user authentication. Appleâ€™s Secure Enclave remains a canonical example of a hardware-isolated security coprocessor for consumer devices.</p>
<div class="no-row-height column-margin column-container"><div id="fn53"><p><sup>53</sup>&nbsp;<strong>ARM TrustZone</strong>: Introduced in 2004, TrustZone now ships in 95% of ARM processors, protecting over 5 billion mobile devices. Despite its ubiquity, many devices underutilize TrustZoneâ€”studies show only 20-30% of Android devices implement meaningful secure world applications beyond basic key storage.</p></div><div id="fn54"><p><sup>54</sup>&nbsp;<strong>Intel SGX Constraints</strong>: SGX enclaves are limited to approximately 128MB of protected memory (EPC) on most consumer processors, though enterprise variants support up to 512MB or 1GB, with cache misses causing 100x performance penalties. For ML workloads, a ResNet-50 requires approximately 98MB for weights alone in FP32 format (25.6M parameters Ã— 4 bytes), consuming 77% of SGX EPC before any intermediate activations. Inference latency increases from 5ms to 150ms when model exceeds EPC capacity. This makes SGX unsuitable for large ML models but effective for protecting cryptographic keys and small inference models under 10MB.</p></div></div><p><a href="#fig-enclave" class="quarto-xref">Figure&nbsp;15</a> illustrates a secure enclave integrated into a system-on-chip (SoC) architecture. The enclave includes a dedicated processor, an AES engine, a true random number generator (TRNG), a public key accelerator (PKA), and a secure IÂ²C interface to nonvolatile storage. These components operate in isolation from the main application processor and memory subsystem. A memory protection engine enforces access control, while cryptographic operations such as NAND flash encryption are handled internally using enclave-managed keys. By physically separating secure execution and key management from the main system, this architecture limits the impact of system-level compromises and establishes hardware-enforced trust.</p>
<div id="fig-enclave" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-enclave-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="0ec21c51afc7fe0b2dd5b4b9844597873005fc86.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-15" title="Figure&nbsp;15: Secure Enclave Architecture: Hardware-isolated enclaves enhance system security by encapsulating sensitive data and cryptographic operations within a dedicated processor and memory. This design minimizes the attack surface and protects important keys even if the main application processor is compromised, providing a trusted execution environment for security-important tasks. Source: Apple."><img src="privacy_security_files/mediabag/0ec21c51afc7fe0b2dd5b4b9844597873005fc86.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-enclave-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;15: <strong>Secure Enclave Architecture</strong>: Hardware-isolated enclaves enhance system security by encapsulating sensitive data and cryptographic operations within a dedicated processor and memory. This design minimizes the attack surface and protects important keys even if the main application processor is compromised, providing a trusted execution environment for security-important tasks. Source: Apple.
</figcaption>
</figure>
</div>
<p>This architecture underpins the secure deployment of machine learning applications on consumer devices. For example, Appleâ€™s Face ID system uses a secure enclave to perform facial recognition entirely within a hardware-isolated environment. The face embedding model is executed inside the enclave, and biometric templates are stored in secure nonvolatile memory accessible only via the enclaveâ€™s IÂ²C interface. During authentication, input data from the infrared camera is processed locally, and no facial features or predictions ever leave the secure region. Even if the application processor or operating system is compromised, the enclave prevents access to sensitive model inputs, parameters, and outputsâ€”ensuring that biometric identity remains protected end to end.</p>
<p>Despite their strengths, Trusted Execution Environments come with notable trade-offs. Implementing a TEE increases both direct hardware costs and indirect costs associated with developing and maintaining secure software. Integrating TEEs into existing systems may require architectural redesigns, especially for legacy infrastructure. Developers must adhere to strict protocols for isolation, attestation, and secure update management, which can extend development cycles and complicate testing workflows. TEEs can also introduce performance overhead, particularly when cryptographic operations are involved, or when context switching between trusted and untrusted modes is frequent.</p>
<p>Energy efficiency is another consideration, particularly in battery-constrained devices. TEEs typically consume additional power due to secure memory accesses, cryptographic computation, and hardware protection logic. In resource-limited embedded systems, these costs may limit their use. In terms of scalability and flexibility, the secure boundaries enforced by TEEs may complicate distributed training or federated inference workloads, where secure coordination between enclaves is required.</p>
<p>Market demand also varies. In some consumer applications, perceived threat levels may be too low to justify the integration of TEEs. Systems with TEEs may be subject to formal security certifications, such as <a href="https://www.commoncriteriaportal.org/ccra/index.cfm">Common Criteria</a> or evaluation under <a href="https://www.enisa.europa.eu/">ENISA</a>, which can introduce additional time and expense. For this reason, TEEs are typically adopted only when the expected threat model, including adversarial users, cloud tenants, and malicious insiders, justifies the investment.</p>
<p>Nonetheless, TEEs remain a powerful hardware primitive in the machine learning security landscape. When paired with software- and system-level defenses, they provide a trusted foundation for executing ML models securely, privately, and verifiably, especially in scenarios where adversarial compromise of the host environment is a serious concern.</p>
<p>Here is the revised 7.5.2 Secure Boot section, rewritten in formal textbook tone with all original technical content, hyperlinks, and figures preserved. The structure emphasizes narrative clarity, avoids bullet lists, and integrates the Apple Face ID case study naturally.</p>
</section>
<section id="sec-security-privacy-secure-boot-5242" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-security-privacy-secure-boot-5242">Secure Boot</h4>
<p>Secure Boot is a mechanism that ensures a device only boots software components that are cryptographically verified and explicitly authorized by the manufacturer. At startup, each stage of the boot process, comprising the bootloader, kernel, and base operating system, is checked against a known-good digital signature. If any signature fails verification, the boot sequence is halted, preventing unauthorized or malicious code from executing. This chain-of-trust model establishes system integrity from the very first instruction executed.</p>
<p>In ML systems, especially those deployed on embedded or edge hardware, Secure Boot plays an important role. A compromised boot process may result in malicious software loading before the ML runtime begins, enabling attackers to intercept model weights, tamper with training data, or reroute inference results. Such breaches can lead to incorrect or manipulated predictions, unauthorized data access, or device repurposing for botnets or crypto-mining.</p>
<p>For machine learning systems, Secure Boot offers several guarantees. First, it protects model-related data, such as training data, inference inputs, and outputs, during the boot sequence, preventing pre-runtime tampering. Second, it ensures that only authenticated model binaries and supporting software are loaded, which helps guard against deployment-time model substitution. Third, Secure Boot allows secure model updates by verifying that firmware or model changes are signed and have not been altered in transit.</p>
<p>Secure Boot frequently works in tandem with hardware-based Trusted Execution Environments (TEEs) to create a fully trusted execution stack. As shown in <a href="#fig-secure-boot" class="quarto-xref">Figure&nbsp;16</a>, this layered boot process verifies firmware, operating system components, and TEE integrity before permitting execution of cryptographic operations or ML workloads. In embedded systems, this architecture provides resilience even under severe adversarial conditions or physical device compromise.</p>
<div id="fig-secure-boot" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-secure-boot-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="8e31bdfff4fde62680d6a77a435ff58c2eaa5031.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-16" title="Figure&nbsp;16: Secure Boot Sequence: Embedded systems employ a layered boot process to verify firmware and software integrity, establishing a root of trust before executing machine learning workloads and protecting against pre-runtime attacks. This architecture ensures only authenticated code runs, safeguarding model data and preventing unauthorized model substitution or modification during deployment. Source: [@rashmi2018secure]."><img src="privacy_security_files/mediabag/8e31bdfff4fde62680d6a77a435ff58c2eaa5031.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-secure-boot-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;16: <strong>Secure Boot Sequence</strong>: Embedded systems employ a layered boot process to verify firmware and software integrity, establishing a root of trust before executing machine learning workloads and protecting against pre-runtime attacks. This architecture ensures only authenticated code runs, safeguarding model data and preventing unauthorized model substitution or modification during deployment. Source: <span class="citation" data-cites="rashmi2018secure">(<a href="#ref-rashmi2018secure" role="doc-biblioref">R. V. and A. 2018</a>)</span>.
</figcaption>
<div class="no-row-height column-margin column-container"><div id="ref-rashmi2018secure" class="csl-entry" role="listitem">
R. V., Rashmi, and Karthikeyan A. 2018. <span>â€œSecure Boot of Embedded Applications - a Review.â€</span> In <em>2018 Second International Conference on Electronics, Communication and Aerospace Technology (ICECA)</em>, 291â€“98. IEEE. <a href="https://doi.org/10.1109/iceca.2018.8474730">https://doi.org/10.1109/iceca.2018.8474730</a>.
</div></div></figure>
</div>
<p>A well-known real-world implementation of Secure Boot appears in Appleâ€™s Face ID system, which uses advanced machine learning for facial recognition. For Face ID to operate securely, the entire device stack, from the initial power-on to the execution of the model, must be verifiably trusted.</p>
<p>Upon device startup, Secure Boot initiates within Appleâ€™s <a href="https://support.apple.com/en-us/102381">Secure Enclave</a>, a dedicated security coprocessor that handles biometric data. The firmware loaded onto the Secure Enclave is digitally signed by Apple, and any unauthorized modification causes the boot process to fail. Once verified, the Secure Enclave performs continuous checks in coordination with the central processor to maintain a trusted boot chain. Each system component, ranging from the iOS kernel to the application-level code, is verified using cryptographic signatures.</p>
<p>After completing the secure boot sequence, the Secure Enclave activates the ML-based Face ID system. The facial recognition model projects over 30,000 infrared points to map a userâ€™s face, generating a depth image and computing a mathematical representation that is compared against a securely stored profile. These facial data artifacts are never written to disk, transmitted off-device, or shared externally. All processing occurs within the enclave to protect against eavesdropping or exfiltration, even in the presence of a compromised kernel.</p>
<p>To support continued integrity, Secure Boot also governs software updates. Only firmware or model updates signed by Apple are accepted, ensuring that even over-the-air patches do not introduce risk. This process maintains a robust chain of trust over time, enabling the secure evolution of the ML system while preserving user privacy and device security.</p>
<p>While Secure Boot provides strong protection, its adoption presents technical and operational challenges. Managing the cryptographic keys used to sign and verify system components is complex, especially at scale. Enterprises must securely provision, rotate, and revoke keys, ensuring that no trusted root is compromised. Any such breach would undermine the entire security chain.</p>
<p>Performance is also a consideration. Verifying signatures during the boot process introduces latency, typically on the order of tens to hundreds of milliseconds per component. Although acceptable in many applications, these delays may be problematic for real-time or power-constrained systems. Developers must also ensure that all components, including bootloaders, firmware, kernels, drivers, and even ML models, are correctly signed. Integrating third-party software into a Secure Boot pipeline introduces additional complexity.</p>
<p>Some systems limit user control in favor of vendor-locked security models, restricting upgradability or customization. In response, open-source bootloaders like <a href="https://source.denx.de/u-boot/u-boot">u-boot</a> and <a href="https://www.coreboot.org/">coreboot</a> have emerged, offering Secure Boot features while supporting extensibility and transparency. To further scale trusted device deployments, emerging industry standards such as the <a href="https://www.microsoft.com/en-us/research/project/dice-device-identifier-composition-engine/">Device Identifier Composition Engine (DICE)</a> and <a href="https://1.ieee802.org/security/802-1ar/">IEEE 802.1AR IDevID</a> provide mechanisms for secure device identity, key provisioning, and cross-vendor trust assurance.</p>
<p>Secure Boot, when implemented carefully and complemented by trusted hardware and secure software update processes, forms the backbone of system integrity for embedded and distributed ML. It provides the assurance that the machine learning model running in production is not only the correct version, but is also executing in a known-good environment, anchored to hardware-level trust.</p>
</section>
<section id="sec-security-privacy-hardware-security-modules-4377" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-security-privacy-hardware-security-modules-4377">Hardware Security Modules</h4>
<p>While TEEs and secure boot provide runtime isolation and integrity verification, Hardware Security Modules (HSMs) specialize in the cryptographic operations that underpin these protections. An HSM<a href="#fn55" class="footnote-ref" id="fnref55" role="doc-noteref"><sup>55</sup></a> is a tamper-resistant physical device designed to perform cryptographic operations and securely manage digital keys. HSMs are widely used across security-important industries such as finance, defense, and cloud infrastructure, and they are increasingly relevant for securing the machine learning pipelineâ€”particularly in deployments where key confidentiality, model integrity, and regulatory compliance are important.</p>
<div class="no-row-height column-margin column-container"><div id="fn55"><p><sup>55</sup>&nbsp;<strong>HSM Performance</strong>: Enterprise HSMs can perform 10,000+ RSA-2048 operations per second but cost $20,000-$100,000+ per unit. In contrast, software-only cryptography on GPUs achieves 100,000+ operations/second at $1,000+ hardware cost, but without the tamper-resistance and regulatory compliance that HSMs provide.</p></div></div><p>HSMs provide an isolated, hardened environment for performing sensitive operations such as key generation, digital signing, encryption, and decryption. Unlike general-purpose processors, they are engineered to withstand physical tampering and side-channel attacks, and they typically include protected storage, cryptographic accelerators, and internal audit logging. HSMs may be implemented as standalone appliances, plug-in modules, or integrated chips embedded within broader systems.</p>
<p>In machine learning systems, HSMs enhance security across several dimensions. They are commonly used to protect encryption keys associated with sensitive data that may be processed during training or inference. These keys might encrypt data at rest in model checkpoints or allow secure transmission of inference requests across networked environments. By ensuring that the keys are generated, stored, and used exclusively within the HSM, the system minimizes the risk of key leakage, unauthorized reuse, or tampering.</p>
<p>HSMs also play a role in maintaining the integrity of machine learning models. In many production pipelines, models must be signed before deployment to ensure that only verified versions are accepted into runtime environments. The signing keys used to authenticate models can be stored and managed within the HSM, providing cryptographic assurance that the deployed artifact is authentic and untampered. Similarly, secure firmware updates and configuration changes, regardless of whether they pertain to models, hyperparameters, or supporting infrastructure, can be validated using signatures produced by the HSM.</p>
<p>In addition to protecting inference workloads, HSMs can be used to secure model training. During training, data may originate from distributed and potentially untrusted sources. HSM-backed protocols can help ensure that training pipelines perform encryption, integrity checks, and access control enforcement securely and in compliance with organizational or legal requirements. In regulated industries such as healthcare and finance, such protections are often mandatory. For instance, HIPAA requires covered entities to implement technical safeguards including â€œintegrity controlsâ€ and â€œencryption and decryption,â€ while GDPR mandates pseudonymization and encryption as examples of appropriate technical measures.</p>
<p>Despite these benefits, incorporating HSMs into embedded or resource-constrained ML systems introduces several trade-offs. First, HSMs are specialized hardware components and often come at a premium. Their cost may be justified in data center settings or safety-important applications but can be prohibitive for low-margin embedded products or wearables. Physical space is also a concern. Embedded systems often operate under strict size, weight, and form factor constraints, and integrating an HSM may require redesigning circuit layouts or sacrificing other functionality.</p>
<p>From a performance standpoint, HSMs introduce latency, particularly for operations like key exchange, signature verification, or on-the-fly decryption. In real-time inference systems, including autonomous vehicles, industrial robotics, and live translation devices, these delays can affect responsiveness. While HSMs are typically optimized for cryptographic throughput, they are not general-purpose processors, and offloading secure operations must be carefully coordinated.</p>
<p>Power consumption is another concern. The continuous secure handling of keys, signing of transactions, and cryptographic validations can consume more power than basic embedded components, impacting battery life in mobile or remote deployments.</p>
<p>Integration complexity also grows when HSMs are introduced into existing ML pipelines. Interfacing between the HSM and the host processor requires dedicated APIs and often specialized software development. Firmware and model updates must be routed through secure, signed channels, and update orchestration must account for device-specific key provisioning. These requirements increase the operational burden, especially in large deployments.</p>
<p>Scalability presents its own set of challenges. Managing a distributed fleet of HSM-equipped devices requires secure provisioning of individual keys, secure identity binding, and coordinated trust management. In large ML deployments, including fleets of smart sensors or edge inference nodes, ensuring uniform security posture across all devices is nontrivial.</p>
<p>Finally, the use of HSMs often requires organizations to engage in certification and compliance processes<a href="#fn56" class="footnote-ref" id="fnref56" role="doc-noteref"><sup>56</sup></a>, particularly when handling regulated data. Meeting standards such as FIPS 140-2<a href="#fn57" class="footnote-ref" id="fnref57" role="doc-noteref"><sup>57</sup></a> or Common Criteria adds time and cost to development.</p>
<div class="no-row-height column-margin column-container"><div id="fn56"><p><sup>56</sup>&nbsp;<strong>HSM Certification</strong>: Hardware Security Module certification under FIPS 140-2 or Common Criteria can take 12-24 months and cost $500,000-$2 million. However, many regulated industries require these certifications, with banking, government, and healthcare sectors mandating Level 3+ certified HSMs for cryptographic operations.</p></div><div id="fn57"><p><sup>57</sup>&nbsp;<strong>FIPS 140-2 Standard</strong>: Federal Information Processing Standard for cryptographic modules, established in 2001 with four security levels. Level 4 HSMs must survive physical attacks, operating at -40Â°C to +85Â°C with tamper detection that zeroizes keys within seconds, making them suitable for the most sensitive ML applications. Access to the HSM is typically restricted to a small set of authorized personnel, which can complicate development workflows and slow iteration cycles.</p></div></div><p>Despite these operational complexities, HSMs remain a valuable option for machine learning systems that require high assurance of cryptographic integrity and access control. When paired with TEEs, secure boot, and software-based defenses, HSMs contribute to a multilayered security model that spans hardware, system software, and ML runtime.</p>
</section>
<section id="sec-security-privacy-physical-unclonable-functions-6533" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="sec-security-privacy-physical-unclonable-functions-6533">Physical Unclonable Functions</h4>
<p>Physical Unclonable Functions (PUFs)<a href="#fn58" class="footnote-ref" id="fnref58" role="doc-noteref"><sup>58</sup></a> provide a hardware-intrinsic mechanism for cryptographic key generation and device authentication by leveraging physical randomness in semiconductor fabrication <span class="citation" data-cites="gassend2002silicon">(<a href="#ref-gassend2002silicon" role="doc-biblioref">Gassend et al. 2002</a>)</span>. Unlike traditional keys stored in memory, a PUF generates secret values based on microscopic variations in a chipâ€™s physical propertiesâ€”variations that are inherent to manufacturing processes and difficult to clone or predict, even by the manufacturer.</p>
<div class="no-row-height column-margin column-container"><div id="fn58"><p><sup>58</sup>&nbsp;<strong>PUF Market Growth</strong>: The PUF market is projected to reach $320 million by 2025, driven by IoT security needs. Major semiconductor companies including Intel, Xilinx, and Synopsis now offer PUF IP, with deployment in smart cards, automotive ECUs, and edge ML devices requiring device-unique authentication.</p></div><div id="ref-gassend2002silicon" class="csl-entry" role="listitem">
Gassend, Blaise, Dwaine Clarke, Marten van Dijk, and Srinivas Devadas. 2002. <span>â€œSilicon Physical Random Functions.â€</span> In <em>Proceedings of the 9th ACM Conference on Computer and Communications Security - CCS â€™02</em>, 148â€“60. ACM; ACM Press. <a href="https://doi.org/10.1145/586131.586132">https://doi.org/10.1145/586131.586132</a>.
</div></div><p>These variations arise from uncontrollable physical factors such as doping concentration, line edge roughness, and dielectric thickness. As a result, even chips fabricated with the same design masks exhibit small but measurable differences in timing, power consumption, or voltage behavior. PUF circuits amplify these variations to produce a device-unique digital output. When a specific input challenge is applied to a PUF, it generates a corresponding response based on the chipâ€™s physical fingerprint. Because these characteristics are effectively impossible to replicate, the same challenge will yield different responses across devices.</p>
<p>This challenge-response mechanism allows PUFs to serve several cryptographic purposes. They can be used to derive device-specific keys that never need to be stored externally, reducing the attack surface for key exfiltration. The same mechanism also supports secure authentication and attestation, where devices must prove their identity to trusted servers or hardware gateways. These properties make PUFs a natural fit for machine learning systems deployed in embedded and distributed environments.</p>
<p>In ML applications, PUFs offer unique advantages for securing resource-constrained systems. For example, consider a smart camera drone that uses onboard computer vision to track objects. A PUF embedded in the droneâ€™s processor can generate a private key to encrypt the model during boot. Even if the model were extracted, it would be unusable on another device lacking the same PUF response. That same PUF-derived key could also be used to watermark the model parameters, creating a cryptographically verifiable link between a deployed model and its origin hardware. If the model were leaked or pirated, the embedded watermark could help prove the source of the compromise.</p>
<p>PUFs also support authentication in distributed ML pipelines. If the drone offloads computation to a cloud server, the PUF can help verify that the drone has not been cloned or tampered with. The cloud backend can issue a challenge, verify the correct response from the device, and permit access only if the PUF proves device authenticity. These protections enhance trust not only in the model and data, but in the execution environment itself.</p>
<p>The internal operation of a PUF is illustrated in <a href="#fig-pfu" class="quarto-xref">Figure&nbsp;17</a>. At a high level, a PUF accepts a challenge input and produces a unique response determined by the physical microstructure of the chip <span class="citation" data-cites="gao2020physical">(<a href="#ref-gao2020physical" role="doc-biblioref">Gao, Al-Sarawi, and Abbott 2020</a>)</span>. Variants include optical PUFs, in which the challenge consists of a light pattern and the response is a speckle image, and electronic PUFs such as Arbiter PUFs (APUFs), where timing differences between circuit paths produce a binary output. Another common implementation is the SRAM PUF, which exploits the power-up state of uninitialized SRAM cells: due to threshold voltage mismatch, each cell tends to settle into a preferred value when power is first applied. These response patterns form a stable, reproducible hardware fingerprint.</p>
<div class="no-row-height column-margin column-container"></div><div id="fig-pfu" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-pfu-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/png/puf_basics.png" class="lightbox" data-gallery="quarto-lightbox-gallery-17" title="Figure&nbsp;17: Physical Unclonable Functions: Pufs generate unique hardware fingerprints from inherent manufacturing variations, enabling device authentication and secure key generation without storing secrets. Optical and electronic PUF implementations use physical phenomenaâ€”such as light speckle patterns or timing differencesâ€”to produce challenge-response pairs that are difficult to predict or replicate. Source: [@gao2020physical]."><img src="images/png/puf_basics.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pfu-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;17: <strong>Physical Unclonable Functions</strong>: Pufs generate unique hardware fingerprints from inherent manufacturing variations, enabling device authentication and secure key generation without storing secrets. Optical and electronic PUF implementations use physical phenomenaâ€”such as light speckle patterns or timing differencesâ€”to produce challenge-response pairs that are difficult to predict or replicate. Source: <span class="citation" data-cites="gao2020physical">(<a href="#ref-gao2020physical" role="doc-biblioref">Gao, Al-Sarawi, and Abbott 2020</a>)</span>.
</figcaption>
<div class="no-row-height column-margin column-container"><div id="ref-gao2020physical" class="csl-entry" role="listitem">
Gao, Yansong, Said F. Al-Sarawi, and Derek Abbott. 2020. <span>â€œPhysical Unclonable Functions.â€</span> <em>Nature Electronics</em> 3 (2): 81â€“91. <a href="https://doi.org/10.1038/s41928-020-0372-5">https://doi.org/10.1038/s41928-020-0372-5</a>.
</div></div></figure>
</div>
<p>Despite their promise, PUFs present several challenges in system design. Their outputs can be sensitive to environmental variation, such as changes in temperature or voltage, which can introduce instability or bit errors in the response. To ensure reliability, PUF systems must often incorporate error correction codes or helper data schemes. Managing large sets of challenge-response pairs also raises questions about storage, consistency, and revocation. Additionally, the unique statistical structure of PUF outputs may make them vulnerable to machine learning-based modeling attacks if not carefully shielded from external observation.</p>
<p>From a manufacturing perspective, incorporating PUF technology can increase device cost or require additional layout complexity. While PUFs eliminate the need for external key storage, thereby reducing long-term security risk and provisioning cost, they may require calibration and testing during fabrication to ensure consistent performance across environmental conditions and device aging.</p>
<p>Nevertheless, Physical Unclonable Functions remain a compelling building block for securing embedded machine learning systems. By embedding hardware identity directly into the chip, PUFs support lightweight cryptographic operations, reduce key management burden, and help establish root-of-trust anchors in distributed or resource-constrained environments. When integrated thoughtfully, they complement other hardware-assisted security mechanisms such as Secure Boot, TEEs, and HSMs to provide defense-in-depth across the ML system lifecycle.</p>
</section>
<section id="sec-security-privacy-mechanisms-comparison-2dcb" class="level4">
<h4 class="anchored" data-anchor-id="sec-security-privacy-mechanisms-comparison-2dcb">Mechanisms Comparison</h4>
<p>Hardware-assisted security mechanisms play a foundational role in establishing trust within modern machine learning systems. While software-based defenses offer flexibility, they ultimately rely on the security of the hardware platform. As machine learning workloads increasingly operate on edge devices, embedded platforms, and untrusted infrastructure, hardware-backed protections become important for maintaining system integrity, confidentiality, and trust.</p>
<p>Trusted Execution Environments (TEEs) provide runtime isolation for model inference and sensitive data handling. Secure Boot enforces integrity from power-on, ensuring that only verified software is executed. Hardware Security Modules (HSMs) offer tamper-resistant storage and cryptographic processing for secure key management, model signing, and firmware validation. Physical Unclonable Functions (PUFs) bind secrets and authentication to the physical characteristics of a specific device, enabling lightweight and unclonable identities.</p>
<p>These mechanisms address different layers of the system stack, ranging from initialization and attestation to runtime protection and identity binding, and complement one another when deployed together. <a href="#tbl-hw-security-comparison" class="quarto-xref">Table&nbsp;9</a> below compares their roles, use cases, and trade-offs in machine learning system design.</p>
<div id="tbl-hw-security-comparison" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-hw-security-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;9: <strong>Hardware Security Mechanisms</strong>: Machine learning systems use diverse hardware defensesâ€”trusted execution environments, secure boot, hardware security modules, and physical unclonable functionsâ€”to establish trust and protect sensitive data across the system stack. The table details how each mechanism addresses specific security challengesâ€”from runtime isolation and integrity verification to key management and device identityâ€”and emphasizes the associated trade-offs in performance and complexity.
</figcaption>
<div aria-describedby="tbl-hw-security-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 26%">
<col style="width: 30%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Mechanism</strong></th>
<th style="text-align: left;"><strong>Primary Function</strong></th>
<th style="text-align: left;"><strong>Common Use in ML</strong></th>
<th style="text-align: left;"><strong>Trade-offs</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><strong>Trusted Execution</strong></p>
<p><strong>Environment (TEE)</strong></p></td>
<td style="text-align: left;">Isolated runtime environment for secure computation</td>
<td style="text-align: left;">Secure inference and on-device privacy for sensitive inputs and outputs</td>
<td style="text-align: left;"><p>Added complexity, memory limits, perf. cost</p>
<p>Requires trusted code development</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Secure Boot</strong></td>
<td style="text-align: left;">Verified boot sequence and firmware validation</td>
<td style="text-align: left;">Ensures only signed ML models and firmware execute on embedded devices</td>
<td style="text-align: left;">Key management complexity, vendor lock-in Performance impact during startup</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Hardware Security Module</strong> <strong>(HSM)</strong></td>
<td style="text-align: left;">Secure key generation and storage, crypto-processing</td>
<td style="text-align: left;">Signing ML models, securing training pipelines, verifying firmware</td>
<td style="text-align: left;"><p>High cost, integration overhead, limited I/O</p>
<p>Requires infrastructure-level provisioning</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><strong>Physical Unclonable</strong></p>
<p><strong>Function (PUF)</strong></p></td>
<td style="text-align: left;">Hardware-bound identity and key derivation</td>
<td style="text-align: left;">Model binding, device authentication, protecting IP in embedded deployments</td>
<td style="text-align: left;"><p>Environmental sensitivity, modeling attacks</p>
<p>Needs error correction and calibration</p></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Together, these hardware primitives form the foundation of a defense-in-depth strategy for securing ML systems in adversarial environments. Their integration is especially important in domains that demand provable trust, such as autonomous vehicles, healthcare devices, federated learning systems, and important infrastructure.</p>
<!-- ### Toward Trustworthy Systems {#sec-security-privacy-toward-trustworthy-systems-1e6d}

Defending machine learning systems against adversarial threats, misuse, and system compromise requires more than isolated countermeasures. As this section has shown, effective defense emerges from the careful integration of mechanisms at multiple layers of the ML stackâ€”from privacy-preserving data handling and robust model design to runtime monitoring and hardware-enforced isolation. No single component can provide complete protection; instead, a trustworthy system is the result of coordinated design decisions that address risk across the data, model, system, and infrastructure layers.

Defensive strategies must align with the deployment context and threat model. What is appropriate for a public cloud API may differ from the requirements of an embedded medical device or a fleet of edge-deployed sensors. Design choices must balance security, performance, and usability, recognizing that protections often introduce operational trade-offs. Monitoring and incident response mechanisms ensure resilience during live operation, while hardware-based roots of trust ensure system integrity even when higher layers are compromised.

As machine learning continues to expand into safety-important, privacy-sensitive, and decentralized environments, the need for robust, end-to-end defense becomes increasingly urgent. Building ML systems that are not only accurate, but secure, private, and auditable, is core to long-term deployment success and public trust.

The technical defenses we've established here form the foundation for the broader robustness framework explored in @sec-robust-ai. While this chapter has focused on protecting against malicious attacks and privacy breaches, @sec-robust-ai extends these concepts to ensure system-wide reliability under all forms of stressâ€”from natural distribution shifts to hardware failures. The adversarial training techniques introduced here for security become part of a comprehensive robustness strategy that includes uncertainty quantification, out-of-distribution detection, and graceful degradation. Similarly, the monitoring infrastructure we've established for security incident detection provides the foundation for the broader observability systems required for robust AI deployment.

These security and privacy foundations also connect directly to the operational practices detailed in @sec-ml-operations, which provides the frameworks for implementing these protections at scale. The energy and computational overhead of security measures must be considered within the sustainability frameworks explored in @sec-sustainable-ai, and the broader ethical implications connect to the responsible AI practices covered in @sec-responsible-ai.

The process of engineering trustworthy ML systems requires a structured approach that applies the layered defense principles established earlier to specific deployment contexts. @fig-trustworthy-ml-recipe provides a practical framework to guide this process across technical and deployment dimensions. The design flow begins with a thorough assessment of the threat model and deployment context, which informs the selection of appropriate defenses from our established stack. This includes data-layer protections such as differential privacy (DP), federated learning (FL), and encryption; model-layer defenses like robustness techniques, watermarking, and secure deployment practices; runtime-layer measures such as input validation and output monitoring; and hardware-layer solutions including TEEs, secure boot, and PUFs.

::: {#fig-trustworthy-ml-recipe fig-env="figure" fig-pos="htb"}
```{.tikz}
\begin{tikzpicture}[line join=round,font=\usefont{T1}{phv}{m}{n}]
\tikzset{%
Line/.style={BrownLine!60, -{Triangle[width = 6pt, length = 6pt]}, line width = 1.25pt},
Box/.style={inner xsep=2pt,inner ysep=6pt,
    node distance=0.5,
    draw=RedLine,
    line width=0.75pt,
    fill=RedL!60,
    align=flush center,
    text width=37mm,
    minimum width=37mm, minimum height=15.5mm
  },
Box2/.style={Box,draw=GreenD,fill=GreenL},
Box3/.style={Box,  draw=VioletLine,fill=VioletL2},
Box4/.style={Box,draw=VioletLine,fill=VioletL2},
Box5/.style={Box,draw=BlueLine,fill=BlueL!50},
Box6/.style={Box,draw=OrangeLine,fill=OrangeL!50},
}
\node[Box](B1){Data Layer: DP, FL, Encryption};
\node[Box,right=of B1,  text width=44mm,minimum width=44mm](B2){Model Layer: Robustness, Watermarking, Secure Deployment};
\node[Box,right=of B2](B3){Runtime Layer: Input Validation, Output Monitoring};
\node[Box,right=of B3](B4){Hardware Layer: TEEs, Secure Boot, PUFs};
 %
\node[Box2,above=0.7 of B2,minimum width=44mm](B22){Select Defenses Across the Stack};
\node[Box3,above=0.7 of B22,minimum width=44mm](B23){Assess Threat Model \& Deployment Context};
%
\node[Box6,below=0.7 of B4, text width=40mm,minimum width=44mm](B44){Plan for Runtime Adaptation and Recovery};
\node[Box5,below=0.7  of B44](B45){Rollback, Isolation, Incident Response};
\node[Box5,left=of B45](B46){Monitoring, Logging, Alerting};
\node[Box5,right=of B45](B47){Design Feedback\\ Loop};
\draw[Line](B23)--(B22);
\draw[Line](B22)--(B2);
\draw[Line](B22)-|(B1);
\draw[Line](B22)-|(B3);
\draw[Line](B22)-|(B4);
\draw[Line](B4)--(B44);
\draw[Line](B44)-|(B46);
\draw[Line](B44)-|(B47);
\draw[Line](B44)--(B45);
\end{tikzpicture}
```

**Trustworthy ML System Design**: Engineering secure and private machine learning systems requires a layered approach, integrating defenses at the data, model, runtime, and hardware levels to mitigate evolving threats and ensure responsible deployment. This design flow connects threat modeling with practical safeguards, enabling robust and auditable ML solutions for safety-important applications.
:::

This design flow emphasizes the importance of a comprehensive approach to security, where each layer of the system is fortified against potential threats while remaining adaptable to evolving risks. By integrating these principles into the design and deployment of machine learning systems, organizations can build solutions that are not only effective but also resilient, trustworthy, and aligned with ethical standards.

### Defense Selection Framework {#sec-security-privacy-defense-selection-framework-320b}

Given the breadth of security mechanisms presented, practitioners require systematic methods for selecting appropriate defenses. The choice depends on multiple interacting factors that must be evaluated holistically rather than in isolation.

Step 1: Threat Model Assessment

Begin by characterizing potential adversaries and their capabilities:

- **Who are the adversaries?** Nation-states possess unlimited resources and advanced capabilities. Competitors seek intellectual property and strategic advantages. Curious users probe for vulnerabilities. Insider threats combine access with intent. Each adversary type demands different defensive priorities.

- **What capabilities do they have?** White-box attackers with full model access require different defenses than black-box attackers limited to API queries. Physical access enables hardware attacks that remote adversaries cannot execute. Understanding attacker capabilities determines which defense mechanisms provide meaningful protection versus security theater.

- **What assets require protection?** Training data privacy, model intellectual property, inference confidentiality, and system availability each require specialized defenses. Healthcare applications prioritize patient data protection (HIPAA compliance). Financial systems emphasize transaction integrity and fraud prevention. Ranking asset criticality guides defense investment.

- **What is acceptable risk?** Regulatory environments define minimum acceptable security (GDPR, HIPAA, PCI-DSS). Reputational considerations establish higher barsâ€”a data breach that is legally permissible may still be commercially devastating. Risk tolerance determines how much performance degradation and development cost organizations accept for security gains.

Step 2: Deployment Context Constraints

Security choices must respect operational realities:

- **Computational Budget:** Cloud deployments afford unlimited horizontal scaling, enabling expensive techniques like homomorphic encryption or extensive monitoring. Edge devices operate under severe constraintsâ€”secure enclaves consume precious memory, cryptographic operations drain batteries. Embedded systems may lack security hardware entirely. Defense selection must match available compute resources.

- **Latency Requirements:** Real-time applications (autonomous vehicles, industrial control) tolerate minimal latency overhead. Differential privacy and input validation must execute within millisecond budgets. Batch processing systems (training pipelines, offline analytics) can absorb expensive techniques like secure multi-party computation. Understanding latency budgets constrains feasible defenses.

- **Update Frequency:** Continuously learning systems require runtime security that adapts as models evolve. Static deployments can rely on one-time hardening (model encryption, watermarking). Over-the-air update capabilities enable security patches but introduce new attack surfaces. Update patterns determine whether defenses must be dynamic or can be baked-in.

- **Physical Security:** Data center deployments assume physical security and focus on logical defenses. Field-deployed devices face physical threats (tampering, extraction) requiring hardware security modules and tamper-evident packaging. Public-facing kiosks need different protections than secured facilities.

Step 3: Regulatory and Compliance Requirements

Legal mandates establish non-negotiable security baselines:

- **GDPR** (EU): Mandates data minimization, purpose limitation, privacy by design. Differential privacy and federated learning help demonstrate compliance. Cross-border data transfer restrictions favor on-device processing.

- **HIPAA** (Healthcare): Requires access controls, audit logging, encryption at rest and in transit. HSMs for key management and comprehensive logging become mandatory rather than optional.

- **CCPA** (California): Establishes consumer privacy rights including data deletion. Systems must support cryptographic erasure and maintain data provenance.

- **Industry Standards:** Payment Card Industry Data Security Standard (PCI-DSS), Federal Information Security Management Act (FISMA), and sector-specific regulations impose additional requirements. Non-compliance incurs financial penalties and operational restrictions.

Step 4: Recommended Layered Approach

Rather than selecting individual defenses, deploy coordinated protection:

1. Baseline Security (Universal): All ML systems require authentication, access control, encrypted communications (TLS), audit logging, and basic input validation. These foundational defenses cost little and prevent common attacks. Omitting them constitutes negligence.

2. Domain-Specific Controls (Context-Dependent): Healthcare systems add differential privacy for training data and TEEs for inference. Financial systems deploy HSMs for cryptographic operations and extensive transaction monitoring. Public-facing APIs implement rate limiting and behavioral analysis.

3. Layered Defenses (No Single Point of Failure): Assume each defense will be bypassed eventually. Differential privacy prevents training data extraction even if models are stolen. Input validation catches adversarial examples even if models lack robustness. Monitoring detects attacks that evade technical defenses. Redundancy ensures attack success requires compromising multiple independent layers.

4. Validation Through Red-Team Exercises: Theoretical security assessments miss practical vulnerabilities. Hire adversarial experts to attempt realistic attacks. Document failures and iterate defenses. Treat security as a continuous improvement process rather than one-time implementation.

Step 5: Trade-Off Optimization

Security is never free. Quantify costs and benefits:

- **Performance vs. Protection:** If differential privacy reduces accuracy by 5% but enables GDPR compliance, the trade-off may be mandatory. If homomorphic encryption adds 10 seconds of latency to millisecond-budget applications, alternative approaches are required.

- **Development Time vs. Risk Mitigation:** Basic security (authentication, encryption) adds weeks to development. Advanced techniques (federated learning, secure enclaves) require months of specialized engineering. Prioritize defenses by risk reduction per engineering hour.

- **Operational Overhead vs. Attack Detection:** Comprehensive monitoring adds 10-20% infrastructure cost. Intrusion detection systems generate false positives requiring investigation. Balance detection capabilities against operational burden.

The optimal security architecture emerges from systematically evaluating these factors rather than applying techniques prescriptively. Different deployment contexts demand different solutionsâ€”recognize this diversity and design accordingly. -->
<!-- ### Defense Selection Framework {#sec-security-privacy-selecting-appropriate-defenses-decision-framework-491e-framework-a48f}

To support practical decision making, @tbl-defense-selection-framework maps common threat scenarios to appropriate defensive techniques, organized by deployment context. This framework synthesizes the strategies presented throughout this section into actionable patterns.

+-----------------------------+-------------------------------------+--------------------------------------------------+-----------------------------------------------+
| **Deployment Context**      | **Primary Threats**                 | **Recommended Defenses**                         | **Key Trade-offs**                            |
+:============================+:====================================+:=================================================+:==============================================+
| **Healthcare ML**           | Data leakage (HIPAA violation),     | - Differential Privacy (Îµ â‰¤ 4) for training      | 2-5% accuracy loss acceptable for compliance; |
+-----------------------------+-------------------------------------+--------------------------------------------------+-----------------------------------------------+
| **(Federated diagnostic**   | membership inference,               | - Federated Learning across hospitals            | 50-100ms inference latency from TEE overhead  |
+-----------------------------+-------------------------------------+--------------------------------------------------+-----------------------------------------------+
| **models)**                 | unauthorized access                 | - TEE for inference on sensitive data            |                                               |
|                             |                                     | - Audit logging and access control (RBAC)        |                                               |
+-----------------------------+-------------------------------------+--------------------------------------------------+-----------------------------------------------+
| **Financial ML**            | Model theft (IP loss),              | - Model encryption (AES-256) at rest             | HSM adds $10-50K capital cost; rate limiting  |
+-----------------------------+-------------------------------------+--------------------------------------------------+-----------------------------------------------+
| **(Fraud detection API)**   | adversarial evasion,                | - HSM for cryptographic key management           | may impact legitimate high-frequency users    |
|                             | data poisoning                      | - Adversarial training (PGD-based)               |                                               |
|                             |                                     | - Input validation + rate limiting (100 req/min) |                                               |
|                             |                                     | - Output confidence monitoring                   |                                               |
+-----------------------------+-------------------------------------+--------------------------------------------------+-----------------------------------------------+
| **Edge ML**                 | Physical access,                    | - Secure Boot (verified firmware)                | TEE memory limits constrain model size        |
+-----------------------------+-------------------------------------+--------------------------------------------------+-----------------------------------------------+
| **(Mobile/IoT devices)**    | side-channel attacks,               | - ARM TrustZone or similar TEE                   | (&lt;50MB); quantization required for large   |
|                             | model extraction                    | - Model quantization + obfuscation               | models; 15-30% power overhead from encryption |
|                             |                                     | - Encrypted model storage                        |                                               |
|                             |                                     | - Anti-tampering hardware (PUF)                  |                                               |
+-----------------------------+-------------------------------------+--------------------------------------------------+-----------------------------------------------+
| **Cloud ML Training**       | Data poisoning,                     | - Secure data pipelines (provenance tracking)    | Training time increases 30-120% with DP;      |
+-----------------------------+-------------------------------------+--------------------------------------------------+-----------------------------------------------+
| **(Multi-tenant platform)** | backdoor injection,                 | - Differential Privacy (DP-SGD, Îµ â‰ˆ 1-10)        | gradient verification adds 10-15% compute     |
|                             | gradient leakage                    | - Gradient verification and anomaly detection    | overhead; federated aggregation requires      |
|                             |                                     | - Secure aggregation (if federated)              | secure communication protocols                |
|                             |                                     | - Model watermarking for IP protection           |                                               |
+-----------------------------+-------------------------------------+--------------------------------------------------+-----------------------------------------------+
| **Public-Facing LLM**       | Prompt injection,                   | - Input sanitization (prompt filtering)          | Aggressive filtering may block 5-10% of       |
+-----------------------------+-------------------------------------+--------------------------------------------------+-----------------------------------------------+
| **(Chatbot/API)**           | data extraction (training leakage), | - Output monitoring (PII detection)              | legitimate requests; response time increases  |
|                             | abuse/overuse                       | - Rate limiting (per-user quotas)                | 50-100ms for content filtering; watermarking  |
|                             |                                     | - Response watermarking                          | may be detectable by sophisticated users      |
|                             |                                     | - Confidence thresholding (abstention)           |                                               |
+-----------------------------+-------------------------------------+--------------------------------------------------+-----------------------------------------------+
| **Multi-Party ML**          | Data sharing restrictions,          | - Federated Learning (no raw data sharing)       | Communication overhead: 10-100x more rounds   |
+-----------------------------+-------------------------------------+--------------------------------------------------+-----------------------------------------------+
| **(Cross-organizational**   | honest-but-curious participants,    | - SMPC for secure aggregation                    | than centralized training; SMPC adds 1000x+   |
+-----------------------------+-------------------------------------+--------------------------------------------------+-----------------------------------------------+
| **training)**               | privacy compliance (GDPR)           | - Differential Privacy (Îµ â‰¤ 1)                   | compute cost; accuracy may degrade 5-15%;     |
|                             |                                     | - Homomorphic Encryption (for sensitive ops)     | requires legal agreements for liability       |
+-----------------------------+-------------------------------------+--------------------------------------------------+-----------------------------------------------+
| **Critical Infrastructure** | Supply chain compromise,            | - Hardware attestation (TPM/PUF)                 | Development cost: 6-18 months additional      |
+-----------------------------+-------------------------------------+--------------------------------------------------+-----------------------------------------------+
| **(Autonomous vehicles,**   | real-time adversarial attacks,      | - Secure Boot + runtime integrity checks         | engineering; 20-40% higher hardware costs;    |
+-----------------------------+-------------------------------------+--------------------------------------------------+-----------------------------------------------+
| **power grids)**            | safety-critical failures            | - Redundant model validation                     | latency constraints limit cryptographic       |
|                             |                                     | - Fault injection detection                      | defenses; requires certified hardware         |
|                             |                                     | - Fail-safe fallback mechanisms                  |                                               |
+-----------------------------+-------------------------------------+--------------------------------------------------+-----------------------------------------------+

: **Defense Selection Framework**: Maps deployment contexts to threat-specific defensive strategies with quantified trade-offs. The framework provides starting points for security architecture design, highlighting primary threats, recommended defense combinations, and key implementation trade-offs across common ML system deployment scenarios. Practitioners should adapt these patterns based on specific regulatory requirements, risk assessments, and operational constraints. {#tbl-defense-selection-framework}

This framework provides starting points rather than complete solutions. Real-world systems typically require combinations of defenses tailored to specific regulatory requirements, threat models, and operational constraints. Use these patterns as templates, adapting them based on risk assessments, compliance mandates, and resource availability. The baseline defenses identified in Step 1 (authentication, TLS, audit logging, input validation) apply universally and are assumed present in all deployment contexts above. -->
<!-- ### Implementation Roadmap: Securing a Production ML System {#sec-security-privacy-implementation-roadmap-securing-production-ml-system-511c-securing-production-ml-system-511c}

Securing production machine learning systems requires a systematic approach that evolves from establishing basic protections to implementing comprehensive defense mechanisms. Organizations face the challenge of protecting valuable models and sensitive data while maintaining system performance and meeting regulatory requirements. The path from an unsecured ML deployment to a robust, trustworthy system follows a natural progression through four critical phases, each building upon the security foundations established by its predecessor. This roadmap provides the security-specific implementation details that complement the broader operational frameworks presented in @sec-ml-operations, where these protections are integrated into continuous deployment pipelines, monitoring systems, and incident response workflows.

The journey begins with foundational security controls that provide immediate risk reduction across all ML deployments. Access control mechanisms form the first line of defense, determining who can interact with ML infrastructure and at what level. Organizations typically leverage existing identity providers like Active Directory or OAuth 2.0 to implement role-based access control, ensuring data scientists can train models while limiting production access to authorized deployment systems. Communication security follows, with TLS 1.3 or newer protocols protecting all ML API endpoints from eavesdropping and tampering. This encryption layer becomes particularly critical when models process sensitive data or operate across untrusted networks. Input validation and rate limiting at inference endpoints prevent both accidental misuse and intentional abuse, using API gateways to enforce schema validation and throttle excessive requests. Finally, comprehensive audit logging creates the forensic trail necessary for security monitoring and compliance reporting, capturing all model access, training operations, and data transformations in centralized systems like ELK stack or Splunk.

Once these foundations are established, typically within the first two weeks of implementation, organizations progress to data privacy protections that address regulatory requirements and ethical obligations. This phase begins with comprehensive data classification, cataloging all training and inference data sources to identify sensitive information such as personally identifiable information, protected health information, or financial records. For datasets containing sensitive information, differential privacy techniques add calibrated noise during training, with privacy budgets carefully selected based on regulatory requirementsâ€”typically Îµ â‰¤ 4 for general compliance and Îµ â‰¤ 1 for highly sensitive medical or financial data. When multiple organizations need to collaborate without sharing raw data, federated learning enables distributed training with secure aggregation protocols ensuring individual contributions remain private. Data minimization practices complement these technical measures by establishing retention policies that automatically delete sensitive training data after model completion, reducing the window of exposure for potential breaches.

The third phase shifts focus to protecting the models themselves as valuable intellectual property that may encode sensitive information or competitive advantages. Model encryption using AES-256 or stronger algorithms protects stored models from unauthorized access, with key management systems like AWS KMS or HashiCorp Vault ensuring proper key rotation and access control. For particularly sensitive applications, deployment within trusted execution environments provides hardware-enforced isolation, preventing even privileged system administrators from accessing model internals during inference. Organizations implement model watermarking techniques to embed undetectable ownership markers that survive model extraction attempts, while query monitoring systems detect suspicious patterns that might indicate ongoing theft attempts. Critical applications require adversarial robustness through specialized training techniques, using methods like Projected Gradient Descent to create models that maintain accuracy even when facing malicious inputs designed to cause misclassification.

The final phase establishes continuous monitoring and response capabilities that maintain security throughout the system's operational lifetime. Real-time anomaly detection systems monitor inference patterns, input distributions, and model confidence scores to identify potential attacks or system degradation. When threats are detected, automated response systems implement immediate countermeasures such as rate limiting suspicious users, isolating potentially compromised models, or escalating alerts to security teams. Performance monitoring ensures security measures don't degrade business operations, tracking metrics like inference latency and model accuracy to maintain the delicate balance between protection and utility. Comprehensive incident response procedures specific to ML systems enable rapid reaction to security events, including capabilities for model rollback to known-good versions, forensic data collection for post-incident analysis, and threat intelligence gathering to prevent future attacks.

Success metrics should guide implementation effectiveness: (1) Zero security incidents involving data leakage or model theft; (2) <5% model performance degradation from security measures; (3) 100% compliance with relevant regulations (HIPAA, GDPR, SOX); (4) <100ms additional latency from security overhead.

Implementation prioritization becomes critical for resource-constrained organizations. Start with high-impact, low-effort baseline defenses (TLS, authentication, logging) before progressing to specialized techniques. Focus on regulatory compliance requirements first (HIPAA differential privacy, GDPR data minimization) as these often have legal deadlines. Deploy privacy-preserving techniques based on data sensitivityâ€”use differential privacy for PII/PHI, federated learning for cross-organizational collaboration, and synthetic data for lower-sensitivity use cases.

::: {.callout-warning title="Troubleshooting Guide: Common ML Security Issues" icon=false}
Issue 1: Model Performance Degradation After Security Implementation

*Symptoms*: Model accuracy drops significantly after applying differential privacy, adversarial training, or encryption.

*Root Causes*:

- Excessive noise injection (Îµ too small in differential privacy)
- Insufficient adversarial training budget
- Inappropriate cryptographic operations breaking model computation

*Diagnostics*:
```python
# Check DP noise impact
def measure_privacy_utility_tradeoff(model, data, epsilon_values):
    results = {}
    for eps in epsilon_values:
        dp_model = apply_differential_privacy(model, epsilon=eps)
        accuracy = evaluate_model(dp_model, data)
        results[eps] = accuracy
    return results


# Test different epsilon values: [0.1, 1.0, 4.0, 8.0]
# Look for sweet spot between privacy and utility
```

*Solutions*:

- **DP**: Start with Îµ = 8, gradually decrease while monitoring accuracy
- **Adversarial Training**: Use mixed training (70% clean, 30% adversarial examples)
- **Encryption**: Use approximate methods (quantization-friendly HE) for critical operations only

Issue 2: High Latency from Security Overhead

*Symptoms*: Inference time increases dramatically with TEEs, encryption, or secure protocols.

*Debugging Steps*:
1. Profile each security component separately
2. Identify bottlenecks (network, crypto, context switching)
3. Measure baseline vs. secured performance

*Optimization Strategies*:

- **TEE Optimization**: Batch inference calls, minimize context switches
- **Encryption**: Use hardware acceleration (AES-NI), optimize key operations
- **Network Security**: Pipeline TLS handshakes, use connection pooling

Issue 3: Adversarial Attack Detection False Positives

*Symptoms*: Legitimate inputs flagged as adversarial examples, causing service disruption.

*Tuning Approach*:
```python
# Adjust detection thresholds
def calibrate_adversarial_detector(detector, clean_data, attack_data):
    # Find threshold balancing false positive rate vs.
    # detection rate
    thresholds = np.linspace(0.1, 0.9, 20)
    for threshold in thresholds:
        fp_rate = compute_false_positive_rate(
            detector, clean_data, threshold
        )
        detection_rate = compute_detection_rate(
            detector, attack_data, threshold
        )
        print(
            f"Threshold {threshold}: FP={fp_rate:.3f}, "
            + f"Detection={detection_rate:.3f}"
        )
```

*Best Practices*:

- Set different thresholds for different input types
- Implement human-in-the-loop for borderline cases
- Use ensemble detection methods for robustness

Issue 4: Privacy Budget Exhaustion in Production

*Symptoms*: Cannot retrain models due to depleted privacy budget.

*Management Strategy*:

- Implement privacy budget monitoring and alerting
- Reserve budget for emergency retraining (20% buffer)
- Use synthetic data for non-critical model updates
- Plan budget allocation across model lifecycle

Issue 5: Federated Learning Convergence Problems

*Symptoms*: Models fail to converge or converge slowly in federated settings.

*Diagnostic Checklist*:

- Check data distribution across clients (non-IID data)
- Verify secure aggregation isn't corrupting gradients
- Monitor client participation rates and dropouts
- Analyze communication rounds and bandwidth usage

*Solutions*:

- Implement FedProx or FedAvgM for non-IID data
- Use client sampling strategies to ensure representative participation
- Add gradient compression to reduce communication overhead
- Implement client reliability scoring and failover mechanisms
::: -->
<div id="quiz-question-sec-security-privacy-comprehensive-defense-architectures-48ab" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.8</strong></summary><div>
<ol type="1">
<li><p>Which of the following best describes the principle of layered defense in machine learning systems?</p>
<ol type="a">
<li>A single security mechanism that protects against all threats.</li>
<li>A focus on protecting only the data layer of the system.</li>
<li>Multiple independent defensive mechanisms working together to protect against diverse threat vectors.</li>
<li>Relying solely on hardware-based security features.</li>
</ol></li>
<li><p>Explain how differential privacy contributes to the data layer of a layered defense strategy in ML systems.</p></li>
<li><p>True or False: Trusted Execution Environments (TEEs) are primarily used to enhance the security of the data layer in machine learning systems.</p></li>
<li><p>In a production ML system, which layer would most likely employ input validation and output monitoring as part of its defense strategy?</p>
<ol type="a">
<li>Data Layer</li>
<li>Model Layer</li>
<li>Hardware Layer</li>
<li>Runtime Layer</li>
</ol></li>
<li><p>Consider a scenario where an ML system is deployed in a healthcare setting. What trade-offs might be involved in implementing differential privacy and secure model deployment?</p></li>
</ol>
<p><a href="#quiz-answer-sec-security-privacy-comprehensive-defense-architectures-48ab" class="question-label">See Answers â†’</a></p>
</div></details>
</div>
</section>
</section>
</section>
<section id="sec-security-privacy-practical-roadmap-8f3a" class="level2">
<h2 class="anchored" data-anchor-id="sec-security-privacy-practical-roadmap-8f3a">Practical Implementation Roadmap</h2>
<p>The comprehensive security and privacy techniques covered in this chapter can seem overwhelming for organizations just beginning to secure their ML systems. Rather than implementing every defense simultaneously, a phased approach enables systematic security improvements while managing complexity and costs. This roadmap provides a practical sequence for building robust ML security, progressing from foundational controls to advanced defenses.</p>
<section id="sec-security-privacy-phase1-baseline-foundation-2d9c" class="level3">
<h3 class="anchored" data-anchor-id="sec-security-privacy-phase1-baseline-foundation-2d9c">Phase 1: Foundation Security Controls</h3>
<p>Begin with basic security controls that provide the greatest risk reduction for the least complexity. These foundational measures address the most common attack vectors and create the trust infrastructure needed for more advanced defenses.</p>
<ul>
<li><p><strong>Access Control and Authentication</strong>: Implement role-based access control (RBAC) for all ML system components, including training data, model repositories, and inference APIs. Use multi-factor authentication for administrative access and service-to-service authentication with short-lived tokens. Establish the principle of least privilege, ensuring users and services have only the minimum permissions required for their functions.</p></li>
<li><p><strong>Data Protection</strong>: Encrypt all data at rest using AES-256 and enforce TLS 1.3 for all data in transit. This includes training datasets, model files, and inference communications. Implement comprehensive logging of all data access and model operations to support incident investigation and compliance auditing.</p></li>
<li><p><strong>Input Validation and Basic Monitoring</strong>: Deploy input validation for all ML APIs to reject malformed requests, implement rate limiting to prevent abuse, and establish baseline monitoring for unusual inference patterns. These measures protect against basic adversarial inputs and provide visibility into system behavior.</p></li>
<li><p><strong>Secure Development Practices</strong>: Establish secure coding practices for ML pipelines, including dependency management with vulnerability scanning, secure model serialization that validates model integrity, and automated security testing in deployment pipelines.</p></li>
</ul>
</section>
<section id="sec-security-privacy-phase2-privacy-model-protection-7a8b" class="level3">
<h3 class="anchored" data-anchor-id="sec-security-privacy-phase2-privacy-model-protection-7a8b">Phase 2: Privacy Controls and Model Protection</h3>
<p>With foundational controls in place, focus on protecting sensitive data and securing your ML models from theft and manipulation. This phase addresses privacy regulations and intellectual property protection.</p>
<ul>
<li><p><strong>Privacy-Preserving Techniques</strong>: Implement data anonymization for non-sensitive use cases and differential privacy for scenarios requiring formal privacy guarantees. For collaborative learning scenarios, deploy federated learning architectures that keep sensitive data localized while enabling model improvement.</p></li>
<li><p><strong>Model Security</strong>: Protect deployed models through encryption of model files, secure API design that limits information leakage, and monitoring for model extraction attempts. Implement model versioning and integrity checking to detect unauthorized modifications.</p></li>
<li><p><strong>Secure Training Infrastructure</strong>: Harden training environments by isolating training workloads, implementing secure data pipelines with validation and provenance tracking, and establishing secure model registries with access controls and audit trails.</p></li>
<li><p><strong>Compliance Integration</strong>: Implement necessary controls for regulatory requirements such as GDPR, HIPAA, or industry-specific standards. This includes data subject rights management, privacy impact assessments, and documentation of data processing activities.</p></li>
</ul>
</section>
<section id="sec-security-privacy-phase3-advanced-defenses-runtime-8c2d" class="level3">
<h3 class="anchored" data-anchor-id="sec-security-privacy-phase3-advanced-defenses-runtime-8c2d">Phase 3: Advanced Threat Defense</h3>
<p>The final phase implements sophisticated defenses for high-stakes environments where advanced adversaries pose significant threats. These defenses require more expertise and resources but provide protection against state-of-the-art attacks.</p>
<ul>
<li><p><strong>Adversarial Robustness</strong>: Deploy adversarial training to improve model robustness against evasion attacks, implement certified defenses for safety-critical applications, and establish continuous testing against new adversarial techniques.</p></li>
<li><p><strong>Advanced Runtime Monitoring</strong>: Deploy ML-specific anomaly detection systems that can identify sophisticated attacks like data poisoning effects or gradual model degradation. Implement behavioral analysis that establishes normal operation baselines and alerts on deviations.</p></li>
<li><p><strong>Hardware-Based Security</strong>: For the highest security requirements, implement trusted execution environments (TEEs) for model inference, secure boot processes for edge devices, and hardware security modules (HSMs) for cryptographic key management.</p></li>
<li><p><strong>Incident Response and Recovery</strong>: Establish ML-specific incident response procedures, including model rollback capabilities, contaminated data isolation procedures, and forensic analysis techniques for ML-specific attacks.</p></li>
</ul>
</section>
<section id="sec-security-privacy-implementation-considerations-9f4e" class="level3">
<h3 class="anchored" data-anchor-id="sec-security-privacy-implementation-considerations-9f4e">Implementation Considerations</h3>
<p>Success with this roadmap requires balancing security improvements with operational capabilities. Each phase should be fully implemented and stabilized before progressing to the next level. Organizations should customize this sequence based on their specific threat model: healthcare systems may prioritize Phase 2 privacy controls, financial institutions may emphasize Phase 1 data protection, and autonomous vehicle systems may fast-track to Phase 3 adversarial robustness.</p>
<p>Resource allocation should account for the increasing technical complexity and operational overhead of advanced phases. Phase 1 controls typically require standard IT security expertise, while Phase 3 defenses may require specialized ML security knowledge or external consulting. Organizations should invest in training and hiring appropriate expertise before implementing advanced controls.</p>
<p>Regular security assessments should validate the effectiveness of implemented controls and guide progression through phases. These assessments should include penetration testing of ML-specific attack vectors, red team exercises that simulate realistic adversarial scenarios, and compliance audits that verify regulatory requirements are met effectively.</p>
<div id="quiz-question-sec-security-privacy-practical-roadmap-8f3a" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.9</strong></summary><div>
<ol type="1">
<li><p>Order the following phases of the ML security roadmap: (1) Baseline Security Foundation, (2) Advanced Defenses and Runtime Protection, (3) Data Privacy and Model Protection.</p></li>
<li><p>Which of the following is a key focus of the Baseline Security Foundation phase?</p>
<ol type="a">
<li>Implementing adversarial robustness</li>
<li>Deploying federated learning architectures</li>
<li>Establishing role-based access control</li>
<li>Integrating compliance controls</li>
</ol></li>
<li><p>Explain why it is important to implement a phased approach to securing ML systems.</p></li>
<li><p>In the Data Privacy and Model Protection phase, which technique is used to ensure privacy while enabling collaborative learning?</p>
<ol type="a">
<li>Federated learning</li>
<li>Differential privacy</li>
<li>Adversarial training</li>
<li>Secure boot processes</li>
</ol></li>
</ol>
<p><a href="#quiz-answer-sec-security-privacy-practical-roadmap-8f3a" class="question-label">See Answers â†’</a></p>
</div></details>
</div>
</section>
</section>
<section id="sec-security-privacy-fallacies-pitfalls-0c20" class="level2">
<h2 class="anchored" data-anchor-id="sec-security-privacy-fallacies-pitfalls-0c20">Fallacies and Pitfalls</h2>
<p>Having examined both defensive and offensive capabilities, we now address common misconceptions that can undermine security efforts. Security and privacy in machine learning systems present unique challenges that extend beyond traditional cybersecurity concerns, involving sophisticated attacks on data, models, and inference processes. The complexity of modern ML pipelines, combined with the probabilistic nature of machine learning and the sensitivity of training data, creates numerous opportunities for misconceptions about effective protection strategies.</p>
<p><strong>Fallacy:</strong> <em>Security through obscurity provides adequate protection for machine learning models.</em></p>
<p>This outdated approach assumes that hiding model architectures, parameters, or implementation details provides meaningful security protection. Modern attacks often succeed without requiring detailed knowledge of target systems, relying instead on black-box techniques that probe system behavior through input-output relationships. Model extraction attacks can reconstruct significant model functionality through carefully designed queries, while adversarial attacks often transfer across different architectures. Effective ML security requires robust defenses that function even when attackers have complete knowledge of the system, following established security principles rather than relying on secrecy.</p>
<p><strong>Pitfall:</strong> <em>Assuming that differential privacy automatically ensures privacy without considering implementation details.</em></p>
<p>Many practitioners treat differential privacy as a universal privacy solution without understanding the critical importance of proper implementation and parameter selection. Poorly configured privacy budgets can provide negligible protection while severely degrading model utility. Implementation vulnerabilities like floating-point precision issues, inadequate noise generation, or privacy budget exhaustion can completely compromise privacy guarantees. Real-world systems require careful analysis of privacy parameters, rigorous implementation validation, and ongoing monitoring to ensure that theoretical privacy guarantees translate to practical protection.</p>
<p><strong>Fallacy:</strong> <em>Federated learning inherently provides privacy protection without additional safeguards.</em></p>
<p>A related privacy misconception assumes that keeping data decentralized automatically ensures privacy protection. While federated learning improves privacy compared to centralized training, gradient and model updates can still leak significant information about local training data through inference attacks. Sophisticated adversaries can reconstruct training examples, infer membership information, or extract sensitive attributes from shared model parameters. True privacy protection in federated settings requires additional mechanisms like secure aggregation, differential privacy, and careful communication protocols rather than relying solely on data locality.</p>
<p><strong>Pitfall:</strong> <em>Treating security as an isolated component rather than a system-wide property.</em></p>
<p>Beyond specific technical misconceptions, a key architectural pitfall involves organizations that approach ML security by adding security features to individual components without considering system-level interactions and attack vectors. This piecemeal approach fails to address sophisticated attacks that span multiple components or exploit interfaces between subsystems. Effective ML security requires holistic threat modeling that considers the entire system lifecycle from data collection through model deployment and maintenance, following the threat prioritization principles established in <a href="#sec-security-privacy-threat-prioritization-framework-f2d5" class="quarto-xref">Section&nbsp;1.4.1</a>. Security must be integrated into every stage of the ML pipeline rather than treated as an add-on feature or post-deployment consideration.</p>
<p><strong>Pitfall:</strong> <em>Underestimating the attack surface expansion in distributed ML systems.</em></p>
<p>Many organizations focus on securing individual components without recognizing how distributed ML architectures increase the attack surface and introduce new vulnerability classes. Distributed training across multiple data centers creates opportunities for man-in-the-middle attacks on gradient exchanges, certificate spoofing, and unauthorized participation in training rounds. Edge deployment multiplies endpoints that require security updates, monitoring, and incident response capabilities. Model serving infrastructure spanning multiple clouds introduces dependency chain attacks, where compromising any component in the distributed system can affect overall security. Orchestration systems, load balancers, model registries, and monitoring infrastructure each present potential entry points for sophisticated attackers. Effective distributed ML security requires thorough threat modeling that accounts for network communication security, endpoint hardening, identity management across multiple domains, and coordination of security policies across heterogeneous infrastructure components.</p>
<div id="quiz-question-sec-security-privacy-fallacies-pitfalls-0c20" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.10</strong></summary><div>
<ol type="1">
<li><p>Which of the following statements best describes the fallacy of â€˜security through obscurityâ€™ in machine learning models?</p>
<ol type="a">
<li>Hiding model details provides complete protection against attacks.</li>
<li>Modern attacks can succeed without detailed knowledge of the model.</li>
<li>Security through obscurity is effective when combined with robust defenses.</li>
<li>Obscuring model details is the primary method of securing ML systems.</li>
</ol></li>
<li><p>True or False: Differential privacy automatically ensures privacy protection in machine learning systems without careful implementation.</p></li>
<li><p>Explain why federated learning does not inherently provide complete privacy protection.</p></li>
<li><p>How does treating security as a system-wide property differ from adding security features to individual components?</p></li>
<li><p>In the context of distributed ML systems, what is a common pitfall related to the attack surface?</p>
<ol type="a">
<li>Assuming that centralized systems have a larger attack surface.</li>
<li>Relying on traditional security measures for distributed systems.</li>
<li>Focusing solely on securing individual components.</li>
<li>Assuming that distributed systems inherently reduce security risks.</li>
</ol></li>
</ol>
<p><a href="#quiz-answer-sec-security-privacy-fallacies-pitfalls-0c20" class="question-label">See Answers â†’</a></p>
</div></details>
</div>
</section>
<section id="sec-security-privacy-summary-831c" class="level2">
<h2 class="anchored" data-anchor-id="sec-security-privacy-summary-831c">Summary</h2>
<p>This chapter has explored the complex landscape of security and privacy in machine learning systems, from core threats to comprehensive defense strategies. Security and privacy represent essential requirements for deploying machine learning systems in production environments. As these systems handle sensitive data, operate across diverse platforms, and face sophisticated threats, their security posture must encompass the entire technology stack. Modern machine learning systems encounter attack vectors ranging from data poisoning and model extraction to adversarial examples and hardware-level compromises that can undermine system integrity and user trust.</p>
<p>Effective security strategies employ defense-in-depth approaches that operate across multiple layers of the system architecture. Privacy-preserving techniques like differential privacy and federated learning protect sensitive data while enabling model training. Robust model design incorporates adversarial training and input validation to resist manipulation. Hardware security features provide trusted execution environments and secure boot processes. Runtime monitoring detects anomalous behavior and potential attacks during operation. These complementary defenses create resilient systems that can withstand coordinated attacks across multiple attack surfaces.</p>
<div class="callout callout-style-default callout-important callout-titled" title="Key Takeaways">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Key Takeaways
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Security and privacy must be integrated from initial architecture design rather than added as afterthoughts to ML systems</li>
<li>ML systems face threats across three categories: model confidentiality (theft), training integrity (poisoning), and inference robustness (adversarial attacks)</li>
<li>Historical security patterns (supply chain compromise, insufficient isolation, weaponized endpoints) amplify in ML contexts due to autonomous decision-making capabilities</li>
<li>Effective defense requires layered protection spanning data privacy, model security, runtime monitoring, and hardware trust anchors</li>
<li>Context drives defense selection: healthcare prioritizes regulatory compliance, autonomous vehicles prioritize adversarial robustness, financial systems prioritize model theft prevention</li>
<li>Privacy-preserving techniques include differential privacy, federated learning, homomorphic encryption, and synthetic data generation, each with distinct trade-offs</li>
<li>Hardware security mechanisms (TEEs, secure boot, HSMs, PUFs) provide foundational trust for software-level protections</li>
<li>Security introduces inevitable trade-offs in computational cost, accuracy degradation, and implementation complexity that must be balanced against protection benefits</li>
</ul>
</div>
</div>
<p>Looking forward, the security and privacy foundations established in this chapter form critical building blocks for the comprehensive robustness framework explored in <strong><a href="../robust_ai/robust_ai.html#sec-robust-ai">Chapter 16: Robust AI</a></strong>. While weâ€™ve focused on defending against malicious actors and protecting sensitive information, true system reliability requires expanding these concepts to handle all forms of operational stress. The monitoring infrastructure, defensive mechanisms, and layered architectures weâ€™ve developed here provide the foundation for detecting distribution shifts, managing uncertainty, and ensuring graceful degradation under adverse conditionsâ€”topics that will be central to our exploration of robust AI.</p>


<div id="quiz-question-sec-security-privacy-summary-831c" class="callout callout-quiz-question">
<details class="callout-quiz-question fbx-default closebutton"><summary><strong>Self-Check: Question 1.11</strong></summary><div>
<ol type="1">
<li><p>Which of the following best describes a defense-in-depth approach in machine learning systems?</p>
<ol type="a">
<li>Adding security features after deployment</li>
<li>Focusing solely on data encryption</li>
<li>Implementing multiple layers of security throughout the system</li>
<li>Relying on hardware security features exclusively</li>
</ol></li>
<li><p>Explain the trade-offs involved in implementing privacy-preserving techniques like differential privacy and federated learning in ML systems.</p></li>
<li><p>In a production ML system, which context would most likely prioritize adversarial robustness over other security concerns?</p>
<ol type="a">
<li>Healthcare systems</li>
<li>Social media platforms</li>
<li>Financial systems</li>
<li>Autonomous vehicles</li>
</ol></li>
</ol>
<p><a href="#quiz-answer-sec-security-privacy-summary-831c" class="question-label">See Answers â†’</a></p>
</div></details>
</div>
</section>
<section id="self-check-answers" class="level2">
<h2 class="anchored" data-anchor-id="self-check-answers">Self-Check Answers</h2>
<div id="quiz-answer-sec-security-privacy-security-privacy-ml-systems-0b1e" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.1</strong></summary><div>
<ol type="1">
<li><p><strong>How do machine learning systems differ from traditional software applications in terms of data processing?</strong></p>
<ol type="a">
<li>ML systems process data transiently and deterministically.</li>
<li>Traditional software systems operate across heterogeneous environments.</li>
<li>Traditional software systems learn patterns from data and store them persistently.</li>
<li>ML systems encode patterns from data into persistent model parameters.</li>
</ol>
<p><em>Answer</em>: The correct answer is D. ML systems encode patterns from data into persistent model parameters. This is correct because ML systems learn from data and store this knowledge in model parameters, unlike traditional software that processes data transiently.</p>
<p><em>Learning Objective</em>: Understand the fundamental differences in data processing between ML systems and traditional software.</p></li>
<li><p><strong>True or False: The distributed nature of modern ML deployments reduces the attack surface for potential security threats.</strong></p>
<p><em>Answer</em>: False. The distributed nature of modern ML deployments expands the attack surface, making comprehensive security implementation more complex.</p>
<p><em>Learning Objective</em>: Recognize how distributed ML architectures affect the security landscape.</p></li>
<li><p><strong>Explain why traditional cybersecurity frameworks may not adequately address the security needs of modern ML systems.</strong></p>
<p><em>Answer</em>: Traditional cybersecurity frameworks are often insufficient for ML systems because they do not account for the unique vulnerabilities introduced by persistent model parameters and distributed architectures. For example, ML models can inadvertently memorize sensitive data, which can be exposed through model outputs. This is important because it highlights the need for specialized security measures in ML systems.</p>
<p><em>Learning Objective</em>: Analyze why existing security measures may fall short in protecting ML systems.</p></li>
<li><p><strong>Which of the following is a potential vulnerability specific to machine learning systems?</strong></p>
<ol type="a">
<li>Data is processed transiently and deterministically.</li>
<li>Sensitive information can be memorized and exposed through model outputs.</li>
<li>Models operate only in centralized environments.</li>
<li>There are no privacy concerns in ML systems.</li>
</ol>
<p><em>Answer</em>: The correct answer is B. Sensitive information can be memorized and exposed through model outputs. This is correct because ML systems can inadvertently store and reveal sensitive data, unlike traditional systems.</p>
<p><em>Learning Objective</em>: Identify specific vulnerabilities associated with ML systems.</p></li>
</ol>
<p><a href="#quiz-question-sec-security-privacy-security-privacy-ml-systems-0b1e" class="answer-label">â† Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-security-privacy-foundational-concepts-definitions-d529" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.2</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following best describes the primary goal of security in machine learning systems?</strong></p>
<ol type="a">
<li>Limit exposure of sensitive information</li>
<li>Prevent unauthorized access or disruption</li>
<li>Enhance model performance and accuracy</li>
<li>Ensure compliance with data protection laws</li>
</ol>
<p><em>Answer</em>: The correct answer is B. Prevent unauthorized access or disruption. This is correct because security focuses on protecting systems from adversarial threats that could compromise system integrity and availability. Other options relate more to privacy or performance aspects.</p>
<p><em>Learning Objective</em>: Understand the primary goal of security in ML systems.</p></li>
<li><p><strong>True or False: Privacy in machine learning systems is primarily concerned with preventing adversarial attacks.</strong></p>
<p><em>Answer</em>: False. Privacy is concerned with limiting the exposure and misuse of sensitive information, even in the absence of adversarial attacks, focusing on unauthorized disclosure or inference.</p>
<p><em>Learning Objective</em>: Differentiate between the concerns of security and privacy in ML systems.</p></li>
<li><p><strong>Explain how security and privacy can be in tension within a machine learning system.</strong></p>
<p><em>Answer</em>: Security and privacy can be in tension because techniques like encryption enhance security by protecting data but may obscure transparency needed for privacy compliance. Conversely, privacy techniques like differential privacy reduce data exposure but can decrease model utility. These trade-offs require careful balancing to protect against misuse and overexposure.</p>
<p><em>Learning Objective</em>: Analyze the trade-offs between security and privacy in ML systems.</p></li>
<li><p><strong>In the context of machine learning systems, which of the following is an example of a privacy failure?</strong></p>
<ol type="a">
<li>Adversarial inputs causing misclassification</li>
<li>Data poisoning during training</li>
<li>Unauthorized access to model parameters</li>
<li>Model inversion revealing training data</li>
</ol>
<p><em>Answer</em>: The correct answer is D. Model inversion revealing training data. This is a privacy failure because it involves exposing sensitive information from the model, even without direct adversarial attacks.</p>
<p><em>Learning Objective</em>: Identify examples of privacy failures in ML systems.</p></li>
</ol>
<p><a href="#quiz-question-sec-security-privacy-foundational-concepts-definitions-d529" class="answer-label">â† Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-security-privacy-learning-security-breaches-6719" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.3</strong></summary><div>
<ol type="1">
<li><p><strong>What was the primary objective of the Stuxnet worm?</strong></p>
<ol type="a">
<li>To steal sensitive information from industrial systems.</li>
<li>To disrupt internet services globally.</li>
<li>To perform espionage on government networks.</li>
<li>To cause physical damage to industrial infrastructure.</li>
</ol>
<p><em>Answer</em>: The correct answer is D. To cause physical damage to industrial infrastructure. Stuxnet was engineered to sabotage centrifuges in Iranâ€™s Natanz nuclear facility, demonstrating how malware can bridge digital and physical worlds.</p>
<p><em>Learning Objective</em>: Understand the specific goals of historical security incidents like Stuxnet and their implications.</p></li>
<li><p><strong>Explain how the Jeep Cherokee hack illustrates the importance of isolation in connected systems.</strong></p>
<p><em>Answer</em>: The Jeep Cherokee hack demonstrated that insufficient isolation between external interfaces and safety-critical components can lead to remote exploitation. By accessing the Uconnect system, attackers could control critical vehicle functions, highlighting the need for strict isolation in connected systems to prevent unauthorized access and ensure safety.</p>
<p><em>Learning Objective</em>: Analyze the importance of isolation in preventing security breaches in connected systems.</p></li>
<li><p><strong>Which of the following measures would NOT effectively defend against supply chain attacks in ML systems?</strong></p>
<ol type="a">
<li>Cryptographic verification of all model artifacts.</li>
<li>Disabling all network connections to ML systems.</li>
<li>Provenance tracking of training data sources.</li>
<li>Integrity validation of model dependencies.</li>
</ol>
<p><em>Answer</em>: The correct answer is B. Disabling all network connections to ML systems. While it might seem secure, this is impractical for most ML deployments and doesnâ€™t address supply chain vulnerabilities directly.</p>
<p><em>Learning Objective</em>: Evaluate effective security measures for defending against supply chain attacks in ML systems.</p></li>
<li><p><strong>How might lessons from the Mirai botnet be applied to securing modern ML edge devices?</strong></p>
<p><em>Answer</em>: Lessons from the Mirai botnet emphasize the need for strong authentication and secure communications in ML edge devices. By eliminating default credentials, encrypting communications, and monitoring device behavior, ML systems can prevent large-scale exploitation and weaponization similar to what occurred with the Mirai botnet.</p>
<p><em>Learning Objective</em>: Apply historical lessons from the Mirai botnet to improve security in modern ML edge deployments.</p></li>
</ol>
<p><a href="#quiz-question-sec-security-privacy-learning-security-breaches-6719" class="answer-label">â† Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-security-privacy-systematic-threat-analysis-risk-assessment-3ef1" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.4</strong></summary><div>
<ol type="1">
<li><p><strong>Which historical security incident is most similar to data poisoning attacks in ML systems?</strong></p>
<ol type="a">
<li>Heartbleed</li>
<li>Jeep Cherokee hack</li>
<li>Mirai botnet</li>
<li>Stuxnet</li>
</ol>
<p><em>Answer</em>: The correct answer is D. Stuxnet. This is correct because Stuxnet involved sophisticated manipulation of industrial systems, similar to how data poisoning manipulates ML models. The Jeep Cherokee hack and Mirai botnet are more analogous to isolation and endpoint security issues, respectively.</p>
<p><em>Learning Objective</em>: Understand the analogy between historical security incidents and ML system vulnerabilities.</p></li>
<li><p><strong>Explain why ML systems are particularly vulnerable to subtle attacks compared to traditional systems.</strong></p>
<p><em>Answer</em>: ML systems are particularly vulnerable to subtle attacks because they rely on data-driven learning, which can be manipulated to appear statistically normal while embedding malicious behaviors. For example, data poisoning can introduce backdoors that are difficult to detect. This is important because it highlights the need for specialized defenses that account for the probabilistic nature of ML systems.</p>
<p><em>Learning Objective</em>: Analyze the unique vulnerabilities of ML systems compared to traditional systems.</p></li>
<li><p><strong>In the context of ML-specific threats, which of the following requires specialized defenses beyond traditional infrastructure hardening?</strong></p>
<ol type="a">
<li>Supply chain vulnerabilities</li>
<li>Network intrusion</li>
<li>Data poisoning</li>
<li>Physical theft</li>
</ol>
<p><em>Answer</em>: The correct answer is C. Data poisoning. This is correct because data poisoning exploits the statistical learning aspect of ML systems, requiring defenses that go beyond traditional infrastructure hardening. Supply chain vulnerabilities and network intrusion are addressed by traditional security measures.</p>
<p><em>Learning Objective</em>: Identify ML-specific threats that necessitate specialized defenses.</p></li>
<li><p><strong>Order the following threat priority categories from highest to lowest based on their likelihood and impact: (1) High Likelihood / High Impact, (2) High Likelihood / Medium Impact, (3) Low Likelihood / High Impact, (4) Medium Likelihood / Medium Impact.</strong></p>
<p><em>Answer</em>: The correct order is: (1) High Likelihood / High Impact, (2) High Likelihood / Medium Impact, (4) Medium Likelihood / Medium Impact, (3) Low Likelihood / High Impact. This order reflects the prioritization framework where likelihood and impact guide the allocation of security resources.</p>
<p><em>Learning Objective</em>: Apply a threat prioritization framework to ML security challenges.</p></li>
</ol>
<p><a href="#quiz-question-sec-security-privacy-systematic-threat-analysis-risk-assessment-3ef1" class="answer-label">â† Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-security-privacy-modelspecific-attack-vectors-0575" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.5</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following best describes a data poisoning attack in machine learning systems?</strong></p>
<ol type="a">
<li>Stealing model weights and architecture through API queries.</li>
<li>Injecting malicious data during training to alter model behavior.</li>
<li>Crafting inputs to deceive models at inference time.</li>
<li>Exploiting hardware vulnerabilities to access model data.</li>
</ol>
<p><em>Answer</em>: The correct answer is B. Injecting malicious data during training to alter model behavior. This is correct because data poisoning involves inserting harmful data into the training set to influence the modelâ€™s learning process. Other options describe different types of attacks.</p>
<p><em>Learning Objective</em>: Understand the nature and purpose of data poisoning attacks.</p></li>
<li><p><strong>True or False: Adversarial examples are primarily a threat during the training phase of the ML lifecycle.</strong></p>
<p><em>Answer</em>: False. This is false because adversarial examples target the inference phase, where attackers craft inputs to cause incorrect predictions without altering the training process.</p>
<p><em>Learning Objective</em>: Differentiate between training-time and inference-time threats.</p></li>
<li><p><strong>Explain how model theft could impact a companyâ€™s competitive advantage and suggest one defensive measure.</strong></p>
<p><em>Answer</em>: Model theft can undermine a companyâ€™s competitive advantage by allowing competitors to replicate proprietary models, reducing the original developerâ€™s market edge. A defensive measure is to secure model access through encryption and obfuscation, preventing unauthorized extraction of model files.</p>
<p><em>Learning Objective</em>: Analyze the impact of model theft and propose a defensive strategy.</p></li>
<li><p><strong>Order the following stages of the ML lifecycle in terms of when they are typically targeted by threats: (1) Data Collection, (2) Training, (3) Deployment, (4) Inference.</strong></p>
<p><em>Answer</em>: The correct order is: (1) Data Collection, (2) Training, (3) Deployment, (4) Inference. Threats target these stages sequentially, starting with data poisoning during collection, backdoor attacks during training, model theft during deployment, and adversarial examples during inference.</p>
<p><em>Learning Objective</em>: Understand the sequence of threat targeting across the ML lifecycle.</p></li>
<li><p><strong>In a production system, which defense strategy is most appropriate for protecting against adversarial attacks?</strong></p>
<ol type="a">
<li>Encrypting model files.</li>
<li>Restricting API access.</li>
<li>Implementing input validation and anomaly detection.</li>
<li>Using robust training methods.</li>
</ol>
<p><em>Answer</em>: The correct answer is C. Implementing input validation and anomaly detection. This is correct because adversarial attacks occur at inference, and these defenses help detect and mitigate malicious inputs in real-time. Other options address different threat types.</p>
<p><em>Learning Objective</em>: Identify appropriate defenses for inference-time threats.</p></li>
</ol>
<p><a href="#quiz-question-sec-security-privacy-modelspecific-attack-vectors-0575" class="answer-label">â† Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-security-privacy-hardwarelevel-security-vulnerabilities-1ab4" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.6</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following best describes a side-channel attack in the context of machine learning hardware?</strong></p>
<ol type="a">
<li>A direct attack on the software interface to extract data.</li>
<li>An attack exploiting physical signals to infer sensitive information.</li>
<li>A network-based attack targeting data transmission.</li>
<li>A physical tampering of hardware components.</li>
</ol>
<p><em>Answer</em>: The correct answer is B. An attack exploiting physical signals to infer sensitive information. Side-channel attacks use physical characteristics like power consumption and electromagnetic emissions to extract data.</p>
<p><em>Learning Objective</em>: Understand the nature and implications of side-channel attacks on ML hardware.</p></li>
<li><p><strong>Explain how speculative execution vulnerabilities like Meltdown and Spectre pose a threat to machine learning hardware security.</strong></p>
<p><em>Answer</em>: Speculative execution vulnerabilities allow attackers to exploit out-of-order execution in CPUs to access protected memory areas. In ML hardware, this can lead to exposure of sensitive model data and user information, bypassing conventional security mechanisms. This is important because it highlights the need for architectural safeguards to prevent data leakage.</p>
<p><em>Learning Objective</em>: Analyze the impact of speculative execution vulnerabilities on ML hardware security.</p></li>
<li><p><strong>Order the following hardware threats based on their potential impact on ML system security: (1) Side-Channel Attacks, (2) Physical Attacks, (3) Supply Chain Risks.</strong></p>
<p><em>Answer</em>: The correct order is: (3) Supply Chain Risks, (2) Physical Attacks, (1) Side-Channel Attacks. Supply chain risks can introduce systemic vulnerabilities, physical attacks directly manipulate hardware, and side-channel attacks infer information indirectly.</p>
<p><em>Learning Objective</em>: Prioritize hardware threats based on their impact on ML system security.</p></li>
<li><p><strong>In a production ML system, which strategy is most effective for mitigating the risk of counterfeit hardware?</strong></p>
<ol type="a">
<li>Implementing strong encryption protocols.</li>
<li>Conducting regular software updates.</li>
<li>Increasing network bandwidth.</li>
<li>Performing thorough supplier verification and component testing.</li>
</ol>
<p><em>Answer</em>: The correct answer is D. Performing thorough supplier verification and component testing. This strategy directly addresses the risk of counterfeit hardware by ensuring the authenticity and security of components.</p>
<p><em>Learning Objective</em>: Identify effective strategies for mitigating counterfeit hardware risks in ML systems.</p></li>
</ol>
<p><a href="#quiz-question-sec-security-privacy-hardwarelevel-security-vulnerabilities-1ab4" class="answer-label">â† Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-security-privacy-ml-systems-become-attack-tools-2f34" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.7</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following best describes the dual-use nature of machine learning in security contexts?</strong></p>
<ol type="a">
<li>ML can only be used for defensive purposes.</li>
<li>ML can be used both to protect systems and to launch attacks.</li>
<li>ML can only be used for offensive purposes.</li>
<li>ML is not relevant to security contexts.</li>
</ol>
<p><em>Answer</em>: The correct answer is B. ML can be used both to protect systems and to launch attacks. This is correct because MLâ€™s capabilities can enhance both defensive and offensive operations, making it a dual-use technology.</p>
<p><em>Learning Objective</em>: Understand the dual-use nature of machine learning in security contexts.</p></li>
<li><p><strong>Explain how machine learning models can be used offensively in cyberattacks.</strong></p>
<p><em>Answer</em>: Machine learning models can be used offensively by automating tasks like reconnaissance, crafting phishing messages, generating exploits, and evading detection systems. For example, large language models can create personalized phishing messages that are more likely to deceive targets. This is important because it shows how ML can enhance the sophistication and effectiveness of attacks.</p>
<p><em>Learning Objective</em>: Describe the offensive applications of machine learning models in cyberattacks.</p></li>
<li><p><strong>In the context of offensive ML applications, what advantage does using ML models provide to attackers?</strong></p>
<ol type="a">
<li>ML models are slower than manual methods.</li>
<li>ML models require more expertise than traditional methods.</li>
<li>ML models are less effective than traditional methods.</li>
<li>ML models can automate and scale attack strategies.</li>
</ol>
<p><em>Answer</em>: The correct answer is D. ML models can automate and scale attack strategies. This is correct because ML models can process large amounts of data quickly and adapt to changing conditions, making them effective tools for scaling attacks.</p>
<p><em>Learning Objective</em>: Identify the advantages of using machine learning models in offensive cyber operations.</p></li>
<li><p><strong>The use of machine learning to evade detection systems by crafting minimally perturbed inputs is known as ______.</strong></p>
<p><em>Answer</em>: adversarial input generation. This technique involves creating inputs that are designed to bypass detection systems by exploiting their decision boundaries.</p>
<p><em>Learning Objective</em>: Recall the concept of adversarial input generation in the context of ML-based attacks.</p></li>
<li><p><strong>How might understanding offensive ML capabilities help in designing better defenses?</strong></p>
<p><em>Answer</em>: Understanding offensive ML capabilities helps in designing better defenses by allowing security professionals to anticipate potential attack vectors and develop strategies to mitigate them. For example, knowing how ML can be used to automate phishing attacks can lead to the development of more robust email filtering systems. This is important because it enables the creation of proactive security measures.</p>
<p><em>Learning Objective</em>: Explain the importance of understanding offensive ML capabilities for defensive strategy development.</p></li>
</ol>
<p><a href="#quiz-question-sec-security-privacy-ml-systems-become-attack-tools-2f34" class="answer-label">â† Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-security-privacy-comprehensive-defense-architectures-48ab" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.8</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following best describes the principle of layered defense in machine learning systems?</strong></p>
<ol type="a">
<li>A single security mechanism that protects against all threats.</li>
<li>A focus on protecting only the data layer of the system.</li>
<li>Multiple independent defensive mechanisms working together to protect against diverse threat vectors.</li>
<li>Relying solely on hardware-based security features.</li>
</ol>
<p><em>Answer</em>: The correct answer is C. Multiple independent defensive mechanisms working together to protect against diverse threat vectors. This approach recognizes that no single mechanism can address all threats, so security emerges from the interaction of complementary protections across different layers.</p>
<p><em>Learning Objective</em>: Understand the concept of layered defense and its application in ML systems.</p></li>
<li><p><strong>Explain how differential privacy contributes to the data layer of a layered defense strategy in ML systems.</strong></p>
<p><em>Answer</em>: Differential privacy ensures that the inclusion or exclusion of a single individualâ€™s data has a limited effect on the modelâ€™s output, thus protecting individual privacy. This is achieved by adding calibrated noise to data queries or model updates, balancing privacy with model utility. In practice, it helps safeguard sensitive information during training, forming a crucial part of the data layer defenses.</p>
<p><em>Learning Objective</em>: Analyze the role of differential privacy in enhancing data security within a layered defense framework.</p></li>
<li><p><strong>True or False: Trusted Execution Environments (TEEs) are primarily used to enhance the security of the data layer in machine learning systems.</strong></p>
<p><em>Answer</em>: False. Trusted Execution Environments (TEEs) are primarily used to enhance the security of the runtime layer by providing isolated execution environments for sensitive computations, ensuring confidentiality and integrity even if the host system is compromised.</p>
<p><em>Learning Objective</em>: Differentiate between the roles of various security mechanisms within the layered defense framework.</p></li>
<li><p><strong>In a production ML system, which layer would most likely employ input validation and output monitoring as part of its defense strategy?</strong></p>
<ol type="a">
<li>Data Layer</li>
<li>Model Layer</li>
<li>Hardware Layer</li>
<li>Runtime Layer</li>
</ol>
<p><em>Answer</em>: The correct answer is D. Runtime Layer. Input validation and output monitoring are measures taken to secure inference operations, ensuring that inputs conform to expected formats and outputs are monitored for anomalies.</p>
<p><em>Learning Objective</em>: Identify the appropriate layer for specific security measures within the layered defense strategy.</p></li>
<li><p><strong>Consider a scenario where an ML system is deployed in a healthcare setting. What trade-offs might be involved in implementing differential privacy and secure model deployment?</strong></p>
<p><em>Answer</em>: Implementing differential privacy in a healthcare setting involves a trade-off between privacy and model accuracy, as increased noise for privacy can degrade accuracy. Secure model deployment may require additional computational resources and can introduce latency, impacting real-time decision-making. Balancing these trade-offs is critical to ensure both patient privacy and system performance.</p>
<p><em>Learning Objective</em>: Evaluate the trade-offs involved in implementing specific security measures in a real-world ML deployment.</p></li>
</ol>
<p><a href="#quiz-question-sec-security-privacy-comprehensive-defense-architectures-48ab" class="answer-label">â† Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-security-privacy-practical-roadmap-8f3a" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.9</strong></summary><div>
<ol type="1">
<li><p><strong>Order the following phases of the ML security roadmap: (1) Baseline Security Foundation, (2) Advanced Defenses and Runtime Protection, (3) Data Privacy and Model Protection.</strong></p>
<p><em>Answer</em>: The correct order is: (1) Baseline Security Foundation, (3) Data Privacy and Model Protection, (2) Advanced Defenses and Runtime Protection. This sequence reflects the roadmapâ€™s progression from basic security measures to more advanced defenses.</p>
<p><em>Learning Objective</em>: Understand the phased approach to securing ML systems and the rationale for their sequence.</p></li>
<li><p><strong>Which of the following is a key focus of the Baseline Security Foundation phase?</strong></p>
<ol type="a">
<li>Implementing adversarial robustness</li>
<li>Deploying federated learning architectures</li>
<li>Establishing role-based access control</li>
<li>Integrating compliance controls</li>
</ol>
<p><em>Answer</em>: The correct answer is C. Establishing role-based access control. This is correct because the Baseline Security Foundation phase focuses on basic security controls like access control to reduce risk.</p>
<p><em>Learning Objective</em>: Identify the primary security measures implemented in the initial phase of the roadmap.</p></li>
<li><p><strong>Explain why it is important to implement a phased approach to securing ML systems.</strong></p>
<p><em>Answer</em>: A phased approach allows organizations to manage complexity and costs while systematically improving security. For example, starting with foundational controls reduces the most common risks, providing a stable base for more advanced defenses. This is important because it ensures security measures are effectively integrated without overwhelming resources.</p>
<p><em>Learning Objective</em>: Understand the benefits and rationale behind a phased security implementation strategy.</p></li>
<li><p><strong>In the Data Privacy and Model Protection phase, which technique is used to ensure privacy while enabling collaborative learning?</strong></p>
<ol type="a">
<li>Federated learning</li>
<li>Differential privacy</li>
<li>Adversarial training</li>
<li>Secure boot processes</li>
</ol>
<p><em>Answer</em>: The correct answer is A. Federated learning. This technique allows for model improvement without sharing sensitive data, ensuring privacy in collaborative learning scenarios.</p>
<p><em>Learning Objective</em>: Identify techniques used for privacy and model protection in the second phase of the roadmap.</p></li>
</ol>
<p><a href="#quiz-question-sec-security-privacy-practical-roadmap-8f3a" class="answer-label">â† Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-security-privacy-fallacies-pitfalls-0c20" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.10</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following statements best describes the fallacy of â€˜security through obscurityâ€™ in machine learning models?</strong></p>
<ol type="a">
<li>Hiding model details provides complete protection against attacks.</li>
<li>Modern attacks can succeed without detailed knowledge of the model.</li>
<li>Security through obscurity is effective when combined with robust defenses.</li>
<li>Obscuring model details is the primary method of securing ML systems.</li>
</ol>
<p><em>Answer</em>: The correct answer is B. Modern attacks can succeed without detailed knowledge of the model. This is correct because attackers often use black-box techniques that donâ€™t require access to model specifics. Hiding details is insufficient for robust security.</p>
<p><em>Learning Objective</em>: Understand why â€˜security through obscurityâ€™ is an ineffective strategy in ML systems.</p></li>
<li><p><strong>True or False: Differential privacy automatically ensures privacy protection in machine learning systems without careful implementation.</strong></p>
<p><em>Answer</em>: False. This is false because differential privacy requires careful implementation and parameter selection to be effective. Poor configurations can lead to negligible protection and degraded model utility.</p>
<p><em>Learning Objective</em>: Recognize the importance of proper implementation in achieving privacy through differential privacy.</p></li>
<li><p><strong>Explain why federated learning does not inherently provide complete privacy protection.</strong></p>
<p><em>Answer</em>: Federated learning keeps data decentralized, which improves privacy, but gradient and model updates can still leak information through inference attacks. Additional safeguards like secure aggregation and differential privacy are needed to ensure true privacy protection.</p>
<p><em>Learning Objective</em>: Identify the limitations of federated learning in providing privacy and the need for additional security measures.</p></li>
<li><p><strong>How does treating security as a system-wide property differ from adding security features to individual components?</strong></p>
<p><em>Answer</em>: Treating security as a system-wide property involves holistic threat modeling and integration of security into every stage of the ML pipeline. This approach addresses attacks that span multiple components, unlike the piecemeal method that fails to consider system interactions and attack vectors.</p>
<p><em>Learning Objective</em>: Understand the importance of a holistic approach to ML security over isolated component security.</p></li>
<li><p><strong>In the context of distributed ML systems, what is a common pitfall related to the attack surface?</strong></p>
<ol type="a">
<li>Assuming that centralized systems have a larger attack surface.</li>
<li>Relying on traditional security measures for distributed systems.</li>
<li>Focusing solely on securing individual components.</li>
<li>Assuming that distributed systems inherently reduce security risks.</li>
</ol>
<p><em>Answer</em>: The correct answer is C. Focusing solely on securing individual components. This is a pitfall because distributed architectures increase the attack surface, requiring comprehensive threat modeling and security coordination across the system.</p>
<p><em>Learning Objective</em>: Recognize the expanded attack surface in distributed ML systems and the need for comprehensive security strategies.</p></li>
</ol>
<p><a href="#quiz-question-sec-security-privacy-fallacies-pitfalls-0c20" class="answer-label">â† Back to Questions</a></p>
</div></details>
</div>
<div id="quiz-answer-sec-security-privacy-summary-831c" class="callout callout-quiz-answer">
<details class="callout-quiz-answer fbx-answer closebutton"><summary><strong>Self-Check: Answer 1.11</strong></summary><div>
<ol type="1">
<li><p><strong>Which of the following best describes a defense-in-depth approach in machine learning systems?</strong></p>
<ol type="a">
<li>Adding security features after deployment</li>
<li>Focusing solely on data encryption</li>
<li>Implementing multiple layers of security throughout the system</li>
<li>Relying on hardware security features exclusively</li>
</ol>
<p><em>Answer</em>: The correct answer is C. Implementing multiple layers of security throughout the system. This approach ensures comprehensive protection by addressing potential vulnerabilities at different layers. Options A, B, and D are incorrect as they represent incomplete or inadequate security strategies.</p>
<p><em>Learning Objective</em>: Understand the concept of defense-in-depth in ML systems.</p></li>
<li><p><strong>Explain the trade-offs involved in implementing privacy-preserving techniques like differential privacy and federated learning in ML systems.</strong></p>
<p><em>Answer</em>: Privacy-preserving techniques such as differential privacy and federated learning introduce trade-offs between data protection and system performance. For example, differential privacy may reduce model accuracy due to noise addition, while federated learning can increase computational overhead and complexity. These trade-offs must be balanced against the need for privacy in sensitive applications.</p>
<p><em>Learning Objective</em>: Analyze the trade-offs of privacy-preserving techniques in ML systems.</p></li>
<li><p><strong>In a production ML system, which context would most likely prioritize adversarial robustness over other security concerns?</strong></p>
<ol type="a">
<li>Healthcare systems</li>
<li>Social media platforms</li>
<li>Financial systems</li>
<li>Autonomous vehicles</li>
</ol>
<p><em>Answer</em>: The correct answer is D. Autonomous vehicles. These systems require high adversarial robustness to ensure safety and reliability in dynamic environments. Options A, B, and C prioritize different security aspects such as compliance, theft prevention, and user data protection.</p>
<p><em>Learning Objective</em>: Identify context-specific security priorities in ML systems.</p></li>
</ol>
<p><a href="#quiz-question-sec-security-privacy-summary-831c" class="answer-label">â† Back to Questions</a></p>
</div></details>
</div>

</section>
</section>


<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "î§‹";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/mlsysbook\.ai\/book\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../../contents/core/ondevice_learning/ondevice_learning.html" class="pagination-link" aria-label="On-Device Learning">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">On-Device Learning</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../../contents/core/robust_ai/robust_ai.html" class="pagination-link" aria-label="Robust AI">
        <span class="nav-page-text">Robust AI</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Â© 2024-2025 Harvard University. Licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC-BY-NC-SA 4.0</a></p>
</div>   
    <div class="nav-footer-center">
<p>Written, edited and curated by Prof.&nbsp;Vijay Janapa Reddi (Harvard University)</p>
</div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/harvard-edge/cs249r_book">
      <i class="bi bi-github" role="img" aria-label="View source on GitHub">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/harvard-edge/cs249r_book">
      <i class="bi bi-star" role="img" aria-label="Star this repository">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>