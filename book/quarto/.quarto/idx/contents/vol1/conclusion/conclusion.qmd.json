{"title":"Conclusion","markdown":{"yaml":{"bibliography":"conclusion.bib","quiz":"footnote_context_quizzes.json","concepts":"conclusion_concepts.yml","glossary":"conclusion_glossary.json"},"headingText":"Conclusion","headingAttr":{"id":"sec-conclusion","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n\n::: {layout-narrow}\n::: {.column-margin}\n_DALL·E 3 Prompt: An image depicting a concluding chapter of an ML systems book, open to a two-page spread. The pages summarize key concepts such as neural networks, model architectures, hardware acceleration, and MLOps. One page features a diagram of a neural network and different model architectures, while the other page shows illustrations of hardware components for acceleration and MLOps workflows. The background includes subtle elements like circuit patterns and data points to reinforce the technological theme. The colors are professional and clean, with an emphasis on clarity and understanding._\n:::\n\n\\noindent\n![](images/png/cover_conclusion.png)\n\n:::\n\n::: {.callout-tip title=\"Learning Objectives\"}\n\n- Synthesize the six core systems engineering principles (measure everything, design for 10x scale, optimize the bottleneck, plan for failure, design cost-consciously, co-design for hardware) into a unified framework that transcends specific ML technologies\n\n- Analyze how systems engineering principles manifest differently across the three critical domains: building technical foundations, engineering for performance at scale, and navigating production reality\n\n- Evaluate trade-offs between deployment contexts (cloud, edge, mobile, embedded) by applying multiple principles simultaneously to assess scalability, efficiency, and reliability requirements\n\n- Assess the evolution from isolated components to integrated ML systems by tracing how data pipelines, training frameworks, model architectures, hardware acceleration, and operational infrastructure interconnect\n\n- Critique the societal implications of ML systems design decisions by examining how technical choices in efficiency, security, and sustainability affect democratization, accessibility, and environmental impact\n\n- Formulate professional strategies for applying systems thinking to emerging challenges in robust AI, compound systems, and the path toward artificial general intelligence\n\n:::\n\n## Synthesizing ML Systems Engineering: From Components to Intelligence {#sec-conclusion-synthesizing-ml-systems-engineering-components-intelligence-f244}\n\nYou have mastered quantitative analysis of systems that seemed opaque at the start. You can now calculate arithmetic intensity and identify whether workloads are memory-bound or compute-bound (@sec-ai-acceleration). You understand why modern training requires thousands of accelerators and how compression techniques achieve 10-50x model size reduction (@sec-model-optimizations). You can design monitoring systems that detect silent failures before they affect users (@sec-ml-operations). This chapter synthesizes these capabilities into six enduring principles that will guide your practice regardless of how specific technologies evolve.\n\nOur progression from data engineering principles through model architectures, optimization techniques, and operational infrastructure has constructed a complete knowledge foundation spanning ML systems engineering. The neural network mathematics established in @sec-dl-primer provides the technical vocabulary that enables all subsequent optimization and deployment discussions: forward propagation defines inference computation, backpropagation enables training, and the interplay between algorithmic complexity and hardware constraints shapes every system design decision.\n\nContemporary artificial intelligence[^fn-ai-systems-view] achievements emerge not from isolated algorithmic innovations, but through careful integration of interacting components that unifies computational theory with engineering practice. This systems perspective positions machine learning within the same engineering principles that built reliable computers, where transformative capabilities arise from careful coordination of many parts working together. The transformer architectures [@vaswani2017attention] enabling large language models exemplify this principle: their practical utility derives from integrating mathematical foundations with distributed training infrastructure, algorithmic optimization techniques, and robust operational frameworks rather than architectural innovation alone.\n\n[^fn-ai-systems-view]: **Artificial Intelligence (Systems Perspective)**: Intelligence emerging from integrated systems rather than individual algorithms. Modern AI applications like GPT-4 combine data pipelines (processing petabytes), distributed training (coordinating thousands of processors), efficient inference (serving millions of requests), security measures (preventing attacks), and governance frameworks (ensuring safety). Success depends on systems engineering excellence across all components.\n\nThree fundamental questions define the boundaries of machine learning systems engineering. First, what enduring principles transcend specific technologies and provide systematic guidance for engineering decisions across deployment contexts, from contemporary production systems to anticipated artificial general intelligence architectures? Second, how do these principles manifest across resource-abundant cloud infrastructures, resource-constrained edge devices, and emerging generative systems? Third, how can this knowledge be applied systematically to create systems that satisfy technical requirements while addressing broader societal objectives and ethical considerations?\n\nOur analysis reflects the systems thinking paradigm that has structured this volume, drawing from established computer systems research and engineering methodology. We systematically derive six fundamental engineering principles from technical concepts established throughout the text: comprehensive measurement, scale-oriented design, bottleneck optimization, systematic failure planning, cost-conscious design, and hardware co-design. These principles constitute a framework for principled decision-making across machine learning systems contexts. We examine their application across three domains that structure contemporary ML systems engineering: establishing technical foundations, engineering for performance at scale, and navigating production deployment realities.\n\nThe analysis examines emerging frontiers where these principles confront their most significant challenges. From developing resilient AI systems that manage failure modes gracefully to deploying artificial intelligence for societal benefit across healthcare, education, and climate science, these engineering principles will determine artificial intelligence's societal impact trajectory. As artificial intelligence systems approach general intelligence capabilities[^fn-agi-systems], the critical question becomes not feasibility, but whether they will be engineered according to established principles of sound systems design and responsible computing.\n\nThe frameworks synthesized in this chapter establish systematic approaches for navigating the rapidly evolving artificial intelligence technology landscape while maintaining focus on fundamental engineering objectives: creating systems that scale effectively, perform reliably under diverse conditions, and address significant societal challenges. The future trajectory of artificial intelligence will be determined not through isolated research contributions, but through systematic application of systems engineering principles by practitioners who integrate technical excellence with operational realities and societal responsibility.\n\n[^fn-agi-systems]: **Artificial General Intelligence (AGI)**: AI systems matching human-level performance across all cognitive tasks. Current estimates suggest AGI would require 10^15-10^17 FLOPS (1000x more than GPT-4), demanding novel distributed architectures, energy-efficient hardware, and infrastructure investments exceeding $1 trillion. The engineering challenge lies not in algorithms but in scaling current ML systems principles to unprecedented computational requirements.\n\nThis synthesis establishes systematic theoretical understanding and provides the conceptual foundation for professional application within machine learning systems as a mature engineering discipline.\n\n## Systems Engineering Principles for ML {#sec-conclusion-systems-engineering-principles-ml-6501}\n\nSix core principles unite the concepts explored throughout this textbook. These principles outlast any particular tool or framework and provide enduring guidance for building today's production systems and tomorrow's artificial general intelligence.\n\n| Principle | Core Question | Key Metric | Chapter Example |\n|:----------|:--------------|:-----------|:----------------|\n| 1. Measure Everything | Where are the bottlenecks? | Roofline operational intensity | @sec-ai-acceleration |\n| 2. Design for 10x Scale | Will it survive production? | Headroom factor | @sec-serving |\n| 3. Optimize the Bottleneck | What limits performance? | Memory bandwidth utilization | @sec-ai-acceleration |\n| 4. Plan for Failure | What happens when components fail? | MTBF, recovery time | @sec-ml-operations |\n| 5. Design Cost-Consciously | What is the TCO? | $/FLOP, $/inference | @sec-efficient-ai |\n| 6. Co-Design for Hardware | Does algorithm match hardware? | TOPS/W, arithmetic intensity | @sec-model-optimizations |\n\n: **Six Core Systems Engineering Principles**: These principles provide enduring guidance regardless of how specific technologies evolve. Each principle connects to a core question engineers must answer, key metrics for measurement, and chapter examples demonstrating application. {#tbl-six-principles}\n\nThese principles map directly onto the AI Triad framework established in @sec-introduction. The Data dimension encompasses Principles 1 (Measure Everything) and 5 (Design Cost-Consciously), since data quality monitoring and cost-effective data management determine learning outcomes. The Algorithms dimension encompasses Principles 3 (Optimize the Bottleneck) and 6 (Co-Design for Hardware), since algorithmic efficiency and hardware alignment determine computational feasibility. The Infrastructure dimension encompasses Principles 2 (Design for 10x Scale) and 4 (Plan for Failure), since robust infrastructure that scales gracefully enables reliable deployment. This mapping reveals why optimizing any single AI Triad component in isolation leads to suboptimal outcomes: the principles themselves are interdependent across the triad's dimensions.\n\n**Principle 1: Measure Everything**\n\nThe measurement frameworks established in @sec-benchmarking-ai, complemented by the monitoring systems from @sec-ml-operations, reinforce a fundamental truth: you cannot optimize what you do not measure. Successful ML systems instrument every component. Four analytical frameworks provide enduring measurement foundations that transcend specific technologies.\n\nRoofline analysis[^fn-roofline-analysis] identifies computational bottlenecks by plotting operational intensity against peak performance. This technique reveals whether systems are memory bound or compute bound, which is essential for optimizing everything from training workloads to edge inference.\n\n[^fn-roofline-analysis]: **Roofline Analysis**: Performance modeling technique developed at UC Berkeley that plots computational intensity (operations per byte) against achievable performance. Reveals whether applications are limited by memory bandwidth or computational throughput, guiding optimization priorities for ML workloads.\n\nCost performance evaluation systematically compares total ownership costs against delivered capabilities, incorporating training expenses, infrastructure requirements, and operational overhead to guide deployment decisions. Systematic benchmarking establishes reproducible measurement protocols that enable fair comparisons across architectures, frameworks, and deployment targets, ensuring optimization efforts target actual rather than perceived bottlenecks. These measurements reveal a critical insight: systems rarely fail at expected loads but when demand exceeds design assumptions by orders of magnitude.\n\n**Principle 2: Design for 10x Scale**\n\nSystems that work in research rarely survive production traffic, requiring design for an order of magnitude more data, users, and computational demands than currently needed[^fn-scale-challenges]. Building on concepts from @sec-ml-systems, this principle manifests across deployment contexts: cloud systems must handle traffic spikes from thousands to millions of users, edge systems need redundancy for network partitions, and embedded systems require graceful degradation under resource exhaustion.\n\n[^fn-scale-challenges]: **10x Scale Design**: Engineering principle that systems must handle 10x their expected load to survive real-world deployment. Netflix's recommendation system scales from handling thousands to millions of concurrent users, while maintaining sub-100ms response times through careful architecture design and predictive scaling.\n\nScale alone, however, provides no value if systems waste resources on non-critical paths.\n\n**Principle 3: Optimize the Bottleneck**\n\nWhile @sec-efficient-ai establishes efficiency principles and @sec-model-optimizations provides optimization techniques, systems analysis reveals that the majority of performance gains come from addressing the primary constraint (recall the roofline analysis in @sec-ai-acceleration where memory-bound workloads saw 5-10x improvements from bandwidth optimization versus only 20-30% from compute optimization): memory bandwidth in training workloads, network latency in distributed inference, or energy consumption in mobile deployment.\n\n**Principle 4: Plan for Failure**\n\nRobustness techniques and security frameworks assume systems will fail, requiring redundancy, monitoring, and recovery mechanisms from the start. Production systems experience component failures, network partitions, and adversarial inputs daily, necessitating circuit breakers[^fn-circuit-breakers], graceful fallbacks, and automated recovery procedures.\n\n[^fn-circuit-breakers]: **Circuit Breakers**: Software design pattern that prevents cascading failures by temporarily blocking requests to failing services. When error rates exceed thresholds (typically 50% over 30 seconds), circuit breakers open to prevent additional load, automatically retrying after cooldown periods to detect service recovery.\n\n**Principle 5: Design Cost-Consciously**\n\nFrom sustainability concerns to operational expenses, every technical decision has economic implications. Optimizing for total cost of ownership[^fn-ml-tco], not just performance, becomes critical when cloud GPU costs can exceed $30,000/month for large models [@ben2019cost], making efficiency optimizations worth millions in operational savings over deployment lifetimes.\n\n[^fn-ml-tco]: **Total Cost of Ownership (TCO) for ML**: Comprehensive cost including training ($100K-$10M for large models), infrastructure (3x training costs annually), data preparation (40-60% of project budgets), operations (monitoring, updates, compliance), and failure costs (downtime averaging $5,600/minute for e-commerce). TCO analysis drives architectural decisions from cloud vs. edge deployment to model compression priorities.\n\n**Principle 6: Co-Design for Hardware**\n\nBuilding on the acceleration techniques from @sec-ai-acceleration, efficient AI systems require algorithm hardware co-optimization, not just individual component excellence. This comprehensive approach encompasses three critical dimensions: algorithm hardware matching ensures computational patterns align with target hardware capabilities (systolic arrays favor dense matrix operations while sparse accelerators require structured pruning patterns), memory hierarchy optimization provides frameworks for analyzing data movement costs and optimizing for cache locality, and energy efficiency modeling incorporates TOPS/W metrics to guide power-conscious design decisions essential for mobile and edge deployment.\n\n## Applying Principles Across Three Critical Domains {#sec-conclusion-applying-principles-across-three-critical-domains-ca7d}\n\nThese six foundational principles apply practically across the ML systems landscape. These principles are not abstract ideals but concrete guides that shaped every technical decision explored throughout our journey. Their manifestation varies by context yet remains consistent in purpose. We examine how they operate across three critical domains that structure ML systems engineering: building robust technical foundations where measurement and co-design establish the groundwork, engineering for performance at scale where optimization and planning enable growth, and navigating production realities where all principles converge under operational constraints.\n\n### Building Technical Foundations {#sec-conclusion-building-technical-foundations-5865}\n\nMachine learning systems engineering rests on solid technical foundations where multiple principles converge.\n\nThe foundation begins with data engineering, where @sec-data-engineering established that data quality determines system quality. This insight cannot be overstated: production ML failures trace more frequently to data issues than to algorithmic limitations. \"Data is the new code\" [@karpathy2017software] for neural networks, and like code, data requires version control, testing, and continuous validation. The data engineering discipline from @sec-data-engineering provides systematic approaches to feature engineering, data validation, and pipeline reliability. Production systems require instrumentation for schema evolution, lineage tracking, and quality degradation detection. When data quality degrades, effects cascade through the entire system, silently eroding accuracy without triggering conventional error alerts, a phenomenon we explored in @sec-introduction when examining how ML systems fail differently from traditional software. This makes data governance both a technical necessity and ethical imperative. The measurement principle manifests through continuous monitoring of distribution shifts, labeling consistency, and pipeline performance.\n\nBuilding on this data foundation, frameworks and training systems embody both scale and co-design principles. The framework ecosystem from @sec-ai-frameworks introduced you to navigating trade-offs between TensorFlow's production maturity and PyTorch's research flexibility. @sec-ai-training then revealed how these frameworks scale beyond single machines, teaching you data parallelism strategies that transform weeks of training into hours through distributed coordination. Framework selection (@sec-ai-frameworks) impacts development velocity and deployment constraints. Specialization from TensorFlow Lite for mobile (@sec-ai-frameworks) to JAX for research (@sec-ai-frameworks) exemplifies hardware co-design. Distributed training through data and model parallelism, mixed precision techniques, and gradient compression all demonstrate designing for scale beyond current needs while optimizing for hardware capabilities.\n\nEfficiency and Optimization (Principle 3: Optimize the Bottleneck): @sec-efficient-ai demonstrates that efficiency determines whether AI moves beyond laboratories to resource-constrained deployment. Neural compression algorithms (pruning, quantization, and knowledge distillation) systematically address bottlenecks (memory, compute, energy) while maintaining performance. This multidimensional optimization requires identifying the limiting factor and addressing it systematically rather than pursuing isolated improvements.\n\n## Engineering for Performance at Scale {#sec-conclusion-engineering-performance-scale-a99a}\n\nThe technical foundations we have examined (data engineering, frameworks, and efficiency) provide the substrate for ML systems. Yet foundations alone do not create value. The second pillar of ML systems engineering transforms these foundations into systems that perform reliably at scale, shifting focus from \"does it work?\" to \"does it work efficiently for millions of users?\" This transition demands new engineering priorities and systematic application of our scaling and optimization principles.\n\n### Model Architecture and Optimization {#sec-conclusion-model-architecture-optimization-4e0b}\n\n@sec-dnn-architectures traced your journey from understanding simple perceptrons (where you first grasped how weighted inputs produce decisions) through convolutional networks that revealed how hierarchical feature extraction mirrors biological vision, to transformer architectures whose attention mechanisms enabled the language understanding powering today's AI assistants. However, architectural innovation alone proves insufficient for production deployment. Optimization techniques from @sec-model-optimizations bridge research architectures and production constraints.\n\nFollowing the hardware co-design principles outlined earlier, three complementary compression approaches demonstrate systematic bottleneck optimization: pruning removes redundant parameters while maintaining accuracy, quantization reduces precision requirements for 4x memory reduction, and knowledge distillation transfers capabilities to compact networks for resource-constrained deployment.\n\nThe Deep Compression pipeline [@han2015deep] exemplifies this systematic integration. Pruning, quantization, and coding combine for 10-50x compression ratios[^fn-mobilenets]. Operator fusion (combining conv-batchnorm-relu sequences) reduces memory bandwidth by 3x, demonstrating how algorithmic and systems optimizations compound when guided by the co-design imperative established in our foundational principles.\n\n[^fn-mobilenets]: **Efficient Architecture Design**: MobileNets [@howard2017mobilenets] achieve 8-9x computation reduction through depthwise separable convolutions, enabling real-time inference on mobile devices. These constraint-driven architectures demonstrate how deployment limitations catalyze algorithmic innovation applicable to all contexts.\n\nThese optimizations validate Principle 3's core insight: identify the bottleneck (memory, compute, or energy), then optimize systematically rather than pursuing isolated improvements.\n\n### Hardware Acceleration and System Performance {#sec-conclusion-hardware-acceleration-system-performance-59cc}\n\n@sec-ai-acceleration shows how specialized hardware transforms computational bottlenecks into acceleration opportunities. GPUs excel at parallel matrix operations, TPUs[^fn-tpu-performance] optimize for tensor workloads, and FPGAs[^fn-fpga-ml] provide reconfigurable acceleration for specific operators.\n\n[^fn-tpu-performance]: **Tensor Processing Unit (TPU)**: Google's custom ASIC designed specifically for neural network operations, achieving significantly better performance-per-watt than contemporary GPUs for ML workloads. TPU v4 pods deliver 1.1 exaflops of peak performance for large-scale model training.\n\n[^fn-fpga-ml]: **Field-Programmable Gate Array (FPGA)**: Reconfigurable hardware that can be optimized for specific ML operators post-manufacturing. Microsoft's Brainwave achieves ultra-low latency inference (sub-millisecond) by customizing FPGA configurations for specific neural network architectures.\n\nBuilding on the co-design framework established previously, software optimizations must align with hardware capabilities through kernel fusion, operator scheduling, and precision selection that balances accuracy with throughput.\n\n@sec-benchmarking-ai establishes benchmarking as the essential feedback loop for performance engineering. MLPerf[^fn-mlperf-impact] provides standardized metrics across hardware platforms, enabling data-driven decisions about deployment trade-offs.\n\n[^fn-mlperf-impact]: **MLPerf**: Industry-standard benchmark suite measuring AI system performance across training and inference workloads. Since 2018, MLPerf [@mattson2020mlperf] has driven hardware innovation, with participating systems showing 2-5x performance improvements across various benchmarks over 4 years while maintaining fair comparisons across vendors.\n\nThis performance engineering foundation enables new deployment paradigms that extend beyond centralized systems to edge and mobile environments.\n\n## Navigating Production Reality {#sec-conclusion-navigating-production-reality-c406}\n\nThe third pillar addresses production deployment realities where all six principles converge under the constraint that systems must serve users reliably, securely, and responsibly.\n\nThe transition from training to serving inverts the fundamental optimization objectives that governed model development. Where training maximizes throughput over days of computation, serving optimizes latency per request under strict time constraints measured in milliseconds. This inversion, explored in depth in @sec-serving, transforms every system design decision. The benchmarking techniques from @sec-benchmarking-ai now target percentile latencies rather than aggregate throughput. The quantization methods from @sec-model-optimizations must be validated not just for accuracy preservation but for calibration with production traffic. A common misconception is that faster hardware automatically means faster serving, but preprocessing and postprocessing often dominate latency: production systems report preprocessing consuming 60-70% of total request time when inference runs on optimized accelerators.\n\nUnderstanding why systems degrade under load requires queuing theory fundamentals that explain nonlinear behavior. The M/M/1 queuing model (derived in @sec-serving) gives average wait time $W = 1/(\\mu - \\lambda)$, where $\\mu$ is service rate and $\\lambda$ is arrival rate. At utilization $\\rho = \\lambda/\\mu = 0.5$, $W = 2/\\mu$ (double the service time); at $\\rho = 0.9$, $W = 10/\\mu$. This hyperbolic relationship explains why systems that perform well at moderate load suddenly violate service level objectives when traffic increases modestly. The measurement principle becomes critical here: tracking p50, p95, and p99 latencies reveals how systems perform across the full range of requests, since mean latency tells little about user experience when one in a hundred users waits 40 times longer than average.\n\nService level objectives connect directly to user experience and business outcomes. Meeting a 100ms p99 latency target requires not just fast models but careful capacity planning based on queuing analysis, appropriate batching strategies matched to traffic patterns, and preprocessing pipelines optimized for the serving context rather than training convenience. These serving realities validate Principle 1 (Measure Everything) in its most demanding form: production systems must instrument every component of the request path to identify actual bottlenecks.\n\nThe operations and deployment landscape demonstrates how MLOps[^fn-mlops] orchestrates the full system lifecycle, from continuous integration pipelines with quality gates to A/B testing frameworks for safe rollout. Edge deployment exemplifies the convergence of multiple principles: balancing privacy benefits against latency constraints while ensuring graceful degradation under network failures.\n\n[^fn-mlops]: **Machine Learning Operations (MLOps)**: Engineering discipline applying DevOps principles to ML systems. Netflix deploys 4,000+ ML model updates daily through automated pipelines, while maintaining 99.99% uptime. MLOps transforms artisanal model development into industrial software engineering, encompassing continuous integration, deployment, monitoring, and governance at production scale.\n\nSecurity and privacy considerations reveal ML's unique vulnerabilities (model extraction, data poisoning, membership inference) requiring layered defenses. Differential privacy provides mathematical guarantees, federated learning enables secure collaboration, and adversarial training builds robustness against attacks that traditional software never faces.\n\nBeyond technical concerns, responsible AI and sustainability considerations broaden cost consciousness beyond computation. Fairness metrics and explainability requirements shape architectural choices from inception. Environmental impact becomes a design constraint: GPT-3's estimated 1,287 MWh training cost [@patterson2021carbon] equals powering 120 homes annually, making efficiency improvements on 6+ billion smartphones more impactful than datacenter optimizations.\n\nResponsible engineering principles connect directly to the six systems principles established earlier. The measurement imperative (Principle 1) requires monitoring not just for performance but for fairness violations: tracking prediction distributions across demographic groups, detecting bias amplification over time, and alerting on unexplained accuracy disparities. Failure planning (Principle 4) must account for silent bias, where systems continue operating while producing discriminatory outcomes that evade conventional error detection. The cost-conscious design principle (Principle 5) expands to include societal costs: a highly efficient system that produces biased outcomes imposes costs on affected populations that no financial metric captures. These connections reveal that responsible AI is not an addition to systems engineering but an integral dimension of it.\n\nProduction reality validates that isolated technical excellence proves insufficient. Systems must integrate operational maturity, security defenses, ethical frameworks, and environmental responsibility to deliver sustained value.\n\n## Future Directions and Emerging Opportunities {#sec-conclusion-future-directions-emerging-opportunities-0840}\n\nHaving established technical foundations, engineered for performance, and navigated production realities, we examine emerging opportunities where the six principles guide future development.\n\nThe convergence of technical foundations, performance engineering, and production reality reveals three emerging frontiers where our established principles face their greatest tests: near-term deployment across diverse contexts, building resilient systems for societal benefit, and engineering the path toward artificial general intelligence.\n\n### Applying Principles to Emerging Deployment Contexts {#sec-conclusion-applying-principles-emerging-deployment-contexts-e1bb}\n\nAs ML systems move beyond research labs, three deployment paradigms test different combinations of our established principles: resource-abundant cloud environments, resource-constrained edge devices, and emerging generative systems.\n\nCloud deployment prioritizes throughput and scalability, achieving high GPU utilization through kernel fusion, mixed precision training, and gradient compression techniques explored in @sec-model-optimizations and @sec-ai-training. Success requires balancing performance optimization with cost efficiency at scale.\n\nIn contrast, mobile and edge systems face stringent power, memory, and latency constraints that demand sophisticated hardware-software co-design. The efficiency techniques from @sec-efficient-ai (depthwise separable convolutions, neural architecture search, and quantization) enable deployment on devices with 100-1000x less computational power than data centers. Edge deployment represents AI's democratization[^fn-ai-democratization]: systems that cannot run on billions of edge devices cannot achieve global impact.\n\n[^fn-ai-democratization]: **AI Democratization**: Making AI accessible beyond tech giants through efficient systems engineering. Mobile-optimized models enable AI on 6+ billion smartphones worldwide, while cloud APIs serve 50+ million developers. Cost reductions from $100,000 to $100 for training specialized models democratize access, but require systematic optimization across hardware, algorithms, and infrastructure to maintain quality at scale.\n\nGenerative AI systems exemplify the principles at unprecedented scale, requiring novel approaches to autoregressive computation, dynamic model partitioning, and speculative decoding. These systems demonstrate how the measurement, optimization, and co-design principles from earlier sections apply to emerging technologies pushing infrastructure boundaries.\n\nOperating under even more extreme constraints, TinyML and embedded systems face kilobyte memory budgets, milliwatt power envelopes, and decade-long deployment lifecycles. Success in these contexts validates the full systems engineering approach: careful measurement reveals actual bottlenecks, hardware co-design maximizes efficiency, and planning for failure ensures reliability despite severe resource limitations. Mobile deployment constraints have driven breakthrough techniques like MobileNets and EfficientNets that benefit all AI deployment contexts, demonstrating how systems constraints catalyze algorithmic innovation.\n\nThese deployment contexts validate our core thesis: success depends on applying the six systems engineering principles systematically rather than pursuing isolated optimizations.\n\n### Building Robust AI Systems {#sec-conclusion-building-robust-ai-systems-827c}\n\nRobustness requires designing for failure from the ground up, Principle 4's core mandate. ML systems face unique failure modes: distribution shifts degrade accuracy, adversarial inputs exploit vulnerabilities, and edge cases reveal training data limitations. Resilient systems combine redundant hardware for fault tolerance, ensemble methods to reduce single-point failures, and uncertainty quantification to enable graceful degradation. As AI systems take on increasingly autonomous roles, planning for failure becomes the difference between safe deployment and catastrophic failure. Volume II explores these robustness techniques in depth.\n\n### AI for Societal Benefit {#sec-conclusion-ai-societal-benefit-daba}\n\nAI's transformative potential across healthcare, climate science, education, and accessibility represents domains where all six principles converge. Climate modeling requires efficient inference (Principle 3: Optimize Bottleneck). Medical AI demands explainable decisions and continuous monitoring (Principle 1: Measure). Educational technology needs privacy-preserving personalization at global scale (Principles 2 and 4: Design for Scale, Plan for Failure). These applications validate that technical excellence alone proves insufficient. Success requires interdisciplinary collaboration among technologists, domain experts, policymakers, and affected communities. Volume II examines these applications in detail.\n\n### The Path to AGI {#sec-conclusion-path-agi-1c6d}\n\nThe compound AI systems[^fn-compound-ai] framework provides the architectural blueprint for advanced intelligence: modular components that can be updated independently, specialized models optimized for specific tasks, and decomposable architectures that enable interpretability and safety through multiple validation layers.\n\n[^fn-compound-ai]: **Compound AI Systems**: Architectures combining multiple specialized models rather than single monolithic systems. Google's PaLM-2 uses separate models for reasoning, memory, and tool use, enabling independent scaling and debugging. This modular approach reduces training costs by 10x while improving reliability through redundancy and specialization, validating systems engineering principles of modularity and fault isolation.\n\nThe engineering challenges ahead require mastery across the full stack we have explored, from data engineering (@sec-data-engineering) and distributed training (@sec-ai-training) to model optimization (@sec-model-optimizations) and operational infrastructure (@sec-ml-operations). These systems engineering principles, not algorithmic breakthroughs, define the path toward artificial general intelligence.\n\nTo put this in systems terms: achieving $10^{17}$ FLOPS would require roughly 10,000 of today's fastest accelerators, interconnected with aggregate bandwidth exceeding 1 PB/s, all coordinated with failure rates demanding automatic recovery every few minutes. The engineering challenge is not algorithmic but infrastructural: our six principles, applied at unprecedented scale.\n\n## Your Journey Forward: Engineering Intelligence {#sec-conclusion-journey-forward-engineering-intelligence-427d}\n\nAt the start of this textbook, we presented artificial intelligence as a transformative force reshaping how we build software systems. You now possess the systems engineering principles to contribute to that transformation.\n\nAdvanced AI systems are built by engineers who understand that intelligence is a systems property, emerging from the integration of components rather than any single breakthrough. Consider GPT-4's success [@openai2023gpt4]: it required robust data pipelines processing petabytes of text (@sec-data-engineering), distributed training infrastructure[^fn-distributed-ml] coordinating thousands of GPUs (@sec-ai-training), efficient architectures leveraging attention mechanisms and mixture-of-experts (@sec-efficient-ai), secure deployment preventing prompt injection attacks, and responsible governance implementing safety filters and usage policies.\n\n[^fn-distributed-ml]: **Distributed ML Systems**: Traditional distributed systems principles (consensus, partitioning, replication) extended for ML workloads. GPT-3 training required 1024 A100 GPUs communicating 175 billion parameters, where network topology and gradient synchronization become critical bottlenecks. Unlike stateless web services, ML systems maintain massive shared state, requiring novel approaches like gradient compression and asynchronous updates.\n\nEvery principle in this text, from measuring everything to co-designing for hardware, represents a tool for building that future.\n\nThe six principles you have mastered transcend specific technologies. As frameworks evolve, hardware advances, and new architectures emerge, these foundational concepts remain constant. They will guide you whether optimizing today's production recommendation systems or architecting tomorrow's compound AI systems approaching general intelligence. The compound AI framework, edge deployment paradigms, and efficiency optimization techniques you have explored represent current instantiations of enduring systems thinking.\n\nBut mastery of technical principles alone proves insufficient. The question confronting our generation is not whether artificial general intelligence will arrive, but whether it will be built well: efficiently enough to democratize access beyond wealthy institutions, securely enough to resist exploitation, sustainably enough to preserve our planet, and responsibly enough to serve all humanity equitably. These challenges demand the full stack of ML systems engineering, technical excellence unified with ethical commitment.\n\nAs you apply these principles to your own engineering challenges, remember that ML systems engineering centers on serving users and society. Every architectural decision, every optimization technique, and every operational practice should ultimately make AI more beneficial, accessible, and trustworthy. Measure your success not only in reduced latency or improved accuracy, but in real-world impact: lives improved, problems solved, capabilities democratized.\n\nThe intelligent systems that will define the coming century await your engineering expertise: climate models predicting extreme weather, medical AI diagnosing rare diseases, educational systems personalizing learning, and assistive technologies empowering billions. You now possess the knowledge to build them: the principles to guide design, the techniques to ensure efficiency, the frameworks to guarantee safety, and the wisdom to deploy responsibly.\n\n## Continuing in Volume II {#sec-conclusion-continuing-volume-ii}\n\nVolume I has deliberately focused on single-machine systems to establish principles you can directly observe and experiment with. Understanding bottlenecks on one machine, whether memory bandwidth limitations, CPU-GPU data transfer overhead, or preprocessing inefficiencies, enables recognition of when and why scaling to multiple machines becomes necessary. The queuing theory, latency analysis, and capacity planning techniques from @sec-serving apply whether serving from a single GPU or a fleet of thousands. The optimization techniques from @sec-model-optimizations produce identical compression ratios regardless of deployment scale. By mastering these foundations on systems you can instrument completely, you develop the diagnostic intuition required for distributed systems where visibility becomes fragmented across nodes.\n\nConsider how each principle transforms at scale: the roofline model must now account for network bandwidth (typically 100-400 GB/s for InfiniBand versus 900 GB/s for HBM3), adding a third ceiling to the analysis. Failure planning shifts from \"if\" to \"when\": with 1000 nodes, mean time between failures drops from months to hours, demanding fundamentally different architectures. Volume II provides the quantitative tools for these analyses.\n\nThis textbook has established the foundational principles of ML systems engineering. Volume II extends these foundations into specialized domains requiring the expertise you have developed:\n\n**Scaling Beyond Single Systems**: Distributed training, fault tolerance, and infrastructure for systems that span thousands of machines.\n\n**Production at Scale**: On-device learning, edge intelligence, and operational challenges when serving millions of users.\n\n**Security and Governance**: Privacy-preserving techniques, adversarial robustness, and the regulatory landscape shaping AI deployment.\n\n**Responsible Impact**: Sustainable AI practices, AI for societal good, and the emerging frontiers that will define the next decade of ML systems.\n\nThe principles you have mastered provide the foundation for these advanced topics. Whether you continue directly to Volume II or apply these foundations in practice first, the systems thinking developed here will guide your engineering decisions.\n\nYour journey as an ML systems engineer begins now. Take the principles you have mastered. Apply them to challenges that matter. Build systems that scale. Create solutions that endure. Engineer intelligence that serves humanity.\n\nThe future of intelligence is not something we will simply witness. It is something we must build. Go build it well.\n\n*Prof. Vijay Janapa Reddi, Harvard University*\n\n::: { .quiz-end }\n:::\n","srcMarkdownNoYaml":"\n\n# Conclusion {#sec-conclusion}\n\n::: {layout-narrow}\n::: {.column-margin}\n_DALL·E 3 Prompt: An image depicting a concluding chapter of an ML systems book, open to a two-page spread. The pages summarize key concepts such as neural networks, model architectures, hardware acceleration, and MLOps. One page features a diagram of a neural network and different model architectures, while the other page shows illustrations of hardware components for acceleration and MLOps workflows. The background includes subtle elements like circuit patterns and data points to reinforce the technological theme. The colors are professional and clean, with an emphasis on clarity and understanding._\n:::\n\n\\noindent\n![](images/png/cover_conclusion.png)\n\n:::\n\n::: {.callout-tip title=\"Learning Objectives\"}\n\n- Synthesize the six core systems engineering principles (measure everything, design for 10x scale, optimize the bottleneck, plan for failure, design cost-consciously, co-design for hardware) into a unified framework that transcends specific ML technologies\n\n- Analyze how systems engineering principles manifest differently across the three critical domains: building technical foundations, engineering for performance at scale, and navigating production reality\n\n- Evaluate trade-offs between deployment contexts (cloud, edge, mobile, embedded) by applying multiple principles simultaneously to assess scalability, efficiency, and reliability requirements\n\n- Assess the evolution from isolated components to integrated ML systems by tracing how data pipelines, training frameworks, model architectures, hardware acceleration, and operational infrastructure interconnect\n\n- Critique the societal implications of ML systems design decisions by examining how technical choices in efficiency, security, and sustainability affect democratization, accessibility, and environmental impact\n\n- Formulate professional strategies for applying systems thinking to emerging challenges in robust AI, compound systems, and the path toward artificial general intelligence\n\n:::\n\n## Synthesizing ML Systems Engineering: From Components to Intelligence {#sec-conclusion-synthesizing-ml-systems-engineering-components-intelligence-f244}\n\nYou have mastered quantitative analysis of systems that seemed opaque at the start. You can now calculate arithmetic intensity and identify whether workloads are memory-bound or compute-bound (@sec-ai-acceleration). You understand why modern training requires thousands of accelerators and how compression techniques achieve 10-50x model size reduction (@sec-model-optimizations). You can design monitoring systems that detect silent failures before they affect users (@sec-ml-operations). This chapter synthesizes these capabilities into six enduring principles that will guide your practice regardless of how specific technologies evolve.\n\nOur progression from data engineering principles through model architectures, optimization techniques, and operational infrastructure has constructed a complete knowledge foundation spanning ML systems engineering. The neural network mathematics established in @sec-dl-primer provides the technical vocabulary that enables all subsequent optimization and deployment discussions: forward propagation defines inference computation, backpropagation enables training, and the interplay between algorithmic complexity and hardware constraints shapes every system design decision.\n\nContemporary artificial intelligence[^fn-ai-systems-view] achievements emerge not from isolated algorithmic innovations, but through careful integration of interacting components that unifies computational theory with engineering practice. This systems perspective positions machine learning within the same engineering principles that built reliable computers, where transformative capabilities arise from careful coordination of many parts working together. The transformer architectures [@vaswani2017attention] enabling large language models exemplify this principle: their practical utility derives from integrating mathematical foundations with distributed training infrastructure, algorithmic optimization techniques, and robust operational frameworks rather than architectural innovation alone.\n\n[^fn-ai-systems-view]: **Artificial Intelligence (Systems Perspective)**: Intelligence emerging from integrated systems rather than individual algorithms. Modern AI applications like GPT-4 combine data pipelines (processing petabytes), distributed training (coordinating thousands of processors), efficient inference (serving millions of requests), security measures (preventing attacks), and governance frameworks (ensuring safety). Success depends on systems engineering excellence across all components.\n\nThree fundamental questions define the boundaries of machine learning systems engineering. First, what enduring principles transcend specific technologies and provide systematic guidance for engineering decisions across deployment contexts, from contemporary production systems to anticipated artificial general intelligence architectures? Second, how do these principles manifest across resource-abundant cloud infrastructures, resource-constrained edge devices, and emerging generative systems? Third, how can this knowledge be applied systematically to create systems that satisfy technical requirements while addressing broader societal objectives and ethical considerations?\n\nOur analysis reflects the systems thinking paradigm that has structured this volume, drawing from established computer systems research and engineering methodology. We systematically derive six fundamental engineering principles from technical concepts established throughout the text: comprehensive measurement, scale-oriented design, bottleneck optimization, systematic failure planning, cost-conscious design, and hardware co-design. These principles constitute a framework for principled decision-making across machine learning systems contexts. We examine their application across three domains that structure contemporary ML systems engineering: establishing technical foundations, engineering for performance at scale, and navigating production deployment realities.\n\nThe analysis examines emerging frontiers where these principles confront their most significant challenges. From developing resilient AI systems that manage failure modes gracefully to deploying artificial intelligence for societal benefit across healthcare, education, and climate science, these engineering principles will determine artificial intelligence's societal impact trajectory. As artificial intelligence systems approach general intelligence capabilities[^fn-agi-systems], the critical question becomes not feasibility, but whether they will be engineered according to established principles of sound systems design and responsible computing.\n\nThe frameworks synthesized in this chapter establish systematic approaches for navigating the rapidly evolving artificial intelligence technology landscape while maintaining focus on fundamental engineering objectives: creating systems that scale effectively, perform reliably under diverse conditions, and address significant societal challenges. The future trajectory of artificial intelligence will be determined not through isolated research contributions, but through systematic application of systems engineering principles by practitioners who integrate technical excellence with operational realities and societal responsibility.\n\n[^fn-agi-systems]: **Artificial General Intelligence (AGI)**: AI systems matching human-level performance across all cognitive tasks. Current estimates suggest AGI would require 10^15-10^17 FLOPS (1000x more than GPT-4), demanding novel distributed architectures, energy-efficient hardware, and infrastructure investments exceeding $1 trillion. The engineering challenge lies not in algorithms but in scaling current ML systems principles to unprecedented computational requirements.\n\nThis synthesis establishes systematic theoretical understanding and provides the conceptual foundation for professional application within machine learning systems as a mature engineering discipline.\n\n## Systems Engineering Principles for ML {#sec-conclusion-systems-engineering-principles-ml-6501}\n\nSix core principles unite the concepts explored throughout this textbook. These principles outlast any particular tool or framework and provide enduring guidance for building today's production systems and tomorrow's artificial general intelligence.\n\n| Principle | Core Question | Key Metric | Chapter Example |\n|:----------|:--------------|:-----------|:----------------|\n| 1. Measure Everything | Where are the bottlenecks? | Roofline operational intensity | @sec-ai-acceleration |\n| 2. Design for 10x Scale | Will it survive production? | Headroom factor | @sec-serving |\n| 3. Optimize the Bottleneck | What limits performance? | Memory bandwidth utilization | @sec-ai-acceleration |\n| 4. Plan for Failure | What happens when components fail? | MTBF, recovery time | @sec-ml-operations |\n| 5. Design Cost-Consciously | What is the TCO? | $/FLOP, $/inference | @sec-efficient-ai |\n| 6. Co-Design for Hardware | Does algorithm match hardware? | TOPS/W, arithmetic intensity | @sec-model-optimizations |\n\n: **Six Core Systems Engineering Principles**: These principles provide enduring guidance regardless of how specific technologies evolve. Each principle connects to a core question engineers must answer, key metrics for measurement, and chapter examples demonstrating application. {#tbl-six-principles}\n\nThese principles map directly onto the AI Triad framework established in @sec-introduction. The Data dimension encompasses Principles 1 (Measure Everything) and 5 (Design Cost-Consciously), since data quality monitoring and cost-effective data management determine learning outcomes. The Algorithms dimension encompasses Principles 3 (Optimize the Bottleneck) and 6 (Co-Design for Hardware), since algorithmic efficiency and hardware alignment determine computational feasibility. The Infrastructure dimension encompasses Principles 2 (Design for 10x Scale) and 4 (Plan for Failure), since robust infrastructure that scales gracefully enables reliable deployment. This mapping reveals why optimizing any single AI Triad component in isolation leads to suboptimal outcomes: the principles themselves are interdependent across the triad's dimensions.\n\n**Principle 1: Measure Everything**\n\nThe measurement frameworks established in @sec-benchmarking-ai, complemented by the monitoring systems from @sec-ml-operations, reinforce a fundamental truth: you cannot optimize what you do not measure. Successful ML systems instrument every component. Four analytical frameworks provide enduring measurement foundations that transcend specific technologies.\n\nRoofline analysis[^fn-roofline-analysis] identifies computational bottlenecks by plotting operational intensity against peak performance. This technique reveals whether systems are memory bound or compute bound, which is essential for optimizing everything from training workloads to edge inference.\n\n[^fn-roofline-analysis]: **Roofline Analysis**: Performance modeling technique developed at UC Berkeley that plots computational intensity (operations per byte) against achievable performance. Reveals whether applications are limited by memory bandwidth or computational throughput, guiding optimization priorities for ML workloads.\n\nCost performance evaluation systematically compares total ownership costs against delivered capabilities, incorporating training expenses, infrastructure requirements, and operational overhead to guide deployment decisions. Systematic benchmarking establishes reproducible measurement protocols that enable fair comparisons across architectures, frameworks, and deployment targets, ensuring optimization efforts target actual rather than perceived bottlenecks. These measurements reveal a critical insight: systems rarely fail at expected loads but when demand exceeds design assumptions by orders of magnitude.\n\n**Principle 2: Design for 10x Scale**\n\nSystems that work in research rarely survive production traffic, requiring design for an order of magnitude more data, users, and computational demands than currently needed[^fn-scale-challenges]. Building on concepts from @sec-ml-systems, this principle manifests across deployment contexts: cloud systems must handle traffic spikes from thousands to millions of users, edge systems need redundancy for network partitions, and embedded systems require graceful degradation under resource exhaustion.\n\n[^fn-scale-challenges]: **10x Scale Design**: Engineering principle that systems must handle 10x their expected load to survive real-world deployment. Netflix's recommendation system scales from handling thousands to millions of concurrent users, while maintaining sub-100ms response times through careful architecture design and predictive scaling.\n\nScale alone, however, provides no value if systems waste resources on non-critical paths.\n\n**Principle 3: Optimize the Bottleneck**\n\nWhile @sec-efficient-ai establishes efficiency principles and @sec-model-optimizations provides optimization techniques, systems analysis reveals that the majority of performance gains come from addressing the primary constraint (recall the roofline analysis in @sec-ai-acceleration where memory-bound workloads saw 5-10x improvements from bandwidth optimization versus only 20-30% from compute optimization): memory bandwidth in training workloads, network latency in distributed inference, or energy consumption in mobile deployment.\n\n**Principle 4: Plan for Failure**\n\nRobustness techniques and security frameworks assume systems will fail, requiring redundancy, monitoring, and recovery mechanisms from the start. Production systems experience component failures, network partitions, and adversarial inputs daily, necessitating circuit breakers[^fn-circuit-breakers], graceful fallbacks, and automated recovery procedures.\n\n[^fn-circuit-breakers]: **Circuit Breakers**: Software design pattern that prevents cascading failures by temporarily blocking requests to failing services. When error rates exceed thresholds (typically 50% over 30 seconds), circuit breakers open to prevent additional load, automatically retrying after cooldown periods to detect service recovery.\n\n**Principle 5: Design Cost-Consciously**\n\nFrom sustainability concerns to operational expenses, every technical decision has economic implications. Optimizing for total cost of ownership[^fn-ml-tco], not just performance, becomes critical when cloud GPU costs can exceed $30,000/month for large models [@ben2019cost], making efficiency optimizations worth millions in operational savings over deployment lifetimes.\n\n[^fn-ml-tco]: **Total Cost of Ownership (TCO) for ML**: Comprehensive cost including training ($100K-$10M for large models), infrastructure (3x training costs annually), data preparation (40-60% of project budgets), operations (monitoring, updates, compliance), and failure costs (downtime averaging $5,600/minute for e-commerce). TCO analysis drives architectural decisions from cloud vs. edge deployment to model compression priorities.\n\n**Principle 6: Co-Design for Hardware**\n\nBuilding on the acceleration techniques from @sec-ai-acceleration, efficient AI systems require algorithm hardware co-optimization, not just individual component excellence. This comprehensive approach encompasses three critical dimensions: algorithm hardware matching ensures computational patterns align with target hardware capabilities (systolic arrays favor dense matrix operations while sparse accelerators require structured pruning patterns), memory hierarchy optimization provides frameworks for analyzing data movement costs and optimizing for cache locality, and energy efficiency modeling incorporates TOPS/W metrics to guide power-conscious design decisions essential for mobile and edge deployment.\n\n## Applying Principles Across Three Critical Domains {#sec-conclusion-applying-principles-across-three-critical-domains-ca7d}\n\nThese six foundational principles apply practically across the ML systems landscape. These principles are not abstract ideals but concrete guides that shaped every technical decision explored throughout our journey. Their manifestation varies by context yet remains consistent in purpose. We examine how they operate across three critical domains that structure ML systems engineering: building robust technical foundations where measurement and co-design establish the groundwork, engineering for performance at scale where optimization and planning enable growth, and navigating production realities where all principles converge under operational constraints.\n\n### Building Technical Foundations {#sec-conclusion-building-technical-foundations-5865}\n\nMachine learning systems engineering rests on solid technical foundations where multiple principles converge.\n\nThe foundation begins with data engineering, where @sec-data-engineering established that data quality determines system quality. This insight cannot be overstated: production ML failures trace more frequently to data issues than to algorithmic limitations. \"Data is the new code\" [@karpathy2017software] for neural networks, and like code, data requires version control, testing, and continuous validation. The data engineering discipline from @sec-data-engineering provides systematic approaches to feature engineering, data validation, and pipeline reliability. Production systems require instrumentation for schema evolution, lineage tracking, and quality degradation detection. When data quality degrades, effects cascade through the entire system, silently eroding accuracy without triggering conventional error alerts, a phenomenon we explored in @sec-introduction when examining how ML systems fail differently from traditional software. This makes data governance both a technical necessity and ethical imperative. The measurement principle manifests through continuous monitoring of distribution shifts, labeling consistency, and pipeline performance.\n\nBuilding on this data foundation, frameworks and training systems embody both scale and co-design principles. The framework ecosystem from @sec-ai-frameworks introduced you to navigating trade-offs between TensorFlow's production maturity and PyTorch's research flexibility. @sec-ai-training then revealed how these frameworks scale beyond single machines, teaching you data parallelism strategies that transform weeks of training into hours through distributed coordination. Framework selection (@sec-ai-frameworks) impacts development velocity and deployment constraints. Specialization from TensorFlow Lite for mobile (@sec-ai-frameworks) to JAX for research (@sec-ai-frameworks) exemplifies hardware co-design. Distributed training through data and model parallelism, mixed precision techniques, and gradient compression all demonstrate designing for scale beyond current needs while optimizing for hardware capabilities.\n\nEfficiency and Optimization (Principle 3: Optimize the Bottleneck): @sec-efficient-ai demonstrates that efficiency determines whether AI moves beyond laboratories to resource-constrained deployment. Neural compression algorithms (pruning, quantization, and knowledge distillation) systematically address bottlenecks (memory, compute, energy) while maintaining performance. This multidimensional optimization requires identifying the limiting factor and addressing it systematically rather than pursuing isolated improvements.\n\n## Engineering for Performance at Scale {#sec-conclusion-engineering-performance-scale-a99a}\n\nThe technical foundations we have examined (data engineering, frameworks, and efficiency) provide the substrate for ML systems. Yet foundations alone do not create value. The second pillar of ML systems engineering transforms these foundations into systems that perform reliably at scale, shifting focus from \"does it work?\" to \"does it work efficiently for millions of users?\" This transition demands new engineering priorities and systematic application of our scaling and optimization principles.\n\n### Model Architecture and Optimization {#sec-conclusion-model-architecture-optimization-4e0b}\n\n@sec-dnn-architectures traced your journey from understanding simple perceptrons (where you first grasped how weighted inputs produce decisions) through convolutional networks that revealed how hierarchical feature extraction mirrors biological vision, to transformer architectures whose attention mechanisms enabled the language understanding powering today's AI assistants. However, architectural innovation alone proves insufficient for production deployment. Optimization techniques from @sec-model-optimizations bridge research architectures and production constraints.\n\nFollowing the hardware co-design principles outlined earlier, three complementary compression approaches demonstrate systematic bottleneck optimization: pruning removes redundant parameters while maintaining accuracy, quantization reduces precision requirements for 4x memory reduction, and knowledge distillation transfers capabilities to compact networks for resource-constrained deployment.\n\nThe Deep Compression pipeline [@han2015deep] exemplifies this systematic integration. Pruning, quantization, and coding combine for 10-50x compression ratios[^fn-mobilenets]. Operator fusion (combining conv-batchnorm-relu sequences) reduces memory bandwidth by 3x, demonstrating how algorithmic and systems optimizations compound when guided by the co-design imperative established in our foundational principles.\n\n[^fn-mobilenets]: **Efficient Architecture Design**: MobileNets [@howard2017mobilenets] achieve 8-9x computation reduction through depthwise separable convolutions, enabling real-time inference on mobile devices. These constraint-driven architectures demonstrate how deployment limitations catalyze algorithmic innovation applicable to all contexts.\n\nThese optimizations validate Principle 3's core insight: identify the bottleneck (memory, compute, or energy), then optimize systematically rather than pursuing isolated improvements.\n\n### Hardware Acceleration and System Performance {#sec-conclusion-hardware-acceleration-system-performance-59cc}\n\n@sec-ai-acceleration shows how specialized hardware transforms computational bottlenecks into acceleration opportunities. GPUs excel at parallel matrix operations, TPUs[^fn-tpu-performance] optimize for tensor workloads, and FPGAs[^fn-fpga-ml] provide reconfigurable acceleration for specific operators.\n\n[^fn-tpu-performance]: **Tensor Processing Unit (TPU)**: Google's custom ASIC designed specifically for neural network operations, achieving significantly better performance-per-watt than contemporary GPUs for ML workloads. TPU v4 pods deliver 1.1 exaflops of peak performance for large-scale model training.\n\n[^fn-fpga-ml]: **Field-Programmable Gate Array (FPGA)**: Reconfigurable hardware that can be optimized for specific ML operators post-manufacturing. Microsoft's Brainwave achieves ultra-low latency inference (sub-millisecond) by customizing FPGA configurations for specific neural network architectures.\n\nBuilding on the co-design framework established previously, software optimizations must align with hardware capabilities through kernel fusion, operator scheduling, and precision selection that balances accuracy with throughput.\n\n@sec-benchmarking-ai establishes benchmarking as the essential feedback loop for performance engineering. MLPerf[^fn-mlperf-impact] provides standardized metrics across hardware platforms, enabling data-driven decisions about deployment trade-offs.\n\n[^fn-mlperf-impact]: **MLPerf**: Industry-standard benchmark suite measuring AI system performance across training and inference workloads. Since 2018, MLPerf [@mattson2020mlperf] has driven hardware innovation, with participating systems showing 2-5x performance improvements across various benchmarks over 4 years while maintaining fair comparisons across vendors.\n\nThis performance engineering foundation enables new deployment paradigms that extend beyond centralized systems to edge and mobile environments.\n\n## Navigating Production Reality {#sec-conclusion-navigating-production-reality-c406}\n\nThe third pillar addresses production deployment realities where all six principles converge under the constraint that systems must serve users reliably, securely, and responsibly.\n\nThe transition from training to serving inverts the fundamental optimization objectives that governed model development. Where training maximizes throughput over days of computation, serving optimizes latency per request under strict time constraints measured in milliseconds. This inversion, explored in depth in @sec-serving, transforms every system design decision. The benchmarking techniques from @sec-benchmarking-ai now target percentile latencies rather than aggregate throughput. The quantization methods from @sec-model-optimizations must be validated not just for accuracy preservation but for calibration with production traffic. A common misconception is that faster hardware automatically means faster serving, but preprocessing and postprocessing often dominate latency: production systems report preprocessing consuming 60-70% of total request time when inference runs on optimized accelerators.\n\nUnderstanding why systems degrade under load requires queuing theory fundamentals that explain nonlinear behavior. The M/M/1 queuing model (derived in @sec-serving) gives average wait time $W = 1/(\\mu - \\lambda)$, where $\\mu$ is service rate and $\\lambda$ is arrival rate. At utilization $\\rho = \\lambda/\\mu = 0.5$, $W = 2/\\mu$ (double the service time); at $\\rho = 0.9$, $W = 10/\\mu$. This hyperbolic relationship explains why systems that perform well at moderate load suddenly violate service level objectives when traffic increases modestly. The measurement principle becomes critical here: tracking p50, p95, and p99 latencies reveals how systems perform across the full range of requests, since mean latency tells little about user experience when one in a hundred users waits 40 times longer than average.\n\nService level objectives connect directly to user experience and business outcomes. Meeting a 100ms p99 latency target requires not just fast models but careful capacity planning based on queuing analysis, appropriate batching strategies matched to traffic patterns, and preprocessing pipelines optimized for the serving context rather than training convenience. These serving realities validate Principle 1 (Measure Everything) in its most demanding form: production systems must instrument every component of the request path to identify actual bottlenecks.\n\nThe operations and deployment landscape demonstrates how MLOps[^fn-mlops] orchestrates the full system lifecycle, from continuous integration pipelines with quality gates to A/B testing frameworks for safe rollout. Edge deployment exemplifies the convergence of multiple principles: balancing privacy benefits against latency constraints while ensuring graceful degradation under network failures.\n\n[^fn-mlops]: **Machine Learning Operations (MLOps)**: Engineering discipline applying DevOps principles to ML systems. Netflix deploys 4,000+ ML model updates daily through automated pipelines, while maintaining 99.99% uptime. MLOps transforms artisanal model development into industrial software engineering, encompassing continuous integration, deployment, monitoring, and governance at production scale.\n\nSecurity and privacy considerations reveal ML's unique vulnerabilities (model extraction, data poisoning, membership inference) requiring layered defenses. Differential privacy provides mathematical guarantees, federated learning enables secure collaboration, and adversarial training builds robustness against attacks that traditional software never faces.\n\nBeyond technical concerns, responsible AI and sustainability considerations broaden cost consciousness beyond computation. Fairness metrics and explainability requirements shape architectural choices from inception. Environmental impact becomes a design constraint: GPT-3's estimated 1,287 MWh training cost [@patterson2021carbon] equals powering 120 homes annually, making efficiency improvements on 6+ billion smartphones more impactful than datacenter optimizations.\n\nResponsible engineering principles connect directly to the six systems principles established earlier. The measurement imperative (Principle 1) requires monitoring not just for performance but for fairness violations: tracking prediction distributions across demographic groups, detecting bias amplification over time, and alerting on unexplained accuracy disparities. Failure planning (Principle 4) must account for silent bias, where systems continue operating while producing discriminatory outcomes that evade conventional error detection. The cost-conscious design principle (Principle 5) expands to include societal costs: a highly efficient system that produces biased outcomes imposes costs on affected populations that no financial metric captures. These connections reveal that responsible AI is not an addition to systems engineering but an integral dimension of it.\n\nProduction reality validates that isolated technical excellence proves insufficient. Systems must integrate operational maturity, security defenses, ethical frameworks, and environmental responsibility to deliver sustained value.\n\n## Future Directions and Emerging Opportunities {#sec-conclusion-future-directions-emerging-opportunities-0840}\n\nHaving established technical foundations, engineered for performance, and navigated production realities, we examine emerging opportunities where the six principles guide future development.\n\nThe convergence of technical foundations, performance engineering, and production reality reveals three emerging frontiers where our established principles face their greatest tests: near-term deployment across diverse contexts, building resilient systems for societal benefit, and engineering the path toward artificial general intelligence.\n\n### Applying Principles to Emerging Deployment Contexts {#sec-conclusion-applying-principles-emerging-deployment-contexts-e1bb}\n\nAs ML systems move beyond research labs, three deployment paradigms test different combinations of our established principles: resource-abundant cloud environments, resource-constrained edge devices, and emerging generative systems.\n\nCloud deployment prioritizes throughput and scalability, achieving high GPU utilization through kernel fusion, mixed precision training, and gradient compression techniques explored in @sec-model-optimizations and @sec-ai-training. Success requires balancing performance optimization with cost efficiency at scale.\n\nIn contrast, mobile and edge systems face stringent power, memory, and latency constraints that demand sophisticated hardware-software co-design. The efficiency techniques from @sec-efficient-ai (depthwise separable convolutions, neural architecture search, and quantization) enable deployment on devices with 100-1000x less computational power than data centers. Edge deployment represents AI's democratization[^fn-ai-democratization]: systems that cannot run on billions of edge devices cannot achieve global impact.\n\n[^fn-ai-democratization]: **AI Democratization**: Making AI accessible beyond tech giants through efficient systems engineering. Mobile-optimized models enable AI on 6+ billion smartphones worldwide, while cloud APIs serve 50+ million developers. Cost reductions from $100,000 to $100 for training specialized models democratize access, but require systematic optimization across hardware, algorithms, and infrastructure to maintain quality at scale.\n\nGenerative AI systems exemplify the principles at unprecedented scale, requiring novel approaches to autoregressive computation, dynamic model partitioning, and speculative decoding. These systems demonstrate how the measurement, optimization, and co-design principles from earlier sections apply to emerging technologies pushing infrastructure boundaries.\n\nOperating under even more extreme constraints, TinyML and embedded systems face kilobyte memory budgets, milliwatt power envelopes, and decade-long deployment lifecycles. Success in these contexts validates the full systems engineering approach: careful measurement reveals actual bottlenecks, hardware co-design maximizes efficiency, and planning for failure ensures reliability despite severe resource limitations. Mobile deployment constraints have driven breakthrough techniques like MobileNets and EfficientNets that benefit all AI deployment contexts, demonstrating how systems constraints catalyze algorithmic innovation.\n\nThese deployment contexts validate our core thesis: success depends on applying the six systems engineering principles systematically rather than pursuing isolated optimizations.\n\n### Building Robust AI Systems {#sec-conclusion-building-robust-ai-systems-827c}\n\nRobustness requires designing for failure from the ground up, Principle 4's core mandate. ML systems face unique failure modes: distribution shifts degrade accuracy, adversarial inputs exploit vulnerabilities, and edge cases reveal training data limitations. Resilient systems combine redundant hardware for fault tolerance, ensemble methods to reduce single-point failures, and uncertainty quantification to enable graceful degradation. As AI systems take on increasingly autonomous roles, planning for failure becomes the difference between safe deployment and catastrophic failure. Volume II explores these robustness techniques in depth.\n\n### AI for Societal Benefit {#sec-conclusion-ai-societal-benefit-daba}\n\nAI's transformative potential across healthcare, climate science, education, and accessibility represents domains where all six principles converge. Climate modeling requires efficient inference (Principle 3: Optimize Bottleneck). Medical AI demands explainable decisions and continuous monitoring (Principle 1: Measure). Educational technology needs privacy-preserving personalization at global scale (Principles 2 and 4: Design for Scale, Plan for Failure). These applications validate that technical excellence alone proves insufficient. Success requires interdisciplinary collaboration among technologists, domain experts, policymakers, and affected communities. Volume II examines these applications in detail.\n\n### The Path to AGI {#sec-conclusion-path-agi-1c6d}\n\nThe compound AI systems[^fn-compound-ai] framework provides the architectural blueprint for advanced intelligence: modular components that can be updated independently, specialized models optimized for specific tasks, and decomposable architectures that enable interpretability and safety through multiple validation layers.\n\n[^fn-compound-ai]: **Compound AI Systems**: Architectures combining multiple specialized models rather than single monolithic systems. Google's PaLM-2 uses separate models for reasoning, memory, and tool use, enabling independent scaling and debugging. This modular approach reduces training costs by 10x while improving reliability through redundancy and specialization, validating systems engineering principles of modularity and fault isolation.\n\nThe engineering challenges ahead require mastery across the full stack we have explored, from data engineering (@sec-data-engineering) and distributed training (@sec-ai-training) to model optimization (@sec-model-optimizations) and operational infrastructure (@sec-ml-operations). These systems engineering principles, not algorithmic breakthroughs, define the path toward artificial general intelligence.\n\nTo put this in systems terms: achieving $10^{17}$ FLOPS would require roughly 10,000 of today's fastest accelerators, interconnected with aggregate bandwidth exceeding 1 PB/s, all coordinated with failure rates demanding automatic recovery every few minutes. The engineering challenge is not algorithmic but infrastructural: our six principles, applied at unprecedented scale.\n\n## Your Journey Forward: Engineering Intelligence {#sec-conclusion-journey-forward-engineering-intelligence-427d}\n\nAt the start of this textbook, we presented artificial intelligence as a transformative force reshaping how we build software systems. You now possess the systems engineering principles to contribute to that transformation.\n\nAdvanced AI systems are built by engineers who understand that intelligence is a systems property, emerging from the integration of components rather than any single breakthrough. Consider GPT-4's success [@openai2023gpt4]: it required robust data pipelines processing petabytes of text (@sec-data-engineering), distributed training infrastructure[^fn-distributed-ml] coordinating thousands of GPUs (@sec-ai-training), efficient architectures leveraging attention mechanisms and mixture-of-experts (@sec-efficient-ai), secure deployment preventing prompt injection attacks, and responsible governance implementing safety filters and usage policies.\n\n[^fn-distributed-ml]: **Distributed ML Systems**: Traditional distributed systems principles (consensus, partitioning, replication) extended for ML workloads. GPT-3 training required 1024 A100 GPUs communicating 175 billion parameters, where network topology and gradient synchronization become critical bottlenecks. Unlike stateless web services, ML systems maintain massive shared state, requiring novel approaches like gradient compression and asynchronous updates.\n\nEvery principle in this text, from measuring everything to co-designing for hardware, represents a tool for building that future.\n\nThe six principles you have mastered transcend specific technologies. As frameworks evolve, hardware advances, and new architectures emerge, these foundational concepts remain constant. They will guide you whether optimizing today's production recommendation systems or architecting tomorrow's compound AI systems approaching general intelligence. The compound AI framework, edge deployment paradigms, and efficiency optimization techniques you have explored represent current instantiations of enduring systems thinking.\n\nBut mastery of technical principles alone proves insufficient. The question confronting our generation is not whether artificial general intelligence will arrive, but whether it will be built well: efficiently enough to democratize access beyond wealthy institutions, securely enough to resist exploitation, sustainably enough to preserve our planet, and responsibly enough to serve all humanity equitably. These challenges demand the full stack of ML systems engineering, technical excellence unified with ethical commitment.\n\nAs you apply these principles to your own engineering challenges, remember that ML systems engineering centers on serving users and society. Every architectural decision, every optimization technique, and every operational practice should ultimately make AI more beneficial, accessible, and trustworthy. Measure your success not only in reduced latency or improved accuracy, but in real-world impact: lives improved, problems solved, capabilities democratized.\n\nThe intelligent systems that will define the coming century await your engineering expertise: climate models predicting extreme weather, medical AI diagnosing rare diseases, educational systems personalizing learning, and assistive technologies empowering billions. You now possess the knowledge to build them: the principles to guide design, the techniques to ensure efficiency, the frameworks to guarantee safety, and the wisdom to deploy responsibly.\n\n## Continuing in Volume II {#sec-conclusion-continuing-volume-ii}\n\nVolume I has deliberately focused on single-machine systems to establish principles you can directly observe and experiment with. Understanding bottlenecks on one machine, whether memory bandwidth limitations, CPU-GPU data transfer overhead, or preprocessing inefficiencies, enables recognition of when and why scaling to multiple machines becomes necessary. The queuing theory, latency analysis, and capacity planning techniques from @sec-serving apply whether serving from a single GPU or a fleet of thousands. The optimization techniques from @sec-model-optimizations produce identical compression ratios regardless of deployment scale. By mastering these foundations on systems you can instrument completely, you develop the diagnostic intuition required for distributed systems where visibility becomes fragmented across nodes.\n\nConsider how each principle transforms at scale: the roofline model must now account for network bandwidth (typically 100-400 GB/s for InfiniBand versus 900 GB/s for HBM3), adding a third ceiling to the analysis. Failure planning shifts from \"if\" to \"when\": with 1000 nodes, mean time between failures drops from months to hours, demanding fundamentally different architectures. Volume II provides the quantitative tools for these analyses.\n\nThis textbook has established the foundational principles of ML systems engineering. Volume II extends these foundations into specialized domains requiring the expertise you have developed:\n\n**Scaling Beyond Single Systems**: Distributed training, fault tolerance, and infrastructure for systems that span thousands of machines.\n\n**Production at Scale**: On-device learning, edge intelligence, and operational challenges when serving millions of users.\n\n**Security and Governance**: Privacy-preserving techniques, adversarial robustness, and the regulatory landscape shaping AI deployment.\n\n**Responsible Impact**: Sustainable AI practices, AI for societal good, and the emerging frontiers that will define the next decade of ML systems.\n\nThe principles you have mastered provide the foundation for these advanced topics. Whether you continue directly to Volume II or apply these foundations in practice first, the systems thinking developed here will guide your engineering decisions.\n\nYour journey as an ML systems engineer begins now. Take the principles you have mastered. Apply them to challenges that matter. Build systems that scale. Create solutions that endure. Engineer intelligence that serves humanity.\n\nThe future of intelligence is not something we will simply witness. It is something we must build. Go build it well.\n\n*Prof. Vijay Janapa Reddi, Harvard University*\n\n::: { .quiz-end }\n:::\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":true,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["../../../filters/sidenote.lua","../../../filters/inject_parts.lua","../../../filters/inject_quizzes.lua","pandoc-ext/diagram","mlsysbook-ext/custom-numbered-blocks"],"title-prefix":"","reference-location":"margin","highlight-style":"../../../assets/styles/custom-code.theme","toc":true,"toc-depth":4,"number-sections":false,"include-in-header":{"text":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css\">\n<link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n<link href=\"https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap\" rel=\"stylesheet\">\n<link rel=\"manifest\" href=\"/site.webmanifest\">\n<link rel=\"apple-touch-icon\" href=\"/assets/images/icons/favicon.png\">\n<meta name=\"theme-color\" content=\"#A51C30\">\n\n<script type=\"module\"  src=\"/tools/scripts/socratiQ/bundle.js\" defer></script>\n<script src=\"/assets/scripts/sidebar-auto-collapse.js\" defer></script>\n<script src=\"/assets/scripts/version-link.js\" defer></script>\n<script src=\"/assets/scripts/subscribe-modal.js\" defer></script>\n"},"citeproc":true,"output-file":"conclusion.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author, Editor & Curator","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Last Updated","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.25","bibliography":["../../../contents/vol1/introduction/introduction.bib","../../../contents/vol1/responsible_engr/responsible_engr.bib","../../../contents/vol1/benchmarking/benchmarking.bib","../../../contents/vol1/data_engineering/data_engineering.bib","../../../contents/vol1/dl_primer/dl_primer.bib","../../../contents/vol1/dnn_architectures/dnn_architectures.bib","../../../contents/vol1/efficient_ai/efficient_ai.bib","../../../contents/vol1/ml_systems/ml_systems.bib","../../../contents/vol1/frameworks/frameworks.bib","../../../contents/vol1/hw_acceleration/hw_acceleration.bib","../../../contents/vol1/ops/ops.bib","../../../contents/vol1/optimizations/optimizations.bib","../../../contents/vol1/training/training.bib","../../../contents/vol1/workflow/workflow.bib","../../../contents/vol1/serving/serving.bib","../../../contents/vol1/conclusion/conclusion.bib","../../../contents/vol2/ops_scale/ops_scale.bib","../../../contents/vol2/edge_intelligence/edge_intelligence.bib","../../../contents/vol2/privacy_security/privacy_security.bib","../../../contents/vol2/responsible_ai/responsible_ai.bib","../../../contents/vol2/robust_ai/robust_ai.bib","../../../contents/vol2/sustainable_ai/sustainable_ai.bib","../../../contents/vol2/ai_for_good/ai_for_good.bib","../../../contents/vol2/frontiers/frontiers.bib","conclusion.bib"],"crossref":{"appendix-title":"Appendix","appendix-delim":":","custom":[{"kind":"float","key":"vid","latex-env":"vid","reference-prefix":"Video"}]},"filter-metadata":{"quiz-config":{"file-pattern":"*_quizzes.json","scan-directory":"../../../contents/vol1","auto-discover-pdf":false},"part-summaries":{"file":"../../../contents/parts/summaries.yml","enabled":true},"mlsysbook-ext/custom-numbered-blocks":{"icon-path":"../../../assets/images/icons/callouts","icon-format":"png","groups":{"quiz-question":{"colors":["F0F0F8","5B4B8A"],"collapse":true},"quiz-answer":{"colors":["E8F2EA","4a7c59"],"collapse":true},"resource-slides":{"colors":["E0F2F1","20B2AA"],"collapse":true,"numbered":false},"resource-videos":{"colors":["E0F2F1","20B2AA"],"collapse":true,"numbered":false},"resource-exercises":{"colors":["E0F2F1","20B2AA"],"collapse":true,"numbered":false},"chapter-connection":{"colors":["FDF2F7","A51C30"],"boxstyle":"foldbox.simple","collapse":true,"numbered":false},"chapter-forward":{"colors":["FDF2F7","A51C30"],"boxstyle":"foldbox.simple","collapse":true,"numbered":false},"chapter-recall":{"colors":["FFF4E6","C06014"],"collapse":true,"numbered":false},"code-listing":{"colors":["F2F4F8","D1D7E0"],"collapse":false,"numbered":false},"definition":{"colors":["F0F4F8","1B4F72"],"collapse":false,"numbered":false},"example":{"colors":["F0F8F6","148F77"],"collapse":false,"numbered":false},"colab-interactive":{"colors":["FFF5E6","FF6B35"],"collapse":false,"numbered":false}},"classes":{"callout-quiz-question":{"label":"Self-Check: Question","group":"quiz-question"},"callout-quiz-answer":{"label":"Self-Check: Answer","group":"quiz-answer"},"callout-resource-slides":{"label":"Listing","group":"resource-slides"},"callout-resource-videos":{"label":"Videos","group":"resource-videos"},"callout-resource-exercises":{"label":"Exercises","group":"resource-exercises"},"callout-chapter-connection":{"label":"Related Topics","group":"chapter-connection"},"callout-code":{"label":"Code","group":"code-listing"},"callout-definition":{"label":"Definition","group":"definition"},"callout-example":{"label":"Example","group":"example"},"callout-colab":{"label":"Interactive Colab","group":"colab-interactive"}}}},"diagram":{"engine":{"dot":false,"mermaid":false,"asymptote":false,"tikz":{"execpath":"lualatex","output-format":"svg","header-includes":["\\usepackage{tikz}","\\usepackage{pgfplots}","\\usepackage{pgf-pie}","\\usepackage{amsmath}","\\usepackage{amssymb}","\\usepackage{xcolor}","\\pgfplotsset{compat=1.9}","\\usepgfplotslibrary{fillbetween}","\\usetikzlibrary{angles}","\\usetikzlibrary{arrows.meta}","\\usetikzlibrary{arrows}","\\usetikzlibrary{backgrounds}","\\usetikzlibrary{bending}","\\usetikzlibrary{calc}","\\usetikzlibrary{shadows.blur}","\\usetikzlibrary{fit}","\\usetikzlibrary{intersections}","\\usetikzlibrary{positioning}","\\usetikzlibrary{shapes.geometric}","\\usetikzlibrary{shapes}","\\usetikzlibrary{quotes}","\\usetikzlibrary{decorations.pathmorphing}","\\usetikzlibrary{decorations.markings}","\\usetikzlibrary{matrix}","\\usepgfplotslibrary{dateplot}","\\usepgfplotslibrary{polar}","\\definecolor{Brown}{rgb}{0.65, 0.16, 0.16}","\\definecolor{BrownL}{rgb}{0.6, 0.4, 0.2}","\\definecolor{BrownLine}{rgb}{0.5, 0.3, 0.1}","\\definecolor{BackColor}{RGB}{255,255,229}","\\definecolor{BackLine}{RGB}{181,181,72}","\\definecolor{BlueD}{RGB}{62,100,125}","\\definecolor{BlueL}{RGB}{209,243,255}","\\definecolor{BlueLine}{RGB}{34,148,189}","\\definecolor{BrownL}{RGB}{233,222,220}","\\definecolor{BrownLine}{RGB}{143,120,116}","\\definecolor{Green}{rgb}{0.0, 0.5, 0.0}","\\definecolor{GreenD}{RGB}{40,117,40}","\\definecolor{GreenL}{RGB}{219,253,166}","\\definecolor{GreenLine}{RGB}{73,89,56}","\\definecolor{OliveL}{RGB}{230,227,191}","\\definecolor{OliveLine}{RGB}{173,166,10}","\\definecolor{OrangeL}{RGB}{250,212,175}","\\definecolor{OrangeLine}{RGB}{255,127,76}","\\definecolor{RedL}{RGB}{253,226,240}","\\definecolor{RedLine}{RGB}{201,20,110}","\\definecolor{Sepia}{rgb}{0.44, 0.26, 0.08}","\\definecolor{TextColor}{RGB}{224,224,224}","\\definecolor{VioletL}{RGB}{247,180,247}","\\definecolor{VioletL2}{RGB}{243,243,255}","\\definecolor{VioletLine}{RGB}{34,125,189}","\\definecolor{VioletLine2}{RGB}{169,136,229}"]}}},"editor":{"render-on-save":true},"_quarto-vars":{"email":{"contact":"vj@eecs.harvard.edu","subject":["MLSys Book"],"info":"mailto:vj@eecs.harvard.edu?subject=\"CS249r%20MLSys%20with%20TinyML%20Book%20-%20\""},"title":{"long":"Machine Learning Systems","short":"Machine Learning Systems"}},"comments":{"hypothesis":{"theme":"clean","openSidebar":false}},"lightbox":true,"mermaid":{"theme":"default"},"theme":{"light":["default","../../../assets/styles/style.scss"],"dark":["default","../../../assets/styles/style.scss","../../../assets/styles/dark-mode.scss"]},"respect-user-color-scheme":true,"pagetitle":"ML Systems Textbook","code-block-bg":true,"code-copy":true,"citation-location":"margin","sidenote":true,"anchor-sections":true,"smooth-scroll":false,"citations-hover":false,"footnotes-hover":false,"toc-expand":true,"toc-title":"On this page","number-depth":3,"quiz":"footnote_context_quizzes.json","concepts":"conclusion_concepts.yml","glossary":"conclusion_glossary.json"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}