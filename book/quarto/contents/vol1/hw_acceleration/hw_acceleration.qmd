---
quiz: hw_acceleration_quizzes.json
concepts: hw_acceleration_concepts.yml
glossary: hw_acceleration_glossary.json
engine: jupyter
---

# Hardware Acceleration {#sec-ai-acceleration}

::: {layout-narrow}
::: {.column-margin}
\chapterminitoc
:::

\noindent
![](images/png/cover_ai_hardware.png){fig-alt="Colorful illustration of a System on Chip design showing specialized machine learning accelerators and chiplets integrated into a processor, with vibrant data streams flowing between neural network nodes."}

:::

## Purpose {.unnumbered}

\begin{marginfigure}
\mlsysstack{90}{35}{25}{35}{30}{0}{0}{0}
\end{marginfigure}

_Why does moving data cost more than computing it?_

The central surprise of modern computing is that *arithmetic is nearly free while memory access is expensive*. In the time it takes to fetch a single value from main memory, a processor could perform thousands of calculations. This inversion, the "Memory Wall," is not an engineering limitation awaiting a fix; it is a physical consequence of the speed of light and the energy cost of moving electrons across silicon. It explains why specialized accelerators exist: GPUs, TPUs, and neural processing units are not merely faster at math but architected specifically to hide, amortize, and minimize the crushing cost of moving data through deep memory hierarchies, massive parallelism, and specialized data paths. It explains why some optimizations that reduce theoretical computation fail to improve actual runtime: if the operation was already memory-bound, computing less changes nothing because the bottleneck was never computation. And it explains why hardware selection cannot be reduced to comparing peak FLOPS—what matters is whether a workload's data movement patterns align with what the hardware was actually designed to accelerate. For the engineer choosing hardware, this means the question is never "which chip is fastest?" but "which chip's memory system best matches my model's access patterns?" A model with large embedding tables and irregular lookups needs a very different accelerator than one performing dense matrix multiplications over compact weight tensors. Getting this match right is the difference between running at 10% of theoretical peak and running at 80%.

::: {.content-visible when-format="pdf"}
\newpage
:::

::: {.callout-tip title="Learning Objectives"}

- Explain why systolic arrays and tensor cores achieve 10–100× better efficiency than general-purpose processors for matrix operations
- Calculate arithmetic intensity and use the roofline model to determine compute-bound versus memory-bound workloads
- Predict performance bottlenecks by quantifying the memory wall: bandwidth limits, energy costs, and cache hierarchy trade-offs
- Select appropriate dataflow strategies (weight-stationary, output-stationary, input-stationary) based on workload reuse priorities
- Analyze compiler optimizations including kernel fusion, tiling, and memory planning for efficient hardware execution
- Evaluate accelerator choices for specific deployment scenarios by reasoning about cost-performance trade-offs
- Identify common pitfalls such as ignoring bandwidth limits, expecting linear scaling, or optimizing for peak FLOPS

:::

<!-- Calculation stencil: PIPO (Purpose → Input → Process → Output).
     Markdown uses only *_str or *_math variables. -->

```{python}
#| echo: false
#| label: chapter-start
from mlsys.registry import start_chapter

start_chapter("vol1:hw_acceleration")
```

## Acceleration Fundamentals {#sec-ai-acceleration-ai-hardware-acceleration-fundamentals-9b28}

\index{D·A·M Taxonomy!machine axis}
We have optimized the **Data** in @sec-data-selection and compressed the **Algorithm** (Model) in @sec-model-compression. Now we turn to the final axis of the D·A·M taxonomy (@sec-introduction): the **Machine**. Hardware acceleration exists because of a striking asymmetry in modern computing: arithmetic is *cheap*, but moving data is *expensive*. In the time a modern GPU computes a thousand floating-point operations, a single value travels from main memory. This inversion, where computation is the abundant resource and bandwidth is the scarce one, is the reason specialized hardware matters for machine learning.

::: {.callout-definition title="Hardware Acceleration"}

***Hardware Acceleration***\index{Hardware Acceleration!definition} is the practice of trading **General-Purpose Programmability** for **Compute Density** to achieve order-of-magnitude efficiency gains on specific workloads. Accelerators eliminate control logic such as branch prediction and out-of-order execution. These features are unnecessary for predictable workloads. This freed silicon area is dedicated to arithmetic units (such as systolic arrays and tensor cores, detailed in @sec-ai-acceleration-systolic-arrays-6fa8 and @sec-ai-acceleration-tensor-cores-771f), achieving efficiency gains bounded only by the **Memory Wall**.

:::

The definition above frames the chapter's central engineering tradeoff. General-purpose processors devote substantial silicon area to branch prediction\index{Branch Prediction!eliminated in accelerators}, speculative execution\index{Speculative Execution!eliminated in accelerators}, and complex cache coherence protocols\index{Cache Coherence!accelerator trade-offs}. Accelerators strip away that generality, filling the die with arithmetic units tuned to the regular, data-parallel patterns that characterize neural network computation. The result is order-of-magnitude improvements in throughput per watt for the workloads that match these patterns.

Hardware alone, however, cannot achieve these gains. The algorithms must be designed to leverage what the hardware offers, and the hardware must be built to accelerate the operations algorithms actually use. This symbiosis motivates a complementary principle: *hardware-software co-design*.

::: {.callout-definition title="Hardware-Software Co-design"}

***Hardware-Software Co-design***\index{Hardware-Software Co-design!principles} is the practice of breaking abstraction layers to expose **Hardware Primitives** directly to **Algorithmic Logic**. By tailoring algorithms to physical constraints (e.g., quantization for INT8 accelerators) and tailoring silicon to algorithmic patterns (e.g., Sparse Tensor Cores), it bypasses the inefficiencies of general-purpose instruction sets.

:::

\index{Quantization!INT8 co-design}\index{Structured Pruning!hardware alignment}
Co-design explains *why* the compression techniques introduced in @sec-model-compression deliver real speedups. Quantization from FP32 to INT8 (as described in @sec-model-compression) yields 2–4× acceleration not because of fewer bits in the abstract, but because accelerators pack 4× more INT8 operations into the same silicon area. Structured pruning improves performance while unstructured pruning often does not, because structured patterns preserve the regular memory access patterns that hardware can optimize. Throughout this chapter, the physical constraints of silicon will reveal *why* some theoretically promising algorithmic optimizations succeed in practice and others fail.

\index{Iron Law!ML systems performance}\index{Amdahl's Law!acceleration ceiling}
Hardware acceleration targets specific terms in the **Iron Law of ML Systems** (@sec-silicon-contract), which decomposes end-to-end time into data volume ($D_{vol}/BW$), computation ($O / R_{peak} \cdot \eta$), and fixed latency ($L_{lat}$). While data selection reduced the total data and model compression reduced the ops per sample, hardware acceleration increases the rate at which those ops execute by maximizing the Throughput and Bandwidth denominators. Yet acceleration has a hard ceiling, established by *Amdahl's Law*[^fn-amdahls-law].

[^fn-amdahls-law]: **Amdahl's Law**\index{Amdahl's Law!etymology}: Named after computer architect Gene Amdahl [@amdahl1967validity], who argued at the 1967 AFIPS Conference that the serial fraction of a program sets an absolute ceiling on parallel speedup---no matter how many processors you add. Its relevance to ML is striking: data loading, Python overhead, and gradient synchronization can negate ever-faster GPUs. Gustafson's Law [@gustafson1988reevaluating] later offered a counterpoint, showing that scaling problem size alongside processor count can circumvent Amdahl's ceiling.

To quantify this ceiling, consider the formalization of Amdahl's Law applied to accelerator speedup.

::: {.callout-notebook title="The Fundamental Limit of Acceleration (Amdahl's Law)"}

Hardware acceleration does not speed up the entire system; it *only speeds up the parallelizable fraction ($p$)*. This is governed by **Amdahl's Law for AI**\index{Amdahl's Law!parallel fraction}\index{Parallel Computing!Amdahl's Law} [@amdahl1967validity], formalized in @eq-amdahl:

$$ Speedup = \frac{1}{(1 - p) + \frac{p}{S}} $$ {#eq-amdahl}

*   **$p$ (Parallel Fraction):** The matrix multiplications (typically 90–99% of an ML workload).
*   **$S$ (Speedup):** The raw speed advantage of the GPU/TPU over the CPU (typically 100x-1000x).
*   **$1-p$ (Serial Fraction):** Data loading, Python overhead, and kernel launch latency.\index{Serial Fraction!Amdahl bottleneck}\index{Kernel Launch Latency!serial overhead}

**The Pitfall:** If data loading takes 10% of the time ($p=0.9$), even an **infinite speed** accelerator ($S=\infty$) can only achieve a **10x** total speedup. The "boring" serial part dominates the "exciting" AI part.
:::

\index{Acceleration Wall!diminishing returns}
Amdahl's Law is not merely theoretical: it explains *why* many GPU upgrades disappoint in practice. The following heatmap (@fig-iron-law-heatmap) visualizes the *Acceleration Wall*—the diminishing returns from faster hardware when serial bottlenecks persist—showing that unless your workload is highly parallelizable ($p > 0.99$), investing in faster hardware yields diminishing returns. The contour values are illustrative ranges for intuition.

```{python}
#| label: fig-iron-law-heatmap
#| echo: false
#| fig-cap: "**The Iron Law Heatmap**: Total system speedup as a function of Accelerator Speed ($S$) and Parallel Fraction ($p$). The 'Acceleration Wall' at the top reveals that if a workload is even slightly serial ($p < 0.9$), increasing hardware speed yields almost no benefit. Contours span roughly 1×–500× speedup."
#| fig-alt: "Heatmap of Speedup vs Accelerator Speed and Parallel Fraction. High speedup (green/yellow) is only achieved in the bottom right corner where Parallel Fraction is near 1.0. The rest of the map is dominated by blue (low speedup), showing the serial bottleneck."

import sys
import os
import numpy as np
import matplotlib.colors as mcolors

sys.path.insert(0, ".")
from mlsys import viz

fig, ax, COLORS, plt = viz.setup_plot()

# =============================================================================
# PLOT: The Iron Law Heatmap
# =============================================================================
S_vals = np.logspace(0, 3, 100)
P_vals = np.linspace(0.8, 0.999, 100)
S_grid, P_grid = np.meshgrid(S_vals, P_vals)
Speedup = 1 / ((1 - P_grid) + (P_grid / S_grid))

levels = [1, 2, 5, 10, 20, 50, 100, 200, 500]
norm = mcolors.LogNorm(vmin=1, vmax=500)

cf = ax.contourf(S_grid, P_grid, Speedup, levels=levels, cmap='RdYlBu_r', norm=norm, alpha=0.8)
cs = ax.contour(S_grid, P_grid, Speedup, levels=levels, colors='white', linewidths=0.8, alpha=0.6)
ax.clabel(cs, inline=1, fontsize=8, fmt='%gx', colors='black')

ax.set_xscale('log')
ax.set_xlabel('Accelerator Raw Speedup (S)')
ax.set_ylabel('Parallelizable Fraction (p)')

ax.text(100, 0.98, "Compute Bound", color='black', ha='center', va='top', fontweight='bold', fontsize=9, bbox=dict(facecolor='white', alpha=0.8, edgecolor='none', pad=0.5))
ax.text(100, 0.82, "Serial Bound", color='white', ha='center', va='bottom', fontweight='bold', fontsize=9, bbox=dict(facecolor='black', alpha=0.6, edgecolor='none', pad=0.5))
plt.show()
```

Before examining specific hardware architectures, test your intuition about these physical limits.

::: {.callout-checkpoint title="The Parallelism Gate" collapse="false"}
Hardware speedups are capped by sequential bottlenecks.

**Amdahl's Reality**

- [ ] **Serial Bottlenecks**: Why does a 1,000× faster GPU only speed up training by 5× if data loading is slow? (Because $Speedup \le 1/(1-p)$).
- [ ] **Workload Variation**: Why does ResNet (compute-bound) scale better than MobileNet (latency-bound)? (ResNet spends more time in parallelizable matrix math).\index{ResNet-50!compute-bound workload}\index{MobileNet!latency-bound workload}
:::

To see Amdahl's Law in action, consider how the parallel fraction $p$ differs dramatically between workload archetypes on the same hardware.

```{python}
#| label: amdahl-h100-calc
#| echo: false
# ┌─────────────────────────────────────────────────────────────────────────────
# │ AMDAHL'S LAW ON H100
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: "Amdahl's Law on H100" lighthouse callout
# │
# │ Why: Demonstrates why serial bottlenecks cap total speedup regardless of
# │      accelerator speed. ResNet (95% parallel) gets ~20x speedup; GPT-2
# │      (80% parallel) gets only 5x despite same hardware. This explains why
# │      LLM optimization focuses on reducing serial fraction.
# │
# │ Imports: mlsys.constants (H100_FLOPS_INT8), mlsys.formatting (fmt)
# │ Exports: amdahl_*_str, hw_speedup_str, h100_tflops_int8
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.formatting import fmt, check
from mlsys.constants import (
    H100_FLOPS_INT8, TFLOPs, second,
    BILLION, MILLION, TRILLION, THOUSAND
)

# ┌── P.I.C.O. ISOLATED SCENARIO ───────────────────────────────────────────────
class AmdahlH100:
    """
    Namespace for Amdahl's Law on H100.
    Scenario: Comparing speedup for Compute-Bound (ResNet) vs Memory-Bound (GPT-2).
    """

    # ┌── 1. PARAMETERS (Inputs) ───────────────────────────────────────────────
    hw_speedup_factor = 500.0  # H100 vs CPU matmul

    # Workload Parallel Fractions (p)
    p_resnet = 0.95  # 95% parallel (Compute Bound)
    p_gpt2 = 0.80    # 80% parallel (Bandwidth Bound / Serial Overhead)

    # ┌── 2. CALCULATION (The Physics) ─────────────────────────────────────────
    # Amdahl's Law: Speedup = 1 / ((1-p) + (p/s))

    def calc_speedup(p, s):
        serial = 1 - p
        parallel_component = p / s
        return 1 / (serial + parallel_component)

    speedup_resnet = calc_speedup(p_resnet, hw_speedup_factor)
    speedup_gpt2 = calc_speedup(p_gpt2, hw_speedup_factor)

    # Theoretical ceiling (if s -> infinity)
    ceiling_gpt2 = 1 / (1 - p_gpt2)

    # ┌── 3. INVARIANTS (Guardrails) ───────────────────────────────────────────
    check(speedup_resnet >= speedup_gpt2 * 3,
          f"ResNet speedup ({speedup_resnet:.1f}x) should be much higher than GPT-2 ({speedup_gpt2:.1f}x).")
    check(speedup_gpt2 <= ceiling_gpt2, "Speedup cannot exceed theoretical ceiling.")

    # ┌── 4. OUTPUTS (Formatting) ──────────────────────────────────────────────
    # Hardware context
    h100_tflops_int8 = f"{H100_FLOPS_INT8.to(TFLOPs/second).magnitude:,.0f}"
    hw_speedup_str = fmt(hw_speedup_factor, precision=0, commas=False)

    # ResNet
    p_resnet_str = fmt(p_resnet, precision=2, commas=False)
    p_resnet_pct_str = fmt(p_resnet*100, precision=0, commas=False)
    serial_resnet_str = fmt(1-p_resnet, precision=2, commas=False)
    serial_resnet_pct_str = fmt((1-p_resnet)*100, precision=0, commas=False)
    p_resnet_per_s_str = fmt(p_resnet / hw_speedup_factor, precision=4, commas=False)
    amdahl_resnet_str = fmt(speedup_resnet, precision=1, commas=False)
    amdahl_resnet_round_str = fmt(speedup_resnet, precision=0, commas=False)

    # GPT-2
    p_gpt2_str = fmt(p_gpt2, precision=2, commas=False)
    serial_gpt2_str = fmt(1-p_gpt2, precision=2, commas=False)
    serial_gpt2_pct_str = fmt((1-p_gpt2)*100, precision=0, commas=False)
    p_gpt2_per_s_str = fmt(p_gpt2 / hw_speedup_factor, precision=4, commas=False)
    amdahl_gpt2_str = fmt(speedup_gpt2, precision=1, commas=False)
    amdahl_gpt2_ceil_str = fmt(ceiling_gpt2, precision=0, commas=False)

# ┌── EXPORTS (Bridge to Text) ─────────────────────────────────────────────────
h100_tflops_int8 = AmdahlH100.h100_tflops_int8
hw_speedup_str = AmdahlH100.hw_speedup_str
p_resnet_str = AmdahlH100.p_resnet_str
p_resnet_pct_str = AmdahlH100.p_resnet_pct_str
serial_resnet_str = AmdahlH100.serial_resnet_str
serial_resnet_pct_str = AmdahlH100.serial_resnet_pct_str
p_resnet_per_s_str = AmdahlH100.p_resnet_per_s_str
amdahl_resnet_str = AmdahlH100.amdahl_resnet_str
amdahl_resnet_round_str = AmdahlH100.amdahl_resnet_round_str
p_gpt2_str = AmdahlH100.p_gpt2_str
serial_gpt2_str = AmdahlH100.serial_gpt2_str
serial_gpt2_pct_str = AmdahlH100.serial_gpt2_pct_str
p_gpt2_per_s_str = AmdahlH100.p_gpt2_per_s_str
amdahl_gpt2_str = AmdahlH100.amdahl_gpt2_str
amdahl_gpt2_ceil_str = AmdahlH100.amdahl_gpt2_ceil_str
```

::: {.callout-lighthouse #lighthouse-amdahl-h100 title="Amdahl's Law on H100"}

**ResNet-50 inference on NVIDIA H100:**

- H100 delivers S = `{python} hw_speedup_str`× speedup over CPU for matrix multiply (`{python} h100_tflops_int8` TOPS INT8 vs. ~8 TOPS on baseline CPU without AMX extensions)
- Typical inference has P = `{python} p_resnet_str` (`{python} p_resnet_pct_str`% parallelizable, `{python} serial_resnet_pct_str`% serial: data loading, preprocessing, postprocessing)

Speedup = 1 / ((1-`{python} p_resnet_str`) + `{python} p_resnet_str` / `{python} hw_speedup_str`) = 1 / (`{python} serial_resnet_str` + `{python} p_resnet_per_s_str`) ≈ `{python} amdahl_resnet_str`×

Despite a `{python} hw_speedup_str`× hardware advantage, total system speedup is only **`{python} amdahl_resnet_round_str`×**. The `{python} serial_resnet_pct_str`% serial fraction caps practical gains.

**Contrast with GPT-2 (autoregressive):**

- Same H100, but GPT-2 token generation has P = `{python} p_gpt2_str` (`{python} serial_gpt2_pct_str`% serial: KV-cache updates, sampling, Python overhead)

Speedup = 1 / ((1-`{python} p_gpt2_str`) + `{python} p_gpt2_str` / `{python} hw_speedup_str`) = 1 / (`{python} serial_gpt2_str` + `{python} p_gpt2_per_s_str`) ≈ `{python} amdahl_gpt2_str`×

The *Bandwidth Hog* archetype suffers more from serial bottlenecks. Even infinite accelerator speed yields only $1/(1-p)$ = `{python} amdahl_gpt2_ceil_str`× maximum speedup. This is *why* LLM inference optimization focuses on reducing the serial fraction (batching, speculative decoding) rather than raw hardware speed.
:::

These examples reveal that the critical question for any hardware optimization is not "how fast is the chip?" but rather: *is this workload limited by how fast we can compute, or how fast we can move data?* The answer determines which accelerator to choose, which optimizations matter, and whether a 10× more powerful chip will actually help. The *roofline model* (introduced formally in @sec-system-foundations-roofline-model-5f7c and applied to AI workloads in @sec-ai-acceleration-measuring-efficiency) provides the analytical framework for answering this question. It plots an operation's *arithmetic intensity*[^fn-arithmetic-intensity] — defined as the ratio of floating-point operations to bytes of memory traffic (FLOP/byte) — against hardware capabilities, revealing whether performance is capped by compute or bandwidth. A dense matrix multiplication with high arithmetic intensity benefits from more TFLOPS; a LayerNorm with low arithmetic intensity benefits from more memory bandwidth. ResNet-50's convolutions are compute-bound while GPT-2's attention layers are memory-bound, and this distinction is precisely *why* these architectures require different optimization strategies.

[^fn-arithmetic-intensity]: **Arithmetic Intensity**\index{Arithmetic Intensity!etymology}: Also called *operational intensity*. Formalized as the x-axis of the roofline model by Williams, Waterman, and Patterson [@williams2009roofline]. Expressed in FLOPs per byte of DRAM traffic, it captures a fundamental tension: computation is cheap but data movement is expensive. A dense matrix multiply achieves high arithmetic intensity (many FLOPs per byte loaded); a vector addition achieves low intensity (one FLOP per byte). This single metric determines whether more compute or more bandwidth will improve performance.

With this analytical lens in place, the chapter proceeds through four major topics. First, we trace the historical evolution of domain-specific architectures, from floating-point coprocessors through graphics processors to contemporary AI accelerators. Second, we examine the computational primitives that characterize ML workloads (matrix multiplication, vector operations, and nonlinear activation functions) and analyze how specialized hardware optimizes these operations through innovations such as systolic arrays and tensor cores. Third, we turn to memory hierarchy design, where data movement energy costs exceeding computation costs by more than 100× make on-chip buffer optimization and high-bandwidth memory interfaces critical. Fourth, the software stack: compiler optimization and runtime system support determine the extent to which theoretical hardware capabilities translate into measurable performance. Throughout, the focus remains on single-machine systems; multi-machine coordination constitutes an advanced topic beyond this scope.

The Amdahl's Law analysis and roofline framework establish the analytical tools; the rest of the chapter examines the hardware that these tools diagnose. We begin with the question that precedes all architecture: *why* did specialized hardware emerge, and what recurring design patterns does that history reveal?

## Hardware Specialization {#sec-ai-acceleration-evolution-hardware-specialization-fdb7}

\index{Hardware Specialization!evolution}
The definitions above establish *what* hardware acceleration achieves. Understanding *why* these architectural choices emerged requires tracing their historical development. Computing architectures follow a recurring pattern: as workloads grow in complexity, general-purpose processors become inefficient, prompting specialized hardware development. Machine learning acceleration represents the latest stage in this evolution, following a trajectory observed in floating-point arithmetic, graphics processing, and digital signal processing. Understanding this history serves a practical purpose, since the architectural innovations that addressed floating-point bottlenecks in the 1980s, graphics throughput in the 1990s, and media processing in the 2000s inform today's AI accelerator designs. Each era confronted the same constraint introduced in the Purpose section: data movement costs dominate computation costs, and specialization succeeds by minimizing unnecessary data movement.

Modern ML accelerators (GPUs with tensor cores, Google's TPUs[^fn-hwacc-tpu], Apple's Neural Engine) emerged from these established architectural principles. This section traces the evolution through four phases: specialized computing origins, parallel graphics processing, domain-specific architectures, and the emergence of ML-specific hardware. Each phase reveals design principles that remain relevant for understanding and optimizing contemporary AI systems. The magnitude of the gains from domain-specific design became unmistakable in 2015, when Google's first TPU delivered an *efficiency shock* that reshaped the industry's approach to AI hardware.

::: {.callout-example title="The TPUv1 vs. K80 Efficiency Shock"}
**The Comparison**: In 2015, Google deployed its first Tensor Processing Unit (TPUv1)\index{TPU!v1 efficiency shock} and compared it to the dominant GPU of the era, the NVIDIA K80\index{NVIDIA!K80}.

**The Shock**: The TPUv1 was not just slightly faster; it was **15×–30× faster** on inference workloads and achieved **30×–80× better performance-per-watt**.

**The Reason**: The K80 was a general-purpose processor (good for graphics, physics, diverse math). The TPU was a **Domain-Specific Architecture (DSA)**\index{Domain-Specific Architecture!definition} built for *one thing*: 8-bit integer matrix multiplication\index{INT8!TPU optimization}. It stripped away caches, branch prediction, and out-of-order execution logic to fill the chip with pure arithmetic units (Systolic Arrays)\index{Systolic Arrays!TPU design}.

**The Legacy**: This result ended the "General Purpose" era for AI. It proved that tailoring silicon to the **Algorithmic Primitive** (Matrix Multiply) yields order-of-magnitude gains that Moore's Law alone could not deliver for decades.
:::

[^fn-hwacc-tpu]: **TPU Origins**: Google secretly developed the Tensor Processing Unit (TPU) starting in 2013 when they realized CPUs could not handle the computational demands of their neural networks. The project was led by Norman Jouppi, a Google Distinguished Engineer and former HP Labs researcher whose earlier work on memory hierarchies and RISC processors had already shaped a generation of computer architecture. Jouppi's 2017 paper documenting the TPUv1 [@jouppi2017datacenter] became one of the most cited hardware architecture papers of the decade, establishing the blueprint for domain-specific AI accelerators.

Hardware specialization improves performance by implementing frequent patterns in dedicated circuits, but introduces tradeoffs in flexibility, silicon area, and programming complexity. The principles that shaped early floating-point and graphics accelerators now inform AI hardware design.

### Specialized Computing {#sec-ai-acceleration-specialized-computing-22ce}

Hardware specialization emerges when specific computational patterns become the primary system bottleneck, preventing general-purpose processors from scaling efficiently. Historically, this progression follows three distinct phases: the *Precision Bottleneck* (scalar floating-point), the *Throughput Bottleneck* (parallel graphics), and the *Integration Bottleneck* (memory-compute locality).

\index{Floating-Point Unit!precision bottleneck}
The first phase, the Precision Bottleneck, occurred when scientific and engineering applications required high-precision decimal math that general-purpose CPUs performed poorly. In the late 1970s, CPUs typically emulated floating-point operations in software, requiring hundreds of cycles for a single multiplication. This scalar inefficiency led to the first major instance of hardware specialization: the mathematics coprocessor.

The Intel 8087\index{Intel 8087!floating-point coprocessor}\index{Floating-Point Unit!history} (1980)[^fn-intel-8087] addressed this bottleneck by offloading arithmetic-intensive tasks to a dedicated unit. By implementing floating-point logic in hardware rather than software emulation, the 8087 achieved up to 100$\times$ performance gains for scientific workloads [@fisher_8087_1981]. This established a core principle: when a specific data type or operation consumes the majority of execution cycles, moving it to specialized silicon provides 10–100× improvements.

[^fn-intel-8087]: **Intel 8087 Impact**: The 8087 coprocessor transformed scientific computing by providing dedicated hardware for the IEEE 754 floating-point standard. This success established the economic model for hardware specialization: premium pricing for dramatic performance jumps in specific domains (CAD, simulation).

As specialized functions like floating-point math proved their value, they followed a recurring pattern of **integration**. The Intel 486DX (1989) moved the FPU directly onto the CPU die, eliminating the off-chip communication latency and making high-precision math a standard feature rather than an optional accelerator [@patterson2021hardware]. This cycle (specialization to solve a bottleneck, followed by integration into the general-purpose stack) repeats across every era of hardware evolution.

The progression from specialization to integration has shaped modern computing. Each domain (graphics, signal processing, machine learning) introduced specialized architectures that were later absorbed into general-purpose platforms.

To see this recurring cycle of specialization and integration in action, follow the progression in @fig-timeline from left to right: each era produced accelerators addressing the dominant computational bottleneck of its period. The capabilities enabling today's real-time translation, recommendations, and on-device inference build directly on principles established in these earlier specialization waves.

::: {#fig-timeline fig-env="figure" fig-pos="htb" fig-cap="**Hardware Specialization Timeline.** Computing architectures progressively incorporate specialized accelerators to address emerging performance bottlenecks, from floating-point units to graphics processors and machine learning accelerators. Each era produced hardware tailored to the dominant computational patterns of its period." fig-alt="Timeline spanning 1980s to 2020s showing hardware evolution: floating-point units, GPUs with hardware transform and lighting, media codecs, TPUs with tensor cores, and application-specific AI engines."}
```{.tikz}
\begin{tikzpicture}[font=\usefont{T1}{phv}{m}{n}\small]
\tikzset{
  Box/.style={inner xsep=1pt,
    draw=none,node distance=3mm,
    fill=#1,align=flush center,
    anchor=west,
    text width=35mm,
    minimum width=35mm, minimum height=10mm
  },
  Box/.default=red
}
\definecolor{col1}{RGB}{128, 179, 255}
\definecolor{col2}{RGB}{255, 255, 128}
\definecolor{col3}{RGB}{204, 255, 204}
\definecolor{col4}{RGB}{230, 179, 255}
\definecolor{col5}{RGB}{255, 153, 204}
\definecolor{col6}{RGB}{245, 82, 102}
\definecolor{col7}{RGB}{255, 102, 102}
\node[Box={col1}](B1){1980s};
\node[Box={col2!},right=of B1](B2){1990s};
\node[Box={col3},right=of B2](B3){2000s};
\node[Box={col4},right=of B3](B4){2010s};
\node[Box={col5},right=of B4](B5){2020s};
\foreach \x in{1,2,...,5}
\draw[dashed,thick,-latex](B\x)--++(270:8.5);
\path[red]([yshift=-8mm]B1.south west)coordinate(P)-|coordinate(K)(B5.south east);
\draw[line width=2pt,-latex](P)--(K)--++(0:3mm);
%
\node[Box={col1!50},below=2 of B1](BB1){Floating-Point \&\\Signal Processing};
\node[Box={col1!50},below=of BB1](BB2){Intel 8087 FPU\\(1980)};
\node[Box={col1!50},below=of BB2](BB3){Texas Instruments\\TMS32010 DSP (1983)};
\node[Box={col1!50},below=of BB3](BB4){Integration of FPU\\into Intel 486DX\\(1989)};
%
\node[Box={col2!50},below=2 of B2](2BB1){3D Graphics \&\\Multimedia};
\node[Box={col2!50},below=of 2BB1](2BB2){Introduction of\\Early GPUs};
\node[Box={col2!50},below=of 2BB2](2BB3){NVIDIA GeForce 256 --\\First GPU with\\Hardware T\&L (1999)};
\node[Box={col2!50},below=of 2BB3](2BB4){Rise of SIMD\\Processing Units};
%
\node[Box={col3!50},below=2 of B3](3BB1){Real-time Media\\Coding \&\\Network Processing};
\node[Box={col3!50},below=of 3BB1](3BB2){Media Codecs\\(H.264, MP3)};
\node[Box={col3!50},below=of 3BB2](3BB3){Intel IXP2800\\Network Processor};
\node[Box={col3!50},below=of 3BB3](3BB4){Dedicated hardware\\for streaming\\and encoding};
%
\node[Box={col4!50},below=2 of B4](4BB1){Deep Learning\\Tensor Operations};
\node[Box={col4!50},below=of 4BB1](4BB2){Google TPU v1 for\\ML Inference (2015)};
\node[Box={col4!50},below=of 4BB2](4BB3){NVIDIA Tensor Cores\\for DL Acceleration};
\node[Box={col4!50},below=of 4BB3](4BB4){AI-specific memory\\optimizations};
%
\node[Box={col5!50},below=2 of B5](5BB1){Application-Specific\\Acceleration};
\node[Box={col5!50},below=of 5BB1](5BB2){AI Engines \&\\SmartNICs};
\node[Box={col5!50},below=of 5BB2](5BB3){Multi-chip and\\wafer-scale ML\\acceleration};
\node[Box={col5!50},below=of 5BB3](5BB4){ML frameworks\\optimizing for\\specialized hardware};
\end{tikzpicture}
```
:::

### Parallel Computing and Graphics Processing {#sec-ai-acceleration-parallel-computing-graphics-processing-4654}

The principles established through floating-point acceleration provided a blueprint for addressing subsequent computational challenges. As computing applications diversified, new computational patterns emerged that exceeded the capabilities of general-purpose processors, and each domain contributed unique insights to hardware acceleration strategies.

Graphics processing emerged as a primary driver of hardware specialization in the 1990s. Early graphics accelerators focused on specific operations like bitmap transfers and polygon filling. NVIDIA's GeForce 256\index{NVIDIA!GeForce 256}\index{GPU!history} in 1999 represented a milestone in specialized computing. The GeForce 256 implemented hardware-accelerated transform and lighting (T&L)\index{Transform and Lighting!hardware acceleration}, moving these computations from CPU to dedicated silicon. While not yet programmable, these Graphics Processing Units (GPUs) demonstrated how fixed-function parallel architectures could efficiently handle data-parallel workloads, achieving 50-100$\times$ speedups in 3D rendering tasks like texture mapping and vertex transformation. The transition to programmable shaders with the GeForce 3 (2001) and unified shader architectures with the GeForce 8 (2006) eventually enabled GPU computing for general-purpose workloads. By 2004, high-end GPUs could process over 100 million polygons per second [@owens2008gpu].

\index{Digital Signal Processing!multiply-accumulate units}
Concurrently, Digital Signal Processing (DSP) processors established parallel data path architectures with specialized multiply-accumulate units and circular buffers optimized for filtering and transform operations. Texas Instruments' TMS32010 (1983) demonstrated how domain-specific instruction sets could dramatically improve performance for signal processing applications [@lyons2011understanding].

Network processing introduced additional patterns of specialization. Network processors developed unique architectures to handle packet processing at line rate, incorporating multiple processing cores, specialized packet manipulation units, and tiered memory management systems. Intel's IXP2800 network processor demonstrated how multiple levels of hardware specialization could be combined to address complex processing requirements.

Across these domains, a common blueprint emerges: identify the dominant computational patterns, build specialized processing elements and memory hierarchies around them, create tailored programming models, and progressively evolve toward more flexible architectures. This pattern of architectural co-evolution established the foundation for contemporary AI hardware design. DSP innovations in low-power signal processing enabled real-time inference on edge devices, including voice assistants and wearables. Together, these domains informed ML hardware designs and demonstrated that accelerators could be deployed across both cloud and embedded contexts.

\index{AlexNet!GPU deep learning era}
But it was a single result in 2012 that proved the GPU's relevance to AI was not theoretical. AlexNet[^fn-hwacc-alexnet] [@alexnet2012] won the ImageNet competition by a 10.8-percentage-point margin---on two consumer-grade NVIDIA GTX 580 graphics cards, each with only 3 GB of VRAM. The systems lesson was impossible to ignore: matching a workload's data parallelism to GPU hardware could yield order-of-magnitude improvements in time-to-train. The era of GPU-centric deep learning had begun.

[^fn-hwacc-alexnet]: **AlexNet**\index{Krizhevsky, Alex!AlexNet developer}: Developed by Alex Krizhevsky, Ilya Sutskever, and Geoffrey Hinton at the University of Toronto. CUDA was barely five years old and no ML framework supported GPUs, so Krizhevsky wrote custom CUDA kernels from scratch. The 60-million-parameter model could not fit on a single GTX 580, so he manually partitioned layers across two cards, carefully choosing which layers communicated across the PCIe bus to minimize the data-transfer bottleneck---an ad-hoc form of model parallelism built on consumer gaming hardware. Training took five to six days instead of weeks on a CPU cluster.

### Emergence of Domain-Specific Architectures {#sec-ai-acceleration-emergence-domainspecific-architectures-e56e}

\index{Domain-Specific Architecture!scaling law breakdown}
These diverse acceleration patterns converged in a broader architectural shift. The emergence of domain-specific architectures (DSA)[^fn-dsa] marks a transition in computer system design, driven by two converging factors: the breakdown of traditional scaling laws [@esmaeilzadeh2011dark] and the increasing computational demands of specialized workloads. The slowdown of Moore's Law\index{Moore's Law!slowdown}[^fn-moores-law-end] previously ensured predictable enhancements in transistor density every 18 to 24 months. The end of Dennard scaling\index{Dennard Scaling!end of}[^fn-dennard-scaling] [@dennard1974design] similarly permitted frequency increases without corresponding power increases. Together, these shifts created a performance and efficiency bottleneck in general-purpose computing. As John Hennessy and David Patterson noted in their 2017 Turing Lecture [@hennessy_patterson_2019][^fn-hennessy-patterson], these limitations signaled the onset of a new era in computer architecture centered on domain-specific solutions that optimize hardware for specialized workloads.

\index{Huang's Law!GPU performance scaling}
The scale of this challenge becomes stark in @fig-systems-gap, which plots the *Systems Gap*: the divergence between what models demand and what hardware naturally provides. Compare the two curves: while hardware improves incrementally (following Moore's Law and what is sometimes called *Huang's Law*[^fn-huangs-law] for GPU scaling), model compute requirements have grown exponentially, doubling roughly every 3–4 months during the deep learning era.

[^fn-huangs-law]: **Huang's Law**\index{Huang, Jensen!NVIDIA founder}: Named after Jensen Huang, co-founder of NVIDIA (1993), who transformed a graphics chip company into the dominant AI hardware platform. The term refers to the observation that GPU performance for AI workloads has roughly doubled every year---outpacing Moore's Law---driven by architectural innovations rather than transistor scaling alone. Key milestones: CUDA (2006) opened GPUs to general-purpose computing, Tensor Cores (2017) added dedicated matrix-multiply units, and the H100 (2022) integrated transformer-specific acceleration.

The plot is normalized to a 2012 baseline to emphasize relative growth. Notice how the purple-shaded region between the curves keeps widening — this gap cannot be closed by waiting for faster chips; it requires architectural innovation.

```{python}
#| label: fig-systems-gap
#| echo: false
#| fig-cap: "**The Systems Gap**: Relative compute growth (log scale) comparing model demand to hardware supply, normalized to 2012 = 1.0. The gray dotted line (CPU) and blue dashed line (GPU) reflect hardware progress, which lags the exponential red solid line (Model Demand). The purple region is the 'Systems Gap' that must be bridged through parallelism and co-design."
#| fig-alt: "Log-scale line chart from 2012 to 2024. Red line (Model Demand) rises steeply. Blue line (GPU Supply) rises moderately. Gray line (CPU Trend) rises slowly. A large purple shaded area between Red and Blue is labeled 'THE SYSTEMS GAP'."

import numpy as np
from mlsys import viz

fig, ax, COLORS, plt = viz.setup_plot()

# =============================================================================
# PLOT: The Systems Gap
# =============================================================================
years = np.linspace(2012, 2024.5, 100)

# Growth rates (log10 per year)
cpu_slope = np.log10(19) / 10  # Moore's Law
gpu_slope = np.log10(250) / 10  # Huang's Law
demand_slope = np.log10(4.6e8) / 11  # Model demand

moore = 1.0 * 10**(cpu_slope * (years - 2012))
huang = 1.0 * 10**(gpu_slope * (years - 2012))
demand = 1.0 * 10**(demand_slope * (years - 2012))

ax.plot(years, moore, ':', color=COLORS['grid'], label="CPU Performance Trend", linewidth=2)
ax.plot(years, huang, '--', color=COLORS['BlueLine'], label="GPU Peak (Huang's Law)", linewidth=2.5)
ax.plot(years, demand, '-', color=COLORS['RedLine'], label="Model Demand (Scaling Laws)", linewidth=3)

ax.fill_between(years, huang, demand, where=(demand > huang), color=COLORS['VioletL'], alpha=0.3)

ax.set_yscale('log')
ax.set_xlabel('Year')
ax.set_ylabel('Relative Growth (2012 = 1.0)')
ax.set_xlim(2012, 2024.5)
ax.set_ylim(0.5, 1e10)

gap_x = 2020.0
h_val = 10**(gpu_slope * (gap_x - 2012))
d_val = 10**(demand_slope * (gap_x - 2012))
gap_y = np.sqrt(h_val * d_val)

ax.text(gap_x, gap_y, "THE SYSTEMS GAP\n(Closed by Parallelism,\nArchitecture & Co-design)",
        ha='center', va='center', fontweight='bold', color=COLORS['VioletLine'], fontsize=8,
        bbox=dict(facecolor='white', alpha=0.7, edgecolor='none', pad=2))

# Model milestones
for y, v, l in [(2012, 1.0, "AlexNet"), (2017, 10**(demand_slope*5), "Transformer"), (2020, 10**(demand_slope*8), "GPT-3"), (2023, 10**(demand_slope*11), "GPT-4")]:
    ax.scatter(y, v, color=COLORS['RedLine'], s=25, zorder=5, edgecolors='white')
    ax.annotate(l, (y, v), xytext=(0, 8), textcoords='offset points', fontsize=8, ha='center', color=COLORS['RedLine'], fontweight='bold', bbox=dict(facecolor='white', alpha=0.8, edgecolor='none', pad=0.5))

ax.legend(loc='lower right', fontsize=8)
plt.show()
```

[^fn-dsa]: **Domain-Specific Architectures (DSA)**: Computing architectures optimized for specific application domains rather than general-purpose computation. Unlike CPUs designed for flexibility, DSAs sacrifice programmability for dramatic efficiency gains. Google's TPU achieves 15-30$\times$ better performance per watt than GPUs for neural networks, while video codecs provide 100-1000$\times$ improvements over software decoding. The 2018 Turing Award recognized this shift as the defining trend in modern computer architecture.

[^fn-moores-law-end]: **Moore's Law**\index{Moore, Gordon!transistor density observation}: Intel co-founder Gordon Moore's 1965 observation that transistor density doubles every 18–24 months. This exponential scaling drove computing progress for decades, enabling everything from smartphones to supercomputers. However, power density constraints and rising manufacturing complexity slowed the historical pace of cost-effective scaling. As advanced-node development costs rose from millions to billions of dollars, the industry shifted toward parallelism and specialization.

[^fn-dennard-scaling]: **Dennard Scaling**\index{Dennard, Robert!power density principle}: Robert Dennard's 1974 principle that as transistors shrink, their power density remains constant, allowing higher frequencies without increased power consumption. This enabled CPUs to reach 3+ GHz by 2005. However, quantum effects and leakage current ended Dennard scaling around 2005, forcing architects to prioritize efficiency over raw speed and leading to the multi-core revolution.

[^fn-hennessy-patterson]: **Hennessy & Patterson**\index{Hennessy, John!RISC pioneer}\index{Patterson, David!RISC pioneer}: John Hennessy and David Patterson pioneered Reduced Instruction Set Computing (RISC), transforming processor design into a quantitative science. Their textbook *Computer Architecture: A Quantitative Approach* is the definitive reference in the field, and they received the 2017 ACM A.M. Turing Award for these contributions.

### The Technology S-Curve: Why We Must Shift {#sec-ai-acceleration-technology-s-curve}

\index{Technology S-Curve!computing paradigms}
To understand the gravity of this transition, we must view it through the lens of the *Technology S-Curve*. Every computing paradigm follows a distinct lifecycle characterized by three phases: *ferment* (initial slow progress), *take-off* (exponential growth), and *saturation* (diminishing returns due to physical limits).

Look at the two overlapping curves in @fig-tech-s-curve: general-purpose computing has entered its saturation phase, and the industry is now riding the steep take-off of a new S-curve driven by domain-specific architectures.

```{python}
#| label: fig-tech-s-curve
#| fig-cap: "**The Twin S-Curves of Modern Computing**. General-purpose CPUs (gray) enjoyed decades of exponential growth driven by Moore's Law and Dennard Scaling. As physics constrained this curve around 2010 (Saturation), the industry was forced to jump to a new curve: Domain Specific Architectures (blue). We are currently in the **Take-off** phase of this new paradigm, where massive efficiency gains come from specializing hardware for linear algebra, albeit at the cost of general programmability."
#| fig-alt: "Two overlapping S-curves plotting performance over time. Gray curve shows general-purpose CPUs reaching saturation around 2010. Blue curve shows domain-specific architectures in take-off phase starting 2015."
#| echo: false
#| warning: false

import numpy as np
from mlsys import viz

fig, ax, COLORS, plt = viz.setup_plot(figsize=(10, 6))

# =============================================================================
# PLOT: The Twin S-Curves of Modern Computing
# =============================================================================
years = np.linspace(1980, 2030, 500)

def sigmoid(x, L, k, x0):
    return L / (1 + np.exp(-k * (x - x0)))

# Curve 1: General Purpose Computing (Moore's Law / Dennard Scaling Era)
cpu_curve = sigmoid(years, 100, 0.25, 2000)

# Curve 2: Domain Specific Architectures (Accelerator Era)
accel_curve = sigmoid(years, 10000, 0.35, 2022)

ax.plot(years, cpu_curve, color=COLORS['grid'], linewidth=3, label='General Purpose (CPU)')
ax.plot(years, accel_curve, color=COLORS['BlueLine'], linewidth=3, label='Domain Specific (Accelerator)')

# Fill the gap (The Shift)
mask = (years > 2012) & (accel_curve > cpu_curve)
ax.fill_between(years, cpu_curve, accel_curve, where=mask, color=COLORS['BlueL'], alpha=0.2)

ax.set_yscale('log')
ax.set_ylim(0.1, 20000)
ax.set_xlim(1980, 2030)

# Annotations
ax.text(1990, 2, "Moore's Law\n(Exponential Growth)", color=COLORS['primary'], ha='center', fontsize=9, rotation=25, alpha=0.6)
ax.text(2016, 150, "Dennard Scaling Ends\n(Saturation)", color=COLORS['primary'], ha='center', fontweight='bold', fontsize=9)
ax.annotate("The Paradigm Shift\n(Hardware-Software Co-design)",
            xy=(2016, 50), xytext=(2005, 0.5),
            arrowprops=dict(facecolor=COLORS['RedLine'], arrowstyle='->', lw=2, color=COLORS['RedLine']),
            fontsize=10, fontweight='bold', color=COLORS['RedLine'],
            bbox=dict(facecolor='white', alpha=0.9, edgecolor='none', pad=2))
ax.text(2025, 1000, "Era of Accelerators\n(Matrix Math focus)", color=COLORS['BlueLine'], ha='center', fontweight='bold', fontsize=9, rotation=35)
ax.annotate("", xy=(2029, 9000), xytext=(2029, 105),
            arrowprops=dict(arrowstyle="<->", color=COLORS['primary'], lw=1.5))
ax.text(2028.5, 900, "The Systems Gap\n(~100x)", ha='right', va='center', fontsize=9, fontweight='bold', color=COLORS['primary'])

ax.set_xlabel('Year')
ax.set_ylabel('Performance / Efficiency (Log Scale)')
ax.legend(loc='upper left', fontsize=10)
plt.show()
```

\index{Moore's Law!slowdown impact}
The "easy" gains from shrinking transistors are gone. To sustain the exponential growth required by AI models (which are growing 4–10$\times$ faster than Moore's Law), we cannot simply wait for the next CPU generation. We must shift to a new curve, one defined not by clock speed but by *architecture*. To understand how we reached this inflection point, we must first examine the mechanics of the scaling laws that once fueled the general-purpose era.

Historically, improvements in processor performance depended on semiconductor process scaling and increasing clock speeds. As power density limitations restricted further frequency scaling and transistor miniaturization encountered increasing physical and economic constraints, architects explored alternative approaches to sustain computational growth. The result was a shift toward domain-specific architectures, which dedicate silicon resources to optimize computation for specific application domains, trading flexibility for efficiency.

Domain-specific architectures achieve superior performance and energy efficiency through several reinforcing principles. First, they employ customized data paths\index{Data Path!customization} optimized for target application patterns, enabling direct hardware execution of common operations. Matrix multiplication units in AI accelerators, for example, implement **systolic arrays**\index{Systolic Arrays!definition} — grid-like networks of processing elements that rhythmically compute and pass data through neighboring units — tailored for neural network computations. Second, they build specialized memory hierarchies\index{Memory Hierarchy!domain-specific} around domain-specific access patterns and data reuse characteristics, with custom cache configurations\index{Cache!specialized configuration}, prefetching logic\index{Prefetching!accelerator optimization}, and memory controllers tuned for expected workloads. Third, they reduce instruction overhead by implementing domain-specific instruction sets that encode common operation sequences into single instructions, minimizing decode and dispatch complexity. Finally, they provide direct hardware implementation of frequently used operations through dedicated circuit blocks that bypass software interpretation entirely, eliminating instruction processing overhead and maximizing throughput.

Modern smartphones illustrate these principles compellingly. They can decode 4K video at 60 frames per second while consuming only a few watts of power, despite video processing requiring billions of operations per second. This efficiency is achieved through dedicated hardware video codecs that implement industry standards such as H.264/AVC (introduced in 2003) and H.265/HEVC (finalized in 2013) [@sullivan2012overview]. These specialized circuits provide 100–1000$\times$ improvements in both performance and power efficiency compared to software-based decoding on general-purpose processors.

\index{ASIC!Application-Specific Integrated Circuit}
The trend toward specialization continues to accelerate, with new architectures emerging for an expanding range of domains. Genomics processing benefits from custom accelerators that optimize sequence alignment and variant calling, reducing the time required for DNA analysis [@Shang2018GenomicsAccel]. Similarly, blockchain computation has produced application-specific integrated circuits (ASICs)[^fn-asics] optimized for cryptographic hashing, substantially increasing the efficiency of mining operations [@Taylor2017ASICMining].

[^fn-asics]: **Application-Specific Integrated Circuits (ASICs)**: Custom silicon chips designed for a single application, offering maximum efficiency by eliminating unused features. For well-defined workloads, ASICs can achieve orders-of-magnitude better energy efficiency than general-purpose processors (often \(10^3\) to \(10^5\times\) in specialized domains). However, their inflexibility means they can become obsolete if algorithms or standards change (for example, when cryptocurrency networks change consensus mechanisms).

\index{Dennard Scaling!multi-core revolution}
This shift represents an important engineering lesson: the era of "free" performance gains from general-purpose scaling is over. For decades, software engineers could rely on Moore's Law to accelerate existing code without architectural changes. The breakdown of Dennard scaling forced a decisive change: we can no longer wait for faster CPUs to solve computational bottlenecks. Instead, we must design the hardware to fit the algorithm. This necessity of hardware-software co-design is why modern AI engineering requires deep understanding of the underlying silicon. Performance is now determined by how well the algorithm's memory access patterns and parallelism map to the specialized physical structures of domain-specific architectures.

```{python}
#| echo: false
#| label: cpu-ml-inefficiency
# ┌─────────────────────────────────────────────────────────────────────────────
# │ CPU ML INEFFICIENCY STATISTICS
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: "Machine Learning Hardware Specialization" section
# │
# │ Why: Demonstrates why CPUs are inefficient for ML workloads. These baseline
# │      CPU statistics (5–10% utilization, ~100 GFLOPS) motivate the need for
# │      specialized accelerators that achieve 10-100x better efficiency.
# │
# │ Imports: mlsys.constants (A100_FLOPS*, MOBILE_NPU_TOPS_INT8)
# │ Exports: cpu_utilization_min_str, cpu_utilization_max_str, cpu_gflops_str,
# │          a100_tflops_fp16, a100_tflops_tf32, mobile_tops
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.constants import (
    A100_FLOPS_FP16_TENSOR, A100_FLOPS_TF32,
    MOBILE_NPU_TOPS_INT8, TFLOPs, second,
    KIB_TO_BYTES, MIB_TO_BYTES
)
from mlsys.formatting import fmt

# --- Inputs (typical CPU ML utilization) ---
cpu_utilization_min_value = 5                    # % utilization on ML workloads
cpu_utilization_max_value = 10                   # % utilization on ML workloads
cpu_gflops_value = 100                           # Typical CPU GFLOPS for ML

# --- Outputs (formatted strings for prose) ---
cpu_utilization_min_str = fmt(cpu_utilization_min_value, precision=0, commas=False)  # e.g. "5"
cpu_utilization_max_str = fmt(cpu_utilization_max_value, precision=0, commas=False)  # e.g. "10"
cpu_gflops_str = fmt(cpu_gflops_value, precision=0, commas=False)                    # e.g. "100"

# A100/Mobile specs for footnote comparison
a100_tflops_fp16 = f"{A100_FLOPS_FP16_TENSOR.to(TFLOPs/second).magnitude:.0f}"       # e.g. "312"
a100_tflops_tf32 = f"{A100_FLOPS_TF32.to(TFLOPs/second).magnitude:.0f}"              # e.g. "156"
mobile_tops = f"{MOBILE_NPU_TOPS_INT8.to(TFLOPs/second).magnitude:.0f}"              # e.g. "17"
```

### Machine Learning Hardware Specialization {#sec-ai-acceleration-machine-learning-hardware-specialization-09c5}

\index{Neural Network!predictable computation patterns}
Machine learning constitutes a computational domain with unique characteristics that have driven the development of specialized hardware architectures. Unlike traditional computing workloads that exhibit irregular memory access patterns and diverse instruction streams, neural networks are characterized by predictable patterns: dense matrix multiplications, regular data flow, and tolerance for reduced precision. These characteristics enable specialized hardware optimizations that would be ineffective for general-purpose computing but provide substantial speedups for ML workloads. The hardware built to exploit these patterns constitutes a class of devices known as *ML accelerators*.

::: {.callout-definition title="ML Accelerator"}

***Machine Learning Accelerators***\index{ML Accelerator!domain-specific processors} are domain-specific processors optimized for **Dense Linear Algebra**. They achieve order-of-magnitude efficiency gains over CPUs by maximizing **Parallel Throughput** and **Data Reuse** (via systolic arrays or tensor cores), specifically addressing the **Integration Bottleneck** of moving data to compute.

:::

Machine learning computational requirements reveal limitations in traditional processors. CPUs reach only `{python} cpu_utilization_min_str`–`{python} cpu_utilization_max_str`% utilization on neural network workloads, delivering approximately `{python} cpu_gflops_str` GFLOPS (billions of floating-point operations per second)[^fn-gflops] while consuming hundreds of watts. This inefficiency results from architectural mismatches: CPUs optimize for single-thread performance and irregular memory access, while neural networks require massive parallelism and predictable data streams. The memory bandwidth[^fn-memory-bandwidth-accelerators] constraint — the data transfer rate between memory and processors — becomes particularly severe: a single neural network layer may require accessing gigabytes of parameters, overwhelming CPU cache hierarchies[^fn-cache-hierarchy] designed for kilobyte-scale working sets.

[^fn-gflops]: **GFLOPS/TOPS Performance Metrics**: GFLOPS (10⁹ floating-point ops/second) measures floating-point throughput; TOPS (10¹² ops/second) typically measures INT8 operations in AI accelerators. The A100 delivers `{python} a100_tflops_fp16` TFLOPS for FP16/BF16 dense Tensor Core operations (`{python} a100_tflops_tf32` TFLOPS for TF32), with approximately 2$\times$ higher throughput when structured sparsity is enabled; Apple A17 NPU achieves `{python} mobile_tops` INT8 TOPS. Real workload performance depends on memory bandwidth, achieving 10–30% of peak on typical ML models.

[^fn-memory-bandwidth-accelerators]: Memory bandwidth (introduced in @sec-introduction) measures data transfer rate between memory and processors. For accelerator design, the gap between CPU memory (tens to hundreds of GB/s) and HBM (terabytes per second) explains why specialized hardware achieves 10–100× speedups on bandwidth-bound neural network operations.

[^fn-cache-hierarchy]: **Cache**: From French "cacher" (to hide), describing memory that stores frequently accessed data out of sight from the programmer. The IBM System/360 Model 85 (1968) introduced the first commercial cache. Modern CPUs use multi-level hierarchies (L1/L2/L3) with progressively larger capacity but higher latency. Neural networks often exceed cache capacity, forcing frequent DRAM accesses that reduce effective throughput.

\index{Energy!data movement cost}
The energy economics of data movement influence accelerator design. Accessing data from DRAM can consume on the order of \(10^2\)× more energy than a multiply-accumulate operation (exact values vary by technology node and design), making minimizing data movement a primary optimization target. This disparity helps explain the progression from repurposed graphics processors to purpose-built neural network accelerators. TPUs and other custom accelerators can sustain high utilization on dense kernels by implementing systolic arrays and other architectures that maximize data reuse while minimizing movement.

\index{Training vs. Inference!accelerator design}
Training and inference present distinct computational profiles that influence accelerator design. Training requires high-precision arithmetic (FP32 or FP16)\index{FP16!training precision}\index{FP32!gradient computation} for gradient computation and weight updates, bidirectional data flow for backpropagation\index{Backpropagation!memory requirements}[^fn-backpropagation-memory], and large memory capacity for storing activations. Inference can exploit reduced precision (INT8 or INT4), requires only forward computation, and prioritizes latency over throughput[^fn-latency-throughput]. These differences drive specialized architectures: training accelerators maximize FLOPS and memory bandwidth, while inference accelerators optimize for energy efficiency and deterministic latency.

[^fn-backpropagation-memory]: **Backpropagation**: Short for "backward propagation of errors," formalized by Rumelhart, Hinton, and Williams in 1986, though the mathematical foundation (reverse-mode automatic differentiation) traces to the 1960s. The name describes its mechanism: errors flow backward from output to input, propagating gradients through the network via the chain rule. This bidirectional data flow requires storing all intermediate activations, increasing memory requirements 2–3× versus inference-only forward passes.

[^fn-latency-throughput]: **Latency vs Throughput**: "Latency" from Latin "latere" (to lie hidden), originally described the delay before something becomes apparent. "Throughput" emerged from industrial manufacturing, measuring production rate. In computing, latency measures single-request response time (milliseconds), while throughput measures processing rate (requests/second). Training optimizes throughput for batch processing; inference prioritizes latency for real-time responses.

Deployment context shapes architectural choices through a single question: *what is the binding constraint?* In data centers, the constraint is time-to-result for training massive models. An NVIDIA H100\index{NVIDIA!H100} consuming 700 watts is economically justified if it reduces a GPT-scale training run from weeks to days, because the cumulative cost of compute time (at \$2–4/GPU-hour) dwarfs the energy bill. Google's TPUv4\index{TPU!datacenter integration} makes a similar trade-off, prioritizing raw throughput through massive systolic arrays and high-bandwidth memory, accepting high power consumption because faster iteration reduces both time-to-deploy and total training cost.

\index{Edge Deployment!power constraints}
At the opposite extreme, edge deployment inverts this priority: the binding constraint is *energy per inference*, not throughput. A smartphone camera processing 30 frames per second within a 3-watt power budget cannot afford the DRAM-intensive access patterns of a datacenter accelerator. Instead, edge architectures minimize data movement through processing-in-memory designs that integrate compute directly with storage, dynamic voltage scaling that reduces power during low-intensity operations, and neuromorphic approaches that process only changing inputs — yielding order-of-magnitude power reductions for temporal workloads like always-on audio. The systems insight is that the same Memory Wall principle applies at both extremes: datacenter chips fight it with bandwidth (terabytes per second of HBM), while edge chips fight it with proximity (keeping data in registers and scratchpads).

The success of application-specific accelerators demonstrates that no single architecture can efficiently address all ML workloads. A massive installed base of edge devices demands architectures optimized for energy efficiency and real-time latency targets, while cloud-scale training continues advancing the boundaries of computational throughput. This diversity drives continued innovation in specialized architectures, each optimized for its specific deployment context and computational requirements. However, despite this diversity, all accelerators operate under the same physical constraints. Verify your understanding of the energy physics driving this specialization.

::: {.callout-checkpoint title="The Accelerator Gate" collapse="false"}
Hardware specialization is driven by energy physics.

**The Energy Inversion**

- [ ] **Data Movement Cost**: Can you explain why moving data from DRAM costs 100× more energy than computing on it?
- [ ] **Architectural Response**: How do **Systolic Arrays** (TPU) and **Tensor Cores** (GPU) minimize this cost? (They reuse data in registers for many operations before writing back; see @sec-ai-acceleration-systolic-arrays-6fa8 for details.)

**Selection Logic**

- [ ] **Training vs. Inference**: Why do training chips need massive HBM bandwidth, while inference chips prioritize low latency and INT8 ops?
:::

This historical progression reveals a key pattern: each wave of hardware specialization responded to a specific computational bottleneck. Floating-point coprocessors addressed arithmetic precision limitations. GPUs addressed graphics throughput limitations. But what bottleneck does AI acceleration address? Understanding this question matters because it reveals _why_ modern accelerators are designed the way they are, and why simply adding more transistors to general-purpose processors cannot solve this challenge. Before examining this integration bottleneck in detail, @tbl-hw-evolution summarizes the key milestones in hardware specialization. While these accelerators initially emerged to optimize domain-specific workloads such as floating-point operations, graphics rendering, and media processing, they also introduced architectural strategies that persist in contemporary systems. The specialization principles from earlier generations now underpin the design of modern AI accelerators and provide context for understanding how hardware specialization continues to enable scalable, efficient execution of machine learning workloads across diverse deployment environments.

| **Era**   | **Computational Pattern**          | **Architecture Examples**                   | **Characteristics**                                                                                                         |
|:--------|:---------------------------------|:------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------|
| **1980s** | Floating-Point & Signal Processing | FPU, DSP                                    | <ul><li>Single-purpose engines</li> <li>Focused instruction sets</li> <li>Coprocessor interfaces</li></ul>                  |
| **1990s** | 3D Graphics & Multimedia           | GPU, SIMD Units                             | <ul><li>Many identical compute units</li> <li>Regular data patterns</li> <li>Wide memory interfaces</li></ul>               |
| **2000s** | Real-time Media Coding             | Media Codecs, Network Processors            | <ul><li>Fixed-function pipelines</li> <li>High throughput processing</li> <li>Power-performance optimization</li></ul>      |
| **2010s** | Deep Learning Tensor Operations    | TPU, GPU Tensor Cores                       | <ul><li>Matrix multiplication units</li> <li>Massive parallelism</li> <li>Memory bandwidth optimization</li></ul>           |
| **2020s** | Application-Specific Acceleration  | ML Engines, Smart NICs, Domain Accelerators | <ul><li>Workload-specific datapaths</li> <li>Customized memory hierarchies</li> <li>Application-optimized designs</li></ul> |

: **Hardware Specialization Trends.** Successive computing eras progressively integrate specialized hardware to accelerate prevalent workloads, moving from general-purpose CPUs to domain-specific architectures and ultimately to customizable AI accelerators. Tailoring hardware to computational patterns improves performance and energy efficiency, driving innovation in machine learning systems. {#tbl-hw-evolution}

What distinguishes AI acceleration from earlier specialization waves is the scale of integration required. AI accelerators must work seamlessly with frameworks like TensorFlow, PyTorch, and JAX. They require deep compiler support for graph-level transformations, kernel fusion, and memory scheduling. They must also deploy across environments from data centers to mobile devices, each with distinct performance and efficiency requirements. Such system-level transformation requires tight hardware-software coupling, a theme that recurs throughout this chapter.

First, we must understand _what_ bottleneck AI accelerators are designed to solve. Unlike floating-point coprocessors that addressed arithmetic precision or GPUs that addressed graphics throughput, AI accelerators target a qualitatively different constraint. The answer determines every subsequent architectural decision.

### The Integration Bottleneck {#sec-ai-acceleration-integration-bottleneck-ai-needs-specialized-hardware-0b41}

\index{Integration Bottleneck!data movement cost}
Machine learning represents a computational domain where the primary performance limit has shifted from *arithmetic* to *integration*. While early coprocessors solved the Precision Bottleneck (8087) and GPUs solved the Throughput Bottleneck (rasterization), modern AI workloads are constrained by the Integration Bottleneck: the energy and latency cost of moving massive amounts of data between memory and thousands of parallel compute units.

Neural networks are characterized by three unique properties that drive this shift:

1. **Massive Parallelism**: Unlike general-purpose code with complex branching, neural networks execute billions of independent matrix multiplications and convolutions. This regular structure allows replacing complex CPU control logic with dense arrays of processing elements (systolic arrays).

2. **Predictable Data Flow**: Data movement in deep learning is mathematically determined by the network's layers. This predictability enables hardware to "prefetch" data into local scratchpads[^fn-scratchpad-etymology], bypassing the expensive random-access cache hierarchies of CPUs.

[^fn-scratchpad-etymology]: **Scratchpad**: From the physical scratch pads used for quick calculations before computers. In hardware, scratchpad memory is software-managed fast memory near compute units, contrasting with caches that are hardware-managed. Unlike caches that guess what data to keep, scratchpads give programmers explicit control over what data resides in fast memory, enabling the predictable data movement that ML workloads require.

3. **Tolerance for Reduced Precision**\index{Quantization!reduced precision tolerance}: Neural networks typically remain robust even when using 8-bit or 4-bit integers instead of 64-bit floating-point numbers. This flexibility allows architects to fit 10$\times$ more compute units in the same silicon area.

The primary engineering challenge is no longer "how fast can we calculate?" but "how close can we keep the data to the calculation?" In modern accelerators, accessing data from external memory (DRAM)\index{DRAM!energy cost} can consume $100\times$ more energy than the actual arithmetic operation. This disparity is precisely why the accelerator architecture in @fig-accelerator-anatomy prioritizes high-bandwidth memory (HBM)\index{HBM!High Bandwidth Memory}[^fn-hbm-architecture] and large on-chip scratchpads\index{Scratchpad Memory!accelerator design} over simply adding more compute units.

[^fn-hbm-architecture]: HBM (introduced in @sec-dnn-architectures) achieves 2–10× higher bandwidth than GDDR memory through 3D die stacking with thousands of TSVs. From a hardware architecture perspective, HBM's 2-3 TB/s bandwidth (vs. 500-700 GB/s for GDDR6X) transforms memory-bound ML workloads toward compute-bound performance. The trade-off is higher manufacturing cost, limiting HBM to data center accelerators where bandwidth justifies the premium.

To see how accelerators address this integration bottleneck in practice, examine the architectural blueprint in @fig-accelerator-anatomy. Notice how every design decision, from the processing element grid to the multi-level cache hierarchy, targets data movement reduction rather than raw compute multiplication.

::: {#fig-accelerator-anatomy fig-env="figure" fig-pos="htb" fig-cap="**Anatomy of a Modern AI Accelerator**: AI accelerators integrate specialized processing elements containing tensor cores, vector units, and special function units, supported by a hierarchical memory system from high-bandwidth memory down to local caches. This architecture maximizes data reuse and parallel execution while minimizing energy-intensive data movement, forming the foundation for 100–1,000× performance improvements over general-purpose processors." fig-alt="Block diagram showing AI accelerator architecture: CPU connects to DRAM stacks and processing element grid containing tensor cores, vector units, and local caches in hierarchical arrangement."}
```{.tikz}
\begin{tikzpicture}[line cap=round,line join=round,font=\usefont{T1}{phv}{m}{n}\small]
\tikzset{
  Box/.style={align=center,,outer sep=0pt ,
    inner xsep=2pt,
    node distance=0.45,
    draw=GreenLine,
    line width=0.75pt,
    fill=GreenL!60,
   % text width=32mm,
    minimum width=77mm, minimum height=11mm
  },
   Box2/.style={Box, minimum width=10mm, minimum height=6mm,fill=BrownL!60,draw=BrownLine},
   Box3/.style={Box,text width=20mm,  minimum width=20mm, minimum height=9mm,fill=RedL!60,draw=RedLine},
   Box4/.style={Box3, fill=BlueLine!20,draw=BlueLine},
   Box5/.style={Box3, fill=OrangeLine!20,draw=OrangeLine},
   Box6/.style={Box3, text width=30mm,  minimum width=30mm,  minimum height=13mm,fill=OrangeLine!20,draw=OrangeLine},
Line/.style={violet!50, line width=1.1pt,shorten <=1pt,shorten >=2pt},
LineA/.style={violet!50,line width=0.8pt,{-{Triangle[width=1.0*4pt,length=1.0*6pt]}},shorten <=1pt,shorten >=1pt},
ALine/.style={black!50, line width=1.1pt,{{Triangle[width=0.9*6pt,length=1.2*6pt]}-}},
Larrow/.style={fill=violet!50, double arrow,  inner sep=2pt, double arrow head extend=3pt,
            single arrow head indent=0pt,minimum height=21mm, minimum width=3pt}
}

\tikzset{
pics/dram/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[shift={($(0,0)+(0,0)$)},scale=\scalefac,every node/.append style={transform shape}]
\node[draw=\drawcolor,fill=\filllcolor!70,line width=1.5*\Linewidth,inner sep=0pt,outer sep=0pt,
minimum width=56mm,minimum height=14mm](DRAM\picname)at(0,0){};
\node[draw=\drawcolor,fill=\filllcolor!30,line width=1.5*\Linewidth,inner sep=0pt,outer sep=0pt,anchor=north,
minimum width=52mm,minimum height=6mm](MDRAM\picname)at(DRAM\picname.south){};
%
\pgfmathsetmacro{\spacing}{56/(6+1)}
\foreach \i in {1,...,6} {
  \pgfmathsetmacro{\x}{\i * \spacing}
  \node[draw=\drawcolor,fill=\filllcolor!20,line width=\Linewidth, inner sep=0pt, outer sep=0pt,
        minimum width=6mm, minimum height=8mm]
        at ([xshift=\x mm]DRAM\picname.west) {};
}
%
\foreach \i in {1,...,19} {
  \pgfmathsetmacro{\x}{\i*(52/20)}
  \draw[draw=\drawcolor, line width=3*\Linewidth]
    ([xshift=\x mm,yshift=1pt]MDRAM\picname.south west) -- ++(0,2mm);
}

\end{scope}
    }
  }
}
%CPU style
\tikzset{
pics/cpu/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[local bounding box = CPU,scale=0.6, every node/.append style={transform shape}]
\node[fill=\filllcolor,minimum width=66, minimum height=66,
            rounded corners=2,outer sep=2pt] (C1) {};
\node[fill=white,minimum width=54, minimum height=54] (C2) {};
\node[fill=\filllcolor!50,minimum width=44, minimum height=44] (C3) {\large CPU};

\foreach \x/\y in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{
\node[fill=\filllcolor,minimum width=4, minimum height=15,
           inner sep=0pt,anchor=south](GO\y)at($(C1.north west)!\x!(C1.north east)$){};
}
\foreach \x/\y in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{
\node[fill=\filllcolor,minimum width=4, minimum height=15,
           inner sep=0pt,anchor=north](DO\y)at($(C1.south west)!\x!(C1.south east)$){};
}
\foreach \x/\y in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{
\node[fill=\filllcolor,minimum width=15, minimum height=4,
           inner sep=0pt,anchor=east](LE\y)at($(C1.north west)!\x!(C1.south west)$){};
}
\foreach \x/\y in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{
\node[fill=\filllcolor,minimum width=15, minimum height=4,
           inner sep=0pt,anchor=west](DE\y)at($(C1.north east)!\x!(C1.south east)$){};
}
\end{scope}
    }  }}
\pgfkeys{
  /channel/.cd,
   Depth/.store in=\Depth,
  Height/.store in=\Height,
  Width/.store in=\Width,
  filllcirclecolor/.store in=\filllcirclecolor,
  filllcolor/.store in=\filllcolor,
  drawcolor/.store in=\drawcolor,
  drawcircle/.store in=\drawcircle,
  scalefac/.store in=\scalefac,
  Linewidth/.store in=\Linewidth,
  picname/.store in=\picname,
  filllcolor=BrownLine,
  filllcirclecolor=BlueFill,
  drawcolor=black,
  drawcircle=violet,
  scalefac=1,
  Linewidth=0.5pt,
  Depth=1.3,
  Height=0.8,
  Width=1.1,
  picname=C
}

\node[Box](B1){L2 Cache (Shared)};
\coordinate(PO1)at($(B1.north west)+(0.5,0.65)$);
\pgfmathsetmacro{\spacing}{47/(2+1)}
\foreach \i [count=\j] in {0,...,2} {
  \pgfmathsetmacro{\x}{\i * \spacing}
\node[Box2,anchor=south west](GPE\j)at([xshift=\x mm]PO1){PE};
}
\node[Box2,right=1.5 of GPE3](GPE4){PE};
\node[font=\tiny]at($(GPE3)!0.5!(GPE4)$){$\bullet$ $\bullet$ $\bullet$};
%
\coordinate(PO2)at($(B1.south west)+(0.5,-0.65)$);
\pgfmathsetmacro{\spacing}{47/(2+1)}
\foreach \i [count=\j]in {0,...,2} {
  \pgfmathsetmacro{\x}{\i * \spacing}
\node[Box2,anchor=north west](DPE\j)at([xshift=\x mm]PO2){PE};
}
\node[Box2,right=1.5 of DPE3](DPE4){PE};
\node[font=\tiny]at($(DPE3)!0.5!(DPE4)$){$\bullet$ $\bullet$ $\bullet$};
%arrows
\foreach \i  in {1,...,4} {
\draw[LineA](B1.south)--++(0,-0.25)
-|(DPE\i.north);
}
\foreach \i  in {1,...,4} {
\draw[LineA](B1.north)--++(0,0.25)-|(GPE\i.south);
}
\begin{scope}[shift={($(GPE1)+(0.3,2.8)$)}]
\node[Box3](L1){L1 Cache / Scratchpad};
\node[Box4,above right=-0.10 and 0.3 of L1](TC){Tensor Core};
\node[Box4,below right=0.1 and 0.3of L1](VU){Vector Unit};
\node[Box5,below right=0 and 0.3of TC](SFU){SFU};
\draw[LineA](L1)|-(TC);
\draw[LineA](L1)|-(VU);
\draw[LineA](TC)-|(SFU);
\draw[LineA](VU)-|(SFU);
%%fitting
\scoped[on background layer]
\node[draw=BackLine,fill=BackColor!20, inner ysep=4mm, inner xsep=2mm,yshift=2mm,
fit=(L1)(TC)(SFU)(VU),yshift=0mm](BB1){};
\node[below left=0 and 0 of BB1.north east]{Processing Element};
\scoped[on background layer]
\fill[BrownLine!10](GPE3.north west)--(BB1.south west)--(BB1.south east)--(GPE3.north east)--cycle;
\draw[BrownLine](GPE3.north west)--(BB1.south west) (BB1.south east)--(GPE3.north east);
\end{scope}
%%fitting
\node[draw=red,dashed,fill=none, inner ysep=4mm, inner xsep=3mm,yshift=2mm,
fit=(BB1)(DPE1)(DPE4)(B1),yshift=0mm](BB2){};
\node[below =0pt of BB2.north]{AI Accelerator Chip};
%CPU
\begin{scope}[local bounding box=CPU1,shift={($(B1)+(-7.8,0)$)}]
\pic[shift={(0,0)}] at (0,0) {cpu={scalefac=1,picname=1,drawcolor=BlueLine,filllcolor=BlueLine!80!,Linewidth=0.5pt}};
\end{scope}
\node[above=6pt of CPU1]{Host CPU};
%%%%
\begin{scope}[local bounding box=DRAM1,shift={($(CPU1)+(0,-2)$)},scale=1, every node/.append style={transform shape}]
\pic[shift={(0,0)}] at  (0,0){dram={scalefac=0.45,picname=1,drawcolor=black,filllcolor=OrangeLine!50!,Linewidth=0.5pt}};
\end{scope}
\node[below=9pt of DRAM1]{Host DRAM};
\node[Larrow](AR1)at($(CPU1.east)!0.45!(B1.west)$){};
\node[align=center,above=2pt of AR1,font=\usefont{T1}{phv}{m}{n}\footnotesize]{Host Interface\\ (PCIe/NVLink)};
\draw[LineA,dashed](DRAM1)--(CPU1);
%%
\node[Box6,right=2.5 of B1](B6){High-Bandwidth Memory (HBM)};
\node[Larrow](AR2)at($(B1.east)!0.55!(B6.west)$){};
\node[align=center,above=2pt of AR2,font=\usefont{T1}{phv}{m}{n}\footnotesize]{Memory\\ Interface};
\end{tikzpicture}
```
:::

The evolution from the Intel 8087 to the Google TPU reveals a consistent pattern: hardware evolves to fit the algorithm's dominant bottleneck. Where the 8087 addressed floating-point operations that consumed 80% of scientific computing time, modern AI accelerators address matrix operations that constitute over 95% of neural network computation. This concentration of demand explains why specialized AI silicon achieves 100-1000$\times$ performance improvements over general-purpose processors.

The constraints identified above (massive parallelism, predictable data flow, and tolerance for reduced precision) shape accelerator architecture. Before examining the computational primitives that exploit these characteristics, we examine the architectural organization that enables their efficient execution. Modern AI accelerators achieve their dramatic performance improvements through a carefully orchestrated hierarchy of specialized components operating in concert.

The processing substrate consists of an array of processing elements\index{Processing Element!accelerator building block} (visible as the "PE" grid in @fig-accelerator-anatomy), each containing dedicated computational units optimized for specific operations: tensor cores\index{Tensor Cores!matrix multiplication} execute matrix multiplication, vector units\index{Vector Unit!element-wise operations} perform element-wise operations, and special function units\index{Special Function Unit!activation functions} compute activation functions. These processing elements are organized in a grid topology that enables massive parallelism, with dozens to hundreds of units operating simultaneously on different portions of the computation, exploiting the data-level parallelism inherent in neural network workloads.

The memory hierarchy forms an equally critical architectural component. High-bandwidth memory\index{HBM!throughput requirements} provides the aggregate throughput required to sustain these numerous processing elements, while a multi-level cache hierarchy\index{Cache Hierarchy!L1/L2} from shared L2 caches\index{L2 Cache!shared} down to per-element L1 caches\index{L1 Cache!per-element} and scratchpads minimizes the energy cost of data movement. This hierarchical organization embodies a core design principle: in AI accelerators, data movement typically consumes more energy than computation itself, necessitating architectural strategies that prioritize data reuse by maintaining frequently accessed values (including weights and partial results) in proximity to compute units. Reference specifications for modern accelerators (H100, TPU v5) appear in @tbl-hardware-cheatsheet; @tbl-latency-hierarchy quantifies the access time penalties across each memory level.

The host interface establishes connectivity between the specialized accelerator and the broader computing system, enabling coordination between general-purpose CPUs that manage program control flow and the accelerator that executes computationally intensive neural network operations.

This architectural partitioning reflects specialization at the system level: CPUs address control flow, conditional logic, and system coordination, while accelerators focus on the regular, massively parallel arithmetic operations that dominate neural network execution. Return to @fig-accelerator-anatomy and trace the data path from the host interface on the left, through the memory hierarchy, and into the processing element grid — this end-to-end integration is what makes the system optimized for AI workloads rather than general computation.

With the accelerator's physical architecture established, the natural question becomes: *why* these specific components? Tensor cores, vector units, and hierarchical memory do not exist by accident — they exist because neural network computations repeatedly invoke a small set of operations. Understanding these patterns is essential because they explain which algorithmic changes translate to real speedups (those that align with hardware primitives) and which remain purely theoretical.

## AI Compute Primitives {#sec-ai-acceleration-ai-compute-primitives-2c99}

\index{Compute Primitives!AI accelerators}\index{Neural Network!dominant MAC pattern}Regardless of the layer type — fully connected, convolutional, or attention-based — the dominant operation in neural networks is multiplying input values by learned weights and accumulating the results. This multiply-accumulate (MAC) pattern consumes over 95% of execution time and appears billions of times per inference pass. Its regularity is what makes hardware specialization possible: unlike general-purpose code with unpredictable branches and irregular memory access, MACs follow fixed data-flow patterns with predictable reuse, enabling architectures that trade away generality for raw throughput. The transition from CPUs achieving approximately 100 GFLOPS to accelerators delivering 100,000+ GFLOPS reflects this architectural bet — eliminating flexibility to optimize for the specific operations that neural networks actually perform.

We call the hardware units that exploit these patterns *AI compute primitives*: specialized functional blocks, each optimized for a particular class of operation. Three primitives dominate modern accelerators, each targeting a distinct computational pattern found in neural networks.

@lst-dense_layer_def demonstrates how a dense layer decomposes at the framework level, encapsulating thousands of multiply-accumulate operations in a single high-level call.

::: {#lst-dense_layer_def lst-cap="**Dense Layer Abstraction**: High-level framework APIs encapsulate 131,072 multiply-accumulate operations (256 inputs times 512 outputs) in a single function call, hiding the computational complexity from developers while enabling automatic hardware optimization."}
```{.python}
# Framework abstracts compute-intensive operations
dense = Dense(512)(input_tensor)  # 256×512 = 131K MACs per sample
```
:::

This single line of code conceals the computational complexity that accelerators must handle. @lst-dense_expansion reveals how the framework expands this high-level call into mathematical operations.

::: {#lst-dense_expansion lst-cap="**Matrix Operation Expansion**: Each dense layer decomposes into matrix multiplication and element-wise operations, exposing the dominant compute pattern that consumes over 95% of neural network execution time."}
```{.python}
# Linear transformation: O(input_dim × output_dim × batch) operations
output = (
    matmul(input, weights) + bias
)  # Matrix multiply dominates cost
output = activation(output)  # Element-wise: O(output_dim × batch)
```
:::

The matrix multiplication dominates computation time, but this abstraction still hides the underlying loop structure. At the processor level, @lst-loop_level_dense reveals how nested loops multiply inputs and weights, sum the results, and apply a nonlinear function, exposing the O(batch × input × output) complexity that accelerators must handle efficiently.

::: {#lst-loop_level_dense lst-cap="**Processor-Level Execution**: Nested loops reveal the O(batch × input × output) multiply-accumulate operations that accelerators must execute, with 4 million MACs for typical batch=32, input=256, output=512 configurations."}
```{.python}
# Total operations: batch_size × output_size × input_size MACs
for n in range(batch_size):  # Batch dimension: parallelizable
    for m in range(output_size):  # Output neurons: parallelizable
        sum = bias[m]  # Initialize accumulator
        for k in range(input_size):  # Reduction dimension: sequential
            sum += input[n, k] * weights[k, m]  # MAC operation
        output[n, m] = activation(sum)  # Non-linear transformation
# Example: 32 × 512 × 256 = 4.2M multiply-accumulate operations
```
:::

This loop structure reveals three distinct computational patterns that recur across all neural network architectures: element-wise operations along vectors (the activation function applied to each output), matrix-level reductions (the weighted sum across all input features), and nonlinear transformations (the activation function itself). Each pattern is frequent enough to justify dedicated silicon, offers orders-of-magnitude speedup when specialized, and has remained stable across decades of neural network evolution — from early perceptrons through modern transformers. The following sections examine how accelerators exploit each pattern through *vector operations*, *matrix operations*, and *special function units*.

### Vector Operations {#sec-ai-acceleration-vector-operations-19bf}

\index{Vector Operations!hardware acceleration}\index{SIMD!data-level parallelism}Vector operations provide the first level of hardware acceleration by processing multiple data elements simultaneously. Recall the nested-loop structure exposed in @lst-loop_level_dense: a batch of 32 samples through a 256-to-512 dense layer requires over 4 million multiply-accumulate operations. A traditional scalar processor executes these one at a time — loading an input value and a weight value, multiplying them, and accumulating the result — making this sequential approach hopelessly inefficient for neural networks that repeat this pattern across millions of parameters.

Vector processing units solve this by operating on multiple data elements simultaneously. @lst-riscv_vector_mac reveals these capabilities through RISC-V\index{RISC-V!vector extensions}[^fn-risc-v-ai] assembly code, where a single instruction processes eight data elements in parallel.

[^fn-risc-v-ai]: **RISC-V for AI**\index{RISC-V!open-source ISA for AI}: RISC-V, the open-source instruction set architecture from UC Berkeley (2010), is becoming important for AI accelerators because it is freely customizable. Companies like SiFive and Google have created RISC-V chips with custom AI extensions. Unlike proprietary architectures, RISC-V allows hardware designers to add specialized ML instructions without licensing fees, potentially democratizing AI hardware development beyond the current duopoly of x86 and ARM.

::: {#lst-riscv_vector_mac lst-cap="**Vectorized Multiply-Accumulate Loop**: This loop showcases how RISC-V vector instructions enable efficient batch processing by performing 8 multiply-add operations simultaneously, reducing computational latency in neural network training. [@riscv_manual]"}
```{.c}
vsetvli t0, a0, e32   # <1>
loop_batch:
    loop_neuron:
        vxor.vv v0, v0, v0    # <2>
        loop_feature:
            vle32.v v1, (in_ptr)    # <3>
            vle32.v v2, (wt_ptr)    # <3>
            vfmacc.vv v0, v1, v2    # <4>
            add in_ptr, in_ptr, 32  # <5>
            add wt_ptr, wt_ptr, 32  # <5>
            bnez feature_cnt, loop_feature
```

1. **Vector Length Configuration**: Configures the vector units to process 32-bit elements, automatically determining how many operations happen in parallel based on hardware width (VLEN).
2. **Vector Initialization**: Clears the accumulator vector `v0` (containing e.g., 8 parallel sums) using an exclusive-OR operation, which is more efficient than a load immediate.
3.  **Vector Loads**: Loads continuous 32-bit input and weight values from memory into vector registers `v1` and `v2` in a single instruction, maximizing memory bandwidth utilization.
4.  **Fused Multiply-Accumulate**\index{Fused Multiply-Accumulate!throughput doubling}: Performs parallel multiply-add operations ($v_0 = v_0 + v_1 \times v_2$). This is the core computational primitive, doubling throughput compared to separate multiply and add instructions.
5.  **Pointer Arithmetic**: Updates memory pointers by the vector byte length to prepare for the next data chunk.
:::

The key insight from this assembly sequence is that the fused multiply-accumulate instruction (`vfmacc.vv`) performs the same operation that would require separate multiply and add instructions on a scalar processor, while the vector load instructions (`vle32.v`) amortize memory access overhead across multiple data elements. This vector implementation processes eight data elements in parallel, reducing both computation time and energy consumption. Vector load instructions transfer eight values simultaneously, maximizing memory bandwidth utilization. The vector multiply-accumulate instruction processes eight pairs of values in parallel, dramatically reducing the total instruction count from over 4 million to approximately 500,000.

Key vector operations map directly to common deep learning patterns. @tbl-vector enumerates how operations such as reduction, gather, scatter, and masked operations appear frequently in pooling, embedding lookups, and attention mechanisms, clarifying the direct mapping between low-level vector hardware and high-level machine learning workloads.

| **Vector Operation**        | **Description**                                     | **Neural Network Application**              |
|:--------------------------|:--------------------------------------------------|:------------------------------------------|
| **Reduction**               | Combines elements across a vector (e.g., sum, max)  | Pooling layers, attention score computation |
| **Gather**                  | Loads multiple non-consecutive memory elements      | Embedding lookups, sparse operations        |
| **Scatter**                 | Writes to multiple non-consecutive memory locations | Gradient updates for embeddings             |
| **Masked operations**       | Selectively operates on vector elements             | Attention masks, padding handling           |
| **Vector-scalar broadcast** | Applies scalar to all vector elements               | Bias addition, scaling operations           |

: **Vector Operations.** Core vector operations map directly to deep learning primitives: reductions implement pooling layers, gathers enable embedding lookups, scatters update embedding gradients, and masked operations handle attention masks. Each operation exploits data-level parallelism to process multiple elements simultaneously, explaining why vector units are universal across all accelerator designs. {#tbl-vector}

These efficiency gains extend beyond instruction count reduction. Memory bandwidth utilization improves as vector loads transfer multiple values per operation, and energy efficiency increases because control logic is amortized across many data elements. These improvements compound across the deep layers of modern neural networks, where billions of element-wise operations execute per forward pass. The architectural pattern is not new — the Cray-1\index{Cray-1!vector computing legacy}[^fn-cray-vector] pioneered the same approach for scientific computing in 1975 [@jordan1982guide] — but neural networks have given it unprecedented commercial importance.

[^fn-cray-vector]: **Cray-1 Vector Legacy**: The Cray-1 (1975) cost $8.8 million (approximately $40-45 million in 2024 dollars) but could perform 160 million floating-point operations per second, 1000× faster than typical computers. Its 64-element vector registers and pipelined vector units established the architectural template that modern AI accelerators still follow: process many data elements simultaneously with specialized hardware pipelines.

Vector operations excel at element-wise transformations like activation functions, where each output depends only on its corresponding input. But neural networks also require *structured* computations where each output depends on *all* inputs — the weighted sums that define layer transformations. These many-to-many operations naturally express themselves as matrix multiplications, our second compute primitive.

### Matrix Operations {#sec-ai-acceleration-matrix-operations-508d}

\index{Matrix Multiplication!neural network workhorse}
Matrix operations dominate neural network computation, transforming high-dimensional data through structured patterns of weights, activations, and gradients [@goodfellow2016deep]. While vector operations process elements independently, matrix operations orchestrate computations across multiple dimensions simultaneously. These operations reveal patterns that drive hardware acceleration strategies.

#### Matrix Operations in Neural Networks {#sec-ai-acceleration-matrix-operations-neural-networks-527a}

\index{Matrix Operations!hierarchical decomposition}
Neural network computations decompose into hierarchical matrix operations. @lst-linear_matrix_hierarchy captures this hierarchy through a linear layer that transforms input features into output neurons over a batch.

::: {#lst-linear_matrix_hierarchy lst-cap="**Matrix Operations**: Neural networks perform transformations using matrix multiplications and biases to achieve output predictions. Training requires careful management of input batches and activation functions to optimize model performance."}
```{.python}
layer = nn.Linear(256, 512)  # Layer transforms 256 inputs to
# 512 outputs
output = layer(input_batch)  # Process a batch of 32 samples

# Framework Internal: Core operations
Z = matmul(weights, input)  # Matrix: transforms [256 x 32]
# input to [512 x 32] output
Z = Z + bias  # Vector: adds bias to each
# output independently
output = relu(Z)  # Vector: applies activation to
# each element independently
```
:::

```{python}
#| label: weight-matrix-calc
#| echo: false
# ┌─────────────────────────────────────────────────────────────────────────────
# │ WEIGHT MATRIX PARAMETER COUNT
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: Prose describing scale of matrix operations in neural networks
# │
# │ Why: Calculates weight matrix dimensions and total parameter count to
# │      illustrate why efficient matrix multiplication dominates performance.
# │
# │ Imports: mlsys.formatting (fmt)
# │ Exports: wm_in_str, wm_out_str, wm_params_str
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.formatting import fmt

# --- Inputs (layer dimensions) ---
wm_in_value = 256
wm_out_value = 512

# --- Outputs (formatted strings for prose) ---
wm_params_value = wm_in_value * wm_out_value
wm_params_str = f"{wm_params_value:,}"
wm_out_str = fmt(wm_out_value, precision=0, commas=False)
wm_in_str = fmt(wm_in_value, precision=0, commas=False)
```

This computation demonstrates the scale of matrix operations in neural networks. Each output neuron (`{python} wm_out_str` total) must process all input features (`{python} wm_in_str` total) for every sample in the batch (32 samples). The weight matrix alone contains `{python} wm_in_str` × `{python} wm_out_str` = `{python} wm_params_str` parameters that define these transformations, illustrating why efficient matrix multiplication dominates performance considerations.

Neural networks employ matrix operations across diverse architectural patterns beyond simple linear layers.

\index{Convolution!matrix multiplication equivalence}
Matrix operations appear consistently across modern neural architectures. Convolution operations transform into matrix multiplications through the im2col technique\index{im2col!convolution to matrix}[^fn-im2col-hardware], enabling efficient execution on matrix-optimized hardware. @lst-matrix_patterns illustrates these diverse applications.

[^fn-im2col-hardware]: **Im2col (Image-to-Column)**: A preprocessing technique that converts convolution operations into matrix multiplications by unfolding image patches into column vectors. A 3×3 convolution on a 224×224 image creates a matrix with ~50,000 columns, enabling efficient GEMM execution but increasing memory usage 9× due to overlapping patches. This transformation explains why convolutions are actually matrix operations in modern ML accelerators.

::: {#lst-matrix_patterns lst-cap="**Linear Layers**: Layer transformations combine input features to produce hidden representations. Matrix operations in neural networks enable efficient feature extraction and transformation, forming the backbone of many machine learning architectures."}
```{.python}
hidden = matmul(weights, inputs)
# weights: [out_dim x in_dim], inputs: [in_dim x batch]
# Result combines all inputs for each output

# Attention Mechanisms - Multiple matrix operations
Q = matmul(Wq, inputs)
# Project inputs to query space [query_dim x batch]
K = matmul(Wk, inputs)
# Project inputs to key space [key_dim x batch]
attention = matmul(Q, K.T)
# Compare all queries with all keys [query_dim x key_dim]

# Convolutions - Matrix multiply after reshaping
patches = im2col(input)
# Convert [H x W x C] image to matrix of patches
output = matmul(kernel, patches)
# Apply kernels to all patches simultaneously
```
:::

This pervasive pattern of matrix multiplication has direct implications for hardware design: the need for efficient matrix operations drives the development of specialized hardware architectures that can handle these computations at scale.

#### Matrix Operations Hardware Acceleration {#sec-ai-acceleration-matrix-operations-hardware-acceleration-514a}

\index{Matrix Operations!hardware acceleration}
The computational demands of matrix operations have driven specialized hardware optimizations. @lst-matrix_unit demonstrates how modern processors implement dedicated matrix units that process entire 16×16 blocks simultaneously, achieving 32× higher throughput than vector processing alone.

::: {#lst-matrix_unit lst-cap="**Matrix Unit Operation**: Enables efficient block-wise matrix multiplication and accumulation in hardware-accelerated systems, demonstrating how specialized units streamline computational tasks for AI/ML operations."}
```{.c}
mload mr1, (weight_ptr)     # Load e.g., 16x16 block of
                            # weight matrix
mload mr2, (input_ptr)      # Load corresponding input block
matmul.mm mr3, mr1, mr2     # Multiply and accumulate entire
                            # blocks at once
mstore (output_ptr), mr3    # Store computed output block
```
:::

This matrix processing unit can handle $16\times16$ blocks of the linear layer computation described earlier, processing 256 multiply-accumulate operations simultaneously compared to the 8 operations possible with vector processing. These matrix operations complement vectorized computation by enabling structured many-to-many transformations. The interplay between matrix and vector operations shapes the efficiency of neural network execution.

Like vector processing, matrix acceleration has deep historical roots — DSPs and GPUs optimized for matrix computations in the 1980s-1990s for image processing, scientific computing, and 3D rendering [@Golub1996Matrix; @owens2008gpu; @Hwu2011GPU]. Neural networks have made matrix multiplication commercially dominant, driving the development of dedicated tensor cores and TPUs that process these operations at unprecedented scale.

@tbl-matrix contrasts the two primitive types, clarifying which neural network operations map to each.

| **Operation Type**    | **Best For**            | **Examples**                                                      | **Key Characteristic**                          |
|:--------------------|:----------------------|:----------------------------------------------------------------|:----------------------------------------------|
| **Matrix Operations** | Many-to-many transforms | Layer transformations, attention, convolutions                    | Each output depends on multiple inputs          |
| **Vector Operations** | One-to-one transforms   | Activation functions, layer normalization, element-wise gradients | Each output depends only on corresponding input |

: **Operation Characteristics**: Matrix operations excel at many-to-many transformations common in neural network layers, while vector operations efficiently handle one-to-one transformations like activation functions and normalization. The distinction determines which hardware primitive — tensor core or vector unit — delivers optimal performance for each operation. {#tbl-matrix}

Matrix and vector operations together handle the linear algebra of neural networks. But between every linear transformation sits a non-linear activation function — and these transcendental computations (exponentials, square roots, trigonometric functions) cannot be efficiently expressed through multiply-accumulate alone.

### Special Function Units {#sec-ai-acceleration-special-function-units-ed00}

Special Function Units (SFUs)\index{Special Function Units!SFU} provide dedicated hardware for these non-linear computations, completing the trio of core processing primitives. The need for such units is not new — floating-point co-processors in the 1970s-1980s and SSE/NEON instruction set extensions in the 1990s addressed similar demands for scientific computing [@Smith1997; @palmer_8087_1981]. Neural networks have intensified this demand because activation functions, normalization layers, and softmax transformations appear after every linear layer, making them a throughput bottleneck rather than an occasional convenience.

#### Non-Linear Functions

To see why dedicated hardware matters, consider a typical layer sequence [@goodfellow2016deep]. @lst-nonlinear_layer combines linear transformations with non-linear activations — operations that appear simple in Python but reveal substantial computational complexity at the hardware level.

::: {#lst-nonlinear_layer lst-cap="**Non-Linear Transformations**: Neural networks process input data through a sequence of linear transformations followed by non-linear activations to capture complex patterns. This layer sequence enhances model expressiveness and learning capabilities."}
```{.python}
layer = nn.Sequential(
    nn.Linear(256, 512), nn.ReLU(), nn.BatchNorm1d(512)
)
output = layer(input_tensor)
```
:::

This sequence introduces multiple non-linear transformations that extend beyond simple matrix operations. @lst-nonlinear_math breaks down these operations into their mathematical components, exposing the computational complexity that hardware must address.

::: {#lst-nonlinear_math lst-cap="**Non-linear Transformations**: Neural networks apply linear and non-linear operations to transform input data into meaningful features for learning. Machine learning models use these transformations to capture complex patterns in data efficiently."}
```{.python}
Z = matmul(weights, input) + bias  # Linear transformation
H = max(0, Z)  # ReLU activation
mean = reduce_mean(H, axis=0)  # BatchNorm statistics
var = reduce_mean((H - mean) ** 2)  # Variance computation
output = gamma * (H - mean) / sqrt(var + eps) + beta
# Normalization
```
:::

#### Hardware Implementation of Non-Linear Functions

The computational complexity of these operations becomes apparent when examining their implementation on traditional processors. These seemingly simple mathematical operations translate into complex sequences of instructions. Consider the computation of batch normalization: calculating the square root requires multiple iterations of numerical approximation, while exponential functions in operations like softmax need series expansion or lookup tables [@ioffe2015batch]. \index{Batch Normalization!hardware implementation}\index{ReLU!conditional operation overhead}
Even a simple ReLU activation introduces branching logic that can disrupt instruction pipelining. @lst-traditional_overhead demonstrates these inefficiencies.

::: {#lst-traditional_overhead lst-cap="**ReLU and BatchNorm Operations**: Neural networks process input data through conditional operations that can disrupt instruction pipelining and multiple passes required for normalization, highlighting efficiency challenges in traditional implementations. [@ieee_spectrum_relu]"}
```{.python}
for batch in range(32):
    for feature in range(512):
       # ReLU: Requires branch prediction and potential
       # pipeline stalls
       z = matmul_output[batch, feature]
       h = max(0.0, z)    # Conditional operation

       # BatchNorm: Multiple passes over data
       mean_sum[feature] += h    # First pass for mean
       var_sum[feature] += h * h # Additional pass for variance

       temp[batch, feature] = h  # Extra memory storage needed

# Normalization requires complex arithmetic
for feature in range(512):
    mean = mean_sum[feature] / batch_size
    var = (var_sum[feature] / batch_size) - mean * mean

    # Square root computation: Multiple iterations
    scale = gamma[feature] / sqrt(var + eps)  # Iterative
                                              # approximation
    shift = beta[feature] - mean * scale

    # Additional pass over data for final computation
    for batch in range(32):
        output[batch, feature] = temp[batch, feature] *
                                 scale + shift
```
:::

These operations introduce several interrelated inefficiencies that compound across the deep layers of modern networks. Multiple passes over data inflate memory bandwidth requirements, while complex arithmetic operations like square root and exponential demand many instruction cycles each. Conditional operations such as ReLU's max function cause pipeline stalls on traditional processors, and the need for intermediate storage between passes further increases memory pressure. Vector processing units, designed for regular computations, cannot fully utilize their width on operations like exponentials and square roots that require scalar evaluation.

More specifically, each operation introduces distinct challenges. Batch normalization requires multiple passes through data: one for mean computation, another for variance, and a final pass for output transformation. Each pass loads and stores data through the memory hierarchy. Operations that appear simple in mathematical notation often expand into many instructions. The square root computation typically requires 10–20 iterations of numerical methods like Newton-Raphson approximation for suitable precision [@Goldberg1991]. Conditional operations like ReLU's max function require branch instructions that can stall the processor's pipeline. The implementation needs temporary storage for intermediate values, increasing memory usage and bandwidth consumption. While vector units excel at regular computations, functions like exponentials and square roots often require scalar operations that cannot fully utilize vector processing capabilities.

#### SFU Hardware Implementation

SFUs address these inefficiencies through dedicated hardware implementation. Modern ML accelerators include specialized circuits that transform these complex operations into single-cycle or fixed-latency computations. @lst-sfu_vector_ops demonstrates this efficiency: loading a vector of values allows the accelerator to apply ReLU, sigmoid, and square root operations directly in 1–8 cycles, eliminating multiple passes and complex instruction sequences.

::: {#lst-sfu_vector_ops lst-cap="**Hardware Acceleration**: Single-cycle non-linear operations enable efficient vector processing in ML accelerators, demonstrating how specialized hardware reduces computational latency."}
```{.c}
vld.v v1, (input_ptr)    # Load vector of values
vrelu.v v2, v1           # Single-cycle ReLU on entire vector
vsigm.v v3, v1           # Fixed-latency sigmoid computation
vtanh.v v4, v1           # Direct hardware tanh implementation
vrsqrt.v v5, v1          # Fast reciprocal square root
```
:::

Each SFU implements a specific function through specialized circuitry. For instance, a ReLU unit performs the comparison and selection in dedicated logic, eliminating branching overhead. Square root operations use hardware implementations of algorithms like Newton-Raphson with fixed iteration counts, providing predictable latency bounds. Exponential and logarithmic functions often combine small lookup tables with hardware interpolation circuits [@Lauterbach2019]. @tbl-sfu summarizes the various hardware implementations and their typical latencies, spanning from single-cycle activations to logarithmic-time reductions.

| **Function Unit**    | **Operation**       | **Implementation Strategy**           | **Typical Latency** |
|:-------------------|:------------------|:------------------------------------|------------------:|
| **Activation Unit**  | ReLU, sigmoid, tanh | Piece-wise approximation circuits     |          1–2 cycles |
| **Statistics Unit**  | Mean, variance      | Parallel reduction trees              |       log(N) cycles |
| **Exponential Unit** | exp, log            | Table lookup + hardware interpolation |          2–4 cycles |
| **Root/Power Unit**  | sqrt, rsqrt         | Fixed-iteration Newton-Raphson        |          4–8 cycles |

: **Special Function Units.** Dedicated hardware implementations of common mathematical functions (like relu, sigmoid, and reciprocal square root) accelerate machine learning computations by eliminating software overhead and enabling parallel processing of vector data. Typical latencies of 1–2 cycles per function demonstrate the performance gains achieved through specialized circuitry. {#tbl-sfu}

Vector operations, matrix operations, and special function units constitute the three core computational primitives. The natural question is: how are these components organized into complete execution units? The primitives tell us *what* operations accelerators perform efficiently; the execution models tell us *how* those operations are parallelized across thousands of processing elements. This distinction matters because the same matrix multiplication can achieve 10% or 90% of peak performance depending on how it maps to the execution model — a difference driven by thread organization, memory access patterns, and synchronization overhead rather than algorithmic complexity.

### Compute Units and Execution Models {#sec-ai-acceleration-compute-units-execution-models-f406}

Modern AI processors package the three compute primitives into distinct execution units — SIMD units, tensor cores, and processing elements — that define how computations are structured and exposed to programmers. Understanding this organization reveals both the theoretical capabilities and practical performance characteristics that determine real-world throughput.

#### Mapping Primitives to Execution Units {#sec-ai-acceleration-mapping-primitives-execution-units-ccb6}

The progression from computational primitives to execution units follows a structured hierarchy that reflects the increasing complexity and specialization of AI accelerators:

* Vector operations → SIMD/SIMT units that enable parallel processing of independent data elements
* Matrix operations → Tensor cores and systolic arrays that provide structured matrix multiplication
* Special functions → Dedicated hardware units integrated within processing elements

Each execution unit combines these computational primitives with specialized memory and control mechanisms, optimizing both performance and energy efficiency. This structured packaging allows hardware vendors to expose standardized programming interfaces while implementing diverse underlying architectures tailored to specific workload requirements. The choice of execution unit significantly influences overall system efficiency, affecting data locality, compute density, and workload adaptability. Subsequent sections examine how these execution units operate within AI accelerators to maximize performance across different machine learning tasks.

#### Evolution from SIMD to SIMT Architectures {#sec-ai-acceleration-evolution-simd-simt-architectures-e1fd}

Imagine applying ReLU activation to a 512-element vector. A scalar processor executes 512 comparison-and-select operations sequentially. A **SIMD**[^fn-simd-evolution] (Single Instruction, Multiple Data)\index{SIMD!Single Instruction Multiple Data} unit processes 8 or 16 elements per instruction, reducing the work to 32–64 instructions. An **SIMT** (Single Instruction, Multiple Thread) GPU dispatches 512 lightweight threads simultaneously, one per element, completing the entire operation in a single wave. This progression from scalar to SIMD to SIMT reflects a fundamental insight: neural network operations consist of identical computations applied to independent data elements, and each architectural generation exploits this regularity more aggressively.

SIMD execution applies identical operations to multiple data elements in parallel, minimizing instruction overhead while maximizing data throughput. This execution model is widely used to accelerate workloads with regular, independent data parallelism, such as neural network computations. The ARM Scalable Vector Extension (SVE) provides a representative example of how modern architectures implement SIMD operations efficiently. @lst-arm_sve_vector demonstrates this approach.

[^fn-simd-evolution]: **SIMD (Single Instruction, Multiple Data)**\index{SIMD!Flynn taxonomy origin}\index{Flynn, Michael!architecture taxonomy}: From Michael Flynn's 1966 taxonomy classifying computer architectures by instruction and data streams. SIMD describes machines where one instruction operates on multiple data elements simultaneously. SIMT (Single Instruction, Multiple Thread), coined by NVIDIA, extends this to many lightweight threads sharing instruction fetch. While CPUs use wide SIMD units (e.g., AVX-512), GPUs coordinate tens of thousands of threads concurrently through SIMT, enabling the massive parallelism neural networks require.

::: {#lst-arm_sve_vector lst-cap="**Vector Operation**: Vector multiplication and addition operations enable efficient parallel processing in machine learning models. [@ARM2020]"}
```{.c}
ptrue p0.s              # Create predicate for vector length
ld1w z0.s, p0/z, [x0]   # Load vector of inputs
fmul z1.s, z0.s, z0.s   # Multiply elements
fadd z2.s, z1.s, z0.s   # Add elements
st1w z2.s, p0, [x1]     # Store results
```
:::

\index{AMX!Advanced Matrix Extensions}
Processor architectures continue to expand SIMD capabilities to accommodate increasing computational demands. Intel's Advanced Matrix Extensions (AMX) [@intel2021amx] and ARM's SVE2 architecture [@stephens2017arm] provide flexible SIMD execution, enabling software to scale across different hardware implementations.

To address these limitations, SIMT\index{SIMT!Single Instruction Multiple Thread}[^fn-dally-gpu] extends SIMD principles by enabling parallel execution across multiple independent threads, each maintaining its own program counter and architectural state [@lindholm2008nvidia; @nickolls2008scalable]. This model maps naturally to matrix computations, where each thread processes different portions of a workload while still benefiting from shared instruction execution. In NVIDIA's GPU architectures, each Streaming Multiprocessor (SM)\index{Streaming Multiprocessor!GPU architecture}[^fn-streaming-multiprocessor] coordinates thousands of threads executing in parallel, allowing for efficient scaling of neural network computations. Threads are organized into warps\index{Warp!execution unit}[^fn-warp], which are the basic execution units that enable SIMT efficiency. @lst-cuda_simt shows this parallel processing model in action.

[^fn-dally-gpu]: **GPU Computing for Deep Learning**: The transformation of GPUs from graphics accelerators into deep learning engines owes much to William Dally, a Stanford professor who became NVIDIA's Chief Scientist in 2009. Dally's research on interconnection networks, parallel architectures, and domain-specific computing laid the intellectual foundation for modern GPU design. Under his leadership, NVIDIA developed Tensor Cores and the CUDA programming model that made GPUs the dominant platform for training neural networks. His 2015 paper with collaborators demonstrated that neural networks could achieve AlexNet-level accuracy using only 8-bit precision—a finding that shaped the INT8 acceleration now standard in inference hardware.

[^fn-streaming-multiprocessor]: **Streaming Multiprocessor (SM)**: A GPU compute unit containing many lightweight execution lanes, shared memory, and schedulers. SMs execute threads in a SIMT fashion, where groups of threads follow the same instruction stream while operating on different data, enabling massive parallelism on regular numerical workloads.

[^fn-warp]: **Warp**: From weaving terminology, where the warp consists of parallel threads held taut on a loom while the weft weaves through them. NVIDIA adopted this metaphor for its basic execution unit of 32 threads that execute in lock-step, emphasizing how these parallel threads are "woven" together in coordinated execution. All threads in a warp share instruction fetch; if they diverge in control flow, the warp serializes execution paths, reducing efficiency.

::: {#lst-cuda_simt lst-cap="**SIMT Execution**: Each thread processes a unique output element in parallel, demonstrating how SIMT enables efficient matrix multiplication on GPUs."}
```{.c}
__global__ void matrix_multiply(float* C, float* A, float*
                                B, int N) {  // CUDA kernel\index{CUDA!kernel launch}
    // Each thread processes one output element
    int row = blockIdx.y * blockDim.y + threadIdx.y;
    int col = blockIdx.x * blockDim.x + threadIdx.x;

    float sum = 0.0f;
    for (int k = 0; k < N; k++) {
        // Threads in a warp execute in parallel
        sum += A[row * N + k] * B[k * N + col];
    }
    C[row * N + col] = sum;
}
```
:::

[^fn-cuda]: **CUDA (Compute Unified Device Architecture)**\index{CUDA!etymology}: Released by NVIDIA in 2006, CUDA transformed GPUs from graphics-only devices into general-purpose parallel processors. The name reflects its goal: *unifying* the GPU's capabilities under a single C-like programming model. Before CUDA, using GPUs for scientific computing required disguising computations as graphics operations (GPGPU). CUDA eliminated this friction, enabling the deep learning revolution. The ecosystem it created---cuBLAS, cuDNN, TensorRT---established a software moat that remains NVIDIA's primary competitive advantage. See @sec-ai-frameworks for how modern frameworks abstract over CUDA.

The listing above shows a CUDA[^fn-cuda] kernel where SIMT execution allows neural network computations to scale efficiently across thousands of threads while maintaining flexibility for divergent execution paths. Similar execution models appear in AMD's RDNA and Intel's Xe architectures, reinforcing SIMT as a core mechanism for AI acceleration.

#### Tensor Cores {#sec-ai-acceleration-tensor-cores-771f}

\index{Tensor Cores!definition}
Consider a single transformer attention head computing the $Q \times K^T$ product for a 2048-token sequence with 64-dimensional embeddings. This operation requires multiplying a $2048 \times 64$ matrix by a $64 \times 2048$ matrix — roughly 537 million multiply-accumulate operations. On a scalar processor executing one operation per cycle at 2 GHz, this single attention head would take 268 milliseconds. A GPU's SIMT execution reduces this to roughly 34 milliseconds through thread-level parallelism. But a tensor core, processing entire $16 \times 16$ matrix tiles per instruction, completes the same operation in under 0.5 milliseconds — a 500× improvement over scalar execution. This dramatic speedup arises not from faster clock speeds but from a fundamentally different approach to organizing computation around matrix blocks rather than individual elements.

While SIMD and SIMT units provide efficient execution of vector operations, neural networks rely heavily on matrix computations\index{Matrix Operations!neural network workloads} that require specialized execution units for structured multi-dimensional processing. The energy economics of matrix operations drive this specialization: traditional scalar processing can require multiple off-chip memory accesses per operation, while tensor cores\index{Tensor Cores!energy efficiency} amortize data movement across entire matrix blocks. Tensor processing units extend SIMD and SIMT principles by enabling efficient matrix operations through dedicated hardware blocks (**tensor cores**) that execute matrix multiplications and accumulations on matrix tiles. In many cases, this shifts the dominant cost from off-chip data movement toward on-chip reuse and arithmetic, depending on the kernel mix and memory behavior.

Tensor cores[^fn-hwacc-tensor-cores] provide an example of this approach. @lst-tensor_core_op exposes matrix computation capabilities through specialized instructions that use dedicated hardware blocks.

[^fn-hwacc-tensor-cores]: **Tensor Core**\index{V100!first tensor core GPU}: The term "tensor" derives from Latin "tendere" (to stretch), originally describing mathematical objects that transform under coordinate changes. In ML, tensors generalize matrices to arbitrary dimensions. NVIDIA introduced tensor cores in the V100 (2017) to accelerate the small matrix operations (4x4x4 tiles) common in neural networks. On supported kernels and reduced-precision modes, tensor cores deliver large speedups over conventional GPU execution, with modern accelerators reaching hundreds of TFLOPS for reduced-precision dense kernels.

::: {#lst-tensor_core_op lst-cap="**Tensor Core Operation**: Matrix multiplications are performed in parallel across entire matrix blocks, optimizing computational efficiency for neural network training."}
```{.c}

Tensor Core Operation (example GPU):
mma.sync.aligned.m16n16k16.f16.f16
  {d0,d1,d2,d3},     // Destination registers
  {a0,a1,a2,a3},     // Source matrix A
  {b0,b1,b2,b3},     // Source matrix B
  {c0,c1,c2,c3}      // Accumulator
```
:::

A single tensor core instruction processes an entire matrix block while maintaining intermediate results in local registers, improving computational efficiency compared to implementations based on scalar or vector operations. This structured approach enables hardware to achieve high throughput while reducing the burden of explicit loop unrolling and data management at the software level.

Tensor processing unit architectures differ based on design priorities. Some GPU families incorporate tensor cores\index{Tensor Cores!precision support} optimized for general-purpose deep learning acceleration. TPU-style designs utilize large-scale matrix units arranged in systolic arrays to maximize sustained training throughput on dense tensor kernels. Mobile NPUs[^fn-hwacc-neural-engine] integrate smaller matrix processors optimized for low-power inference workloads, while some server CPUs introduce matrix instruction extensions (AMX-class tiles) designed for datacenter inference and mixed workloads.

[^fn-hwacc-neural-engine]: **On-Device Neural Engine Strategy**: Many mobile SoCs include dedicated neural engines (NPUs) to enable on-device ML within tight battery and thermal envelopes. These blocks can accelerate common inference kernels efficiently, supporting interactive features such as vision and speech processing without requiring cloud connectivity.

The increasing specialization of AI hardware has driven measurable performance improvements in deep learning workloads. To appreciate the magnitude of this shift, trace the curve in @fig-ai-performance from left to right: over a single decade, NVIDIA GPU performance jumped roughly 1,000× as the architecture transitioned from general-purpose floating-point execution units to highly optimized tensor processing cores.

![**GPU Performance Scaling**: NVIDIA GPUs experienced approximately a ~1,000$\times$ increase in integer 8-bit TOPS (tera operations per second) over a decade, from 4 TOPS on the K20X to 4,000 TOPS on the H100. This three-orders-of-magnitude gain was driven by architectural innovations transitioning from floating-point to tensor core acceleration.](images/svg/int8_tops.svg){#fig-ai-performance fig-alt="Line graph of NVIDIA GPU INT8 performance from 2012 to 2023 showing exponential growth from K20X at 4 TOPS to H100 at 4000 TOPS, a 1,000× increase over the decade."}

#### Processing Elements {#sec-ai-acceleration-processing-elements-daa1}

The highest level of execution unit organization integrates multiple tensor cores with local memory into processing elements (PEs). A processing element serves as the primary building block in many AI accelerators, combining different computational units to efficiently execute neural network operations. Each PE typically includes vector units for element-wise operations, tensor cores for matrix computation, special function units for non-linear transformations, and dedicated memory resources to optimize data locality and minimize data movement overhead.

Processing elements balance computational density with memory access efficiency, and their design varies across architectures to support diverse workloads and scalability requirements. Graphcore's Intelligence Processing Unit (IPU)\index{Graphcore!IPU}\index{IPU!Intelligence Processing Unit} distributes computation across 1,472 tiles, each containing independent processing elements optimized for fine-grained parallelism [@Graphcore2020]. Cerebras\index{Cerebras!wafer-scale computing} extends this approach in the CS-2 system, integrating 850,000 processing elements across a wafer-scale device\index{Wafer-Scale Integration!single-die approach} to accelerate sparse computations. Tesla's D1\index{Tesla D1!autonomous vehicle processor} processor arranges processing elements with substantial local memory, optimizing throughput and latency for real-time autonomous vehicle workloads [@Tesla2021].

Processing elements provide the structural foundation for large-scale AI acceleration, though their efficiency depends as much on interconnect strategies and memory hierarchy design as on raw computational capability.

Modern accelerators continue to evolve beyond basic processing element organization, incorporating support for advanced execution techniques that extract more performance from the same silicon. One particularly impactful technique is N:M structured sparsity, which enables hardware to exploit model sparsity without sacrificing memory access efficiency.

#### N:M Structured Sparsity Mechanics {#sec-ai-acceleration-nm-sparsity}

\index{Sparsity!hardware speedup requirement}
While unstructured pruning reduces model size, it rarely translates to hardware speedup because memory access becomes irregular. Hardware accelerators solve this with **N:M Structured Sparsity**\index{Sparsity!N:M structured pattern}[^fn-sparsity-hardware], a pattern-based approach that enforces regularity. The notation "N:M" specifies that exactly N values must be non-zero within every contiguous block of M values, creating a predictable pattern that hardware can exploit.

[^fn-sparsity-hardware]: **Sparsity**: From Latin "sparsus" (scattered), describing how zeros are distributed throughout a matrix rather than densely packed. In ML, sparse matrices have most elements as zero. The N:M notation indicates that exactly N elements must be non-zero in every M-element block, combining the computational benefits of zeros with the predictable access patterns hardware requires.

\index{Structured Sparsity!2:4 hardware support}
NVIDIA's Sparse Tensor Cores implement a concrete instance of this pattern: the 2:4 constraint, which requires that in every contiguous block of 4 values, at least 2 must be zero. This constraint allows the hardware to compress the matrix by 50% in memory and metadata. The execution proceeds in three stages: first, the hardware stores only the 2 non-zero values and 2 bits of metadata (indices) for every 4-element block (compression); second, during matrix multiplication, the Sparse Tensor Core reads the metadata to select the corresponding activations and performs math only on the non-zero weights (compute); third, this effectively doubles the FLOP/byte ratio, providing a theoretical $2\times$ speedup over dense matrix multiplication with minimal accuracy loss, provided the model is fine-tuned to respect the 2:4 constraint.

To understand why "Structured" patterns are required for hardware speedup, consider how sparse matrices are actually stored in memory. Compare the storage layouts in @fig-sparse-formats: a sparse format (like CSR or Block Sparse) must store indices alongside values. If the sparsity is random, the index overhead and irregular access kill performance. Structured sparsity, whether at the *large block* scale or the *fine-grained N:M* scale, makes this indexing predictable and compact, allowing hardware to fetch data efficiently.

::: {#fig-sparse-formats fig-env="figure" fig-pos="htb" fig-cap="**Sparse Storage Formats**: Hardware efficiency depends on how sparse matrices are stored. **Dense** storage (top left) is simple but wasteful for zeros. **Block Sparse** (top right) and **CSR** (bottom) compress the matrix by storing only non-zero values and their indices. Structured sparsity (like N:M or Blocks) makes this indexing predictable, allowing hardware to fetch data and skip zeros efficiently." fig-alt="Grid of 3x3 matrix blocks. Top left: Dense Matrix. Top right: Block Sparse Matrix showing dense sub-blocks. Bottom: Sparse Matrix (CSR) and Block Sparse (BSR) representations showing values and index arrays."}
```{.tikz}
\begin{tikzpicture}[line join=round,font=\usefont{T1}{phv}{m}{n}]
\tikzset{%
helvetica/.style={align=flush center,font=\small\usefont{T1}{phv}{m}{n}},
Line/.style={line width=1.0pt,black!50,text=black},
}
\definecolor{Blue1}{RGB}{23,68,150}
\definecolor{Blue2}{RGB}{84,131,217}
\definecolor{Blue3}{RGB}{145,177,237}
\def\columns{3}
\def\rows{3}
\def\cellsize{5mm}
\def\cellheight{5mm}

\begin{scope}[local bounding box=BL1]
\begin{scope}[local bounding box=matrica1]
\def\rowone{Blue2,Blue3,Blue2}
\def\rowtwo{Blue2,Blue1,Blue2}
\def\rowthree{Blue2,Blue2,Blue2}
\def\br{A}
%
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \node[draw=white, line width=1pt,fill=black!10, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {};
    }
}

%
\foreach \color [count=\x] in \rowone {
    \node[fill=\color,draw=white,line width=1pt, minimum size=\cellsize,
    minimum height=\cellheight] at (cell-\x-1\br) {};
}
\foreach \color [count=\x] in \rowtwo {
    \node[fill=\color,draw=white,line width=1pt, minimum size=\cellsize,
               minimum height=\cellheight] at (cell-\x-2\br) {};
}
\foreach \color [count=\x] in \rowthree {
    \node[fill=\color,draw=white,line width=1pt, minimum size=\cellsize,
               minimum height=\cellheight] at (cell-\x-3\br) {};
}

%countur line
\draw[line width=2pt,black!80]
    (0.5*\cellsize,-0.5*\cellheight) rectangle
    (\columns*\cellsize+0.5*\cellsize,-\rows*\cellheight-0.5*\cellheight);
\end{scope}
%%%%%%
\begin{scope}[shift={(1.5,0)}]
\def\rowone{Blue1,Blue2,Blue2}
\def\rowtwo{Blue3,Blue2,Blue1}
\def\rowthree{Blue2,Blue1,Blue2}
\def\br{B}
%
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \node[draw=white, line width=1pt,fill=black!10, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {};
    }
}

%
\foreach \color [count=\x] in \rowone {
    \node[fill=\color,draw=white,line width=1pt, minimum size=\cellsize,
    minimum height=\cellheight] at (cell-\x-1\br) {};
}
\foreach \color [count=\x] in \rowtwo {
    \node[fill=\color,draw=white,line width=1pt, minimum size=\cellsize,
               minimum height=\cellheight] at (cell-\x-2\br) {};
}
\foreach \color [count=\x] in \rowthree {
    \node[fill=\color,draw=white,line width=1pt, minimum size=\cellsize,
               minimum height=\cellheight] at (cell-\x-3\br) {};
}

%countur line
\draw[line width=2pt,black!80]
    (0.5*\cellsize,-0.5*\cellheight) rectangle
    (\columns*\cellsize+0.5*\cellsize,-\rows*\cellheight-0.5*\cellheight);
\end{scope}
%%%%%%
\begin{scope}[shift={(3.0,0)}]
\def\br{C}
%
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \node[draw=white, line width=1pt,fill=black!10, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {};
    }
}
%countur line
\draw[line width=2pt,black!80]
    (0.5*\cellsize,-0.5*\cellheight) rectangle
    (\columns*\cellsize+0.5*\cellsize,-\rows*\cellheight-0.5*\cellheight);
\end{scope}
\end{scope}

\begin{scope}[local bounding box=BL2,shift={(5.0,0)}]
\begin{scope}[local bounding box=matrica1]
\def\rowone{Blue2,Blue3,Blue2}
\def\rowtwo{Blue2,Blue1,Blue2}
\def\rowthree{Blue2,Blue2,Blue2}
\def\br{D}
%
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \node[draw=white, line width=1pt,fill=black!10, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {};
    }
}

%
\foreach \color [count=\x] in \rowone {
    \node[fill=\color,draw=white,line width=1pt, minimum size=\cellsize,
    minimum height=\cellheight] at (cell-\x-1\br) {};
}
\foreach \color [count=\x] in \rowtwo {
    \node[fill=\color,draw=white,line width=1pt, minimum size=\cellsize,
               minimum height=\cellheight] at (cell-\x-2\br) {};
}
\foreach \color [count=\x] in \rowthree {
    \node[fill=\color,draw=white,line width=1pt, minimum size=\cellsize,
               minimum height=\cellheight] at (cell-\x-3\br) {};
}

%countur line
\draw[line width=2pt,black!80]
    (0.5*\cellsize,-0.5*\cellheight) rectangle
    (\columns*\cellsize+0.5*\cellsize,-\rows*\cellheight-0.5*\cellheight);
\end{scope}
%%%%%%
\begin{scope}[shift={(1.5,0)}]
\def\br{E}
%
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \node[draw=white, line width=1pt,fill=black!10, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {};
    }
}
%countur line
\draw[line width=2pt,black!80]
    (0.5*\cellsize,-0.5*\cellheight) rectangle
    (\columns*\cellsize+0.5*\cellsize,-\rows*\cellheight-0.5*\cellheight);
\end{scope}
%%%%%%
\begin{scope}[shift={(3.0,0)}]
\def\rowone{Blue1,Blue2,Blue2}
\def\rowtwo{Blue3,Blue2,Blue1}
\def\rowthree{Blue2,Blue1,Blue2}
\def\br{F}
%
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \node[draw=white, line width=1pt,fill=black!10, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {};
    }
}

%
\foreach \color [count=\x] in \rowone {
    \node[fill=\color,draw=white,line width=1pt, minimum size=\cellsize,
    minimum height=\cellheight] at (cell-\x-1\br) {};
}
\foreach \color [count=\x] in \rowtwo {
    \node[fill=\color,draw=white,line width=1pt, minimum size=\cellsize,
               minimum height=\cellheight] at (cell-\x-2\br) {};
}
\foreach \color [count=\x] in \rowthree {
    \node[fill=\color,draw=white,line width=1pt, minimum size=\cellsize,
               minimum height=\cellheight] at (cell-\x-3\br) {};
}

%countur line
\draw[line width=2pt,black!80]
    (0.5*\cellsize,-0.5*\cellheight) rectangle
    (\columns*\cellsize+0.5*\cellsize,-\rows*\cellheight-0.5*\cellheight);
\end{scope}
\end{scope}

\begin{scope}[local bounding box=BL3,shift={(0.0,-2.0)}]
\begin{scope}[local bounding box=matrica1]
\def\br{G}
%
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \node[draw=white, line width=1pt,fill=black!10, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {};
    }
}
%countur line
\draw[line width=2pt,black!80]
    (0.5*\cellsize,-0.5*\cellheight) rectangle
    (\columns*\cellsize+0.5*\cellsize,-\rows*\cellheight-0.5*\cellheight);
\end{scope}
%%%%%%
\begin{scope}[shift={(1.5,0)}]
\def\br{H}
%
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \node[draw=white, line width=1pt,fill=black!10, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {};
    }
}
%countur line
\draw[line width=2pt,black!80]
    (0.5*\cellsize,-0.5*\cellheight) rectangle
    (\columns*\cellsize+0.5*\cellsize,-\rows*\cellheight-0.5*\cellheight);
\end{scope}
%%%%%%
\begin{scope}[shift={(3.0,0)}]
\def\rowone{Blue1,Blue2,Blue2}
\def\rowtwo{Blue3,Blue2,Blue1}
\def\rowthree{Blue2,Blue1,Blue2}
\def\br{I}
%
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \node[draw=white, line width=1pt,fill=black!10, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {};
    }
}

%
\foreach \color [count=\x] in \rowone {
    \node[fill=\color,draw=white,line width=1pt, minimum size=\cellsize,
    minimum height=\cellheight] at (cell-\x-1\br) {};
}
\foreach \color [count=\x] in \rowtwo {
    \node[fill=\color,draw=white,line width=1pt, minimum size=\cellsize,
               minimum height=\cellheight] at (cell-\x-2\br) {};
}
\foreach \color [count=\x] in \rowthree {
    \node[fill=\color,draw=white,line width=1pt, minimum size=\cellsize,
               minimum height=\cellheight] at (cell-\x-3\br) {};
}

%countur line
\draw[line width=2pt,black!80]
    (0.5*\cellsize,-0.5*\cellheight) rectangle
    (\columns*\cellsize+0.5*\cellsize,-\rows*\cellheight-0.5*\cellheight);
\end{scope}
\end{scope}

\begin{scope}[local bounding box=BL4,shift={(5.0,-2.0)}]
\begin{scope}[local bounding box=matrica1]
\def\br{J}
%
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \node[draw=white, line width=1pt,fill=black!10, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {};
    }
}
%countur line
\draw[line width=2pt,black!80]
    (0.5*\cellsize,-0.5*\cellheight) rectangle
    (\columns*\cellsize+0.5*\cellsize,-\rows*\cellheight-0.5*\cellheight);
\end{scope}
%%%%%%
\begin{scope}[shift={(1.5,0)}]
\def\rowone{Blue1,Blue2,Blue2}
\def\rowtwo{Blue3,Blue2,Blue1}
\def\rowthree{Blue2,Blue1,Blue2}
\def\br{K}
%
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \node[draw=white, line width=1pt,fill=black!10, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {};
    }
}

%
\foreach \color [count=\x] in \rowone {
    \node[fill=\color,draw=white,line width=1pt, minimum size=\cellsize,
    minimum height=\cellheight] at (cell-\x-1\br) {};
}
\foreach \color [count=\x] in \rowtwo {
    \node[fill=\color,draw=white,line width=1pt, minimum size=\cellsize,
               minimum height=\cellheight] at (cell-\x-2\br) {};
}
\foreach \color [count=\x] in \rowthree {
    \node[fill=\color,draw=white,line width=1pt, minimum size=\cellsize,
               minimum height=\cellheight] at (cell-\x-3\br) {};
}

%countur line
\draw[line width=2pt,black!80]
    (0.5*\cellsize,-0.5*\cellheight) rectangle
    (\columns*\cellsize+0.5*\cellsize,-\rows*\cellheight-0.5*\cellheight);
\end{scope}
%%%%%%
\begin{scope}[shift={(3.0,0)}]
\def\br{L}
%
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \node[draw=white, line width=1pt,fill=black!10, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {};
    }
}
%countur line
\draw[line width=2pt,black!80]
    (0.5*\cellsize,-0.5*\cellheight) rectangle
    (\columns*\cellsize+0.5*\cellsize,-\rows*\cellheight-0.5*\cellheight);
\end{scope}
\end{scope}
\node[helvetica,anchor=south] at (BL1.north){Dense Matrix};
\node[helvetica,anchor=south] at (BL2.north){Block Sparse Matrix};

\node[helvetica,anchor=south] at (BL3.north){Sparse Matrix (CSR)};
\node[helvetica,anchor=south] at (BL4.north){Block Sparse (BSR)};

%array
\node[draw=black, line width=1pt,fill=white, minimum width=5mm,
            minimum height=5mm, line width=0.5pt] (arr-1) at (9.2,1.25) {1};
\node[draw=black, line width=1pt,fill=white, minimum width=5mm,
            minimum height=5mm, line width=0.5pt,anchor=west] (arr-2) at (arr-1.east) {2};
\node[draw=black, line width=1pt,fill=white, minimum width=5mm,
            minimum height=5mm, line width=0.5pt,anchor=west] (arr-3) at (arr-2.east) {4};
\node[draw=black, line width=1pt,fill=white, minimum width=5mm,
            minimum height=5mm, line width=0.5pt,anchor=west] (arr-4) at (arr-3.east) {5};
\node[draw=black, line width=1pt,fill=white, minimum width=5mm,
            minimum height=5mm, line width=0.5pt,anchor=west] (arr-5) at (arr-4.east) {7};
\node[draw=black, line width=1pt,fill=white, minimum width=5mm,
            minimum height=5mm, line width=0.5pt,anchor=west] (arr-6) at (arr-5.east) {9};
\node[helvetica,anchor=south,text width=30mm] at (10.5,1.7){Non-zero Block Indices};

\draw[-latex,Line] (arr-1.south) to [out=-90,in=90] (BL2.north west);
\draw[-latex,Line] (arr-2.south) to [out=-90,in=90] ($(BL2.north west)+(1.5,0)$);
\draw[-latex,Line] (arr-3.south) to [out=-90,in=90] ($(BL2.north west)+(4.5,0)$);
\draw[-latex,Line] (arr-4.south) to [out=-90,in=90] ($(BL2.north west)+(1.5,-2)$);
\draw[-latex,Line] (arr-5.south) to [out=-90,in=90] ($(BL2.north west)+(3.0,-2)$);
\draw[-latex,Line] (arr-6.south) to [out=-90,in=90] ($(BL2.north west)+(4.5,-2)$);

\end{tikzpicture}
```
:::

The 2:4 pattern illustrates a broader principle: hardware achieves efficiency not by computing zeros faster, but by *never loading them in the first place*. This insight connects sparsity to the memory wall, since structured patterns reduce memory traffic, which is where the real cost lies.

Beyond structured sparsity optimizations, different hardware architectures implement matrix operations through distinct computational structures. Systolic arrays represent one such approach that has proven particularly effective for AI workloads.

#### Systolic Arrays {#sec-ai-acceleration-systolic-arrays-6fa8}

While tensor cores package matrix operations into structured computational units, systolic arrays provide an alternative approach optimized for continuous data flow and operand reuse. The core motivation for systolic architectures stems from the energy efficiency constraints discussed earlier: minimizing the impact of memory access penalties through architectural design. Quantifying *the energy advantage of pulsing data* through the array reveals why this architecture has become central to modern AI accelerators.

```{python}
#| label: systolic-energy-calc
#| echo: false
# ┌─────────────────────────────────────────────────────────────────────────────
# │ SYSTOLIC ARRAY ENERGY ADVANTAGE
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: "The Energy Advantage of Pulsing Data" callout
# │
# │ Why: Quantifies why systolic arrays achieve 200x better energy efficiency
# │      than naive vector units for matrix ops. Vector units pay DRAM cost per
# │      operation; systolic arrays amortize across 128 PEs before touching DRAM.
# │
# │ Imports: mlsys.constants (ENERGY_DRAM_ACCESS_PJ, SYSTOLIC_ARRAY_DIM)
# │ Exports: energy_ratio_str, vector_energy_str, systolic_energy_str
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.formatting import fmt
from mlsys.constants import ENERGY_DRAM_ACCESS_PJ, SYSTOLIC_ARRAY_DIM

# ┌── P.I.C.O. ISOLATED SCENARIO ───────────────────────────────────────────────
class SystolicEnergy:
    """
    Namespace for Systolic Array Energy calculation.
    Scenario: Comparing energy per MAC for Vector Unit vs Systolic Array.
    """

    # ┌── 1. PARAMETERS (Inputs) ───────────────────────────────────────────────
    dram_pj = ENERGY_DRAM_ACCESS_PJ.magnitude
    mac_pj = 1.0 # Compute cost

    # Vector Unit: Needs 3 loads (A, B, C) + 1 write (C) per MAC
    vector_dram_accesses = 4.0

    # Systolic Array: Amortizes loads across array width
    array_dim = SYSTOLIC_ARRAY_DIM # 128

    # ┌── 2. CALCULATION (The Physics) ─────────────────────────────────────────
    # Vector Energy = (4 * DRAM) + MAC
    e_vector = (vector_dram_accesses * dram_pj) + mac_pj

    # Systolic Energy = (2 loads / 128 ops * DRAM) + MAC
    # Note: Only 2 loads (A, B) are amortized; C stays in accumulator
    systolic_dram_per_op = 2.0 / array_dim
    e_systolic = (systolic_dram_per_op * dram_pj) + mac_pj

    efficiency_ratio = e_vector / e_systolic

    # ┌── 3. INVARIANTS (Guardrails) ───────────────────────────────────────────
    check(efficiency_ratio >= 100, f"Systolic efficiency ({efficiency_ratio:.1f}x) is too low. Should be >100x to justify TPU design.")

    # ┌── 4. OUTPUTS (Formatting) ──────────────────────────────────────────────
    dram_access_str = fmt(dram_pj, precision=0, commas=False)
    systolic_size_str = fmt(array_dim, precision=0, commas=False)
    vector_accesses_str = fmt(vector_dram_accesses, precision=0, commas=False)
    compute_energy_str = fmt(mac_pj, precision=0, commas=False)
    vector_energy_str = f"{e_vector:,.0f}"
    systolic_access_str = fmt(systolic_dram_per_op, precision=3, commas=False)
    systolic_energy_str = fmt(e_systolic, precision=1, commas=False)
    energy_ratio_str = fmt(efficiency_ratio, precision=0, commas=False)

# ┌── EXPORTS (Bridge to Text) ─────────────────────────────────────────────────
dram_access_str = SystolicEnergy.dram_access_str
systolic_size_str = SystolicEnergy.systolic_size_str
vector_accesses_str = SystolicEnergy.vector_accesses_str
compute_energy_str = SystolicEnergy.compute_energy_str
vector_energy_str = SystolicEnergy.vector_energy_str
systolic_access_str = SystolicEnergy.systolic_access_str
systolic_energy_str = SystolicEnergy.systolic_energy_str
energy_ratio_str = SystolicEnergy.energy_ratio_str
```

This architecture provides *the energy advantage of pulsing data*.

::: {.callout-notebook title="The Energy Advantage of Pulsing Data"}

**Systolic Arrays vs. Traditional Vector Units**:
The "Systolic" (heartbeat) metaphor is not just about timing; it reflects a decisive energy efficiency advantage. We can quantify the energy advantage of systolic dataflow over traditional vector units using the *Energy Corollary*:

1.  **Vector Unit**: Loads $A$, loads $B$, computes $A \times B + C$, writes $C$.
    - **Data Movement**: 3 loads + 1 write = `{python} vector_accesses_str` DRAM accesses (per operation).
    - **Energy**: ≈ `{python} vector_accesses_str` × `{python} dram_access_str` pJ = **`{python} vector_energy_str` pJ/OP**.

2.  **Systolic Array (`{python} systolic_size_str` × `{python} systolic_size_str` size)**: Loads A and B once at the edges. Data "pulses" through `{python} systolic_size_str` processing elements.
    - **Data Movement**: 2 loads per `{python} systolic_size_str` operations = `{python} systolic_access_str` DRAM accesses (per operation).
    - **Energy**: ≈ `{python} systolic_access_str` × `{python} dram_access_str` pJ + `{python} compute_energy_str` pJ (compute) ≈ **`{python} systolic_energy_str` pJ/OP**.

**The Systems Conclusion**: A systolic array is **`{python} energy_ratio_str` x more energy-efficient** than a naive vector unit for large matrix multiplications.
- This efficiency is what allows a Google TPU to pack 100,000+ MAC units into a single chip without melting.
- **The Limitation**: This "Energy Dividend" only pays out if the matrix is large enough to fill the array. For small matrices (common in real-time inference), the array is under-utilized, and the energy efficiency drops back toward the vector unit baseline.
:::

A systolic array\index{Systolic Arrays!energy efficiency}\index{Systolic Arrays!data flow architecture} arranges processing elements in a grid pattern, where data flows rhythmically between neighboring units in a synchronized manner, enabling each operand to participate in multiple computations as it propagates through the array. This structured movement minimizes external memory accesses by maximizing local data reuse. A single weight value can contribute to dozens of operations as it moves through the processing elements, transforming the energy profile from memory-bound to compute-efficient execution.

Kung and Leiserson\index{Kung, H.T.!systolic array inventor}[^fn-systolic-origin] [@kung1979systolic] first introduced systolic arrays, formalizing their use in parallel computing architectures for efficient matrix operations [@Kung1982]. Unlike general-purpose execution units, systolic arrays exploit spatial and temporal locality\index{Data Locality!spatial and temporal} by reusing operands as they propagate through the grid. Google's TPU\index{TPU!systolic array scaling} exemplifies this architectural approach: in the TPUv4, a $128\times128$ systolic array\index{Systolic Arrays!128x128 TPU} of multiply-accumulate units\index{Multiply-Accumulate!MAC unit} processes matrix operations by streaming data through the array in a pipelined manner [@jouppi2017datacenter]. Follow the data paths in @fig-systolic-array to see how inputs stream horizontally while weights flow vertically, with each processing element performing one multiply-accumulate before passing operands to its neighbors.

[^fn-systolic-origin]: **Systolic Array**\index{Systolic Arrays!etymology}: Named from the Greek "systole" (contraction), referring to the rhythmic pumping of the heart. The term captures how data pulses through the processing element grid in waves, like blood through cardiac chambers. Each element contracts (computes) and passes data to neighbors in a coordinated rhythm. Google's TPUs revived systolic designs for neural networks by pairing them with software stacks optimized for dense linear algebra.

::: {#fig-systolic-array fig-env="figure" fig-pos="htb" fig-cap="**Systolic Array Dataflow**: A control unit feeds input data streams into a grid of processing elements, each performing multiply-accumulate operations. Data flows horizontally and vertically through the array in a pipelined manner, maximizing operand reuse and minimizing memory access, as exemplified by Google's TPUv4." fig-alt="Systolic array diagram with control unit feeding data streams into processing element grid. Elements perform multiply-accumulate operations with results flowing through accumulator chain."}
```{.tikz}
\resizebox{0.8\textwidth}{!}{%
\begin{tikzpicture}[font=\usefont{T1}{phv}{m}{n}]
%
\tikzset{%
    Line/.style={line width=1.3pt,black!70,rounded corners}
}
\node[line width=0.75pt, draw=VioletLine,fill=VioletL!30, rectangle,
minimum width=200,minimum height=200](B){};
\foreach \x/\y in{0.08/1,0.33/2,0.58/3,0.95/4}
\draw[Line,line cap=round]($(B.south west)!\x!(B.south east)$)coordinate(G\y)
                --++(270:0.7)coordinate(D\y);
%
\foreach \a in{1,2,3,4}{
\begin{scope}[shift={(D\a)}, yshift=-33]
\node[line width=1.25pt, draw,fill=GreenL!30,
              minimum width=22, minimum height=32](MB\a){};
\foreach \x in{0.2,0.4,0.6,0.8}
\draw[line width=1.25pt]($(MB\a.north west)!\x!(MB\a.south west)$)--
            ($(MB\a.north east)!\x!(MB\a.south east)$);
\node[circle,line width=1.25pt,draw,minimum width=19,
           above=0.22 of MB\a,fill=white](C\a){};
\node[font=\bfseries]at(C\a){+};
\draw[Line](C\a)--(MB\a);
\draw[Line](MB\a.south)--++(270:0.3)--++(180:0.9)|-(C\a.west)coordinate(T\a);
\end{scope}
}

\draw[Line,-latex](MB1)--(MB2);
\draw[Line,-latex](MB2)--(MB3);
\node[font=\Huge](DL)at($(MB3.east)!0.44!(MB4.west)$){...};
\draw[Line,-latex](MB3)--(DL);
\draw[Line,-latex](DL)--(MB4);
\draw[Line,-latex](MB4)--++(0:1)node[right]{Done};

\foreach \x/\y in{0.08/1,0.31/2,0.55/3,0.95/4}
\draw[Line,line cap=round]($(B.north west)!\x!(B.south west)$)coordinate(GG\y)
                --++(180:0.7)coordinate(DD\y);

\foreach \a in{1,2,3,4}{
\begin{scope}[shift={(DD\a)}, xshift=-12,line cap=round]
\node[line width=1.25pt, draw=none,fill=GreenL!80,
              minimum width=32, minimum height=20](2MB\a){};
\foreach \x in{0,0.25,0.5,0.75}
\draw[line width=1.25pt]($(2MB\a.north west)!\x!(2MB\a.north east)$)--
            ($(2MB\a.south west)!\x!(2MB\a.south east)$);
\draw[line width=1.25pt,line cap=round,red](2MB\a.north west)
--++(180:2mm)coordinate(Z);
\draw[line width=1.25pt,line cap=round,red](2MB\a.south west)
--++(180:2mm)coordinate(DZ);
\draw[line width=1.25pt,line cap=round](Z)--(2MB\a.north east)|-(DZ);
\end{scope}
}
\draw[Line,-latex](2MB1)--(2MB2);
\draw[Line,-latex](2MB2)--(2MB3);
\node[font=\Huge,rotate=90](2DL)at($(2MB3.south)!0.52!(2MB4.north)$){...};
\draw[Line,-latex](2MB3)--(2DL);
\draw[Line,-latex](2DL)--(2MB4);
\draw[Line,-latex](2MB4)|-(MB1);
%
\node[line width=1.25pt, draw,fill=BlueL,
             % minimum width=22mm, minimum height=10mm,
             inner ysep=8,inner xsep=10,
              above left=0.25 and 1.2 of 2MB1](CO){Control};
\draw[Line,-latex](CO.350)-|(2MB1);
\draw[Line,-latex](CO.10)-|(B.north west);
%%
\def\di{0.5}
\def\du{1.0}
\draw[Line,-latex](GG1)++(\di,0)--++(0:\du)coordinate(H);
\draw[Line,-latex](H)++(\di,0)--++(0:\du)coordinate(H1);
\draw[Line,-latex](H1)++(\di,0)--++(0:\du)coordinate(H2)
node[right]{Data};
\draw[Line,-latex](GG2)++(\di,0)--++(0:\du)coordinate(2H);
\draw[Line,-latex](2H)++(\di,0)--++(0:\du)coordinate(2H1);
\draw[Line,-latex](GG3)++(\di,0)--++(0:\du)coordinate(3H);
%
\path[](H)-|coordinate(V1)(G4);
\draw[Line,-latex](V1)++(0,-5mm)--++(270:\du)coordinate(V2);
\draw[Line,-latex](V2)++(0,-5mm)--++(270:\du)coordinate(V3);
\draw[Line,-latex](V3)++(0,-5mm)--++(270:\du)coordinate(V4);
%
\path[](2H)-|coordinate(2V1)(G3);
\draw[Line,-latex](2V1)++(0,-0.8*\di)--++(270:0.8*\du)coordinate(2V2);
\draw[Line,-latex](2V2)++(0,-0.8*\di)--++(270:0.8*\du)coordinate(2V3);
\draw[Line,-latex](2V3)++(0,-0.8*\di)--++(270:0.8*\du)node[below]{Partial Sums};
%
\path[](3H)-|coordinate(3V1)(G2);
\draw[Line,-latex](3V1)--++(270:0.8*\du)coordinate(3V2);
\draw[Line,-latex](3V2)++(0,-0.6*\di)--++(270:0.8*\du)coordinate(3V3);
\draw[Line,-latex](3V3)++(0,-0.6*\di)--++(270:0.8*\du)coordinate(3V4);
\end{tikzpicture}}
```
:::

The systolic array architecture achieves computational efficiency through synchronized data movement across a structured grid of processing elements. Systolic arrays organize computation around four components:

1. **Control Unit**: Coordinates timing and data distribution across the array, maintaining synchronized operation throughout the computational grid
2. **Data Streams**: Input matrices propagate through coordinated pathways where matrix A elements traverse horizontally while matrix B elements flow vertically through the processing grid
3. **Processing Element Grid**: Individual processing elements execute multiply-accumulate operations on streaming data, generating partial results that accumulate toward the final computation
4. **Output Collection**: Results aggregate at designated output boundaries where accumulated partial sums form complete matrix elements

\index{Dataflow!weight-stationary vs output-stationary}
Because systolic arrays physically fix how data flows through the grid, designers must decide which operand to keep stationary, a choice that permanently shapes the hardware's affinity for certain workloads. This is not merely an implementation detail but a permanent architectural commitment: the decision made at chip design time determines which neural network operations will achieve high utilization and which will be starved for data.

::: {.callout-perspective title="Matching Architecture to Workload"}

**The Architects' Dilemma**: Systolic arrays must choose which data to keep stationary (in registers) to minimize movement. This choice hard-codes the hardware's preference for certain model types.

| **Strategy**                                                     | **Stationary Item** | **Optimized For**          | **Example Workload**                                                                        |
|:---------------------------------------------------------------|:------------------|:-------------------------|:------------------------------------------------------------------------------------------|
| **Weight-Stationary**\index{Weight-Stationary!dataflow strategy} | Weights ($W$)       | High Reuse of Weights      | **CNNs (Conv2D)**: Filters are small and reused across the entire image.                    |
| **Output-Stationary**\index{Output-Stationary!dataflow strategy} | Partial Sums ($C$)  | High Reuse of Accumulators | **Large Batch MatMul**: Accumulating results for many inputs against a large weight matrix. |
| **Row-Stationary**\index{Row-Stationary!dataflow strategy}       | Input Rows ($A$)    | Data Reuse                 | **General MatMul**: Balancing input and weight reuse.                                       |

There is no "perfect" accelerator. A chip optimized for Weight-Stationary flow (like early TPUs) excels at CNNs where filters are small and heavily reused, but faces challenges with LLM inference at small batch sizes, where the weight matrix is read once per token with minimal reuse, pushing architectures toward output-stationary or hybrid dataflow patterns.
:::

The synchronized data flow ensures that matrix element A[i,k] encounters corresponding B[k,j] elements at precise temporal intervals, executing the multiply-accumulate operations required for matrix multiplication C[i,j] = Σ A[i,k] × B[k,j]. This systematic reuse of operands across multiple processing elements substantially reduces memory bandwidth requirements by eliminating redundant data fetches from external memory subsystems.

Consider the multiplication of 2×2 matrices A and B within a systolic array. During the first computational cycle, element A[0,0]=2 propagates horizontally while B[0,0]=1 moves vertically, converging at processing element PE(0,0) to execute the multiplication 2×1=2. In the subsequent cycle, the same A[0,0]=2 advances to PE(0,1) where it encounters B[0,1]=3, computing 2×3=6. Concurrently, A[0,1]=4 enters PE(0,0) to engage with the next B matrix element. This coordinated data movement enables systematic operand reuse across multiple computational operations, eliminating redundant memory accesses and exemplifying the efficiency principle underlying systolic array architectures.

Each processing element in the array performs a multiply-accumulate operation in every cycle. In the configuration shown here (matching the example above, where matrix $A$ flows horizontally and $B$ flows vertically):

1. Receives a weight value from the left (the $A$ matrix, flowing horizontally)
2. Receives an input activation from above (the $B$ matrix, flowing vertically)
3. Multiplies these values and adds to its running sum
4. Passes the weight value rightward and the input activation downward to neighboring elements

Note that actual data flow directions vary across implementations; some architectures reverse these roles or use weight-stationary configurations where weights are preloaded rather than streamed.

This structured computation model minimizes data movement between global memory and processing elements, improving both efficiency and scalability. As systolic arrays operate in a streaming fashion, they are particularly effective for high-throughput workloads such as deep learning training and inference.

While @fig-systolic-array captures the core dataflow principle, systolic architectures vary significantly across different accelerator designs in practice. Training-focused architectures like Google's TPU employ large arrays (128×128 or larger) optimized for high computational throughput, while inference-oriented designs found in edge devices prioritize energy efficiency with smaller configurations (8×8 to 32×32).

The underlying principle remains consistent: data flows systematically through processing elements, with inputs moving horizontally and vertically to compute partial sums in a synchronized fashion. However, as detailed in @sec-ai-acceleration-understanding-ai-memory-wall-3ea9, practical effectiveness is ultimately constrained by memory bandwidth bottlenecks.

```{python}
#| label: systolic-ops-calc
#| echo: false
# ┌─────────────────────────────────────────────────────────────────────────────
# │ SYSTOLIC ARRAY OPERATIONS PER CYCLE
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: Prose describing systolic array dimensions and throughput
# │
# │ Why: Calculates the number of MAC operations a systolic array can perform
# │      per cycle from its dimensions, showing why data feed is critical.
# │
# │ Imports: mlsys.constants (SYSTOLIC_ARRAY_DIM), mlsys.formatting (fmt)
# │ Exports: systolic_dim_str, systolic_ops_str
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.formatting import fmt
from mlsys.constants import SYSTOLIC_ARRAY_DIM

# --- Inputs (array dimensions from constants) ---
systolic_dim_value = SYSTOLIC_ARRAY_DIM

# --- Outputs (formatted strings for prose) ---
systolic_ops_value = systolic_dim_value * systolic_dim_value
systolic_dim_str = fmt(systolic_dim_value, precision=0, commas=False)
systolic_ops_str = f"{systolic_ops_value:,}"
```

A `{python} systolic_dim_str`×`{python} systolic_dim_str` systolic array capable of `{python} systolic_ops_str` operations per cycle requires continuous data feed to maintain utilization. Each cycle demands fresh input activations and weight parameters that must traverse from off-chip memory through on-chip buffers to the array edges. The TPU's 1,200 GB/s on-chip bandwidth enables high utilization, but even this substantial bandwidth becomes limiting when processing large transformer models where memory requirements exceed on-chip capacity.

Recall from @sec-model-compression that quantization reduces model memory footprint by converting FP32 weights to INT8 representations. This optimization directly addresses the memory bandwidth constraints identified here. Converting 32-bit floating-point weights to 8-bit integers reduces memory traffic by 4×, transforming bandwidth-bound operations into compute-bound workloads where systolic arrays can achieve higher utilization. Similarly, structured pruning removes entire rows or columns of weight matrices, reducing both the data volume that must traverse memory hierarchies and the computation required. These algorithmic optimizations prove valuable precisely because they target the memory bottleneck that limits accelerator performance in practice.

#### Numerics in AI Acceleration {#sec-ai-acceleration-numerics-ai-acceleration-f7be}

Systolic arrays and tensor cores achieve their efficiency partly through specialized support for reduced-precision arithmetic. This connection is direct: the 2× speedup from FP16 versus FP32 is not merely "using fewer bits" but reflects that accelerators physically pack 2x more FP16 multiply-accumulate units into the same silicon area. Building on the quantization and mixed-precision techniques established in @sec-model-compression, this section examines how AI accelerators implement hardware support for these reduced-precision formats. The efficiency of AI accelerators is not determined by computational power alone but also by how effectively the hardware supports different numerical representations. The choice of numerical format shapes the balance between accuracy, throughput, and energy consumption, influencing how different execution units, such as SIMD and SIMT units, tensor cores, and systolic arrays, are designed and deployed.

##### Precision Trade-offs {#sec-ai-acceleration-precision-tradeoffs-8fa8}

\index{Precision!hardware design parameter}
Numerical precision represents a key design parameter in modern AI accelerators. While higher precision formats provide mathematical stability and accuracy, they come with substantial costs in terms of power consumption, memory bandwidth, and computational throughput. Hardware architects must balance these factors when designing accelerator datapaths.

The evolution of AI hardware reflects this co-design between software optimization and hardware capability. Early GPU architectures supported only FP32 for deep learning workloads, but as the precision trade-offs from @sec-model-compression demonstrated that reduced precision could maintain model accuracy, hardware vendors responded by adding native support for FP16, BF16, and integer formats. This hardware evolution enables software optimizations to translate directly into performance gains, as reduced-precision operations execute on dedicated circuits optimized for those specific formats.

The transition from high-precision to lower-precision formats is deeply integrated into hardware execution models. As detailed in @sec-ai-acceleration-evolution-simd-simt-architectures-e1fd, SIMD and SIMT units provide flexible support for multiple precisions. Tensor cores (@sec-ai-acceleration-tensor-cores-771f) accelerate computation using reduced-precision arithmetic, while systolic arrays (@sec-ai-acceleration-systolic-arrays-6fa8) optimize performance by minimizing memory bandwidth constraints through low-precision formats that maximize operand reuse.

Despite the advantages of reduced precision, deep learning models cannot always rely solely on low-bit representations. To address this challenge, modern AI accelerators implement mixed-precision computing, where different numerical formats are used at different stages of execution. These precision choices affect model fairness and reliability. For example, matrix multiplications may be performed in FP16 or BF16, while accumulations are maintained in FP32 to prevent precision loss. Similarly, inference engines use INT8 arithmetic while preserving key activations in higher precision when necessary.

##### Mixed-Precision Computing {#sec-ai-acceleration-mixedprecision-computing-656f}

\index{Mixed-Precision Computing!training and inference}
Modern AI accelerators increasingly support mixed-precision execution, allowing different numerical formats to be used at various stages of computation. Training workloads often use FP16 or BF16 for matrix multiplications, while maintaining FP32 accumulations to preserve precision. The software implementation of mixed-precision training, including loss scaling techniques and framework support, is covered in @sec-ai-training-mixedprecision-training-9218. Inference workloads, by contrast, optimize for INT8 or even INT4, achieving high efficiency while retaining acceptable accuracy.

This shift toward precision diversity is evident in the evolution of AI hardware. Early architectures such as NVIDIA Volta provided limited support for lower precision beyond FP16, whereas later architectures, including Turing and Ampere, expanded the range of supported formats. @tbl-nvidia-numerics traces this progression: Ampere GPUs introduced TF32 as a hybrid between FP32 and FP16, alongside broader support for BF16, INT8, and INT4.

| **Architecture**                             | **Year** |                                                    **Supported Tensor Core Precisions** | **Supported CUDA Core Precisions** |
|:-------------------------------------------|-------:|--------------------------------------------------------------------------------------:|---------------------------------:|
| **Volta**                                    |     2017 |                                                                                    FP16 |                   FP64, FP32, FP16 |
| **Turing**                                   |     2018 |                                                                              FP16, INT8 |             FP64, FP32, FP16, INT8 |
| **Ampere**\index{NVIDIA!Ampere architecture} |     2020 | FP64, TF32\index{TF32!tensor float 32}, bfloat16\index{BF16!bfloat16}, FP16, INT8, INT4 |   FP64, FP32, FP16, bfloat16, INT8 |

: **Precision Support Evolution.** GPU architectures progressively expanded support for lower-precision data types, enabling performance gains and efficiency improvements in AI workloads. Early architectures primarily utilized FP32, while later generations incorporated FP16, BF16, INT8, and INT4 to accelerate both training and inference tasks. {#tbl-nvidia-numerics}

Newer architectures incorporate a growing diversity of numerical formats, reflecting the need for greater flexibility across different AI workloads. This trend suggests that future AI accelerators will continue expanding support for adaptive precision, balancing computational efficiency against model accuracy.

The precision format used in hardware design has cascading implications across the entire system. Reducing from FP32 to FP16 cuts memory traffic in half, which matters far more than it might seem: because memory access dominates energy consumption (recall the 100× DRAM-to-compute energy gap from @sec-ai-acceleration-understanding-ai-memory-wall-3ea9), halving memory traffic can nearly halve total energy per inference. Simultaneously, tensor cores and systolic arrays can pack twice as many FP16 multiply-accumulate units into the same silicon area, doubling peak throughput. Integer formats push this further — INT8 arithmetic requires roughly 30× less energy than FP32 per operation, which is why inference-focused accelerators like the TPUv1 were built around INT8 from the start. The systems insight is that reduced precision does not merely "save bits" — it simultaneously relieves the memory bandwidth bottleneck and increases compute density, attacking both sides of the roofline simultaneously.

As AI models continue to scale in size, accelerator architectures are evolving to support more efficient numerical formats. Future designs are expected to incorporate adaptive precision techniques, dynamically adjusting computation precision based on workload characteristics. Understanding how these execution units and precision formats integrate into complete accelerator architectures reveals the full picture of AI hardware design.

#### Architectural Integration {#sec-ai-acceleration-architectural-integration-01b6}

\index{Architectural Integration!execution unit organization}
The organization of computational primitives into execution units determines the efficiency of AI accelerators. While SIMD, tensor cores, and systolic arrays serve as building blocks, their integration into full-chip architectures varies significantly across different AI processors. The choice of execution units, their numerical precision support, and their connectivity impact how effectively hardware can scale for deep learning workloads.

Modern AI processors exhibit a range of design trade-offs based on their intended applications, and comparing their configurations reveals how deployment constraints drive architectural divergence. A training-optimized accelerator like the NVIDIA A100 packs 108 Streaming Multiprocessors with wide SIMD units and FP16 tensor cores because training throughput scales with aggregate multiply-accumulate capacity. Google's TPUv4 makes a radically different bet: just two cores per chip, each containing a massive $128\times128$ BF16 systolic array — a design that trades programmer flexibility for extreme efficiency on the dense matrix multiplications that dominate transformer training. At the inference end, Intel's Sapphire Rapids dedicates its tensor cores to INT8 and BF16, reflecting the insight from @sec-model-compression that inference models tolerate reduced precision. Apple's M1 NPU takes this further by shrinking processing elements to $16\times16$ FP16 tiles within an 8-core array, prioritizing energy efficiency per operation over peak throughput — the critical metric when a smartphone's entire compute budget is 5 watts. @tbl-execution-units compares these architectural configurations.

| **Processor**      | **SIMD Width** |   **Tensor Core Size** | **Processing Elements** | **Primary Workloads** |
|:-----------------|-------------:|---------------------:|----------------------:|:--------------------|
| **NVIDIA A100**    |       1024-bit | $4\times4\times4$ FP16 |                 108 SMs | Training, HPC         |
| **Google TPUv4**   |       128-wide |    $128\times128$ BF16 |            2 cores/chip | Training              |
| **Intel Sapphire** |    512-bit AVX | $32\times32$ INT8/BF16 |                56 cores | Inference             |
| **Apple M1**       |   128-bit NEON |      $16\times16$ FP16 |             8 NPU cores | Mobile inference      |

: **AI Processor Configurations.** Modern AI processors prioritize different execution unit characteristics for specific workloads: NVIDIA A100 leverages wide SIMD and tensor cores for training, Google TPUv4 emphasizes high-throughput BF16 matrix multiplication, Intel Sapphire Rapids focuses on INT8-optimized inference, and Apple M1 prioritizes low-power FP16 execution. These variations in SIMD width, tensor core size, and processing element count reflect the growing diversity in AI hardware architectures. {#tbl-execution-units}

The pattern across these configurations reveals a consistent engineering principle: each design sacrifices generality to optimize for its target workload's dominant operation and precision. Training chips invest silicon in wide floating-point datapaths; inference chips trade precision for throughput; mobile chips trade throughput for energy efficiency. No single design dominates across all workloads, which is precisely why hardware selection depends on workload analysis rather than headline specifications.

### Cost-Performance Analysis {#sec-ai-acceleration-costperformance-analysis-e925}

\index{Cost-Performance Analysis!accelerator economics}
While architectural specifications define computational potential, practical deployment decisions require understanding cost-performance trade-offs across different accelerator options. However, raw computational metrics alone provide an incomplete picture. The dominant constraint in modern AI acceleration is not compute capacity but data movement efficiency.

The energy differential established earlier (where memory access costs dominate computation) drives the entire specialized hardware revolution. This disparity helps explain why many accelerators achieve only a fraction of peak compute on memory-bound workloads, while architectures that maximize data reuse (e.g., systolic arrays on dense matrix kernels) can sustain substantially higher utilization under favorable conditions.

Consider an organization choosing between “more of an older accelerator” versus “fewer of a newer accelerator.” Peak FLOPS can be misleading for transformer-style workloads with low arithmetic intensity, where training is often memory-bandwidth bound rather than compute-bound. In such cases, bandwidth per dollar and achievable utilization can matter more than headline compute, so a newer accelerator with substantially higher bandwidth can deliver materially better *sustained* performance even if peak FLOPS improves by a smaller factor.

These dynamics help explain the rapid adoption of newer accelerators despite higher unit prices. For memory-bound workloads, improvements in effective bandwidth (and the software stack's ability to use it) can dominate real-world performance. Cloud deployment further complicates the analysis, as rental pricing, utilization, and operational overheads can change the break-even point between purchasing and renting hardware.

```{python}
#| label: accelerator-economics-calc
#| echo: false
# ┌─────────────────────────────────────────────────────────────────────────────
# │ ACCELERATOR ECONOMICS CALCULATION
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: @tbl-accelerator-economics and surrounding prose
# │
# │ Why: Compares price/performance across accelerator generations to show how
# │      cost per TFLOP has collapsed while absolute power climbed. Demonstrates
# │      that bandwidth often matters more than peak FLOPS for memory-bound work.
# │
# │ Imports: mlsys.constants (V100/A100/H100/TPUV4 specs)
# │ Exports: *_tflops, *_bw, *_price_str, *_pp_str for each accelerator
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.constants import (
    V100_FLOPS_FP16_TENSOR, V100_MEM_BW,
    A100_FLOPS_FP16_TENSOR, A100_MEM_BW,
    H100_FLOPS_TF32, H100_FLOPS_FP16_TENSOR, H100_MEM_BW,
    TPUV4_FLOPS_BF16, TPUV4_MEM_BW,
    TFLOPs, second, GB, TB
)

# --- Inputs (approximate list prices, USD) ---
price_v100 = 9000                                # older generation
price_a100 = 15000                               # current workhorse
price_h100 = 25000                               # lower bound of range
price_tpu = 8000                                 # estimated from cloud rates
price_gaudi = 12000                              # Intel alternative

# --- Process (calculate price/performance ratios) ---
# V100
v100_tf = V100_FLOPS_FP16_TENSOR.to(TFLOPs/second).magnitude
v100_ratio = price_v100 / v100_tf

# A100
a100_tf = A100_FLOPS_FP16_TENSOR.to(TFLOPs/second).magnitude
a100_ratio = price_a100 / a100_tf

# H100 (using TF32 for price ratio, FP16 for spec)
h100_tf = H100_FLOPS_TF32.to(TFLOPs/second).magnitude
h100_ratio = price_h100 / h100_tf

# TPUv4
tpu_tf = TPUV4_FLOPS_BF16.to(TFLOPs/second).magnitude
tpu_ratio = price_tpu / tpu_tf

# Gaudi 2 (static spec, not in constants)
gaudi_tf = 200
gaudi_bw_value = 800
gaudi_ratio = price_gaudi / gaudi_tf

# --- Outputs (formatted strings for table and prose) ---
# V100 specs
v100_tflops = f"{V100_FLOPS_FP16_TENSOR.to(TFLOPs/second).magnitude:.0f}"     # e.g. "125"
v100_bw = f"{V100_MEM_BW.to(GB/second).magnitude:.0f}"                         # e.g. "900"
v100_price_str = f"~${price_v100:,}"                                           # e.g. "~$9,000"
v100_pp_str = f"${v100_ratio:.0f}/TFLOP"                                       # e.g. "$72/TFLOP"

# A100 specs (also used later in roofline sections)
a100_tflops_fp16 = f"{A100_FLOPS_FP16_TENSOR.to(TFLOPs/second).magnitude:.0f}" # e.g. "312"
a100_bw = f"{A100_MEM_BW.to(GB/second).magnitude:,.0f}"                        # e.g. "2,039"
a100_bw_tbs = f"{A100_MEM_BW.to(TB/second).magnitude:.1f}"                     # e.g. "2.0"
a100_price_str = f"~${price_a100:,}"                                           # e.g. "~$15,000"
a100_pp_str = f"${a100_ratio:.0f}/TFLOP"                                       # e.g. "$48/TFLOP"

# H100 specs
h100_tflops_tf32 = f"{H100_FLOPS_TF32.to(TFLOPs/second).magnitude:.0f}"        # e.g. "495"
h100_tflops_fp16 = f"{H100_FLOPS_FP16_TENSOR.to(TFLOPs/second).magnitude:.0f}" # e.g. "990"
h100_bw = f"{H100_MEM_BW.to(GB/second).magnitude:,.0f}"                        # e.g. "3,350"
h100_bw_tbs = f"{H100_MEM_BW.to(TB/second).magnitude:.2f}"                     # e.g. "3.35"
h100_price_str = f"~${price_h100:,}-30,000"                                    # e.g. "~$25,000-30,000"
h100_pp_str = f"~${h100_ratio:.0f}/TFLOP"                                      # e.g. "~$51/TFLOP"

# TPUv4 specs
tpuv4_tflops = f"{TPUV4_FLOPS_BF16.to(TFLOPs/second).magnitude:.0f}"           # e.g. "275"
tpuv4_bw = f"{TPUV4_MEM_BW.to(GB/second).magnitude:,.0f}"                      # e.g. "1,200"
tpu_price_str = f"~${price_tpu:,}*"                                            # e.g. "~$8,000*"
tpu_pp_str = f"~${tpu_ratio:.0f}/TFLOP"                                        # e.g. "~$29/TFLOP"

# Gaudi 2 specs
gaudi_tflops = f"{gaudi_tf}"                                                   # e.g. "200"
gaudi_bw = f"{gaudi_bw_value}"                                                 # e.g. "800"
gaudi_price_str = f"~${price_gaudi:,}"                                         # e.g. "~$12,000"
gaudi_pp_str = f"${gaudi_ratio:.0f}/TFLOP"                                     # e.g. "$60/TFLOP"
```

@tbl-accelerator-economics provides representative cost-performance data for common accelerators. Note that these figures are approximate and vary by vendor, region, and purchase volume; the key insight is the trend rather than the absolute numbers. Observe how the cost per TFLOP has collapsed with each generation, even as the absolute power requirement (TDP)\index{TDP!Thermal Design Power} has climbed to nearly 1,000 Watts for flagship units, reflecting the industry's shift toward density over raw unit cost.

| **Accelerator**                    | **List Price (USD)**       |                     **Peak FLOPS (FP16)** |     **Memory Bandwidth** | **Price/Performance**   |
|:---------------------------------|:-------------------------|----------------------------------------:|-----------------------:|:----------------------|
| **NVIDIA V100**\index{NVIDIA!V100} | `{python} v100_price_str`  |             `{python} v100_tflops` TFLOPS |  `{python} v100_bw` GB/s | `{python} v100_pp_str`  |
| **NVIDIA A100**\index{NVIDIA!A100} | `{python} a100_price_str`  |        `{python} a100_tflops_fp16` TFLOPS |  `{python} a100_bw` GB/s | `{python} a100_pp_str`  |
| **NVIDIA H100**                    | `{python} h100_price_str`  | `{python} h100_tflops_tf32` TFLOPS (TF32) |  `{python} h100_bw` GB/s | `{python} h100_pp_str`  |
| **Google TPUv4**                   | `{python} tpu_price_str`   |     `{python} tpuv4_tflops` TFLOPS (BF16) | `{python} tpuv4_bw` GB/s | `{python} tpu_pp_str`   |
| **Intel Gaudi 2**                  | `{python} gaudi_price_str` |                         `{python} gaudi_tflops` TFLOPS (INT8) |                 `{python} gaudi_bw` GB/s | `{python} gaudi_pp_str` |

: **Accelerator Cost-Performance Comparison.** Hardware costs evaluated against computational capabilities for optimal deployment strategy selection. Newer accelerators offer better price-performance ratios, though total cost of ownership includes power consumption, cooling requirements, and infrastructure costs. Prices are approximate list prices and vary by region and volume; TPU pricing estimated from cloud rates. {#tbl-accelerator-economics}

The table reveals several important patterns. First, price-performance improves with each generation, but the gains are not uniform across workload types. Second, memory bandwidth often improves faster than the price-performance ratio suggests, making newer accelerators disproportionately valuable for memory-bound workloads. Third, the "best" accelerator depends heavily on workload characteristics: a transformer training workload that is memory-bandwidth bound may benefit more from H100's `{python} h100_bw` GB/s bandwidth than from raw FLOPS improvements. That bandwidth consistently emerges as the deciding economic factor raises a deeper question: what physical constraints make memory access, rather than arithmetic, the dominant cost in modern AI systems? The following section answers this question by examining the AI memory wall in detail.

Framework selection significantly impacts these economic decisions. Detailed hardware-framework optimization strategies are covered in @sec-ai-frameworks, while performance evaluation methodologies are discussed in @sec-benchmarking-ai.

The preceding sections revealed impressive computational machinery: vector units achieving 8× parallelism through SIMD execution, matrix operations processing 256 elements simultaneously, and tensor cores executing 16×16×16 fused multiply-accumulate blocks in single cycles. An NVIDIA A100's tensor cores can execute `{python} a100_tflops_fp16` trillion operations per second, and an H100 pushes this further to nearly 2 petaFLOPS (dense) in FP8 precision. At these rates, the pure arithmetic for a ResNet-50 forward pass could complete in microseconds.

Looking ahead, the Blackwell (B200) architecture extends this trend by introducing native FP4 support, with NVIDIA reporting up to 4.5 petaFLOPS (dense) or 9 petaFLOPS (sparse) peak throughput in FP4 per chip. This confirms the precision bottleneck trend: as models grow, hardware adapts by trading precision for massive parallelism, requiring systems engineers to master progressively lower-bit numerics (FP8, FP4) to unlock the silicon's full potential.

Yet real ResNet-50 inference takes milliseconds, not microseconds. The gap between theoretical capability and practical performance reveals the chapter's central tension, first posed in the Purpose section: computational capability has outpaced our ability to feed data to processors. Moving data from memory costs 100–1,000× more energy than arithmetic, and memory bandwidth grows at roughly 20% annually while compute throughput doubles every two years. This disparity determines whether those `{python} a100_tflops_fp16` TFLOPS translate to 30 TFLOPS of sustained performance (10% utilization) or 250 TFLOPS (80% utilization).

Understanding *why* this gap exists — and what architectural innovations address it — requires examining the memory systems that feed data to the compute primitives we have just analyzed. The memory hierarchy is not merely a supporting subsystem; it is the primary determinant of whether accelerators achieve their theoretical potential.

## AI Memory Systems {#sec-ai-acceleration-ai-memory-systems-0057}

\index{AI Memory Systems!bandwidth bottleneck}
The execution units examined in previous sections (SIMD units, tensor cores, and systolic arrays) provide impressive computational throughput: modern accelerators achieve 100 to 1000 TFLOPS for neural network operations. Yet these theoretical capabilities remain unrealized in practice when memory subsystems cannot supply data at sufficient rates. This constraint, termed the AI memory wall, represents the dominant bottleneck in real-world accelerator performance.

Unlike conventional workloads, ML models require frequent access to large volumes of parameters, activations, and intermediate results, leading to substantial memory bandwidth demands. This challenge intersects with the data management strategies covered in @sec-data-engineering-ml. Modern AI hardware addresses these demands through advanced memory hierarchies, efficient data movement techniques, and compression strategies that promote efficient execution.

Four perspectives inform memory system design. First, we quantify the growing disparity between computational throughput and memory bandwidth, revealing why the AI memory wall represents the dominant performance constraint in modern accelerators. Second, we explore how memory hierarchies balance competing demands for speed, capacity, and energy efficiency through carefully structured tiers from on-chip SRAM to off-chip DRAM. Third, we analyze communication patterns between host systems and accelerators, exposing transfer bottlenecks that limit end-to-end performance. Finally, we examine how different neural network architectures (multilayer perceptrons, convolutional networks, and transformers) create distinct memory pressure patterns that inform hardware design decisions and optimization strategies.

### Understanding the AI Memory Wall {#sec-ai-acceleration-understanding-ai-memory-wall-3ea9}

\index{Memory Wall!definition}\index{Memory Wall!compute-memory divergence}The AI memory wall represents the primary bottleneck constraining modern accelerator performance: the growing disparity between computational throughput and memory bandwidth\index{Memory Bandwidth!compute gap} that prevents accelerators from achieving their theoretical capabilities. While compute units can execute millions of operations per second through specialized primitives like vector operations and matrix multiplications, they depend critically on memory systems to supply the continuous stream of weights, activations, and intermediate results these operations require.

::: {.callout-definition title="AI Memory Wall"}

***The AI Memory Wall***\index{Memory Wall!AI accelerator bottleneck}\index{Von Neumann Bottleneck!stored-program limitation} is the performance constraint that arises when arithmetic throughput outpaces memory bandwidth. Defined by the divergence of exponential compute growth vs. linear bandwidth growth, it dictates that performance is no longer bounded by FLOPS, but by the energy and latency cost of moving data, necessitating architectures focused on locality and reuse. This phenomenon is the modern manifestation of the *Von Neumann Bottleneck*: the limitation in throughput between compute and memory caused by shared data paths.

For a breakdown of the specific latency costs (e.g., L1 Cache vs. HBM vs. Network) that create this wall, see the "Latencies Every Programmer Should Know" table in @sec-machine-foundations.
:::

[^fn-von-neumann]\index{Von Neumann, John!stored-program architecture}The underlying cause of this wall—the Von Neumann Bottleneck that has constrained computing since 1945—is physical: moving data costs orders of magnitude more energy than processing it.

[^fn-von-neumann]: **John von Neumann**: Hungarian-American mathematician at Princeton's Institute for Advanced Study who described the stored-program computer architecture in his 1945 "First Draft of a Report on the EDVAC." The Von Neumann architecture---where instructions and data share the same memory and bus---enabled programmable computing but created an inherent throughput constraint. John Backus named this the "Von Neumann Bottleneck" in his 1977 Turing Award lecture; it is precisely the constraint that modern AI accelerators fight against with on-chip SRAM, systolic arrays, and near-memory computing. To grasp the severity, study the bar chart in @fig-energy-hierarchy — the "Horowitz Numbers"\index{Horowitz Numbers!energy hierarchy}\index{Energy Hierarchy!silicon costs} lay bare the immutable energy constants of silicon, and the gap between a simple arithmetic operation and a DRAM fetch is staggering.

```{python}
#| label: fig-energy-hierarchy
#| echo: false
#| fig-cap: "**The Energy Hierarchy**: Energy cost per operation (Log Scale) based on the 'Horowitz Numbers.' Fetching data from off-chip DRAM costs ~128x more energy than an SRAM access and ~20,000x more than an INT8 addition. This stark physical disparity dictates that AI accelerators must prioritize data locality (keeping weights in SRAM/Registers) over raw arithmetic throughput to remain within power budgets."
#| fig-alt: "Horizontal bar chart of Energy (pJ) per operation on log scale. INT8 Add is tiny (0.03). DRAM Read is huge (640). An arrow highlights the massive gap between computation and memory access."

import numpy as np
from mlsys import viz

fig, ax, COLORS, plt = viz.setup_plot()

# =============================================================================
# DATA: Horowitz Numbers
# =============================================================================
ENERGY_DATA = [
    {'Operation': 'INT8 Add', 'Energy_pJ': 0.03},
    {'Operation': 'FP32 Add', 'Energy_pJ': 0.9},
    {'Operation': 'FP32 Mult', 'Energy_pJ': 3.7},
    {'Operation': 'SRAM Read (8KB)', 'Energy_pJ': 5.0},
    {'Operation': 'DRAM Read', 'Energy_pJ': 640.0}
]
ops = [d['Operation'] for d in ENERGY_DATA]
energy = [d['Energy_pJ'] for d in ENERGY_DATA]

# =============================================================================
# PLOT: The Energy Hierarchy
# =============================================================================
colors = [COLORS['GreenLine'], COLORS['BlueLine'], COLORS['BlueLine'], COLORS['OrangeLine'], COLORS['RedLine']]
y_pos = np.arange(len(ops))

ax.barh(y_pos, energy, color=colors, alpha=0.8)
ax.set_yticks(y_pos)
ax.set_yticklabels(ops)
ax.set_xscale('log')
ax.set_xlabel('Energy per Operation (picojoules) [Log Scale]')

for i, v in enumerate(energy):
    ax.text(v * 1.1, i, f"{v} pJ", va='center', fontsize=9, fontweight='bold', color=COLORS['primary'], bbox=dict(facecolor='white', alpha=0.8, edgecolor='none', pad=0.5))

ax.annotate("", xy=(640, 3), xytext=(12, 3),
            arrowprops=dict(arrowstyle="->", color=COLORS['RedLine'], lw=1.5))
ax.text(80, 3.3, "~128x Cost\n(The Memory Wall)", color=COLORS['RedLine'], ha='center', fontsize=9, bbox=dict(facecolor='white', alpha=0.8, edgecolor='none', pad=0.5))
plt.show()
```

#### Quantifying the Compute-Memory Performance Gap {#sec-ai-acceleration-quantifying-computememory-performance-gap-1526}

\index{Memory Bandwidth!scaling trends}
The severity of this constraint becomes apparent when examining scaling trends. Over the past two decades, peak computational capabilities have grown substantially faster than DRAM bandwidth [@gholami2024ai]. This divergence creates a widening gap where accelerators possess massive computational power but cannot access data quickly enough to utilize it. Representative high-end accelerators can deliver on the order of \(10^3\) TFLOPS of peak tensor throughput (e.g., NVIDIA H100 delivering 989 TFLOPS in FP16 or nearly 2,000 TFLOPS in FP8) while providing approximately 3.35 TB/s of memory bandwidth. This implies a ridge point on the order of \(10^2\) operations per byte to fully utilize compute, which can exceed the arithmetic intensity of many practical neural network workloads.

The memory wall manifests through three critical constraints.[^fn-bw-analogy] First, the energy disparity: accessing DRAM can consume orders of magnitude more energy than a multiply-accumulate operation [@horowitz2014computing; @sze2020efficient], which often shifts bottlenecks from raw compute to power and data movement. Second, the bandwidth limitation: even TB/s memory systems may not feed large parallel compute arrays continuously on memory-bound workloads, leaving compute underutilized. Third, the latency hierarchy: off-chip memory access can require hundreds of cycles, creating pipeline stalls that cascade through parallel execution units.

[^fn-bw-analogy]: **The Firehose vs. Straw**: A compute-bound system is like a massive firehose trying to push water through a very fine filter (the math). A memory-bound system is like having a powerful pump but being forced to use a tiny drinking straw (the bus); the pump sits idle because it cannot get enough water.

The divergence between these two scaling rates is quantified in @fig-compute-memory-imbalance: watch how the gap between the compute curve and the bandwidth curve widens year over year, confirming that memory bandwidth — not compute — is the primary constraint in AI acceleration. The values are illustrative to emphasize the divergence trend.

```{python}
#| label: fig-compute-memory-imbalance
#| echo: false
#| fig-cap: "**The Compute-Bandwidth Divergence**: Compute throughput (FLOPs) and memory bandwidth (GB/s) plotted on a log scale (2000–2025). While arithmetic throughput has grown exponentially, bandwidth has improved more slowly. Values are illustrative to show the widening AI Memory Wall."
#| fig-alt: "Line graph comparing compute performance and memory bandwidth from 2000 to 2025 on log scale. Compute grows exponentially; bandwidth grows linearly. Shaded gap labeled Memory Wall widens over time."

from mlsys import viz

fig, ax, COLORS, plt = viz.setup_plot()

# =============================================================================
# DATA
# =============================================================================
years = [2000, 2005, 2010, 2015, 2020, 2025]
compute_performance = [1e3, 1e5, 1e7, 1e9, 1e12, 1e15]
memory_bandwidth = [1, 10, 50, 100, 500, 1000]

# =============================================================================
# PLOT: The Compute-Bandwidth Divergence
# =============================================================================
ax.fill_between(years, memory_bandwidth, compute_performance, color=COLORS['grid'], alpha=0.3)
ax.plot(years, compute_performance, 'o-', color=COLORS['BlueLine'], linewidth=1.5, markersize=6, label='Compute Performance')
ax.plot(years, memory_bandwidth, 's-', color=COLORS['OrangeLine'], linewidth=1.5, markersize=6, label='Memory Bandwidth')

ax.annotate('', xy=(2023, 1e13), xytext=(2023, 1e4),
            arrowprops=dict(arrowstyle='<->', color=COLORS['primary'], lw=1.5))
ax.text(2022, 3e6, 'Memory Wall', rotation=90, va='bottom', fontsize=10, color=COLORS['primary'], fontweight='bold', bbox=dict(facecolor='white', alpha=0.8, edgecolor='none', pad=0.5))

ax.set_yscale('log')
ax.set_xlabel('Year')
ax.set_ylabel('Performance (FLOPs or GB/s, log scale)')
ax.legend(loc='upper left', frameon=True, edgecolor=COLORS['grid'])
plt.show()
```

This imbalance has a direct architectural consequence visible in @fig-rising-ridge: the hardware's "Ridge Point" — the arithmetic intensity required to fully saturate the chip — has skyrocketed, pushing sparse and low-reuse operations further into the memory-bound regime with each new accelerator generation.

```{python}
#| label: fig-rising-ridge
#| echo: false
#| fig-cap: "**The Rising Ridge**: Hardware arithmetic intensity (FLOP/byte) over time. As compute capability grows faster than memory bandwidth, the 'Ridge Point' (the intensity required to saturate the chip) skyrockets. This trend explains why architectures with high data reuse flourish while low-reuse workloads face a growing hardware tax."
#| fig-alt: "Line plot showing the Arithmetic Intensity Ridge Point growing from ~140 in 2017 (V100) to over 500 in 2024 (B200). Shaded regions indicate 'Memory-Rich' and 'Compute-Dense' zones."

from mlsys import viz

fig, ax, COLORS, plt = viz.setup_plot()

# =============================================================================
# DATA: Ridge Points (Peak FLOPS / Memory Bandwidth)
# =============================================================================
years = [2017, 2020, 2022, 2024]
chips = ['V100', 'A100', 'H100', 'B200']
ridges = [139, 153, 295, 562]

# =============================================================================
# PLOT: The Rising Ridge
# =============================================================================
ax.plot(years, ridges, 'o-', color=COLORS['RedLine'], linewidth=2.5, markersize=8, label='Hardware Ridge Point')

for y, r, c in zip(years, ridges, chips):
    ax.annotate(c, (y, r), xytext=(0, 12), textcoords='offset points',
                ha='center', fontweight='bold', color=COLORS['RedLine'], fontsize=9, bbox=dict(facecolor='white', alpha=0.8, edgecolor='none', pad=0.5))
    ax.annotate(f"{r:.0f}", (y, r), xytext=(0, -18), textcoords='offset points',
                ha='center', fontsize=8, color=COLORS['primary'], bbox=dict(facecolor='white', alpha=0.8, edgecolor='none', pad=0.5))

ax.axhspan(0, 100, color=COLORS['BlueL'], alpha=0.2)
ax.text(2019, 50, "Memory-Rich Zone\n(Legacy Ops Safe)", color=COLORS['BlueLine'], ha='center', va='center', fontsize=9, fontweight='bold', bbox=dict(facecolor='white', alpha=0.8, edgecolor='none', pad=0.5))
ax.axhspan(100, 600, color=COLORS['OrangeL'], alpha=0.1)
ax.text(2019, 350, "Compute-Dense Zone\n(Transformers Required)", color=COLORS['OrangeLine'], ha='center', va='center', fontsize=9, fontweight='bold', bbox=dict(facecolor='white', alpha=0.8, edgecolor='none', pad=0.5))

ax.set_xlabel('Release Year')
ax.set_ylabel('Arithmetic Intensity (FLOP/byte)')
ax.set_ylim(0, 650)
ax.set_xticks(years)
plt.show()
```

Beyond performance limitations, memory access imposes a steep energy cost. Fetching data from off-chip DRAM consumes far more energy than performing arithmetic operations [@horowitz2014computing]. This inefficiency is particularly evident in machine learning models, where large parameter sizes, frequent memory accesses, and non-uniform data movement patterns exacerbate memory bottlenecks. The energy differential drives architectural decisions: Google's TPU achieves 30-83$\times$ better energy efficiency than contemporary GPUs by minimizing data movement through systolic arrays and large on-chip memory. These design choices demonstrate that energy constraints, not computational limits, often determine practical deployment feasibility.

#### Memory Access Patterns in ML Workloads {#sec-ai-acceleration-memory-access-patterns-ml-workloads-a960}

To make these energy costs concrete, we can trace a single tensor through every level of the memory hierarchy during a real inference pass.

```{python}
#| label: tensor-lifecycle-calc
#| echo: false
# ┌─────────────────────────────────────────────────────────────────────────────
# │ TENSOR LIFECYCLE: KWS AUDIO JOURNEY
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: "Life of a Tensor: The KWS Journey" callout tracing a tensor
# │          through the memory hierarchy during inference
# │
# │ Why: Computes the physical size, latency, and energy cost at each level
# │      of the memory hierarchy for a 1-second KWS audio clip, making the
# │      memory wall concrete with real numbers.
# │
# │ Imports: mlsys.constants (BYTES_FP16, ENERGY_DRAM_PJ_PER_BYTE,
# │          LATENCY_HBM3, LATENCY_L2_CACHE, LATENCY_L1_REGISTER,
# │          A100_FLOPS_FP16_TENSOR, TFLOPs, second),
# │          mlsys.formatting (fmt)
# │ Exports: kws_tensor_str, kws_samples_str, kws_bytes_str,
# │          dram_energy_pj_bit_str, latency_hbm_str, latency_l2_str,
# │          latency_l1_str, a100_tflops_fp16, reg_energy_pj_bit_str
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.formatting import fmt
from mlsys.constants import (
    BYTES_FP16, ENERGY_DRAM_PJ_PER_BYTE,
    LATENCY_HBM3, LATENCY_L2_CACHE, LATENCY_L1_REGISTER,
    A100_FLOPS_FP16_TENSOR, TFLOPs, second,
)

# --- KWS audio tensor sizing ---
kws_samples_value = 16_000
kws_bytes_fp16_value = BYTES_FP16.magnitude
kws_tensor_kb_value = kws_samples_value * kws_bytes_fp16_value / KIB_TO_BYTES
kws_tensor_str = fmt(kws_tensor_kb_value, precision=1, commas=False)
kws_samples_str = fmt(kws_samples_value, precision=0, commas=True)
kws_bytes_str = fmt(kws_bytes_fp16_value, precision=0, commas=False)

# --- Energy constants ---
dram_energy_pj_bit_value = ENERGY_DRAM_PJ_PER_BYTE.magnitude / 8
dram_energy_pj_bit_str = fmt(dram_energy_pj_bit_value, precision=0, commas=False)

# --- Latencies ---
latency_hbm_str = fmt(LATENCY_HBM3.magnitude, precision=0, commas=False)
latency_l2_str = fmt(LATENCY_L2_CACHE.magnitude, precision=0, commas=False)
latency_l1_str = fmt(LATENCY_L1_REGISTER.magnitude, precision=0, commas=False)

# --- A100 throughput (formatted string for prose) ---
a100_fp16_tflops_value = A100_FLOPS_FP16_TENSOR.to(TFLOPs / second).magnitude
a100_tflops_fp16 = f"{a100_fp16_tflops_value:.0f}"

# --- Register energy ---
reg_energy_pj_bit_str = "0.1"
```

::: {.callout-lighthouse title="Life of a Tensor: The KWS Journey"}

Recall the 1-second audio clip from @sec-ml-system-architecture. Here is its physical path through the hardware during inference:

1.  **DRAM (HBM)**: The tensor starts here.
    *   **Size**: `{python} kws_samples_str` samples × `{python} kws_bytes_str` bytes (FP16) = **`{python} kws_tensor_str` KB**.
    *   **Latency**: Fetching this from off-chip memory takes **~`{python} latency_hbm_str` ns** (plus queuing delay).
    *   **Energy**: Cost is **~`{python} dram_energy_pj_bit_str` pJ/bit**. High cost.

2.  **L2 Cache**: The GPU's DMA engine pulls it here.
    *   **Latency**: ~`{python} latency_l2_str` ns.
    *   **Access**: Shared across multiple Streaming Multiprocessors (SMs).

3.  **L1 Cache / Shared Memory**: A specific SM claims a tile of the audio.
    *   **Latency**: ~`{python} latency_l1_str` ns.
    *   **Locality**: Critical step. If the data leaves this level, we pay the "HBM Tax" again.

4.  **Registers**: The Tensor Core operates here.
    *   **Latency**: ~0 ns (single cycle).
    *   **Throughput**: `{python} a100_tflops_fp16` TFLOPS.
    *   **Energy**: Cost is **~`{python} reg_energy_pj_bit_str` pJ/bit**.

**The Systems Insight**: The "Speed of Light" limit means we cannot compute faster than we can move data from Step 1 to Step 4. The roofline is determined by the bandwidth of the Step 1 $\rightarrow$ Step 2 link.
:::

Beyond raw computational throughput, an accelerator's efficiency depends on its ability to continuously supply data to processing units without stalls. Neural networks impose three concurrent demands on this data supply. Model parameters (weights and biases) may number in the billions, requiring efficient storage and streaming to maintain throughput. Intermediate activations produced at each layer must be temporarily held for subsequent operations, contributing to memory overhead in deep architectures. During training, backpropagation adds a third demand: storing and accessing gradients for every parameter, further increasing data movement volume between compute units and memory.

As models increase in size and complexity, improvements in memory capacity and bandwidth become increasingly important. Although specialized compute units accelerate operations like matrix multiplications, their overall performance depends on the continuous, efficient delivery of data to the processing elements. In large-scale applications such as natural language processing and computer vision, models often incorporate millions to billions of parameters [@brown2020language], and achieving high performance requires minimizing delays and stalls caused by inefficient data movement between memory and compute units [@narayanan2021efficient; @Huang2019].

One way to quantify this challenge is by comparing the data transfer time with the time required for computations. Specifically, we define the memory transfer time as
$$
T_{\text{mem}} = \frac{D_{\text{vol}}}{BW},
$$
where $D_{\text{vol}}$ is the total data volume (bytes) and $BW$ is the available memory bandwidth (bytes/second). The result $T_{\text{mem}}$ has units of seconds. In contrast, the compute time is given by
$$
T_{\text{compute}} = \frac{\text{FLOPs}}{R_{\text{peak}}},
$$
where the number of floating-point operations (FLOPs) is divided by the peak hardware throughput $R_{\text{peak}}$ (FLOPs/second), yielding $T_{\text{compute}}$ in seconds. When $T_{\text{mem}} > T_{\text{compute}}$, the system becomes memory-bound, meaning that the processing elements spend more time waiting for data than performing computations. This imbalance demonstrates the need for memory-optimized architectures and efficient data movement strategies to sustain high performance.

@fig-memory-wall quantifies this disparity for specific models and hardware generations, showing how model parameter counts have outpaced memory bandwidth improvements. The gap between these curves, from AlexNet's 60 million parameters to trillion-parameter frontier models, represents the engineering challenge that drives accelerator memory system design. Even the latest accelerators like NVIDIA's B200 (8 TB/s) and AMD's MI325X (6 TB/s) cannot close this gap: bandwidth has improved by roughly 16× since 2014, while model sizes have grown by over 10,000×.

#### Irregular Memory Access {#sec-ai-acceleration-irregular-memory-access-c6ec}

\index{Memory Access!irregular patterns}
Unlike traditional computing workloads, where memory access follows well-structured and predictable patterns, machine learning models often exhibit irregular memory access behaviors that make efficient data retrieval a challenge. These irregularities arise due to the nature of ML computations, where memory access patterns are influenced by factors such as batch size, layer type, and sparsity. As a result, standard caching mechanisms and memory hierarchies often struggle to optimize performance, leading to increased memory latency and inefficient bandwidth utilization.

```{python}
#| label: fig-memory-wall
#| fig-cap: "**Model Size vs. Hardware Bandwidth.** Model parameter counts and hardware memory bandwidth plotted from 2012 to 2025, showing how model growth from AlexNet to trillion-parameter models has far outpaced bandwidth improvements across GPU and TPU generations."
#| fig-alt: "Scatter plot with trend lines comparing AI model parameters (red) and hardware bandwidth (blue) from 2012 to 2024. Models grow from AlexNet to Gemini 1. Shaded gap shows widening memory wall."
#| echo: false

import numpy as np
from mlsys import viz

fig, ax, COLORS, plt = viz.setup_plot(figsize=(10, 6))

# =============================================================================
# DATA
# =============================================================================
proc_names = ["NVIDIA Tesla K80", "Google TPU v2", "NVIDIA Tesla V100", "NVIDIA A100", "Google TPU v4", "NVIDIA H100", "AMD MI300X", "Google TPU v6e", "AMD MI325X", "NVIDIA B200"]
proc_years = [2014, 2017, 2017, 2020, 2021, 2022, 2024, 2024, 2025, 2025]
proc_bw = [480, 600, 900, 2000, 1200, 3000, 5300, 1640, 6000, 8000]
proc_log_bw = np.log10(proc_bw)

model_names = ["AlexNet", "VGG-16", "ResNet-50", "BERT Large", "GPT-3", "PaLM", "GPT-4", "Gemini 1", "Llama 3.1", "DeepSeek-V3", "Llama 4 Maverick"]
model_years = [2012, 2014, 2015, 2018, 2020, 2022, 2023, 2024, 2024.3, 2024.9, 2025.3]
model_params = [60, 138, 25.6, 340, 175000, 540000, 1000000, 1500000, 405000, 671000, 400000]
model_log_params = np.log10(model_params)

# =============================================================================
# PLOT: Model Size vs Hardware Bandwidth
# =============================================================================
proc_fit = np.polyfit(proc_years, proc_log_bw, 1)
model_fit = np.polyfit(model_years, model_log_params, 1)
years_range = np.arange(2012, 2027)
proc_trend = np.polyval(proc_fit, years_range)
model_trend = np.polyval(model_fit, years_range)

mask = years_range >= 2016
ax.fill_between(years_range[mask], proc_trend[mask], model_trend[mask], color=COLORS['grid'], alpha=0.2)

ax.plot(years_range, proc_trend, '--', color=COLORS['BlueLine'], linewidth=1)
ax.plot(years_range, model_trend, '--', color=COLORS['RedLine'], linewidth=1)
ax.scatter(proc_years, proc_log_bw, color=COLORS['BlueLine'], s=50, zorder=3, edgecolors='white')
ax.scatter(model_years, model_log_params, color=COLORS['RedLine'], s=50, zorder=3, edgecolors='white')

# Annotate first 3 processors and latest 3 (MI300X, MI325X, B200)
for i in [0, 1, 2]:
    ax.annotate(proc_names[i], (proc_years[i], proc_log_bw[i]), textcoords='offset points', xytext=(0, 10), fontsize=7, color=COLORS['BlueLine'], ha='center', bbox=dict(facecolor='white', alpha=0.8, edgecolor='none', pad=0.5))
for i in [-3, -2, -1]:
    offset_x = -15 if i == -2 else (15 if i == -3 else 0)
    ax.annotate(proc_names[i], (proc_years[i], proc_log_bw[i]), textcoords='offset points', xytext=(offset_x, 10), fontsize=7, color=COLORS['BlueLine'], ha='center', bbox=dict(facecolor='white', alpha=0.8, edgecolor='none', pad=0.5))

# Annotate last 6 models
for name, year, val in zip(model_names[-6:], model_years[-6:], model_log_params[-6:]):
    ax.annotate(name, (year, val), textcoords='offset points', xytext=(0, 8), fontsize=7, color=COLORS['RedLine'], ha='center', bbox=dict(facecolor='white', alpha=0.8, edgecolor='none', pad=0.5))

mid_y = (np.polyval(proc_fit, 2021) + np.polyval(model_fit, 2021)) / 2
ax.text(2021, mid_y, 'AI Memory Wall', fontsize=12, fontweight='bold', ha='center', color=COLORS['primary'], bbox=dict(facecolor='white', alpha=0.8, edgecolor='none', pad=0.5))

ax.set_xlabel('Year')
ax.set_ylabel('Log Scale (Base 10)')
ax.set_xlim(2011, 2027)
plt.show()
```

Comparing ML memory access patterns against traditional computing workloads reveals the scale of the challenge. Traditional workloads, such as scientific computing, general-purpose CPU applications, and database processing, typically exhibit well-defined memory access characteristics that benefit from standard caching and prefetching techniques. ML workloads, on the other hand, introduce highly dynamic access patterns (@tbl-traditional-vs-ml-mem) that challenge conventional memory optimization strategies.

| **Feature**                      | **Traditional Computing Workloads**                                     | **Machine Learning Workloads**                               |
|:-------------------------------|:----------------------------------------------------------------------|:-----------------------------------------------------------|
| **Memory Access Pattern**        | Regular and predictable (e.g., sequential reads, structured patterns)   | Irregular and dynamic (e.g., sparsity, attention mechanisms) |
| **Cache Locality**               | High temporal and spatial locality                                      | Often low locality, especially in large models               |
| **Data Reuse**                   | Structured loops with frequent data reuse                               | Sparse and dynamic reuse depending on layer type             |
| **Data Dependencies**            | Well-defined dependencies allow efficient prefetching                   | Variable dependencies based on network structure             |
| **Workload Example**             | Scientific computing (e.g., matrix factorizations, physics simulations) | Neural networks (e.g., CNNs, Transformers, sparse models)    |
| **Memory Bottleneck**            | DRAM latency, cache misses                                              | Off-chip bandwidth constraints, memory fragmentation         |
| **Impact on Energy Consumption** | Moderate, driven by FLOP-heavy execution                                | High, dominated by data movement costs                       |

: **Memory Access Characteristics.** Traditional workloads exhibit predictable, sequential memory access benefiting from standard caching, while machine learning workloads introduce irregular and dynamic patterns due to sparsity and data dependencies. These differences inform the design of memory systems that efficiently support modern AI applications. {#tbl-traditional-vs-ml-mem}

One key source of irregularity in ML workloads stems from batch size and execution order. The way input data is processed in batches directly affects memory reuse, creating a complex optimization challenge. Small batch sizes decrease the likelihood of reusing cached activations and weights, resulting in frequent memory fetches from slower, off-chip memory. Larger batch sizes can improve reuse and amortize memory access costs, but simultaneously place higher demands on available memory bandwidth, potentially creating congestion at different memory hierarchy levels. This delicate balance requires careful consideration of model architecture and available hardware resources.

Different neural network layers interact with memory in distinct ways beyond batch size considerations. Convolutional layers benefit from spatial locality, as neighboring pixels in an image are processed together, enabling efficient caching of small weight kernels. Conversely, fully connected layers require frequent access to large weight matrices, often leading to more randomized memory access patterns that poorly align with standard caching policies. Transformers\index{Transformer!memory access patterns} introduce additional complexity, as attention mechanisms demand accessing large key-value pairs stored across varied memory locations. The dynamic nature of sequence length and attention span renders traditional prefetching strategies ineffective, resulting in unpredictable memory latencies.

Another factor contributing to irregular memory access is sparsity[^fn-sparsity] in neural networks. Many modern ML models employ techniques such as weight pruning, activation sparsity, and structured sparsity to reduce computational overhead. However, these optimizations often lead to non-uniform memory access, as sparse representations necessitate fetching scattered elements rather than sequential blocks, making hardware caching less effective. Models that incorporate dynamic computation paths, such as Mixture of Experts\index{Mixture of Experts!dynamic computation paths} and Adaptive Computation Time, introduce highly non-deterministic memory access patterns, where the active neurons or model components can vary with each inference step. This variability challenges efficient prefetching and caching strategies.

[^fn-sparsity]: **Sparsity in Neural Networks**: As introduced in @sec-ai-acceleration-nm-sparsity, sparsity refers to zeros distributed throughout a network's weights or activations. Natural sparsity arises from ReLU activations (50--90% zeros), while artificial sparsity results from pruning (90--99% of weights removed). Realizing speedups requires hardware support such as NVIDIA's 2:4 structured sparsity or software-level sparse format optimizations.

These irregularities have measurable consequences. ML workloads often experience reduced cache efficiency, as activations and weights may not be accessed in predictable sequences. This leads to increased reliance on off-chip memory traffic, which slows down execution and consumes more energy. Irregular access patterns contribute to memory fragmentation, where the way data is allocated and retrieved results in inefficient utilization of available memory resources. The combined effect is that ML accelerators frequently encounter memory bottlenecks that limit their ability to fully utilize available compute power.

The irregular access patterns and memory wall constraints examined above create formidable challenges, but they also reveal optimization opportunities. Although individual memory accesses may appear unpredictable, ML workloads exhibit structured reuse patterns at a higher level: the same weights are applied across batch elements, the same kernels slide across spatial dimensions, and the same attention patterns recur across sequence positions. Hardware designers exploit these regularities through carefully structured memory hierarchies that maintain frequently accessed data close to compute units, even when the specific access sequence varies.

This insight motivates the hierarchical memory architectures found in all modern AI accelerators: rather than treating memory as a monolithic resource, these systems organize storage into distinct tiers, each optimized for different access patterns and reuse characteristics.

### Memory Hierarchy {#sec-ai-acceleration-memory-hierarchy-1839}

\index{Memory Hierarchy!speed-capacity trade-off}
Modern AI accelerators implement multi-level memory hierarchies that balance speed, capacity, and energy efficiency by exploiting these structured reuse patterns. While general-purpose computing contends with unpredictable memory access, ML workloads exhibit structured reuse that can be optimized through careful data organization across multiple memory levels.

At the highest level, large-capacity but slow storage devices provide long-term model storage. At the lowest level, high-speed registers\index{Registers!fastest memory} and caches ensure that compute units can access operands with minimal latency. Between these extremes, intermediate memory levels, such as scratchpad memory\index{Scratchpad Memory!software-managed}, high-bandwidth memory\index{HBM!intermediate tier}, and off-chip DRAM\index{DRAM!off-chip storage}, offer trade-offs between performance and capacity.

@tbl-memory-hierarchy summarizes the multiple memory levels employed by modern AI accelerators, each with distinct latency, bandwidth, and capacity properties that directly influence how neural network data should be allocated.

| **Memory Level**                                 | **Approx. Latency** | **Bandwidth** | **Capacity** | **Example Use in Deep Learning**                                     |
|:-----------------------------------------------|------------------:|:------------|:-----------|:-------------------------------------------------------------------|
| **Registers**                                    |            ~1 cycle | Highest       | Few values   | Storing operands for immediate computation                           |
| **L1/L2 Cache (SRAM)**\index{SRAM!on-chip cache} |            ~1-10 ns | High          | KBs-MBs      | Caching frequently accessed activations and small weight blocks      |
| **Scratchpad Memory**                            |            ~5-20 ns | High          | MBs          | Software-managed storage for intermediate computations               |
| **High-Bandwidth Memory (HBM)**                  |             ~100 ns | Very High     | GBs          | Storing large model parameters and activations for high-speed access |
| **Off-Chip DRAM (DDR, GDDR, LPDDR)**             |          ~50-150 ns | Moderate      | GBs-TBs      | Storing entire model weights that do not fit on-chip                 |
| **Flash Storage (SSD/NVMe)**                     |      ~100 µs - 1 ms | Low           | TBs          | Storing pre-trained models and checkpoints for later loading         |

: **Memory Hierarchy Trade-Offs.** AI accelerators use a multi-level memory hierarchy to balance performance and capacity. Each level provides distinct latency, bandwidth, and capacity characteristics that dictate how neural network components (weights, activations, and intermediate results) should be allocated to minimize bottlenecks and maximize throughput. {#tbl-memory-hierarchy}

A natural question arises from this hierarchy: why not simply build larger, faster off-chip memory and eliminate the need for on-chip SRAM entirely? The answer is rooted in physics, specifically the *speed of light limit* on signal propagation within and between chips.

::: {.callout-notebook title="The Speed of Light Limit"}

**Problem**: Why do we need on-chip SRAM? Why not simply fetch everything from HBM?

**The Physics**:

1.  **Distance**: On a large 700mm² chip, signals travel ~20mm.
2.  **Speed**: Signals in silicon travel at $\approx 0.5c$ (half speed of light).
3.  **Latency**: 20mm takes $\approx 130 \text{ ps}$.
4.  **Clock Cycle**: At 2 GHz, a cycle is $500 \text{ ps}$.
5.  **DRAM**: Off-chip HBM is centimeters away + protocol overhead = **100+ cycles**.

**The Systems Conclusion**: You cannot fetch data from DRAM in a single cycle. It is physically impossible. You *must* have local registers and SRAM (L1) to feed compute units at 2 GHz. The "Memory Wall" is partially a **Distance Wall**.
:::

#### On-Chip Memory {#sec-ai-acceleration-onchip-memory-72d1}

\index{SRAM!on-chip fast memory}
Each level of the memory hierarchy serves a distinct role in AI acceleration, with different trade-offs in speed, capacity, and accessibility. Registers, located within compute cores, provide the fastest access but can only store a few operands at a time. These are best utilized for immediate computations, where the operands needed for an operation can be loaded and consumed within a few cycles. However, because register storage is so limited, frequent memory accesses are required to fetch new operands and store intermediate results.

To reduce the need for constant data movement between registers and external memory, small but fast caches serve as an intermediary buffer. These caches store recently accessed activations, weights, and intermediate values, ensuring that frequently used data remains available with minimal delay. However, the size of caches is limited, making them insufficient for storing full feature maps or large weight tensors in machine learning models. As a result, only the most frequently used portions of a model's parameters or activations can reside here at any given time.

For larger working datasets, many AI accelerators include scratchpad memory, which offers more storage than caches but with a key difference: it allows explicit software control over what data is stored and when it is evicted. Unlike caches, which rely on hardware-based eviction policies, scratchpad memory enables machine learning workloads to retain key values such as activations and filter weights for multiple layers of computation. This capability is useful in models like convolutional neural networks, where the same input feature maps and filter weights are reused across multiple operations. By keeping this data in scratchpad memory rather than reloading it from external memory, accelerators can significantly reduce unnecessary memory transfers and improve overall efficiency [@Chen2016].

#### Off-Chip Memory {#sec-ai-acceleration-offchip-memory-ecdb}

\index{HBM!3D die stacking}\index{DRAM!off-chip bandwidth}
Beyond on-chip memory, high-bandwidth memory provides rapid access to larger model parameters and activations that do not fit within caches or scratchpad buffers. HBM achieves its high performance by stacking multiple memory dies and using wide memory interfaces, allowing it to transfer large amounts of data with minimal latency compared to traditional DRAM. Because of its high bandwidth and lower latency, HBM is often used to store entire layers of machine learning models that must be accessed quickly during execution. However, its cost and power consumption limit its use primarily to high-performance AI accelerators, making it less common in power-constrained environments such as edge devices.

\index{GDDR!off-chip DRAM variant}\index{LPDDR!low-power DRAM variant}
When a machine learning model exceeds the capacity of on-chip memory and HBM, it must rely on off-chip DRAM, such as DDR, GDDR, or LPDDR. While DRAM offers significantly greater storage capacity, its access latency is higher, meaning that frequent retrievals from DRAM can introduce execution bottlenecks. To make effective use of DRAM, models must be structured so that only the necessary portions of weights and activations are retrieved at any given time, minimizing the impact of long memory fetch times.

At the highest level of the hierarchy, flash storage and solid-state drives (SSDs) store large pre-trained models, datasets, and checkpointed weights. These storage devices offer large capacities but are too slow for real-time execution, requiring models to be loaded into faster memory tiers before computation begins. For instance, in training scenarios, checkpointed models stored in SSDs must be loaded into DRAM or HBM before resuming computation, as direct execution from SSDs would be too slow to maintain efficient accelerator utilization [@narayanan2021efficient].

The memory hierarchy thus balances competing objectives of speed, capacity, and energy efficiency. However, moving data through multiple memory levels introduces bottlenecks that limit accelerator performance. Data transfers between memory levels incur latency costs, particularly for off-chip accesses. Limited bandwidth restricts data flow between memory tiers. Memory capacity constraints force constant data movement as models exceed local storage. These constraints make memory bandwidth the primary determinant of real-world accelerator performance, a topic we examine next.

### Memory Bandwidth and Architectural Trade-offs {#sec-ai-acceleration-memory-bandwidth-architectural-tradeoffs-435c}

\index{Memory Bandwidth!architectural trade-offs}
Building on the memory wall analysis established in @sec-ai-acceleration-understanding-ai-memory-wall-3ea9, this section quantifies how specific bandwidth characteristics impact system performance across different deployment scenarios.

Modern accelerators exhibit distinct bandwidth-capacity trade-offs that directly shape which workloads they can serve efficiently. Representative datacenter accelerators provide memory bandwidth on the order of a few TB/s, often paired with tens of GB of high-bandwidth memory. But raw bandwidth alone is misleading: what matters is *achievable* bandwidth for a given access pattern. Transformer attention mechanisms often achieve only 40–60% of peak bandwidth because their irregular key-value lookups across sequence positions create access patterns that cannot fully saturate wide memory buses. Convolutional layers fare better, achieving 70–85% of peak through predictable spatial access that aligns with hardware prefetching. Fully connected layers approach peak bandwidth only when batch sizes are large enough to amortize the cost of loading weight matrices — which connects directly to the batch-size sensitivity discussed in the roofline analysis below. The practical consequence is that an accelerator's effective bandwidth for a specific workload may be half its advertised peak, making bandwidth-per-dollar a more reliable purchasing metric than peak bandwidth alone.

As established earlier, on-chip memory access typically consumes energy in the single-digit-to-tens of picojoules per access, while external DRAM can be on the order of hundreds of picojoules per access, an orders-of-magnitude energy penalty. AI accelerators minimize DRAM access through three key strategies: weight stationarity (keeping model parameters in on-chip memory), input stationarity (buffering input activations locally), and output stationarity (accumulating partial sums on-chip).

Memory bandwidth scaling follows different trajectories across accelerator designs. GPU architectures scale bandwidth by adding memory channels, reaching on the order of 1 TB/s in mainstream products and a few TB/s in high-end systems. TPU-class designs achieve their bandwidth efficiency through systolic array dataflow and aggressive on-chip reuse, often trading flexibility for efficiency on dense tensor kernels. Mobile SoCs face the tightest constraints, delivering on the order of hundreds of GB/s of unified memory bandwidth within a few-watt power envelope, which demands careful workload scheduling and thermal management.

HBM provides far higher bandwidth than commodity DDR memory, but at substantially higher cost and packaging complexity. High-bandwidth accelerators therefore trade higher memory-system cost for higher sustained performance on bandwidth-bound workloads. Edge accelerators often sacrifice bandwidth to meet tight cost and power targets while maintaining sufficient performance for inference workloads.

These bandwidth characteristics directly influence deployment decisions: cloud training prioritizes raw bandwidth for maximum model capacity, edge inference optimizes bandwidth efficiency for energy constraints, and mobile deployment balances bandwidth with cost limitations. Beyond the accelerator's internal memory system, however, data must also flow between the host CPU and the accelerator, introducing another potential bottleneck. This host-accelerator interface often becomes the unexpected chokepoint: even with 2 TB/s of HBM bandwidth on the accelerator, data must first traverse a PCIe link that provides only 64 GB/s, a 30× bandwidth reduction that can dominate total latency for small, frequent transfers.

### Host-Accelerator Communication {#sec-ai-acceleration-hostaccelerator-communication-bb7a}

\index{Host-Accelerator Communication!transfer bottleneck}
Machine learning accelerators, such as GPUs and TPUs, achieve high computational throughput through parallel execution. However, their efficiency is often constrained by data movement between the host (CPU) and accelerator memory. Compared to many traditional workloads that keep most data within a single memory domain, AI workloads can require frequent transfers between CPU memory and accelerator memory, introducing latency, consuming bandwidth, and affecting overall performance.

Host-accelerator data movement follows a structured sequence. Before computation begins, data is copied from CPU memory to the accelerator's memory. The CPU then issues execution instructions, and the accelerator processes the data in parallel. Once computation completes, the results are stored in accelerator memory and transferred back to the CPU. Walk through each of the four steps in @fig-host-accelerator-data-movement and consider the latency cost at every arrow: each transfer represents a potential bottleneck that must be managed to optimize end-to-end performance.

::: {#fig-host-accelerator-data-movement fig-env="figure" fig-pos="htb" fig-cap="**Host-Accelerator Data Transfer**: AI workloads require frequent data movement between CPU memory and accelerators. The four sequential steps of copying input data, issuing execution instructions, parallel computation, and transferring results each introduce potential performance bottlenecks." fig-alt="Four-step data flow diagram: (1) copy data from main memory to GPU memory, (2) CPU instructs GPU, (3) GPU executes in parallel, (4) results copy back to main memory."}

```{.tikz}
\begin{tikzpicture}[font=\usefont{T1}{phv}{m}{n}\small]
\tikzset{%
    Line/.style={line width=1.0pt,black!50}
}
\tikzset{
  Box/.style={inner xsep=2pt,
    draw=GreenLine,
    line width=0.75pt,
    node distance=1.0,
    fill=GreenL!70,
    align=flush center,
    text width=26mm,
    minimum width=26mm,
    minimum height=10mm
  },
}

\begin{scope}
\node[Box](B1){Main Memory};
\node[Box,right=of B1](B2){CPU};
\node[Box,right=of B2](B3){Memory for GPU};
\node[Box,right=of B3](B4){GPU};
\end{scope}
%
\begin{scope}[shift={(0,-6)}]
\colorlet{GreenL}{OrangeL}
\colorlet{GreenLine}{OrangeLine}
\node[Box](2B1){Main Memory};
\node[Box,right=of 2B1](2B2){CPU};
\node[Box,right=of 2B2](2B3){Memory for GPU};
\node[Box,right=of 2B3](2B4){GPU};
%
\end{scope}
%
\foreach \x in {1,2,3,4} {
 \draw[Line] (B\x) -- (2B\x);
}
%
\draw[Line,-latex]($(B1)!0.2!(2B1)$)--
node[above,text=black,pos=0.26]{Copy processing data (1)}
($(B3)!0.2!(2B3)$);
\draw[Line,-latex]($(B2)!0.37!(2B2)$)--
node[above,text=black,pos=0.26]{Instruct the processing (2)}
($(B4)!0.37!(2B4)$);
%
\draw[Line,-latex]($(B4)!0.75!(2B4)$)--
node[above,text=black,pos=0.5]{Store results}
($(B3)!0.75!(2B3)$);
\draw[Line,-latex]($(B3)!0.85!(2B3)$)--
node[above,text=black,pos=0.25]{Copy the result (4)}
($(B1)!0.85!(2B1)$);
%
\draw[Line,-latex]($(B4)!0.57!(2B4)$)
to [out=10,in=350,distance=42]
node[above,text=black,pos=0.1,fill=white]{Execute parallel in each core (3)}
($(B4)!0.62!(2B4)$);
\end{tikzpicture}

```
:::

The key challenges in host-accelerator data movement include latency, bandwidth constraints, and synchronization overheads. The efficiency of ML accelerators depends not only on their computational power but also on the continuous supply of data. Even high-performance GPUs and TPUs remain underutilized if data transfers are inefficient. Host and accelerator memory exist as separate domains, requiring explicit transfers over interconnects such as PCIe, NVLink, or proprietary links. Ineffective data movement causes execution stalls, making transfer optimization a priority.

#### Node-Level Interconnect Topology

To optimize data movement, we must understand the physical topology of the compute node. A typical AI server is not a flat mesh of connected devices but a hierarchy of bandwidths that tapers as we move away from the chip.

```{python}
#| echo: false
#| label: interconnect-bandwidth
# ┌─────────────────────────────────────────────────────────────────────────────
# │ INTERCONNECT BANDWIDTH SPECS
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: "Node-Level Interconnect Topology" prose
# │
# │ Why: Shows the bandwidth hierarchy from GPU-to-GPU (NVLink) down to
# │      node-to-node (InfiniBand). This taper explains why keeping data
# │      local to fast memory matters: 30-100x slowdown when data drops
# │      to PCIe or network speeds.
# │
# │ Imports: mlsys.constants (NVLINK, INFINIBAND bandwidths)
# │ Exports: nvlink_a100, nvlink_h100, ib_hdr, ib_ndr
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.constants import (
    NVLINK_A100_BW, NVLINK_H100_BW,
    INFINIBAND_HDR_BW, INFINIBAND_NDR_BW,
    PCIE_GEN4_BW, A100_MEM_BW,
    GB, second, Gbps
)

# ┌── P.I.C.O. ISOLATED SCENARIO ───────────────────────────────────────────────
class InterconnectHierarchy:
    """
    Namespace for Interconnect Bandwidth Hierarchy.
    Scenario: The bandwidth taper from Chip -> Node -> Cluster.
    """

    # ┌── 1. PARAMETERS (Inputs) ───────────────────────────────────────────────
    # Device
    hbm_bw = A100_MEM_BW.to(GB/second).magnitude

    # Chip-to-Chip
    nvlink_a100 = NVLINK_A100_BW.to(GB/second).magnitude
    nvlink_h100 = NVLINK_H100_BW.to(GB/second).magnitude

    # Host-to-Device
    pcie_gen4 = PCIE_GEN4_BW.to(GB/second).magnitude

    # Node-to-Node (Network)
    ib_hdr_gbps = INFINIBAND_HDR_BW.to(Gbps).magnitude
    ib_hdr_gbs = INFINIBAND_HDR_BW.to(GB/second).magnitude # ~25 GB/s

    ib_ndr_gbps = INFINIBAND_NDR_BW.to(Gbps).magnitude

    # ┌── 3. INVARIANTS (Guardrails) ───────────────────────────────────────────
    # The "Bandwidth Taper" must hold: HBM > NVLink > PCIe > Network
    check(hbm_bw > nvlink_h100 > pcie_gen4 > ib_hdr_gbs,
          f"Bandwidth hierarchy violated. HBM({hbm_bw}) > NVLink({nvlink_h100}) > PCIe({pcie_gen4}) > Net({ib_hdr_gbs})")

    # ┌── 4. OUTPUTS (Formatting) ──────────────────────────────────────────────
    nvlink_a100_str = f"{nvlink_a100:.0f}"
    nvlink_h100_str = f"{nvlink_h100:.0f}"
    ib_hdr_str = f"{ib_hdr_gbps:.0f}"
    ib_ndr_str = f"{ib_ndr_gbps:.0f}"

# ┌── EXPORTS (Bridge to Text) ─────────────────────────────────────────────────
nvlink_a100 = InterconnectHierarchy.nvlink_a100_str
nvlink_h100 = InterconnectHierarchy.nvlink_h100_str
ib_hdr = InterconnectHierarchy.ib_hdr_str
ib_ndr = InterconnectHierarchy.ib_ndr_str
```

1. **Device-Device Interconnect (NVLink / Infinity Fabric)**[^fn-nvlink]\index{NVLink!GPU interconnect}\index{GPU Interconnect!switching fabric}\index{Infinity Fabric!AMD interconnect}: Modern multi-GPU nodes use specialized high-speed bridges like NVLink to connect accelerators directly, bypassing the host CPU. Bandwidth ranges from `{python} nvlink_a100` to `{python} nvlink_h100` GB/s per GPU. The primary use case is gradient synchronization (AllReduce)\index{AllReduce!gradient synchronization}[^fn-allreduce-hardware] during distributed training. This bandwidth is critical for scaling; without it, multi-GPU training often scales poorly.

[^fn-nvlink]: **NVLink**\index{NVLink!etymology}: NVIDIA's proprietary high-bandwidth interconnect, introduced with the Pascal architecture (P100) in 2016. Multiple NVLink "bricks" bond together to far exceed PCIe bandwidth: the A100 provides 600 GB/s (NVLink 3.0) and the H100 achieves 900 GB/s (NVLink 4.0). NVLink enables the NVSwitch fabric, where every GPU in a node communicates at full bandwidth---critical for gradient synchronization during distributed training. AMD's counterpart is Infinity Fabric.

[^fn-allreduce-hardware]: **AllReduce**: From MPI (Message Passing Interface) terminology, where "reduce" operations combine values across processes using a function like sum or max, and "all" means every process receives the result. MPI standardized these collective operations in 1994. In distributed training, AllReduce aggregates gradients from all GPUs (the reduce), then distributes the averaged result back to all GPUs (the all). Ring AllReduce algorithms achieve optimal bandwidth utilization by having each process send and receive simultaneously.

2. **Host-Device Interconnect (PCIe)**\index{PCIe!host-device interconnect}: The link between the CPU and the accelerator. Bandwidth ranges from 32 to 64 GB/s (PCIe Gen4/Gen5)\index{PCIe!bandwidth generations}. This link represents the "Data Loading Bottleneck": all training data must pass through this thin pipe. Even with 8 GPUs providing 5 TB/s of aggregate compute bandwidth, the system is fed by a single ~64 GB/s PCIe switch.

3. **Node-Network Interconnect (NIC)**[^fn-infiniband]\index{Network Interface Card!node interconnect}: The link to the outside world, connecting to other nodes. Bandwidth ranges from 25 to 50 GB/s (`{python} ib_hdr` to `{python} ib_ndr` Gbps Ethernet/InfiniBand)\index{InfiniBand!bandwidth tiers}. This interconnect limits scaling across multiple nodes.

[^fn-infiniband]: **InfiniBand**\index{InfiniBand!etymology}: A high-speed networking standard from the InfiniBand Trade Association (IBTA), formed in 1999. The name combines "infinite" with "band" (bandwidth). Key advantages over Ethernet include RDMA (Remote Direct Memory Access), allowing GPUs to read/write remote memory without CPU involvement, and deterministic low latency. Mellanox (acquired by NVIDIA in 2020 for \$6.9B) was the primary vendor, making NVIDIA the dominant supplier of both compute and networking for AI training infrastructure.

These three levels produce a characteristic bandwidth taper:

$$
\begin{aligned}
\text{HBM (2000 GB/s)} &\gg \text{NVLink (900 GB/s)} \\
&\gg \text{PCIe (64 GB/s)} \gg \text{Network (50 GB/s)}
\end{aligned}
$$

System efficiency depends on keeping data as high up this hierarchy as possible. Once data drops to PCIe or Network speeds, it encounters a 30–100$\times$ slowdown.

This structured sequence begins with step (1), where data is copied from CPU memory to accelerator memory, as GPUs cannot directly access host memory at high speeds. A direct memory access (DMA)\index{DMA!Direct Memory Access}[^fn-dma] engine typically handles this transfer without consuming CPU cycles. In step (2), the CPU issues execution commands via APIs like CUDA, ROCm, or OpenCL. Step (3) involves parallel execution on the accelerator, where stalls can occur if data is not available when needed. Finally, in step (4), computed results are copied back to CPU memory for further processing.

[^fn-dma]: **Direct Memory Access (DMA)**: Hardware mechanism that enables devices to transfer data to and from memory without CPU intervention. DMA engines free the CPU to perform other tasks while data moves between system memory and accelerators. In representative systems, host-accelerator links can provide bandwidth on the order of tens of GB/s (PCIe-class), while some proprietary intra-node interconnects can provide bandwidth on the order of hundreds of GB/s. This asynchronous capability is critical for AI workloads where data movement can overlap with computation, improving overall system utilization.

Latency and bandwidth limitations directly impact AI workloads. PCIe-class host interconnects are typically much slower than an accelerator's on-package high-bandwidth memory, so large transfers can become bottlenecks, particularly in deep learning tasks. Synchronization overheads compound this problem when computation must wait for data transfers to complete. Efficient scheduling and overlapping transfers with execution are necessary to mitigate these inefficiencies.

#### Transfer Optimization

The bandwidth taper described above creates a clear optimization hierarchy. Practitioners have two complementary strategies for mitigating transfer overheads: *asynchronous data movement* and *unified memory abstraction*.

DMA engines enable the first strategy by offloading data transfers from the CPU entirely. While computation proceeds on the accelerator, a DMA engine copies the next batch of training data from host memory into accelerator memory in the background. This overlap of computation and communication is essential for maintaining high utilization — without it, the accelerator would idle during every transfer, reducing effective throughput by 20–40% on typical training workloads.

\index{Unified Memory!single address space}
Unified Memory provides the second strategy, offering a single address space accessible by both CPU and accelerator. Rather than requiring explicit copies, the runtime migrates memory pages on demand when either processor accesses them. This dramatically simplifies programming — a single `malloc` replaces complex staging logic — but introduces performance unpredictability. Page migrations triggered by access patterns can cause latency spikes, and small or scattered accesses may thrash pages back and forth across the interconnect. For this reason, production training workloads typically use explicit DMA-based transfers for predictable performance, while Unified Memory finds its niche in prototyping and workloads where development speed outweighs absolute throughput.

These overheads — interconnect latency, bandwidth taper, and synchronization delays — are not merely implementation details. They directly shape how neural network architectures interact with hardware, because different model types create dramatically different memory pressure patterns. A convolutional layer processing images exhibits regular spatial locality that maps well to tiled prefetching, while a transformer's attention mechanism requires accessing distant tokens across long sequences, stressing bandwidth in qualitatively different ways.

### Model Memory Pressure {#sec-ai-acceleration-model-memory-pressure-f95e}

\index{Model Memory Pressure!architecture-specific}
Building on the memory access patterns examined in @sec-ai-acceleration-memory-access-patterns-ml-workloads-a960, this section analyzes how specific architectures create distinct memory pressure. While multilayer perceptrons (MLPs), convolutional neural networks (CNNs), and transformer networks each require large parameter sets, their distinct memory demands necessitate tailored optimization strategies for accelerators.

To ground this analysis, we return to the Lighthouse Models introduced in @sec-introduction: **ResNet-50** represents CNN workloads with high spatial reuse, **GPT-2/Llama** exemplifies transformer memory pressure, **DLRM** illustrates sparse embedding lookups that stress memory systems differently than dense operations, and **MobileNet** demonstrates efficiency-optimized architectures with depthwise convolutions. These examples will recur throughout the remainder of this chapter as we analyze how memory characteristics translate to hardware utilization.

#### Multilayer Perceptrons {#sec-ai-acceleration-multilayer-perceptrons-0bbc}

MLPs, also referred to as fully connected networks, are among the simplest neural architectures. Each layer consists of a dense matrix multiplication, requiring every neuron to interact with all neurons in the preceding layer. This results in high memory bandwidth demands, particularly for weights, as every input activation contributes to a large set of computations.

From a memory perspective, MLPs rely on large, dense weight matrices that frequently exceed on-chip memory capacity, necessitating off-chip memory accesses. Since accelerators cannot directly access host memory at high speed, data transfers must be explicitly managed via interconnects such as PCIe or NVLink. These transfers introduce latency and consume bandwidth, affecting execution efficiency.

Despite their bandwidth-heavy nature, MLPs exhibit regular and predictable memory access patterns, making them amenable to optimizations such as prefetching and streaming memory accesses. Dedicated AI accelerators mitigate transfer overhead by staging weight matrices in fast SRAM caches and overlapping data movement with computation through direct memory access engines, reducing execution stalls. These optimizations allow accelerators to sustain high throughput even when handling large parameter sets [@Chen2016].

#### Convolutional Neural Networks {#sec-ai-acceleration-convolutional-neural-networks-3085}

\index{CNN!spatial data reuse}
Convolutional Neural Networks (CNNs) are widely used in image processing and computer vision tasks. Unlike MLPs, which require dense matrix multiplications, CNNs process input feature maps using small filter kernels that slide across the image. This localized computation structure results in high spatial data reuse, where the same input pixels contribute to multiple convolutions.

CNN accelerators benefit from on-chip memory optimizations, as convolution filters exhibit extensive reuse, allowing weights to be stored in fast local SRAM instead of frequently accessing off-chip memory. However, activation maps require careful management due to their size. Since accessing main memory over interconnects like PCIe introduces latency and bandwidth bottlenecks, CNN accelerators employ tiling techniques to divide feature maps into smaller regions that fit within on-chip buffers. This minimizes costly external memory transfers, improving overall efficiency [@Chen2016].

While CNN workloads are more memory-efficient than MLPs, managing intermediate activations remains a challenge. Accelerators use hierarchical caching strategies and DMA engines to optimize memory movement, ensuring that computations are not stalled by inefficient host-accelerator data transfers. These memory optimizations help CNN accelerators maintain high throughput by reducing reliance on off-chip memory bandwidth. Pioneering architectures like Eyeriss\index{Eyeriss!row-stationary dataflow} introduced row-stationary dataflows to maximize data reuse for convolutional workloads [@chen2016eyeriss].

#### Transformer Networks {#sec-ai-acceleration-transformer-networks-638c}

The transformer architectures introduced in @sec-dnn-architectures have become the dominant architecture for natural language processing and are increasingly used in other domains such as vision and speech recognition. Unlike CNNs, which rely on local computations, transformers perform global attention[^fn-attention-etymology] mechanisms, where each token in an input sequence can interact with all other tokens.

[^fn-attention-etymology]: **Attention**: Borrowed from cognitive psychology, where attention describes the brain's selective focus on relevant stimuli while filtering distractions. Bahdanau, Cho, and Bengio introduced "attention" to neural networks in 2014, using the term because the mechanism lets models "attend to" relevant parts of input sequences.

\index{Attention Mechanism!global token interaction}
These models are particularly challenging for accelerators due to their massive parameter sizes, which often exceed on-chip memory capacity. As a result, frequent memory transfers between host and accelerator introduce substantial latency overheads, particularly when relying on interconnects such as PCIe. Unified Memory architectures can mitigate some of these issues by dynamically handling data movement, but they introduce additional latency due to unpredictable on-demand memory migrations. Because transformers are memory-bound rather than compute-bound, accelerators optimized for them rely on high-bandwidth memory, tensor tiling, and memory partitioning to sustain performance [@brown2020language].

Attention caching mechanisms and specialized tensor layouts further reduce redundant memory fetches, improving execution efficiency. Given the bandwidth limitations of traditional interconnects, NVLink-enabled architectures offer clear advantages for large-scale transformer training, as they provide higher throughput and lower latency compared to PCIe. DMA-based asynchronous memory transfers enable overlapping computation with data movement, reducing execution stalls [@narayanan2021efficient].

### Accelerator Design Implications {#sec-ai-acceleration-ml-accelerators-implications-c962}

\index{Accelerator Design!workload-specific memory}
The diverse memory requirements of MLPs, CNNs, and Transformers highlight the need to tailor memory architectures to specific workloads. @tbl-model-mem-compare reveals how memory access patterns vary dramatically across model types.

| **Model Type**  | **Weight Size** | **Activation Reuse** | **Memory Access Pattern**      | **Primary Bottleneck**         |
|:--------------|:--------------|:-------------------|:-----------------------------|:-----------------------------|
| **MLP (Dense)** | Large, dense    | Low                  | Regular, sequential (streamed) | Bandwidth (off-chip)           |
| **CNN**         | Small, reused   | High                 | Spatial locality               | Feature map movement           |
| **Transformer** | Massive, sparse | Low                  | Irregular, high-bandwidth      | Memory capacity + Interconnect |

: **ML Model Memory Access.** Different machine learning models exhibit distinct memory access patterns and bottlenecks due to variations in weight size, activation reuse, and data sparsity. Transformers demand high bandwidth and capacity due to their massive, sparsely accessed weights, while CNNs benefit from spatial locality and high activation reuse, reducing memory pressure. {#tbl-model-mem-compare}

Each model type presents unique challenges that directly impact accelerator design. MLPs benefit from fast streaming access to dense weight matrices, making memory bandwidth a critical factor in performance, especially when transferring large weights from host memory to accelerator memory. CNNs, with their high activation reuse and structured memory access patterns, can exploit on-chip caching and tiling strategies to minimize off-chip memory transfers. Transformers, however, impose heavy demands on both bandwidth and capacity, as attention mechanisms require frequent access to large key-value matrices, leading to high interconnect traffic and increased memory pressure.

To address these challenges, modern AI accelerators incorporate multi-tier memory hierarchies that balance speed, capacity, and energy efficiency. On-chip SRAM caches and scratchpad memories store frequently accessed data, while high-bandwidth external memory provides scalability for large models. Efficient interconnects, such as NVLink, help alleviate host-accelerator transfer bottlenecks, particularly in transformer workloads where memory movement constraints can dominate execution time.

As ML workloads continue to grow in complexity, memory efficiency becomes as critical as raw compute power. The analysis reveals how memory systems dominate accelerator performance: DRAM access has 100× or higher energy cost than on-chip arithmetic, carefully structured memory hierarchies can improve effective bandwidth substantially, and different neural network architectures create distinct memory pressure patterns. These constraints — bandwidth limitations, energy costs, and communication overheads — determine whether theoretical computational capabilities translate into real-world performance. But how do we know if a *specific* workload is limited by compute or memory on a *given* accelerator? The memory wall analysis establishes *why* memory matters, but practitioners need a quantitative framework to predict *which* operations will bottleneck on a specific hardware configuration. Without such a framework, optimization becomes guesswork: engineers might spend weeks optimizing compute throughput for an operation that was memory-bound all along.

## Roofline Model {#sec-ai-acceleration-measuring-efficiency}

\index{Roofline Model!efficiency measurement}
The Roofline Model answers this question by plotting arithmetic intensity against attainable performance, revealing whether each operation hits a compute ceiling or a memory bandwidth ceiling. Rather than relying on peak FLOPS figures, which reflect marketing rather than achievable throughput, the Roofline Model provides a quantitative framework that maps any workload onto a specific hardware platform and immediately exposes the binding constraint. This section develops that framework and applies it to the neural network architectures analyzed above.

The roofline model\index{Roofline Model!Williams et al.}[^fn-roofline-etymology] [@williams2009roofline] provides the standard framework for understanding whether workloads are compute-bound\index{Compute-Bound!definition} or memory-bound\index{Memory-Bound!definition}, directly connecting the memory wall discussion to practical performance analysis. This model enables quantitative reasoning about accelerator utilization and guides optimization decisions.

[^fn-roofline-etymology]: **Roofline Model** [@williams2009roofline]\index{Williams, Samuel!roofline model author}: Named for its visual appearance when plotted: a flat horizontal line (the compute ceiling) meets a sloped line (the memory ceiling) forming a shape resembling a building roofline. Samuel Williams, Andrew Waterman, and David Patterson introduced this visualization at UC Berkeley in 2009. The metaphor captures how workloads hit different "ceilings" depending on their arithmetic intensity, making performance bounds intuitive at a glance.

Performance is bounded by two ceilings, as @eq-roofline formalizes. Here, Attainable Performance and Peak Compute are in FLOPs/second (often reported as TFLOPS), Peak Bandwidth is in bytes/second (often TB/s), and Arithmetic Intensity is in FLOP/byte:

$$\text{Attainable Performance} = \min(\text{Peak Compute}, \text{Peak Bandwidth} \times \text{Arithmetic Intensity})$$ {#eq-roofline}

The key metric that determines which ceiling a workload hits is *arithmetic intensity*, the ratio of computation to memory traffic.

::: {.callout-definition title="Arithmetic Intensity"}

***Arithmetic Intensity***\index{Arithmetic Intensity!definition} is the measure of **Computational Density**, defined as the ratio of FLOPs performed to Bytes transferred. It serves as the independent variable in the **Roofline Model**\index{Roofline Model!performance analysis}, determining the **Regime of Operation**: low intensity workloads are **Bandwidth-Bound** (waiting for data), while high intensity workloads are **Compute-Bound** (waiting for math).

:::

Arithmetic intensity (AI) measures operations per byte of memory traffic. FLOPs is a dimensionless count of floating-point operations and Bytes Transferred is in bytes, so AI has units of FLOP/byte, defined by @eq-arithmetic-intensity:

$$\text{AI} = \frac{\text{FLOPs}}{\text{Bytes Transferred}}$$ {#eq-arithmetic-intensity}

The roofline visualization shows performance (TFLOPS) on the vertical axis and arithmetic intensity (FLOP/byte) on the horizontal axis. At low arithmetic intensity, performance increases linearly with intensity (memory-bound region). Above a threshold called the ridge point, performance saturates at peak compute (compute-bound region).

### Hardware Ridge Points

\index{Ridge Point!definition}The ridge point determines the arithmetic intensity threshold where the transition from memory-bound to compute-bound occurs. @tbl-ridge-points quantifies how different accelerators exhibit distinct characteristics based on their compute-to-bandwidth ratios:

| **Accelerator**          |                     **Peak FP16** |                        **Bandwidth** |       **Ridge Point** |
|:-----------------------|--------------------------------:|-----------------------------------:|--------------------:|
| **GPU (2017-era)**       |                $\sim 10^2$ TFLOPS |                     $\sim 10^3$ GB/s | $\sim 10^2$ FLOP/byte |
| **GPU (2020-era)**       |                $\sim 10^2$ TFLOPS | $\sim 10^3$ GB/s to $\sim 10^0$ TB/s | $\sim 10^2$ FLOP/byte |
| **GPU (2023-era)**       |                $\sim 10^3$ TFLOPS |                           a few TB/s | $\sim 10^2$ FLOP/byte |
| **TPU-class (2023-era)** | $\sim 10^2$ to $\sim 10^3$ TFLOPS |                        $\sim 1$ TB/s | $\sim 10^2$ FLOP/byte |

: **Hardware Ridge Points.** Representative ridge point ranges for different accelerator generations, determined by their compute-to-bandwidth ratios. Values shown are order-of-magnitude approximations; actual ridge points vary by precision mode and specific SKU. Higher ridge points require more operations per byte to achieve peak utilization. {#tbl-ridge-points}

These ridge point values reveal a surprising trend: as hardware has become more powerful, keeping it fully utilized has become harder. The following analysis illustrates *the utilization gap*.

```{python}
#| label: roofline-utilization-gap-calc
#| echo: false
# ┌─────────────────────────────────────────────────────────────────────────────
# │ ROOFLINE UTILIZATION GAP CALCULATION
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: "The Utilization Gap" callout in Roofline Model section
# │
# │ Why: Shows why newer accelerators are harder to saturate. As compute grows
# │      faster than bandwidth, the ridge point climbs, pushing more workloads
# │      into the memory-bound regime. Explains why "legacy" code sees <2x
# │      speedup on H100 despite 3x FLOPS improvement.
# │
# │ Imports: mlsys.constants (V100/A100/H100 FLOPS and bandwidth)
# │ Exports: v100_ridge, a100_ridge, h100_ridge, legacy_ai_str, etc.
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.constants import (
    V100_FLOPS_FP16_TENSOR, V100_MEM_BW,
    A100_MEM_BW, A100_FLOPS_FP16_TENSOR, A100_FLOPS_FP32,
    H100_MEM_BW, H100_FLOPS_FP16_TENSOR,
    flop, byte, TB, second
)
from mlsys.formatting import fmt

# ┌── P.I.C.O. ISOLATED SCENARIO ───────────────────────────────────────────────
class RooflineGap:
    """
    Namespace for Roofline Utilization Gap.
    Scenario: Comparing Ridge Points across generations (V100 -> H100).
    """

    # ┌── 1. PARAMETERS (Inputs) ───────────────────────────────────────────────
    # Thresholds
    legacy_ai = 200.0
    relu_ai = 0.125

    # Hardware Specs (Raw magnitudes)
    v100_flops = V100_FLOPS_FP16_TENSOR.to(TFLOPs/second).magnitude * TRILLION
    v100_bw = V100_MEM_BW.to(byte/second).magnitude

    a100_flops = A100_FLOPS_FP16_TENSOR.to(TFLOPs/second).magnitude * TRILLION
    a100_flops_fp32 = A100_FLOPS_FP32.to(TFLOPs/second).magnitude * TRILLION
    a100_bw = A100_MEM_BW.to(byte/second).magnitude

    h100_flops = H100_FLOPS_FP16_TENSOR.to(TFLOPs/second).magnitude * TRILLION
    h100_bw = H100_MEM_BW.to(byte/second).magnitude

    # ┌── 2. CALCULATION (The Physics) ─────────────────────────────────────────
    # Ridge Points (FLOP/Byte)
    v100_ridge = v100_flops / v100_bw
    a100_ridge = a100_flops / a100_bw
    h100_ridge = h100_flops / h100_bw
    a100_ridge_fp32 = a100_flops_fp32 / a100_bw

    # Comparisons
    bw_growth = h100_bw / a100_bw
    flops_growth = h100_flops / a100_flops
    relu_gap = h100_ridge / relu_ai

    # ┌── 3. INVARIANTS (Guardrails) ───────────────────────────────────────────
    # Ridge points must climb: H100 > A100 > V100
    check(h100_ridge > a100_ridge > v100_ridge,
          f"Ridge points must climb. H100({h100_ridge:.0f}) > A100({a100_ridge:.0f}) > V100({v100_ridge:.0f}).")
    check(relu_gap >= 1000, f"ReLU gap ({relu_gap:.0f}x) is too small.")

    # ┌── 4. OUTPUTS (Formatting) ──────────────────────────────────────────────
    v100_ridge_str = f"{v100_ridge:.0f}"
    a100_ridge_str = f"{a100_ridge:.0f}"
    h100_ridge_str = f"{h100_ridge:.0f}"
    a100_ridge_fp32_str = f"{a100_ridge_fp32:.0f}"

    legacy_ai_str = fmt(legacy_ai, precision=0, commas=False)
    bandwidth_ratio_str = fmt(bw_growth, precision=1, commas=False)
    flops_ratio_str = fmt(flops_growth, precision=1, commas=False)
    relu_below_roofline_str = fmt(relu_gap, precision=0, commas=True)

# ┌── EXPORTS (Bridge to Text) ─────────────────────────────────────────────────
v100_ridge = RooflineGap.v100_ridge_str
a100_ridge = RooflineGap.a100_ridge_str
h100_ridge = RooflineGap.h100_ridge_str
a100_ridge_fp32 = RooflineGap.a100_ridge_fp32_str
legacy_ai_str = RooflineGap.legacy_ai_str
bandwidth_ratio_str = RooflineGap.bandwidth_ratio_str
flops_ratio_str = RooflineGap.flops_ratio_str
relu_below_roofline_str = RooflineGap.relu_below_roofline_str
```

::: {.callout-notebook title="The Utilization Gap"}

**The Utilization Physics**: Why is it harder to get 100% utilization on an H100 than a V100?

**Metric**: The Ridge Point $R$, defined as $R = \text{Peak FLOPS} / \text{Peak Bandwidth}$ (FLOP/byte). This number tells you how many math operations you *must* perform for every byte of data you load to keep the compute units busy.

**The Evolution**:

*   **V100 (2017)**: `{python} v100_tflops` TF / 0.9 TB/s ≈ **`{python} v100_ridge` FLOP/byte**.
*   **A100 (2020)**: `{python} a100_tflops_fp16` TF / `{python} a100_bw_tbs` TB/s ≈ **`{python} a100_ridge` FLOP/byte**.
*   **H100 (2023)**: `{python} h100_tflops_fp16` TF / `{python} h100_bw_tbs` TB/s ≈ **`{python} h100_ridge` FLOP/byte**.

**The Systems Conclusion**: The "bar" for compute intensity has doubled. An algorithm with AI = `{python} legacy_ai_str` FLOP/byte was **compute-bound** (good) on A100 but is **bandwidth-bound** (bad) on H100. This explains why "legacy" code often sees only `{python} bandwidth_ratio_str`x speedup on H100 (bandwidth ratio) instead of the advertised `{python} flops_ratio_str`x (FLOPs ratio).

**Practical Examples**: A standard **ReLU** performs 1 operation for every 8 bytes (0.125 FLOP/byte), placing it `{python} relu_below_roofline_str`x below the H100 roofline. A large **Dense MatMul** (batch=128) might reach 300 FLOP/byte, making it compute-bound. Most operations fall short of the ridge point, which is why **Kernel Fusion** is the most important optimization, as explored in @sec-ai-acceleration-kernel-fusion-7faf.
:::

\index{Depthwise Convolution!low arithmetic intensity}\index{Embedding Lookup!memory-bound operation}\index{LayerNorm!memory-bound operation}\index{Softmax!memory-bound operation}
@tbl-roofline-operations maps common neural network operations to the Roofline model:

| **Operation**         | **Arithmetic Intensity** | **Classification** | **Lighthouse Example**  |
|:--------------------|-----------------------:|:-----------------|:----------------------|
| **Conv2D (Dense)**    |         50-200 FLOP/byte | Compute-bound      | **ResNet-50**           |
| **Dense MatMul**      |         64-256 FLOP/byte | Compute-bound      | **GPT-2 (Projections)** |
| **Depthwise Conv**    |          10-20 FLOP/byte | Memory-bound       | **MobileNet**           |
| **Attention Softmax** |            2-5 FLOP/byte | Memory-bound       | **GPT-2 (Generation)**  |
| **LayerNorm**         |           5-10 FLOP/byte | Memory-bound       | **GPT-2 / Llama**       |
| **Embedding lookup**  |             <1 FLOP/byte | Memory-bound       | **DLRM**                |

: **Operations on the Roofline.** Neural network layers span a wide range of arithmetic intensities. By mapping these operations to the **Lighthouse Models**, ResNet-50 emerges as compute-bound (high AI) while MobileNet and DLRM are memory-bound (low AI). {#tbl-roofline-operations}

To see how these intensity values translate into real performance predictions, a complete *transformer layer analysis* computes the arithmetic intensity of each sub-operation.

```{python}
#| label: transformer-layer-calc
#| echo: false
# ┌─────────────────────────────────────────────────────────────────────────────
# │ TRANSFORMER LAYER ARITHMETIC INTENSITY
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: "Transformer Layer Analysis" callout in Roofline section
# │
# │ Why: Breaks down a transformer layer into QKV projection (compute-bound)
# │      and softmax (memory-bound) to show why FlashAttention focuses on
# │      reducing memory traffic in attention rather than reducing FLOPs.
# │
# │ Imports: mlsys.constants (TRANSFORMER_*, BYTES_FP16)
# │ Exports: t_*_str, qkv_*_str, softmax_*_str
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.formatting import fmt
from mlsys.constants import (
    byte, MB, flop, GFLOPs, MFLOPs,
    TRANSFORMER_HIDDEN_DIM_EXAMPLE, TRANSFORMER_SEQ_LEN_EXAMPLE,
    TRANSFORMER_HEADS_EXAMPLE, BYTES_FP16
)

# --- Inputs (typical transformer dimensions) ---
t_hidden_value = TRANSFORMER_HIDDEN_DIM_EXAMPLE
t_batch_value = 32
t_seq_value = TRANSFORMER_SEQ_LEN_EXAMPLE
t_heads_value = TRANSFORMER_HEADS_EXAMPLE
t_fp_bytes_value = BYTES_FP16.to(byte).magnitude

# --- QKV Projection ---
# FLOPs: 3 projections × batch × seq × hidden × hidden × 2 (multiply-add)
# The "× 2" for multiply-add is often folded into "FLOPs" convention;
# here the text uses: 3 × batch × seq × hidden × hidden
qkv_flops_value = 3 * t_batch_value * t_seq_value * t_hidden_value * t_hidden_value
qkv_flops_b_value = (qkv_flops_value * flop).to(GFLOPs).magnitude

# Bytes: (input + weights + output) × 2 bytes
qkv_input_value = t_batch_value * t_seq_value * t_hidden_value
qkv_weights_value = 3 * t_hidden_value * t_hidden_value
qkv_output_value = t_batch_value * t_seq_value * t_hidden_value * 3
qkv_bytes_value = (qkv_input_value + qkv_weights_value + qkv_output_value) * t_fp_bytes_value
qkv_mb_value = (qkv_bytes_value * byte).to(MB).magnitude

# Arithmetic intensity
qkv_ai_value = qkv_flops_value / qkv_bytes_value

# --- Softmax ---
# FLOPs: batch × heads × seq × seq × 3 (exp, sum, div)
softmax_flops_value = t_batch_value * t_heads_value * t_seq_value * t_seq_value * 3
softmax_flops_m_value = (softmax_flops_value * flop).to(MFLOPs).magnitude

# Bytes: batch × heads × seq × seq × 2 (read + write) × 2 bytes
softmax_bytes_value = t_batch_value * t_heads_value * t_seq_value * t_seq_value * 2 * t_fp_bytes_value
softmax_mb_value = (softmax_bytes_value * byte).to(MB).magnitude

# Arithmetic intensity
softmax_ai_value = softmax_flops_value / softmax_bytes_value

# --- Outputs (formatted strings for prose) ---
t_hidden_str = fmt(t_hidden_value, precision=0, commas=False)
t_batch_str = fmt(t_batch_value, precision=0, commas=False)
t_seq_str = fmt(t_seq_value, precision=0, commas=False)
t_heads_str = fmt(t_heads_value, precision=0, commas=False)
qkv_flops_b_str = fmt(qkv_flops_b_value, precision=0, commas=False)
qkv_mb_str = fmt(qkv_mb_value, precision=0, commas=False)
qkv_ai_str = fmt(qkv_ai_value, precision=0, commas=False)
softmax_flops_m_str = fmt(softmax_flops_m_value, precision=0, commas=False)
softmax_mb_str = fmt(softmax_mb_value, precision=0, commas=False)
softmax_ai_str = fmt(softmax_ai_value, precision=2, commas=False)
```

::: {.callout-notebook #notebook-transformer-layers title="Transformer Layer Analysis"}

For a transformer with hidden_dim=`{python} t_hidden_str`, batch=`{python} t_batch_str`, seq=`{python} t_seq_str`:

*Attention QKV Projection*:

- FLOPs: 3 × `{python} t_batch_str` × `{python} t_seq_str` × `{python} t_hidden_str` × `{python} t_hidden_str` = `{python} qkv_flops_b_str` billion FLOPs
- Bytes: (input + weights + output) = (`{python} t_batch_str` × `{python} t_seq_str` × `{python} t_hidden_str` + 3 × `{python} t_hidden_str` × `{python} t_hidden_str` + `{python} t_batch_str` × `{python} t_seq_str` × `{python} t_hidden_str` × 3) × 2 ≈ `{python} qkv_mb_str` MB
- AI = `{python} qkv_flops_b_str` B / `{python} qkv_mb_str` M = `{python} qkv_ai_str` FLOP/byte, which is **compute-bound on A100** (above `{python} a100_ridge` threshold)

*Softmax*:

- FLOPs: `{python} t_batch_str` × `{python} t_heads_str` × `{python} t_seq_str` × `{python} t_seq_str` × 3 ≈ `{python} softmax_flops_m_str` M FLOPs (exp, sum, div)
- Bytes: `{python} t_batch_str` × `{python} t_heads_str` × `{python} t_seq_str` × `{python} t_seq_str` × 2 × 2 = `{python} softmax_mb_str` MB
- AI = `{python} softmax_flops_m_str` M / `{python} softmax_mb_str` M = `{python} softmax_ai_str` FLOP/byte, which is **memory-bound**

This analysis explains why FlashAttention\index{FlashAttention!memory optimization}\index{Attention Mechanism!memory-bound softmax} focuses on reducing memory traffic in attention rather than reducing FLOPs.
:::

These classifications directly inform optimization strategy. Memory-bound operations benefit from reducing data movement through operator fusion, using reduced precision (FP16, INT8), and increasing arithmetic intensity through algorithmic changes like FlashAttention. Compute-bound operations, by contrast, benefit from maximizing hardware utilization through batching and parallelism, exploiting Tensor Cores and specialized compute units, and optimizing compute efficiency through tiling and scheduling.

### Calculating Memory Bandwidth Bounds

The roofline model's memory-bound region is determined by the peak memory bandwidth. For an operation to achieve throughput $T_{\text{ops}}$ (FLOPs/second, often expressed in TFLOPS) in the memory-bound regime, @eq-required-bandwidth gives the required bandwidth:

$$\text{Required Bandwidth} = \frac{T_{\text{ops}}}{\text{AI}} \text{ bytes/sec}$$ {#eq-required-bandwidth}

When Required Bandwidth exceeds Peak Bandwidth, performance is capped according to @eq-attainable-throughput. Here $T_{\text{ops}}$ and $T_{\text{attainable}}$ are in FLOPs/second and AI is in FLOP/byte.

$$T_{\text{attainable}} = \text{Peak Bandwidth} \times \text{AI}$$ {#eq-attainable-throughput}

A *convolutional layer analysis* demonstrates how these formulas apply in practice.

```{python}
#| label: conv2d-analysis-calc
#| echo: false
# ┌─────────────────────────────────────────────────────────────────────────────
# │ CONV2D LAYER ROOFLINE ANALYSIS
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: "Convolutional Layer Analysis" callout notebook
# │
# │ Why: Calculates FLOPs, memory traffic, and arithmetic intensity for a
# │      Conv2D layer to demonstrate a compute-bound operation on the roofline.
# │
# │ Imports: mlsys.constants (BYTES_FP16, byte, MB, flop, GFLOPs),
# │          mlsys.formatting (fmt)
# │ Exports: conv_out_m_str, conv_flops_per_out_str, conv_total_gflops_str,
# │          conv_input_mb_str, conv_weights_mb_str, conv_output_mb_str,
# │          conv_total_mb_str, conv_ai_str
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.formatting import fmt
from mlsys.constants import BYTES_FP16, byte, MB, flop, GFLOPs

# --- Inputs (Conv2D layer parameters) ---
conv_batch = 32; conv_cin = 128; conv_h = 56; conv_w = 56
conv_cout = 256; conv_k = 3; conv_fp_bytes = BYTES_FP16.magnitude

# --- Computation ---
# Output elements
conv_out_elements = conv_batch * conv_cout * conv_h * conv_w
conv_out_m = conv_out_elements / MILLION

# FLOPs per output element (multiply-add = 2 ops)
conv_flops_per_out = conv_cin * conv_k * conv_k * 2
conv_total_gflops = (conv_out_elements * conv_flops_per_out * flop).to(GFLOPs).magnitude

# Memory traffic (FP16)
conv_input_mb = (conv_batch * conv_cin * conv_h * conv_w * conv_fp_bytes * byte).to(MB).magnitude
conv_weights_mb = (conv_cout * conv_cin * conv_k * conv_k * conv_fp_bytes * byte).to(MB).magnitude
conv_output_mb = (conv_batch * conv_cout * conv_h * conv_w * conv_fp_bytes * byte).to(MB).magnitude
conv_total_mb = conv_input_mb + conv_weights_mb + conv_output_mb

# Arithmetic intensity
conv_ai = conv_total_gflops * 1e3 / conv_total_mb

# --- Outputs (formatted strings for prose) ---
conv_out_m_str = fmt(conv_out_m, precision=1, commas=False)
conv_flops_per_out_str = f"{conv_flops_per_out:,}"
conv_total_gflops_str = fmt(conv_total_gflops, precision=1, commas=False)
conv_input_mb_str = fmt(conv_input_mb, precision=1, commas=False)
conv_weights_mb_str = fmt(conv_weights_mb, precision=1, commas=False)
conv_output_mb_str = fmt(conv_output_mb, precision=1, commas=False)
conv_total_mb_str = fmt(conv_total_mb, precision=1, commas=False)
conv_ai_str = fmt(conv_ai, precision=0, commas=False)
```

::: {.callout-notebook #notebook-conv-analysis title="Convolutional Layer Analysis"}

Consider a Conv2D layer with input shape (batch=32, channels=128, height=56, width=56), output channels=256, kernel size 3×3 on an A100 GPU:

*Computational Requirements*:

- Output size: 32 × 256 × 56 × 56 = `{python} conv_out_m_str` M elements
- FLOPs per output: 128 × 3 × 3 × 2 = `{python} conv_flops_per_out_str` (multiply-add)
- Total FLOPs: `{python} conv_out_m_str` M × `{python} conv_flops_per_out_str` = `{python} conv_total_gflops_str` billion FLOPs

*Memory Traffic Analysis*:

- Input: 32 × 128 × 56 × 56 × 2 = `{python} conv_input_mb_str` MB (FP16)
- Weights: 256 × 128 × 3 × 3 × 2 ≈ `{python} conv_weights_mb_str` MB (FP16)
- Output: 32 × 256 × 56 × 56 × 2 = `{python} conv_output_mb_str` MB (FP16)
- Total: `{python} conv_total_mb_str` MB

**Arithmetic Intensity**:
AI = `{python} conv_total_gflops_str` GFLOPs / `{python} conv_total_mb_str` MB = `{python} conv_ai_str` FLOP/byte

This is **well above** A100's ridge point of `{python} a100_ridge` FLOP/byte, making this operation **compute-bound**. The layer will achieve near-peak performance of ~`{python} a100_tflops_fp16` TFLOPS (FP16 with Tensor Cores).
:::

The convolutional layer's high arithmetic intensity arises from its weight reuse pattern: the same 3×3 kernel is applied across all spatial locations, amortizing the cost of loading weights across millions of output computations. This is the architectural pattern that makes CNNs so efficient on modern accelerators.

However, not all layers in a neural network exhibit this favorable profile. The fully connected (dense) layers that typically appear at the end of classification networks, or as the projection layers in transformers, have different arithmetic intensity characteristics. A *dense layer analysis* reveals this contrast, which is essential for predicting where bottlenecks will occur in end-to-end model execution.

```{python}
#| label: dense-layer-analysis-calc
#| echo: false
# ┌─────────────────────────────────────────────────────────────────────────────
# │ DENSE LAYER ROOFLINE ANALYSIS
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: "Dense Layer Analysis" callout notebook
# │
# │ Why: Calculates FLOPs, memory traffic, arithmetic intensity, and attainable
# │      performance for a dense layer, demonstrating a memory-bound operation.
# │      Contrasts with the compute-bound Conv2D analysis above.
# │
# │ Imports: mlsys.constants (BYTES_FP16, byte, MB, KiB, flop, MFLOPs, GFLOPs,
# │          TFLOPs, A100_MEM_BW, A100_FLOPS_FP16_TENSOR, GB, second),
# │          mlsys.formatting (fmt)
# │ Exports: dense_total_mflops_str, dense_input_kb_str, dense_weights_mb_str,
# │          dense_output_kb_str, dense_total_mb_str, dense_ai_str,
# │          dense_attainable_str, dense_util_pct_str, a100_bw
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.formatting import fmt
from mlsys.constants import (
    BYTES_FP16, byte, MB, KiB, flop, MFLOPs, GFLOPs, TFLOPs,
    A100_MEM_BW, A100_FLOPS_FP16_TENSOR, GB, second,
)

# --- Inputs (dense layer parameters) ---
dense_batch = 32; dense_in = 2048; dense_out = 2048

# --- Computation ---
# FLOPs: 2 × batch × in × out
dense_total_mflops = (2 * dense_batch * dense_in * dense_out * flop).to(MFLOPs).magnitude

# Memory traffic (FP16)
dense_input_kb = dense_batch * dense_in * 2 / KIB_TO_BYTES
dense_weights_mb = (dense_in * dense_out * 2 * byte).to(MB).magnitude
dense_output_kb = dense_batch * dense_out * 2 / KIB_TO_BYTES
dense_total_mb = (dense_input_kb * KiB + dense_weights_mb * MB + dense_output_kb * KiB).to(MB).magnitude

# Arithmetic intensity
dense_ai = dense_total_mflops / dense_total_mb

# Attainable performance (A100)
a100_bw_gbs_value = A100_MEM_BW.to(GB / second).magnitude
a100_peak = A100_FLOPS_FP16_TENSOR.to(TFLOPs / second).magnitude

dense_attainable_tflops = (a100_bw_gbs_value * dense_ai * GFLOPs).to(TFLOPs).magnitude
dense_util_pct = dense_attainable_tflops / a100_peak * 100

# --- Outputs (formatted strings for prose) ---
dense_total_mflops_str = fmt(dense_total_mflops, precision=0, commas=False)
dense_input_kb_str = fmt(dense_input_kb, precision=0, commas=False)
dense_weights_mb_str = fmt(dense_weights_mb, precision=1, commas=False)
dense_output_kb_str = fmt(dense_output_kb, precision=0, commas=False)
dense_total_mb_str = fmt(dense_total_mb, precision=1, commas=False)
dense_ai_str = fmt(dense_ai, precision=1, commas=False)
dense_attainable_str = fmt(dense_attainable_tflops, precision=0, commas=False)
dense_util_pct_str = fmt(dense_util_pct, precision=0, commas=False)
a100_bw = f"{a100_bw_gbs_value:,.0f}"
```

::: {.callout-notebook title="Dense Layer Analysis"}

Consider a fully connected layer: input (batch=32, features=2048) → output (batch=32, features=2048) on the same A100:

*Computational Requirements*:

- Matrix multiply: (32 × 2048) × (2048 × 2048)
- Total FLOPs: 2 × 32 × 2048 × 2048 = `{python} dense_total_mflops_str` million FLOPs

*Memory Traffic Analysis*:

- Input: 32 × 2048 × 2 = `{python} dense_input_kb_str` KB (FP16)
- Weights: 2048 × 2048 × 2 = `{python} dense_weights_mb_str` MB (FP16)
- Output: 32 × 2048 × 2 = `{python} dense_output_kb_str` KB (FP16)
- Total: `{python} dense_total_mb_str` MB

**Arithmetic Intensity**:
AI = `{python} dense_total_mflops_str` MFLOPs / `{python} dense_total_mb_str` MB = `{python} dense_ai_str` FLOP/byte

This is **below** A100's ridge point of `{python} a100_ridge` FLOP/byte, making this operation **memory-bound**. Attainable performance:
Pattainable = `{python} a100_bw` GB/s × `{python} dense_ai_str` FLOP/byte = `{python} dense_attainable_str` TFLOPS

This is only `{python} dense_util_pct_str`% of peak compute capability, demonstrating the memory wall effect for small batch sizes.
:::

The dense layer's lower arithmetic intensity stems from limited weight reuse: each weight element is used only once per batch element, whereas convolutional weights are reused across spatial dimensions. This difference explains why transformer inference (dominated by dense projections) is typically memory-bound while CNN inference can be compute-bound.

The situation becomes even more extreme for element-wise operations like normalization layers. These operations perform very little computation relative to the data they touch, as a *LayerNorm analysis* reveals. Each element is loaded, transformed by a simple formula, and written back, leaving essentially no opportunity for data reuse.

```{python}
#| label: layernorm-analysis-calc
#| echo: false
# ┌─────────────────────────────────────────────────────────────────────────────
# │ LAYERNORM ROOFLINE ANALYSIS
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: "LayerNorm Analysis" callout notebook
# │
# │ Why: Calculates FLOPs, memory traffic, and arithmetic intensity for a
# │      LayerNorm operation, demonstrating a severely memory-bound workload
# │      that achieves <1% of peak compute.
# │
# │ Imports: mlsys.constants (byte, MB, A100_MEM_BW, GB, GFLOPs, TFLOPs,
# │          second), mlsys.formatting (fmt)
# │ Exports: ln_elements_m_str, ln_total_mflops_str, ln_input_mb_str,
# │          ln_params_kb_str, ln_output_mb_str, ln_total_mb_str,
# │          ln_ai_str, ln_attainable_str, a100_bw_str
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.formatting import fmt
from mlsys.constants import byte, MB, A100_MEM_BW, GB, GFLOPs, TFLOPs, second

# --- Inputs (LayerNorm dimensions) ---
ln_batch = 32; ln_seq = 512; ln_hidden = 768

# --- Computation ---
# Elements
ln_elements = ln_batch * ln_seq * ln_hidden
ln_elements_m = ln_elements / MILLION

# FLOPs (6 per element)
ln_flops_per = 6
ln_total_mflops = ln_elements_m * ln_flops_per

# Memory traffic
ln_input_mb = (ln_elements * 2 * byte).to(MB).magnitude
ln_params_kb = ln_hidden * 2 * 2 / KIB_TO_BYTES
ln_output_mb = (ln_elements * 2 * byte).to(MB).magnitude
ln_total_mb = ln_input_mb + ln_output_mb + ln_params_kb / KIB_TO_BYTES

# Arithmetic intensity
ln_ai = ln_total_mflops / ln_total_mb

# Attainable performance
a100_bw_gbs_value = A100_MEM_BW.to(GB / second).magnitude
ln_attainable_tflops = (a100_bw_gbs_value * ln_ai * GFLOPs).to(TFLOPs).magnitude

# --- Outputs (formatted strings for prose) ---
ln_elements_m_str = fmt(ln_elements_m, precision=1, commas=False)
ln_total_mflops_str = fmt(ln_total_mflops, precision=1, commas=False)
ln_input_mb_str = fmt(ln_input_mb, precision=1, commas=False)
ln_params_kb_str = fmt(ln_params_kb, precision=0, commas=False)
ln_output_mb_str = fmt(ln_output_mb, precision=1, commas=False)
ln_total_mb_str = fmt(ln_total_mb, precision=1, commas=False)
ln_ai_str = fmt(ln_ai, precision=1, commas=False)
ln_attainable_str = fmt(ln_attainable_tflops, precision=0, commas=False)
a100_bw_str = fmt(a100_bw_gbs_value, precision=0, commas=False)
```

::: {.callout-notebook title="LayerNorm Analysis"}

LayerNorm with input shape (batch=32, seq=512, hidden=768):

*Computational Requirements*:

- Elements: 32 × 512 × 768 = `{python} ln_elements_m_str` M
- Operations per element: mean (1 ADD), variance (2 ADD, 1 MUL), normalize (1 ADD, 1 MUL, 1 DIV) ≈ 6 FLOPs
- Total FLOPs: `{python} ln_elements_m_str` M × 6 = `{python} ln_total_mflops_str` M FLOPs

*Memory Traffic*:

- Input: `{python} ln_elements_m_str` M × 2 = `{python} ln_input_mb_str` MB
- Parameters (scale, bias): 768 × 2 × 2 = `{python} ln_params_kb_str` KB (negligible)
- Output: `{python} ln_elements_m_str` M × 2 = `{python} ln_output_mb_str` MB
- Total: `{python} ln_total_mb_str` MB

**Arithmetic Intensity**:
AI = `{python} ln_total_mflops_str` MFLOPs / `{python} ln_total_mb_str` MB = `{python} ln_ai_str` FLOP/byte

This is **severely memory-bound** (102× below ridge point). Performance is limited to:
Pattainable = `{python} a100_bw_str` GB/s × `{python} ln_ai_str` FLOP/byte = `{python} ln_attainable_str` TFLOPS

This represents less than 1% of A100's compute capacity, explaining why normalization layers contribute negligible compute time but significant latency.
:::

### Optimization by Intensity Regime

The roofline analysis directly informs optimization priorities:

1. **High AI (>200 FLOP/byte)**: Compute-bound operations like large convolutions
   - Priority: Maximize compute utilization
   - Techniques: Use Tensor Cores, optimize thread block dimensions, maximize occupancy
   - Impact: Can approach 90-95% of peak TFLOPS

2. **Medium AI (20-200 FLOP/byte)**: Borderline operations like medium-sized dense layers
   - Priority: Balance compute and memory optimization
   - Techniques: Increase batch size to improve AI, use register tiling, fuse with adjacent operations
   - Impact: Can move from memory-bound to compute-bound regime

3. **Low AI (<20 FLOP/byte)**: Memory-bound operations like small dense layers, element-wise operations
   - Priority: Reduce memory traffic
   - Techniques: Aggressive operator fusion, reduce precision (FP16 → INT8), algorithmic changes
   - Impact: 2-4× speedup possible through fusion alone

4. **Very Low AI (<2 FLOP/byte)**: Severely memory-bound operations like normalization, activation functions
   - Priority: Eliminate memory round-trips
   - Techniques: Mandatory fusion with adjacent operations, in-place computation where possible
   - Impact: Can achieve 10× speedup through fusion (e.g., LayerNorm + GELU → single fused kernel)\index{Operator Fusion!memory-bound optimization}\index{LayerNorm!kernel fusion target}

One of the most accessible levers for shifting an operation's position on the roofline is increasing *batch size and arithmetic intensity*.

::: {.callout-notebook title="Batch Size and Arithmetic Intensity"}

\index{Batch Size!arithmetic intensity impact}Increasing batch size improves AI for matrix operations by amortizing weight loading. @eq-batch-ai formalizes this relationship for a dense layer $(B \times M) \times (M \times N)$:

$$\text{AI} = \frac{2BMN}{2BM + 2MN + 2BN} \approx \frac{2BMN}{2MN} = B \quad (\text{when } 2MN \gg 2B(M+N))$$ {#eq-batch-ai}

Example: Dense layer with M=N=2048 (FP16)
- Batch=1: AI \approx 1 FLOP/byte (memory-bound)
- Batch=32: AI = 32 FLOP/byte (memory-bound)
- Batch=256: AI = 205 FLOP/byte (compute-bound on A100)

This explains the 10–100× throughput improvement from batching in production inference systems, as MLPerf\index{MLPerf!inference benchmarking} inference scenarios demonstrate.
:::

The batch size analysis reveals why inference serving systems are designed around batching: it changes the arithmetic intensity regime of memory-bound workloads. However, batching introduces latency trade-offs, since requests must wait in a queue until a batch forms. This tension between throughput (favoring large batches) and latency (favoring small batches) is a central challenge in ML serving systems, explored in depth in @sec-model-serving-systems.

For workloads where batching is impractical, such as interactive LLM generation where users expect streaming responses, the arithmetic intensity remains inherently low. Understanding this ceiling is essential for setting realistic performance expectations.

```{python}
#| label: gpt2-throughput-calc
#| echo: false
# ┌─────────────────────────────────────────────────────────────────────────────
# │ GPT-2 THROUGHPUT CEILING ANALYSIS
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: "The Throughput Ceiling" callout
# │
# │ Why: Shows why GPT-2 (batch=1) achieves only ~1% of A100 peak utilization.
# │      At low arithmetic intensity, the accelerator is starved for data and
# │      the majority of compute capacity sits idle waiting for memory.
# │
# │ Imports: mlsys.constants (GPT2_PARAMS, A100_*, BYTES_FP16)
# │ Exports: gpt2_*_str, a100_tflops_fp32
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.formatting import fmt
from mlsys.formulas import model_memory
from mlsys.constants import (
    GB, GPT2_PARAMS, BYTES_FP16, flop, GFLOPs,
    A100_MEM_BW, A100_FLOPS_FP16_TENSOR, A100_FLOPS_FP32,
    TB, TFLOPs, second
)

# --- Inputs (GPT-2 XL model) ---
# Data movement: load all weights per token (batch size 1)
gpt2_weight_gb = model_memory(GPT2_PARAMS, BYTES_FP16, GB)

# Compute: 2 FLOPs per parameter (vector-matrix multiply)
gpt2_decode_flops = 2 * GPT2_PARAMS.magnitude
gpt2_decode_gflops = (gpt2_decode_flops * flop).to(GFLOPs).magnitude

# --- Process (calculate arithmetic intensity and utilization) ---
# Arithmetic intensity
gpt2_decode_ai = gpt2_decode_gflops / gpt2_weight_gb

# Utilization ceiling on A100
a100_bw_tbs_val = A100_MEM_BW.to(TB/second).magnitude
a100_tflops_fp16_val = A100_FLOPS_FP16_TENSOR.to(TFLOPs/second).magnitude
gpt2_max_tflops = gpt2_decode_ai * a100_bw_tbs_val
gpt2_utilization = gpt2_max_tflops / a100_tflops_fp16_val * 100

# --- Outputs (formatted strings for prose) ---
gpt2_weight_gb_str = fmt(gpt2_weight_gb, precision=1, commas=False)         # e.g. "3.0"
gpt2_decode_gflops_str = fmt(gpt2_decode_gflops, precision=1, commas=False) # e.g. "3.0"
gpt2_decode_ai_str = fmt(gpt2_decode_ai, precision=1, commas=False)         # e.g. "1.0"
gpt2_max_tflops_str = fmt(gpt2_max_tflops, precision=1, commas=False)       # e.g. "2.0"
gpt2_utilization_str = fmt(gpt2_utilization, precision=1, commas=False)     # e.g. "0.6"

# A100 FP32 spec for ridge point comparison
a100_tflops_fp32 = f"{A100_FLOPS_FP32.to(TFLOPs/second).magnitude:.1f}"     # e.g. "19.5"
```

This bandwidth constraint creates *the throughput ceiling*.

::: {.callout-notebook title="The Throughput Ceiling"}

**The Problem:** Predict the maximum possible utilization of an NVIDIA A100 when running GPT-2 inference (batch size 1).

**1. The Hardware Constraints (The Denominators)**

*   **Peak Compute:** `{python} a100_tflops_fp16` TFLOPS (FP16 Tensor Core).
*   **Peak Bandwidth:** `{python} a100_bw_tbs` TB/s (HBM2e).
*   **Ridge Point (Compute/BW):** `{python} a100_tflops_fp16` / `{python} a100_bw_tbs` = **`{python} a100_ridge` FLOP/byte** (for FP16 Tensor Core).
    *   *Meaning:* To saturate this chip at FP16 precision, you must perform `{python} a100_ridge` operations for every byte loaded. The ridge point varies by precision: FP32 operations (`{python} a100_tflops_fp32` TFLOPS peak) have a ridge point of only ~`{python} a100_ridge_fp32` FLOP/byte.

**2. The Workload Characteristics (The Numerator)**

*   **Model:** GPT-2 XL (1.5B parameters).
*   **Operation:** Autoregressive generation (1 token at a time).
*   **Data Movement:** Must load all weights (`{python} gpt2_weight_gb_str` GB @ FP16) for every token.
*   **Compute:** Vector-Matrix multiplication. 2 × Params ≈ `{python} gpt2_decode_gflops_str` GFLOPs.
*   **Arithmetic Intensity:**
    `{python} gpt2_decode_gflops_str` GFLOPs / `{python} gpt2_weight_gb_str` GB = **`{python} gpt2_decode_ai_str` FLOP/byte**

**3. The Prediction (Iron Law)**

Since Actual Intensity (`{python} gpt2_decode_ai_str`) ≪ Ridge Point (`{python} a100_ridge`), the system is **Bandwidth Bound**.

*   **Maximum Throughput:** `{python} gpt2_decode_ai_str` FLOP/byte × `{python} a100_bw_tbs` TB/s = **`{python} gpt2_max_tflops_str` TFLOPS**.
*   **Utilization Ceiling:**
    `{python} gpt2_max_tflops_str` TFLOPS (Actual) / `{python} a100_tflops_fp16` TFLOPS (Peak) ≈ **`{python} gpt2_utilization_str`%**

**The Systems Conclusion:**
Without batching or caching, a \$15,000 GPU runs at **less than 1% efficiency** on LLM inference. This "Utilization Gap" drives the need for Key-Value Caching and Quantization.
:::

As this derivation demonstrates, the Roofline model provides the diagnostic framework for identifying whether operations are compute-bound or memory-bound. Knowing that a workload is memory-bound at `{python} gpt2_utilization_str`% utilization is only the first step; the next challenge is translating this diagnosis into efficient execution plans that exploit accelerator architectures.

## Hardware Mapping {#sec-ai-acceleration-hardware-mapping-fundamentals-neural-networks-f9a9}

\index{Hardware Mapping!computational graph to hardware}
The Roofline analysis taught us to diagnose whether specific operations are compute-bound or memory-bound on given hardware. We saw that ResNet-50's convolutions achieve high arithmetic intensity (50–200 FLOP/byte) and operate in the compute-bound regime, while GPT-2's attention layers achieve only 2–5 FLOP/byte and are severely memory-bound. But diagnosis is only half the challenge. Once we know that LayerNorm achieves just 1–2 FLOP/byte on an A100, the question becomes: *how* do we execute it efficiently despite this limitation? This is the domain of hardware mapping, the art of translating abstract computational graphs into concrete execution plans that exploit accelerator architectures while respecting their constraints.

The memory system challenges examined in @sec-ai-acceleration-understanding-ai-memory-wall-3ea9 established *why* memory access dominates modern AI systems: DRAM access consumes 100–200× more energy than a multiply-accumulate operation [@horowitz2014computing]. The Roofline model established *how to measure* whether a workload is compute-bound or memory-bound. This section addresses the critical follow-up: *how to map* computations to maximize data reuse and minimize the energy-intensive transfers that the Roofline analysis revealed as the primary bottleneck.

Efficient execution of machine learning models on specialized AI acceleration hardware requires a structured approach to computation, ensuring that available resources are fully utilized while minimizing performance bottlenecks. These mapping considerations become particularly critical in distributed training scenarios, as explored in @sec-ai-training. Unlike general-purpose processors, which rely on dynamic task scheduling, AI accelerators operate under a structured execution model that maximizes throughput by carefully assigning computations to processing elements. This process, known as mapping, dictates how computations are distributed across hardware resources, influencing execution speed, memory access patterns, and overall efficiency.

::: {.callout-definition title="Mapping in AI Acceleration"}

***Mapping in AI Acceleration***\index{Energy-Delay Product!mapping optimization target} is the binding of the **Logical Computation Graph** to the **Physical Hardware Topology**. It optimizes the **Spatiotemporal Schedule**, deciding *where* data resides (spatial) and *when* it moves (temporal), to minimize the **Energy-Delay Product** of execution under strict memory bandwidth constraints.

:::

Mapping machine learning models onto AI accelerators presents several challenges due to hardware constraints and the diversity of model architectures. Given the hierarchical memory system of modern accelerators, mapping strategies must carefully manage when and where data is accessed to minimize latency and power overhead while ensuring that compute units remain actively engaged. Poor mapping decisions can lead to underutilized compute resources, excessive data movement, and increased execution time, ultimately reducing overall efficiency.

Mapping encompasses three aspects that form the foundation of effective AI accelerator design.

- **Computation Placement**: Systematically assigns operations (e.g., matrix multiplications, convolutions) to processing elements to maximize parallelism and reduce idle time.
- **Memory Allocation**: Carefully determines where model parameters, activations, and intermediate results reside within the memory hierarchy to optimize access efficiency.
- **Dataflow and Execution Scheduling**: Structures the movement of data between compute units to reduce bandwidth bottlenecks and ensure smooth, continuous execution.

Effective mapping strategies minimize off-chip memory accesses, maximize compute utilization, and efficiently manage data movement across different levels of the memory hierarchy. In practice, *the role of the compiler* is central to achieving these goals.

::: {.callout-perspective title="The Role of the Compiler"}

Developers rarely perform this complex mapping manually. Instead, a specialized **compiler** (like NVIDIA's NVCC or Google's XLA) takes the high-level model from the framework and automatically explores the mapping search space to find an optimal execution plan for the target hardware. The compiler is the critical software layer that translates the model's computational graph into an efficient hardware-specific dataflow, balancing the three interrelated aspects of computation placement, memory allocation, and execution scheduling described above. This compiler support is examined in detail in @sec-ai-acceleration-compiler-support-172e.

:::

Key mapping choices influence execution efficiency and lay the groundwork for optimization strategies that refine these decisions.

### Placement and Allocation {#sec-ai-acceleration-computation-placement-23d2}

\index{Computation Placement!processing element assignment}
Translating a model's computational graph into efficient hardware execution requires solving two tightly coupled problems. *Computation placement* determines which operations run on which processing elements, balancing parallelism against communication costs. *Memory allocation* determines where data resides within the memory hierarchy, trading capacity against access latency. These two decisions interact: placing operations on distant processing elements increases the memory bandwidth required to shuttle data between them, while allocating data to fast but small on-chip memory limits which operations can execute concurrently. Getting either wrong leaves thousands of processing elements idle or starved for data.

#### Computation Placement

Computation placement is the process of strategically assigning operations to an accelerator's processing elements (PEs) to maximize parallelism, minimize idle time, and reduce unnecessary data movement. Modern accelerators contain enormous numbers of PEs: the NVIDIA H100 has over 16,000 streaming processors\index{CUDA Cores!streaming processors} and more than 500 tensor cores [@nvidia2022h100], TPUs use systolic arrays of thousands of multiply-accumulate units [@jouppi2017datacenter], and wafer-scale processors like Cerebras' CS-2 integrate over 850,000 cores [@Cerebras2021]. At these scales, even small placement inefficiencies compound into measurable performance losses because idle cores and redundant memory transfers waste both time and energy.

\index{Graph Neural Network!irregular computation}
The difficulty of placement depends on workload regularity. CNNs exhibit structured, spatially local computation: a $256\times256$ image can be tiled across thousands of GPU cores with each tile processed independently, yielding balanced utilization. Transformers are harder because self-attention requires every token to interact with every other, creating non-uniform demands where attention score computation is far heavier than other operations. Graph Neural Networks (GNNs) are harder still, as sparse, dynamically changing graph structures make static partitioning ineffective [@Zheng2020]. @tbl-placement-challenges summarizes the core challenges that placement strategies must address across these workload types.

| **Challenge**                      | **Impact on Execution**                                                                                            | **Key Considerations for Placement**                                                        |
|:---------------------------------|:-----------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------|
| **Workload Imbalance**             | Some processing elements finish early while others remain overloaded, leading to idle compute resources.           | Distribute operations evenly to prevent stalls and ensure full utilization of PEs.          |
| **Irregular Computation Patterns** | Models like transformers and GNNs introduce non-uniform computation demands, making static placement difficult.    | Use adaptive placement strategies that adjust execution based on workload characteristics.  |
| **Excessive Data Movement**        | Frequent memory transfers introduce latency and increase power consumption.                                        | Keep frequently used data close to the compute units and minimize off-chip memory accesses. |
| **Limited Interconnect Bandwidth** | Poorly placed operations can create congestion, slowing data movement between PEs.                                 | Optimize spatial and temporal placement to reduce communication overhead.                   |
| **Model-Specific Execution Needs** | CNNs, transformers, and GNNs require different execution patterns, making a single placement strategy ineffective. | Tailor placement strategies to match the computational structure of each model type.        |

: **Computation Placement Challenges.** Effective neural network deployment requires strategic allocation of computations to processing elements, balancing workload distribution, data movement costs, and hardware constraints to maximize execution efficiency. These challenges guide the design of mapping strategies that optimize resource utilization and minimize communication overhead. {#tbl-placement-challenges}

Because a well-placed workload can reduce latency by 10 to 100 times while a poorly placed one leaves thousands of PEs idle, modern accelerators increasingly rely on runtime-aware scheduling that adapts placement to real-time workload behavior rather than static execution plans. Placement decisions also interact directly with the next concern: where the data those PEs need actually resides in the memory hierarchy.

#### Memory Allocation

While computation placement determines where operations execute, memory allocation defines where data resides and how it flows through the memory hierarchy during execution. The primary goal is to keep frequently accessed data as close as possible to the processing elements, minimizing latency and power consumption. GPUs achieve this through a mix of global memory, shared memory, and registers with careful tiling strategies [@nvidia2020ampere]. TPUs use on-chip SRAM scratchpads where activations and weights must be preloaded to sustain systolic array execution (@fig-systolic-array), with weights streamed in perfect synchronization with input activations to maintain pipelined computation flow [@jouppi2017datacenter]. Wafer-scale processors demand careful memory partitioning to avoid excessive interconnect traffic [@Cerebras2021]. Unlike general-purpose computing, where caches abstract memory management, AI accelerators require explicit data placement strategies because poor allocation leads to three compounding penalties: increased memory latency when data must be fetched from higher-latency tiers, higher power consumption from off-chip accesses that cost orders of magnitude more energy than on-chip storage, and reduced computational throughput when processing elements stall waiting for data.

The severity of these penalties varies by workload. CNNs rely on structured, localized access patterns and benefit from well-defined memory layouts that facilitate predictable reuse [@chen2016eyeriss]. Transformer models require frequent access to large parameter sets and intermediate activations, making them highly sensitive to memory bandwidth constraints. GNNs introduce the greatest challenge, as their irregular and sparse data structures produce unpredictable access patterns that resist static allocation strategies. @tbl-memory-allocation summarizes these allocation challenges. As model sizes continue to grow, accelerators must dynamically manage memory resources rather than relying on static allocation schemes, and memory capacity increasingly dictates how large a model can be deployed on a given accelerator.

| **Challenge**                        | **Impact on Execution**                                                                | **Key Considerations for Allocation**                                                             |
|:-----------------------------------|:-------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------|
| **High Memory Latency**              | Slow data access delays execution and reduces throughput.                              | Prioritize placing frequently accessed data in faster memory locations.                           |
| **Limited On-Chip Storage**          | Small local memory constrains the amount of data available near compute units.         | Allocate storage efficiently to maximize data availability without exceeding hardware limits.     |
| **High Off-Chip Bandwidth Demand**   | Frequent access to external memory increases delays and power consumption.             | Reduce unnecessary memory transfers by carefully managing when and how data is moved.             |
| **Irregular Memory Access Patterns** | Some models require accessing data unpredictably, leading to inefficient memory usage. | Organize memory layout to align with access patterns and minimize unnecessary data movement.      |
| **Model-Specific Memory Needs**      | Different models require different allocation strategies to optimize performance.      | Tailor allocation decisions based on the structure and execution characteristics of the workload. |

: **Memory Allocation Challenges.** Efficient memory management in AI accelerators balances data access speed with hardware constraints, mitigating performance bottlenecks caused by latency, bandwidth limitations, and irregular data patterns. Complex models such as transformers and graph networks impose variable and demanding memory requirements that amplify these challenges. {#tbl-memory-allocation}

### Combinatorial Complexity {#sec-ai-acceleration-combinatorial-complexity-ea33}

\index{Mapping!combinatorial search space}
The efficient execution of machine learning models on AI accelerators requires careful consideration of placement and allocation. Placement involves spatial assignment of computations and data, while allocation covers temporal distribution of resources. These decisions are interdependent, and each introduces trade-offs that impact performance, energy efficiency, and scalability. @tbl-combinatorial-complexity enumerates the key trade-offs between computation placement and resource allocation that shape overall performance. Placement decisions influence parallelism, memory access patterns, and communication overhead, while allocation strategies determine how resources are distributed over time to balance execution efficiency. The interplay between these factors requires a careful balance to avoid bottlenecks such as excessive synchronization, memory congestion, or underutilized compute resources. Optimizing these trade-offs is necessary for ensuring that AI accelerators operate at peak efficiency.

| **Dimension**                         | **Placement Considerations**                                                                             | **Allocation Considerations**                                                                        |
|:------------------------------------|:-------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------|
| **Computational Granularity**         | Fine-grained placement enables greater parallelism but increases synchronization overhead.               | Coarse-grained allocation reduces synchronization overhead but may limit flexibility.                |
| **Spatial vs. Temporal Mapping**      | Spatial placement enhances parallel execution but can lead to resource contention and memory congestion. | Temporal allocation balances resource sharing but may reduce overall throughput.                     |
| **Memory and Data Locality**          | Placing data closer to compute units minimizes latency but may reduce overall memory availability.       | Allocating data across multiple memory levels increases capacity but introduces higher access costs. |
| **Communication and Synchronization** | Co-locating compute units reduces communication latency but may introduce contention.                    | Allocating synchronization mechanisms mitigates stalls but can introduce additional overhead.        |
| **Dataflow and Execution Ordering**   | Static placement simplifies execution but limits adaptability to workload variations.                    | Dynamic allocation improves adaptability but adds scheduling complexity.                             |

: **Placement-Allocation Trade-Offs.** AI accelerator performance depends on strategically mapping computations to hardware and allocating resources over time, balancing parallelism, memory access, and execution efficiency. Careful consideration of these interdependent factors is essential for maximizing throughput and minimizing energy consumption. {#tbl-combinatorial-complexity}

Each of these dimensions requires balancing trade-offs between placement and allocation. Spatially distributing computations across multiple processing elements can increase throughput, but if data allocation is not optimized, memory bandwidth limitations introduce bottlenecks. Likewise, allocating resources for fine-grained computations enhances flexibility but, without appropriate placement strategies, leads to excessive synchronization overhead.

These interacting factors define a vast combinatorial design space where small variations in mapping decisions lead to large differences in performance and energy efficiency. Unlike traditional workloads with predictable execution patterns, machine learning models introduce diverse computational structures that require flexible mappings adapted to data reuse, parallelization opportunities, and memory constraints. The search space grows combinatorially, making exhaustive search infeasible. Three sources of variation contribute to this complexity:

##### Ordering Computation and Execution

\index{Loop Ordering!computational efficiency}
Machine learning workloads are often structured as nested loops that iterate over various dimensions of computation. For instance, a matrix multiplication kernel may loop over batch size ($N$), input features ($C$), and output features ($K$). The order in which these loops execute has a profound effect on data locality, reuse patterns, and computational efficiency.

The number of ways to arrange $d$ loops follows a factorial growth pattern:
$$
\mathcal{O} = d!
$$
which scales rapidly. A typical convolutional layer may involve up to seven loop dimensions, leading to:
$$
7! = 5,040 \text{ possible execution orders.}
$$

When considering multiple memory levels, the search space expands as:
$$
(d!)^l
$$
where $l$ is the number of memory hierarchy levels. This rapid expansion shows why execution order optimization matters: poor loop ordering can lead to excessive memory traffic, while an optimized order improves cache utilization [@sze2020efficient].

##### Parallelization Across Processing Elements

Modern AI accelerators use thousands of processing elements to maximize parallelism, but determining which computations should be parallelized is non-trivial. Excessive parallelization can introduce synchronization overheads and increased bandwidth demands, while insufficient parallelization leads to underutilized hardware.

The number of ways to distribute computations among parallel units follows the binomial coefficient:
$$
\mathcal{P} = \frac{d!}{(d-k)!}
$$
where $d$ is the number of loops, and $k$ is the number selected for parallel execution. For a six-loop computation where three loops are chosen for parallel execution, the number of valid configurations is:
$$
\frac{6!}{(6-3)!} = 120.
$$

Even for a single layer, there can be hundreds of valid parallelization strategies, each affecting data synchronization, memory contention, and overall compute efficiency. Expanding this across multiple layers and model architectures further magnifies the complexity.

##### Memory Placement and Data Movement

The hierarchical memory structure of AI accelerators introduces additional constraints, as data must be efficiently placed across registers, caches, shared memory, and off-chip DRAM. Data placement impacts latency, bandwidth consumption, and energy efficiency. Frequent access to slow memory creates bottlenecks, while optimized placement reduces costly memory transfers.

The number of ways to allocate data across memory levels follows an exponential growth function:
$$
\mathcal{M} = n^{d \times l}
$$
where:

- $n$ = number of placement choices per level,
- $d$ = number of computational dimensions,
- $l$ = number of memory hierarchy levels.

For a model with:

- $d = 5$ computational dimensions,
- $l = 3$ memory levels,
- $n = 4$ possible placement choices per level,

\noindent the number of possible memory allocations is:
$$
4^{5 \times 3} = 4^{15} = 1,073,741,824.
$$

This highlights how even a single layer may have over a billion possible memory configurations, making manual optimization impractical.

##### Mapping Search Space

By combining the complexity from computation ordering, parallelization, and memory placement, the total mapping search space can be approximated as:
$$
\mathcal{S} = \left( n^d \times d! \times \frac{d!}{(d-k)!} \right)^l
$$
where:

- $n^d$ represents memory placement choices,
- $d!$ accounts for computation ordering choices,
- $\frac{d!}{(d-k)!}$ captures parallelization possibilities,
- $l$ is the number of memory hierarchy levels.

This equation illustrates the exponential growth of the search space, making brute-force search infeasible for all but the simplest cases.

The combinatorial explosion revealed by this analysis — potentially billions of valid configurations for a single neural network layer — poses a practical question: how do practitioners routinely achieve near-optimal performance despite this vast search space? Exhaustive enumeration is clearly impossible, yet production systems consistently achieve 60–80% of theoretical peak performance. The answer lies in a small set of principled dataflow patterns that reduce this intractable configuration space to a manageable set of strategic choices.

## Dataflow Optimization {#sec-ai-acceleration-dataflow-optimization-strategies-ce52}

\index{Dataflow Optimization!data movement minimization}
The mapping strategies from the preceding section establish *where* computations execute and *where* data resides, but they do not specify *how* data flows through processing elements during execution. A systolic array might process a matrix multiplication with weights in local memory, but the order in which weights, inputs, and outputs move through the array directly determines memory bandwidth consumption and energy efficiency. The choice among strategies directly impacts whether an accelerator operates in the compute-bound or memory-bound region identified by the Roofline analysis — which is why compilers (@sec-ai-acceleration-compiler-support-172e) and runtime systems (@sec-ai-acceleration-runtime-support-f94f) must select appropriate dataflow patterns based on workload characteristics.

Three questions structure all dataflow decisions:

1. **Which data stays local?** Weight-stationary, output-stationary, and input-stationary strategies each make different choices about what to cache near compute units, trading off different memory access patterns.
2. **How is data organized?** Tensor layouts (NHWC vs. NCHW) determine whether memory accesses align with hardware preferences, with performance impacts of 2-5x.
3. **How are operations combined?** Kernel fusion and tiling restructure computation to minimize memory traffic, often achieving 2–10× speedups through reduced data movement alone.

By mastering these patterns, we can reason about 90% of dataflow optimization decisions without exhaustive search. We examine each question in turn, then see how they combine for specific neural network architectures including ResNet-50, GPT-2, and MLPs.

### Building Blocks of Mapping Strategies {#sec-ai-acceleration-building-blocks-mapping-strategies-4932}

The three questions above map to four foundational techniques\index{Data Movement!optimization strategies}: *data movement patterns*\index{Tensor Layout!memory-aware} (weight-stationary, output-stationary, input-stationary), *memory-efficient tensor layouts*\index{Row-Major Layout!NHWC}\index{Channel-Major Layout!NCHW} (row-major vs. channel-major), *kernel fusion*\index{Kernel Fusion!reducing memory writes} (combining operations to eliminate intermediate writes), and *tiling*\index{Tiling!memory optimization} (partitioning computations into memory-friendly blocks). We examine each in turn.

Each of these building blocks forms the basis for both heuristic and model-driven optimization techniques.

#### Data Movement Patterns {#sec-ai-acceleration-data-movement-patterns-3b06}

\index{Data Movement!energy dominance}
While computational mapping determines where and when operations occur, its success depends heavily on how efficiently data is accessed and transferred across the memory hierarchy. As discussed in @sec-ai-acceleration-irregular-memory-access-c6ec, machine learning workloads exhibit irregular access patterns that challenge standard caching mechanisms. This irregularity makes data movement strategy critical to overall system performance.

Even when computational units are mapped efficiently, poor data movement strategies can severely degrade performance, leading to frequent memory stalls and underutilized hardware resources. If data cannot be supplied to processing elements at the required rate, computational units remain idle, increasing latency, memory traffic, and energy consumption [@chen2016eyeriss].

@lst-matmul_data_movement illustrates how data movement inefficiencies affect the backbone computation of many machine learning models through a typical matrix multiplication operation.

::: {#lst-matmul_data_movement lst-cap="**Matrix Multiplication**: Data movement bottlenecks can lead to underutilized hardware resources, illustrating the importance of efficient data flow in optimizing machine learning model performance."}
```{.python}
## Matrix multiplication where:
## weights: [512 x 256] - model parameters
## input:   [256 x 32]  - batch of activations
## Z:       [512 x 32]  - output activations

## Computing each output element Z[i,j]:
for i in range(512):
    for j in range(32):
        for k in range(256):
            Z[i, j] += weights[i, k] * input[k, j]
```
:::

This computation reveals several critical dataflow challenges. The first challenge is the number of memory accesses required. For each output $Z[i, j]$, the computation must fetch an entire row of weights from the weight matrix and a full column of activations from the input matrix. Since the weight matrix contains 512 rows and the input matrix contains 32 columns, this results in repeated memory accesses that place a heavy burden on memory bandwidth.

The second challenge comes from weight reuse. The same weights are applied to multiple inputs, meaning that an ideal mapping strategy should maximize weight locality to avoid redundant memory fetches. Without proper reuse, the accelerator would waste bandwidth loading the same weights multiple times [@chen2018tvm].

The third challenge involves the accumulation of intermediate results. Since each element in $Z[i,j]$ requires contributions from 256 different weight-input pairs, partial sums must be stored and retrieved before the final value is computed. If these intermediate values are stored inefficiently, the system will require frequent memory accesses, further increasing bandwidth demands.

One way to mitigate these challenges is to use SIMD and SIMT execution models, which allow multiple values to be fetched in parallel. However, even with these optimizations, data movement remains a bottleneck. The issue is not just how quickly data is retrieved but how often it must be moved and where it is placed within the memory hierarchy [@han2016eie].

Given that data movement is 100–1,000× more expensive than computation, the single most important goal of an accelerator is to minimize memory access. Dataflow strategies\index{Dataflow!optimization strategies} achieve this by maximizing data reuse\index{Data Reuse!accelerator optimization}. The question is: which data is most valuable to keep local? To address this, accelerators implement dataflow strategies that determine which data remains fixed in memory and which data is streamed dynamically. These strategies represent different answers to the central question of data locality: weight-stationary keeps model parameters local, input-stationary maintains activation data, and output-stationary preserves intermediate results. Each approach trades off different memory access patterns to maximize data reuse and minimize the energy-intensive transfers that constitute the primary bottleneck in AI acceleration.

##### Weight Stationary {#sec-ai-acceleration-weight-stationary-156a}

\index{Weight Stationary!CNN optimization}
The Weight Stationary strategy keeps weights fixed in local memory, while input activations and partial sums are streamed through the system. Weight stationary approaches prove particularly beneficial in CNNs and matrix multiplications, where the same set of weights is applied across multiple inputs. By ensuring weights remain stationary, this method reduces redundant memory fetches, which helps alleviate bandwidth bottlenecks and improves energy efficiency.

A key advantage of weight stationary is that it maximizes weight reuse, reducing the frequency of memory accesses to external storage. Since weight parameters are often shared across multiple computations, keeping them in local memory eliminates unnecessary data movement, lowering the overall energy cost of computation. This makes it particularly effective for architectures where weights represent the dominant memory overhead, such as systolic arrays and custom accelerators designed for machine learning.

@lst-weight_stationary demonstrates how Weight Stationary execution keeps weights fixed in local memory while streaming inputs and accumulating partial sums.

::: {#lst-weight_stationary lst-cap="**Weight Stationary Matrix Multiplication**: Weight stationary matrix multiplication keeps weights fixed in local memory while input activations stream through, demonstrating how it maximizes weight reuse to reduce energy costs."}
```{.python}
## Weight Stationary Matrix Multiplication
## - Weights remain fixed in local memory
## - Input activations stream through
## - Partial sums accumulate for final output

for weight_block in weights:  # Load and keep weights stationary
    load_to_local(weight_block)  # Fixed in local storage
    for input_block in inputs:  # Stream inputs dynamically
        for output_block in outputs:  # Compute results
            output_block += compute(weight_block, input_block)
            # Reuse weights across inputs
```
:::

In weight stationary execution, weights are loaded once into local memory and remain fixed throughout the computation while inputs stream dynamically, reducing redundant memory accesses. Partial sums accumulate efficiently, minimizing unnecessary data movement. Because weights need not be reloaded for each new computation, bandwidth requirements drop significantly, making this dataflow highly effective for workloads with heavy weight reuse patterns such as CNNs and matrix multiplications.

However, while this strategy reduces weight-related memory traffic, it introduces trade-offs in input and output movement. Since inputs must be streamed dynamically while weights remain fixed, the efficiency of this approach depends on how well input activations can be delivered to the computational units without causing stalls. Partial sums, which represent intermediate results, must also be carefully accumulated to avoid excessive memory traffic. The total performance gain depends on the size of available on-chip memory, as storing larger weight matrices locally can become a constraint in models with millions or billions of parameters.

The weight stationary strategy is well-suited for workloads where weights exhibit high reuse and memory bandwidth is a limiting factor. It is commonly employed in CNNs, systolic arrays, and matrix multiplication kernels, where structured weight reuse leads to measurable performance improvements. However, for models where input or output reuse is more critical, alternative dataflow strategies, such as output stationary or input stationary, may provide better trade-offs.

##### Output Stationary {#sec-ai-acceleration-output-stationary-54e5}

\index{Output Stationary!partial sum accumulation}
Weight stationary keeps weights local and streams inputs through the system. But what if the dominant cost is not weight loading but the frequent writes of partial sums? In fully connected layers and transformer attention mechanisms, each output element accumulates contributions from hundreds or thousands of weight-input pairs. Writing those intermediate partial sums to external memory after every accumulation step would create a write-bandwidth bottleneck far more severe than the read overhead that weight stationary addresses. The Output Stationary strategy inverts the priority: it keeps partial sums fixed in local memory while streaming both weights and input activations through the system, so that each output element is written to external memory only once, after all its contributions have been accumulated [@chen2016eyeriss].

@lst-output_stationary demonstrates how accumulating partial sums locally minimizes memory writes and enhances efficiency during matrix multiplication.

::: {#lst-output_stationary lst-cap="**Output Stationary Execution**: Accumulates partial sums locally to reduce memory writes and enhance efficiency during matrix multiplication, making it ideal for transformer-based models."}
```{.python}
## - Partial sums remain in local memory
## - Weights and input activations stream through dynamically
## - Final outputs are written only once

for output_block in outputs:  # Keep partial sums stationary
    accumulator = 0  # Initialize accumulation buffer
    for weight_block, input_block in zip(weights, inputs):
        accumulator += compute(weight_block, input_block)
        # Accumulate partial sums
    store_output(accumulator)  # Single write to memory
```
:::

In this implementation, the accumulator buffer stays in local registers or scratchpad throughout the inner loop; weights and inputs stream in, contribute to the running sum, and are discarded. The final result is written out only once per output element, eliminating the repeated write traffic that would otherwise dominate bandwidth.

This approach aligns naturally with systolic arrays, where computation progresses through a grid of processing elements and partial sums can flow along one axis without leaving the chip. The trade-off is that both weights and activations must now be streamed dynamically, so the system must sustain high read bandwidth for two data streams simultaneously. Parallel implementations also require careful synchronization when multiple PEs contribute to the same output element. Output stationary is therefore most effective for workloads where accumulation dominates, such as fully connected layers and attention mechanisms, but less suitable when input reuse is the critical bottleneck.

##### Input Stationary {#sec-ai-acceleration-input-stationary-6c7b}

\index{Input-Stationary!dataflow strategy}The two strategies examined so far each fix a different operand in local memory: weight stationary fixes weights to reduce read bandwidth for parameters, and output stationary fixes partial sums to reduce write bandwidth for accumulations. The third strategy completes the picture by fixing the remaining operand: input activations. In transformer models, a single input token participates in computations across multiple attention heads and layers; in batch processing, the same activation batch feeds into many different weight matrices. When activation reuse is the dominant memory cost, keeping inputs stationary and streaming weights through the system yields the best energy and bandwidth trade-off.

@lst-input_stationary illustrates this approach, maximizing reuse by keeping input activations stationary in local memory while dynamically streaming weights.

::: {#lst-input_stationary lst-cap="**Input Stationary**: This approach keeps input activations stationary while dynamically streaming weights to maximize memory reuse and reduce energy consumption."}
```{.python}
## - Input activations remain in local memory
## - Weights stream through dynamically
## - Partial sums accumulate and are written out

for input_block in inputs:  # Keep input activations stationary
    load_to_local(input_block)  # Fixed in local storage
    for weight_block in weights:  # Stream weights dynamically
        for output_block in outputs:  # Compute results
            output_block += compute(weight_block, input_block)
            # Reuse inputs across weights
```
:::

Here, input activations are loaded once and held fixed while weights stream through. Partial sums accumulate and are eventually written out, but unlike output stationary, the accumulation buffer is not the primary beneficiary of locality; instead, the input data is.

The trade-off mirrors the other two strategies: weights must now be streamed dynamically, so the system needs sustained read bandwidth for the weight stream, and partial sums require buffering before write-back. Input stationary is most effective in transformers (where each token is reused across attention heads), recurrent networks (where the hidden state participates in repeated computations), and large-batch inference (where the same activation batch feeds many weight matrices).

Taken together, the three dataflow strategies illustrate a central design choice rather than a hierarchy of quality. Weight stationary minimizes read traffic for parameters and suits CNNs with small, heavily reused filters. Output stationary minimizes write traffic for accumulations and suits fully connected layers with high fan-in. Input stationary minimizes read traffic for activations and suits transformers and batch processing with high activation reuse. No single strategy dominates; the optimal choice depends on which data element has the highest reuse ratio relative to its size, a determination that the compiler and hardware designer must make based on the specific workload and memory hierarchy.

#### Memory-Efficient Tensor Layouts {#sec-ai-acceleration-memoryefficient-tensor-layouts-e250}

\index{Tensor Layout!hardware alignment}
The dataflow strategies above determine *which* data stays close to compute; tensor layouts determine *whether* that data can be accessed efficiently once it arrives. A perfectly chosen weight-stationary dataflow still suffers if weights are stored in a format that causes scattered memory accesses. Efficient execution of machine learning workloads depends not only on how data moves (dataflow strategies) but also on how data is stored and accessed in memory. Tensor layouts, the arrangement of multidimensional data in memory, can directly impact memory access efficiency, cache performance, and computational throughput. Poorly chosen layouts can lead to excessive memory stalls, inefficient cache usage, and increased data movement costs.

In AI accelerators, tensor layout optimization is particularly important because data is frequently accessed in patterns dictated by the underlying hardware architecture. Choosing the right layout ensures that memory accesses align with hardware-friendly access patterns, minimizing overhead from costly memory transactions [@nvidia2021cudnn].

While developers can sometimes manually specify tensor layouts, the choice is often determined automatically by machine learning frameworks (e.g., TensorFlow, PyTorch, JAX), compilers, or AI accelerator runtimes. Low-level optimization tools such as cuDNN (for NVIDIA GPUs), XLA (for TPUs), and MLIR (for custom accelerators) may rearrange tensor layouts dynamically to optimize performance [@xla2020]. In high-level frameworks, layout transformations are typically applied transparently, but developers working with custom kernels or low-level libraries (e.g., CUDA, Metal, or OpenCL) may have direct control over tensor format selection.

For example, in PyTorch, users can manually modify layouts using tensor.permute() or tensor.contiguous() to ensure efficient memory access [@paszke2019pytorch]. In TensorFlow, layout optimizations are often applied internally by the XLA compiler, choosing between NHWC (row-major) and NCHW (channel-major) based on the target hardware [@tensorflow2022]. Hardware-aware machine learning libraries, such as cuDNN for GPUs or OneDNN for CPUs, enforce specific memory layouts to maximize cache locality and SIMD efficiency. Ultimately, while developers may have some control over tensor layout selection, most layout decisions are driven by the compiler and runtime system, ensuring that tensors are stored in memory in a way that best suits the underlying hardware.

##### Row-Major Layout {#sec-ai-acceleration-rowmajor-layout-741f}

Row-major layout is the memory storage convention where multi-dimensional tensor elements are arranged row by row, ensuring that all values in a given row are placed contiguously before moving to the next row. This storage format is widely used in general-purpose CPUs and some machine learning frameworks because it aligns naturally with sequential memory access patterns, making it more cache-efficient for certain types of operations [@oneDNN2021].

To understand how row-major layout works, consider a single RGB image represented as a tensor of shape (Height, Width, Channels). If the image has a size of $3\times 3$ pixels with 3 channels (RGB), the corresponding tensor is structured as (3, 3, 3). The values are stored in memory as follows:
\begin{gather*}
I(0,0,0), I(0,0,1), I(0,0,2), I(0,1,0), I(0,1,1), \\
I(0,1,2), I(0,2,0), I(0,2,1), I(0,2,2), \ldots
\end{gather*}

Each row is stored contiguously, meaning all pixel values in the first row are placed sequentially in memory before moving on to the second row. This ordering is advantageous because CPUs and cache hierarchies are optimized for sequential memory access. When data is accessed in a row-wise fashion, such as when applying element-wise operations like activation functions or basic arithmetic transformations, memory fetches are efficient, and cache utilization is maximized [@sodani2017knl].

The efficiency of row-major storage becomes particularly evident in CPU-based machine learning workloads, where operations such as batch normalization, matrix multiplications, and element-wise arithmetic frequently process rows of data sequentially. Since modern CPUs employ cache prefetching mechanisms, a row-major layout allows the next required data values to be preloaded into cache ahead of execution, reducing memory latency and improving overall computational throughput.

However, row-major layout can introduce inefficiencies when performing operations that require accessing data across channels rather than across rows. Consider a convolutional layer that applies a filter across multiple channels of an input image. Since channel values are interleaved in row-major storage, the convolution operation must jump across memory locations to fetch all the necessary channel values for a given pixel. These strided memory accesses can be costly on hardware architectures that rely on vectorized execution and coalesced memory access, such as GPUs and TPUs.

Despite these limitations, row-major layout remains a dominant storage format in CPU-based machine learning frameworks. TensorFlow, for instance, defaults to the NHWC\index{NHWC!CPU-optimized layout} (row-major) format on CPUs, ensuring that cache locality is optimized for sequential processing. However, when targeting GPUs, frameworks often rearrange data dynamically to take advantage of more efficient memory layouts, such as channel-major storage, which aligns better with parallelized computation.

##### Channel-Major Layout {#sec-ai-acceleration-channelmajor-layout-d6a9}

In contrast to row-major layout, channel-major layout arranges data in memory such that all values for a given channel are stored together before moving to the next channel. The key insight is that GPUs process data in parallel *across threads*, and when threads access consecutive memory addresses, the hardware can combine these requests into a single efficient transaction (memory coalescing). Channel-major layout aligns with this access pattern for convolution operations, where threads typically process different spatial locations of the same channel simultaneously.

To understand how channel-major layout works, consider the same RGB image tensor of size (Height, Width, Channels) = (3, 3, 3). Instead of storing pixel values row by row, the data is structured channel-first in memory as follows:
\begin{gather*}
I(0,0,0), I(1,0,0), I(2,0,0), I(0,1,0), I(1,1,0), I(2,1,0), \ldots, \\
I(0,0,1), I(1,0,1), I(2,0,1), \ldots, I(0,0,2), I(1,0,2), I(2,0,2), \ldots
\end{gather*}

In this format, all red channel values for the entire image are stored first, followed by all green values, and then all blue values. This ordering allows hardware accelerators to efficiently load and process data across channels in parallel, which is important for convolution operations and SIMD (Single Instruction, Multiple Data) execution models [@chetlur2014cudnn].

The advantage of channel-major layout becomes clear when performing convolutions in machine learning models. Convolutional layers process images by applying a shared set of filters across all channels. When the data is stored in a channel-major format, a convolution kernel can load an entire channel efficiently, reducing the number of scattered memory fetches. This reduces memory latency, improves throughput, and enhances data locality for matrix multiplications, which are central to machine learning workloads.

\index{NCHW!GPU-optimized layout}
Because GPUs and TPUs rely on memory coalescing\index{Memory Coalescing!GPU optimization}[^fn-memory-coalescing], a technique in which consecutive threads fetch contiguous memory addresses, channel-major layout aligns naturally with the way these processors execute parallel computations. For example, in NVIDIA GPUs, each thread in a warp (a group of threads executed simultaneously) processes different elements of the same channel, ensuring that memory accesses are efficient and reducing the likelihood of strided memory accesses, which can degrade performance.

[^fn-memory-coalescing]: **Memory Coalescing**: From Latin "coalescere" (to grow together), describing how separate things merge into one. In GPU architecture, coalescing combines multiple memory requests from threads in a warp into a single efficient transaction when threads access consecutive addresses. Uncoalesced access (scattered addresses) reduces bandwidth by 10–20×, making tensor layouts and data organization critical for GPU performance.

Despite its advantages in machine learning accelerators, channel-major layout can introduce inefficiencies when running on general-purpose CPUs. Since CPUs optimize for sequential memory access, storing all values for a single channel before moving to the next disrupts cache locality for row-wise operations. This is why many machine learning frameworks (e.g., TensorFlow, PyTorch) default to row-major (NHWC) on CPUs and channel-major (NCHW) on GPUs, optimizing for the strengths of each hardware type.

Modern AI frameworks and compilers often transform tensor layouts dynamically depending on the execution environment. For instance, TensorFlow and PyTorch automatically switch between NHWC[^fn-nhwc-nchw] and NCHW based on whether a model is running on a CPU, GPU, or TPU, ensuring that the memory layout aligns with the most efficient execution path.

[^fn-nhwc-nchw]: **NHWC vs NCHW**: Tensor layout formats where letters indicate dimension order: N(batch), H(height), W(width), C(channels). NHWC stores data row-by-row with channels interleaved (CPU-friendly), while NCHW groups all values for each channel together (GPU-friendly). A 224×224 RGB image in NHWC stores as [R1,G1,B1,R2,G2,B2,...] while NCHW stores as [R1,R2,...,G1,G2,...,B1,B2,...]. This seemingly minor difference can impact performance by 2–5$\times$ depending on hardware.

##### Comparing Row-Major and Channel-Major Layouts {#sec-ai-acceleration-comparing-rowmajor-channelmajor-layouts-e410}

Both row-major (NHWC) and channel-major (NCHW) layouts serve distinct purposes in machine learning workloads, with their efficiency largely determined by the hardware architecture, memory access patterns, and computational requirements. The choice of layout directly influences cache utilization, memory bandwidth efficiency, and processing throughput. @tbl-major contrasts the performance trade-offs and hardware compatibility between these two approaches.

| **Feature**                 | **Row-Major (NHWC)**                                   | **Channel-Major (NCHW)**                                 |
|:--------------------------|:-----------------------------------------------------|:-------------------------------------------------------|
| **Memory Storage Order**    | Pixels are stored row-by-row, channel interleaved      | All values for a given channel are stored together first |
| **Best for**                | CPUs, element-wise operations                          | GPUs, TPUs, convolution operations                       |
| **Cache Efficiency**        | High cache locality for sequential row access          | Optimized for memory coalescing across channels          |
| **Convolution Performance** | Requires strided memory accesses (inefficient on GPUs) | Efficient for GPU convolution kernels                    |
| **Memory Fetching**         | Good for operations that process rows sequentially     | Optimized for SIMD execution across channels             |
| **Default in Frameworks**   | Default on CPUs (e.g., TensorFlow NHWC)                | Default on GPUs (e.g., cuDNN prefers NCHW)               |

: **Data Layout Strategies.** Row-major (NHWC) and channel-major (NCHW) layouts optimize memory access patterns for different hardware architectures; NHWC suits CPUs and element-wise operations, while NCHW accelerates GPU and TPU-based convolution operations. Choosing the appropriate layout directly impacts performance by maximizing cache utilization and memory bandwidth efficiency. {#tbl-major}

The decision to use row-major (NHWC) or channel-major (NCHW) layouts is not always made manually by developers. Instead, machine learning frameworks and AI compilers often determine the optimal layout dynamically based on the target hardware and operation type. CPUs tend to favor NHWC due to cache-friendly sequential memory access, while GPUs perform better with NCHW, which reduces memory fetch overhead for machine learning computations.

In practice, modern AI compilers such as TensorFlow's XLA and PyTorch's TorchScript perform automatic layout transformations, converting tensors between NHWC and NCHW as needed to optimize performance across different processing units. This ensures that machine learning models achieve the highest possible throughput without requiring developers to manually specify tensor layouts.

#### Kernel Fusion {#sec-ai-acceleration-kernel-fusion-7faf}

\index{Kernel Fusion!definition}
One of the most impactful optimization techniques in AI acceleration involves reducing the overhead of intermediate data movement between operations. Kernel fusion[^fn-kernel-etymology] transforms multiple separate computations into unified operations, dramatically improving memory efficiency and execution performance. This subsection first analyzes the memory bottlenecks created by intermediate writes, then explores how fusion techniques eliminate these inefficiencies.

[^fn-kernel-etymology]: **Kernel**: From Old English "cyrnel" (seed, grain), the innermost essential part. In operating systems, the kernel is the core that manages hardware resources. GPU computing borrowed this term for the core unit of parallel execution launched on the device. In ML, a "kernel" is a compiled function that executes on an accelerator, with "kernel fusion" combining multiple such functions into one to eliminate intermediate memory traffic.

##### Intermediate Memory Write {#sec-ai-acceleration-intermediate-memory-write-f140}

AI model performance is often constrained by memory bandwidth and intermediate memory writes rather than pure arithmetic operations. Every time an operation produces an intermediate result that must be written to memory and later read back, execution stalls from the data movement overhead.

Building on software optimization techniques from @sec-model-compression and memory bandwidth constraints established in @sec-ai-acceleration-understanding-ai-memory-wall-3ea9, kernel fusion represents the critical bridge between software optimization and hardware acceleration. Many AI workloads introduce unnecessary intermediate memory writes, leading to increased memory bandwidth consumption and reduced execution efficiency [@nvidia2017gpu].

```{python}
#| label: memory-footprint-calc
#| echo: false
# ┌─────────────────────────────────────────────────────────────────────────────
# │ INTERMEDIATE MEMORY FOOTPRINT CALCULATION
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: @tbl-memory-footprint showing naive execution memory overhead
# │
# │ Why: Demonstrates the memory cost of storing intermediate tensors in naive
# │      execution. Each step (ReLU, BatchNorm, scale) writes to memory,
# │      quadrupling the memory footprint compared to just the final result.
# │
# │ Imports: mlsys.constants (BYTES_FP32, byte, MB), mlsys.formatting (fmt)
# │ Exports: tensor_mb_str, total_mb_str, footprint_ratio_str
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.formatting import fmt
from mlsys.constants import BYTES_FP32, byte, MB

# --- Inputs (tensor dimensions and precision) ---
tensor_dim = 1024                        # 1024x1024 tensor for worked example
bytes_fp32 = BYTES_FP32.magnitude        # 4 bytes per FP32 element
n_intermediates = 4                      # X, X', X'', Y tensors stored

# --- Outputs (formatted strings for prose) ---
tensor_mb = (tensor_dim * tensor_dim * bytes_fp32 * byte).to(MB).magnitude
total_mb = n_intermediates * tensor_mb
footprint_ratio = n_intermediates

tensor_mb_str = fmt(tensor_mb, precision=1, commas=False)      # e.g. "4.0" MB per tensor
total_mb_str = fmt(total_mb, precision=1, commas=False)        # e.g. "16.0" MB total
footprint_ratio_str = fmt(footprint_ratio, precision=0, commas=False)  # e.g. "4" ratio
```

@lst-naive_execution reveals how each operation becomes a separate kernel in a naïve execution model, forcing intermediate results to be written to memory and then read back for the next operation.

::: {#lst-naive_execution lst-cap="**Naïve Execution**: Each step writes intermediate results to memory before processing the next, leading to increased bandwidth usage and reduced efficiency."}
```{.python}
import torch

## Input tensor
X = torch.randn(1024, 1024).cuda()

## Step-by-step execution (naïve approach)
X1 = torch.relu(X)  # Intermediate tensor stored
# in memory
X2 = torch.batch_norm(X1)  # Another intermediate tensor stored
Y = 2.0 * X2 + 1.0  # Final result
```
:::

Each operation produces an intermediate tensor that must be written to memory and retrieved for the next operation. On large tensors, this overhead of moving data can outweigh the computational cost of the operations [@shazeer2018mesh]. @tbl-memory-footprint illustrates the memory overhead in a naïve execution model. While only the final result $Y$ is needed, storing multiple intermediate tensors creates unnecessary memory traffic and inefficient memory usage.

| **Tensor**       | **Size (MB) for 1024 $\times$ 1024 Tensor** |
|:---------------|:------------------------------------------|
| **X**            | `{python} tensor_mb_str` MB                 |
| **X'**           | `{python} tensor_mb_str` MB                 |
| **X''**          | `{python} tensor_mb_str` MB                 |
| **Y**            | `{python} tensor_mb_str` MB                 |
| **Total Memory** | **`{python} total_mb_str` MB**              |

: **Intermediate Tensor Storage.** Naive execution models require substantial memory to store intermediate tensors generated by each operation. For a 1024×1024 tensor, storing intermediate results (even when only the final output is needed) quadruples the total memory footprint from 4 MB to 16 MB. Minimizing intermediate data storage is essential for improving memory efficiency. {#tbl-memory-footprint}

```{python}
#| label: memory-footprint-table-calc
#| echo: false
# ┌─────────────────────────────────────────────────────────────────────────────
# │ MEMORY FOOTPRINT TABLE VALUES
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: Caption text for @tbl-memory-footprint
# │
# │ Why: Provides rounded values for table caption prose. Complements the
# │      precision=1 values in memory-footprint-calc with precision=0 values
# │      for cleaner prose references (e.g., "4 MB" instead of "4.0 MB").
# │
# │ Imports: mlsys.constants (BYTES_FP32), mlsys.formatting (fmt)
# │ Exports: tensor_mb_str, total_mb_str
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.formatting import fmt
from mlsys.constants import BYTES_FP32

# --- Inputs (tensor dimensions and precision) ---
tensor_dim = 1024                        # 1024x1024 tensor for worked example
bytes_per_float = BYTES_FP32.magnitude   # 4 bytes per FP32 element
total_tensors = 4                        # X, X', X'', Y stored in naive execution

# --- Outputs (formatted strings for prose) ---
tensor_bytes = tensor_dim * tensor_dim * bytes_per_float
tensor_mb = tensor_bytes / MIB_TO_BYTES
total_mb = tensor_mb * total_tensors

tensor_mb_str = fmt(tensor_mb, precision=0, commas=False)   # e.g. "4" MB per tensor
total_mb_str = fmt(total_mb, precision=0, commas=False)     # e.g. "16" MB total
```

The three intermediate tensors waste both memory capacity and bandwidth, limiting scalability on AI accelerators where data movement dominates execution cost.

##### Kernel Fusion for Memory Efficiency {#sec-ai-acceleration-kernel-fusion-memory-efficiency-f227}

\index{Kernel Fusion!memory efficiency}
Kernel fusion minimizes intermediate memory writes, reducing the memory footprint and bandwidth consumption of machine learning workloads [@jia2018beyond].

Kernel fusion merges multiple computation steps into a single, optimized operation, eliminating the need for storing and reloading intermediate tensors. Instead of executing each layer or element-wise operation separately, in which each step writes its output to memory before the next step begins, fusion enables direct data propagation between operations, keeping computations within high-speed registers or local memory.

A common machine learning sequence might involve applying a nonlinear activation function (e.g., ReLU), followed by batch normalization, and then scaling the values for input to the next layer. In a naïve implementation, each of these steps generates an intermediate tensor, which is written to memory, read back, and then modified again:
$$
X' = \text{ReLU}(X)
X'' = \text{BatchNorm}(X')
Y = \alpha \cdot X'' + \beta
$$

With kernel fusion, these operations are combined into a single computation step, allowing the entire transformation to occur without generating unnecessary intermediate tensors:
$$
Y = \alpha \cdot \text{BatchNorm}\big(\text{ReLU}(X)\big) + \beta
$$

```{python}
#| label: fusion-benefits-calc
#| echo: false
# ┌─────────────────────────────────────────────────────────────────────────────
# │ KERNEL FUSION BENEFITS CALCULATION
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: @tbl-fusion-benefits comparing naive vs fused execution
# │
# │ Why: Quantifies the memory savings from kernel fusion. Naive execution
# │      stores all intermediate tensors (X, X', X'', Y = 16 MB), while fused
# │      execution eliminates intermediates, storing only final output (4 MB).
# │
# │ Imports: mlsys.constants (BYTES_FP32)
# │ Exports: naive_mb_str, fused_mb_str
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.constants import BYTES_FP32

# --- Re-derive tensor sizes (self-contained, no namespace leak) ---
tensor_dim = 1024
bytes_per_float = BYTES_FP32.magnitude
tensor_mb = tensor_dim * tensor_dim * bytes_per_float / MIB_TO_BYTES
total_mb = tensor_mb * 4

# --- Outputs (formatted strings for prose) ---
naive_mb = total_mb                      # 16 MB with all intermediates stored
fused_mb = tensor_mb                     # 4 MB with only final result Y stored
naive_mb_str = f"{naive_mb:.0f} MB"      # e.g. "16 MB" naive execution
fused_mb_str = f"{fused_mb:.0f} MB"      # e.g. "4 MB" fused execution
```

@tbl-fusion-benefits highlights the impact of operation fusion on memory efficiency. By keeping intermediate results in registers or local memory rather than writing them to main memory, fusion significantly reduces memory traffic. This optimization is especially beneficial on highly parallel architectures like GPUs and TPUs, where minimizing memory accesses translates directly into improved execution throughput. Compared to the naïve execution model, fused execution eliminates the need for storing intermediate tensors, dramatically lowering the total memory footprint and improving overall efficiency.

| **Execution Model** | **Intermediate Tensors Stored** | **Total Memory Usage (MB)** |
|:------------------|:------------------------------|--------------------------:|
| **Naïve Execution** | X', X''                         |     `{python} naive_mb_str` |
| **Fused Execution** | None                            |     `{python} fused_mb_str` |

: **Operation Fusion Benefits.** Fused execution reduces memory usage by eliminating the need to store intermediate tensors, directly improving efficiency on memory-bound hardware like GPUs and TPUs. Memory consumption drops from 16 MB in naive execution to 4 MB with fused operations. {#tbl-fusion-benefits}

##### Performance Benefits and Constraints {#sec-ai-acceleration-performance-benefits-constraints-1b74}

Kernel fusion brings several key advantages that enhance memory efficiency and computation throughput. By reducing memory accesses, fused kernels ensure that intermediate values stay within registers instead of being repeatedly written to and read from memory. This significantly lowers memory traffic, which is one of the primary bottlenecks in machine learning workloads. GPUs and TPUs, in particular, benefit from kernel fusion because high-bandwidth memory is a scarce resource, and reducing memory transactions leads to better utilization of compute units [@nvidia2020ampere].

However, not all operations can be fused. Element-wise operations, such as ReLU, batch normalization, and simple arithmetic transformations, are ideal candidates for fusion since their computations depend only on single elements from the input tensor. In contrast, operations with complex data dependencies, such as matrix multiplications and convolutions, involve global data movement, making direct fusion impractical. These operations require values from multiple input elements to compute a single output, which prevents them from being executed as a single fused kernel.

Another major consideration is register pressure. Fusing multiple operations means all temporary values must be kept in registers rather than memory. While this eliminates redundant memory writes, it also increases register demand. If a fused kernel exceeds the available registers per thread, the system must spill excess values into shared memory, introducing additional latency and potentially negating the benefits of fusion. On GPUs, where thread occupancy (the number of threads that can run in parallel) is limited by available registers, excessive fusion can reduce parallelism, leading to diminishing returns.

Different AI accelerators and compilers handle fusion in distinct ways. NVIDIA GPUs, for example, favor warp-level parallelism, where element-wise fusion is straightforward. TPUs, on the other hand, prioritize systolic array execution, which is optimized for matrix-matrix operations rather than element-wise fusion [@nvidia2020ampere]. AI compilers such as XLA (TensorFlow), TorchScript (PyTorch), TensorRT (NVIDIA), and MLIR automatically detect fusion opportunities and apply heuristics to balance memory savings and execution efficiency [@xla2020].

Despite its advantages, fusion is not always beneficial. Some AI frameworks allow developers to disable fusion selectively, especially when debugging performance issues or making frequent model modifications. The decision to fuse operations must consider trade-offs between memory efficiency, register usage, and hardware execution constraints to ensure that fusion leads to tangible performance improvements.

These fusion decisions are ultimately about data locality. Use the following checkpoint to consolidate your understanding of data movement strategies.

::: {.callout-checkpoint title="Data Movement and Kernel Fusion"}

At this point, you should be able to answer the first two questions from the roadmap:

**Which data stays local?** The weight-stationary, output-stationary, and input-stationary patterns each make a principled choice about which data to cache near compute units. Weight-stationary (used in Google's TPU) maximizes weight reuse for CNN workloads. Output-stationary (used in NVIDIA's tensor cores) reduces partial sum memory traffic for fully connected layers. Input-stationary minimizes input reloads for models with shared inputs across multiple filters.

**How are operations combined?** Kernel fusion eliminates intermediate memory writes by merging consecutive operations (Conv2D + BatchNorm + ReLU becomes a single kernel). This optimization is most effective for element-wise operations that share data dependencies and can achieve 2–10× speedups by avoiding round-trips to DRAM.

The remaining question, *how is data organized*, brings us to tiling: the technique of partitioning computations into memory-friendly blocks. Tiling complements the stationary strategies by ensuring that whichever data we choose to keep local actually fits in fast memory.

:::

#### Memory-Efficient Tiling Strategies {#sec-ai-acceleration-memoryefficient-tiling-strategies-9fce}

While modern AI accelerators offer high computational throughput, their performance is often limited by memory bandwidth rather than raw processing power. If data cannot be supplied to processing units fast enough, execution stalls occur, leading to wasted cycles and inefficient hardware utilization.

\index{Tiling!definition}
Tiling[^fn-tiling-etymology] is a technique used to mitigate this issue by restructuring computations into smaller, memory-friendly subproblems. The core insight is simple but powerful: if we cannot make memory faster, we can at least make fewer trips to it. Instead of processing entire matrices or tensors at once, which leads to excessive memory traffic, tiling partitions computations into smaller blocks (tiles) that fit within fast local memory (e.g., caches, shared memory, or registers) [@lam1991cache].

[^fn-tiling-etymology]: **Tiling**\index{Lam, Monica!cache optimization pioneer}: Borrowed from floor or mosaic tiling, where a large surface is covered by repeating smaller pieces. In computing, Monica Lam popularized the term in her 1991 PhD thesis on cache optimization. Just as physical tiles tessellate to cover a floor, computational tiles partition large matrices into blocks that fit in fast memory. The technique is also called "blocking" or "loop blocking" in compiler literature. By doing so, tiling increases data reuse, minimizes memory fetches, and improves overall computational efficiency.

Matrix multiplication, widely used in AI models, demonstrates inefficient memory access when implemented naively. @lst-naive_matmul shows how, without tiling, repeated memory accesses for the same data lead to unnecessary bandwidth consumption.

::: {#lst-naive_matmul lst-cap="**Naïve Matrix Multiplication**: Direct implementation without tiling requires O(N^3) memory accesses for N×N matrices, repeatedly fetching the same elements from slow DRAM memory and limiting performance to a fraction of theoretical peak throughput."}
```{.python}
for i in range(N):
    for j in range(N):
        for k in range(N):
            C[i, j] += A[i, k] * B[k, j]  # Repeatedly fetching
            # A[i, k] and B[k, j]
```
:::

Each iteration requires loading elements from matrices $A$ and $B$ multiple times from memory, causing excessive data movement. As the size of the matrices increases, the memory bottleneck worsens, limiting performance.

Tiling addresses this problem by ensuring that smaller portions of matrices are loaded into fast memory, reused efficiently, and only written back to main memory when necessary. This technique is especially important in AI accelerators, where memory accesses dominate execution time. In @fig-tiling-diagram, notice how the highlighted tiles within the full matrices represent the working set that fits in fast memory at any given moment. The key insight is that we process *all* computations for each tile before moving to the next, rather than bouncing between tiles and repeatedly paying the DRAM access penalty.

::: {#fig-tiling-diagram fig-env="figure" fig-pos="htb" fig-cap="**Matrix Tiling**: Partitioning large matrices into smaller tiles optimizes data reuse and reduces memory access overhead during computation. This technique improves performance on AI accelerators by enabling efficient loading and processing of data in fast memory, minimizing transfers from slower main memory." fig-alt="Three matrices A, B, C with highlighted tiles showing how matrix multiplication partitions into smaller blocks. Dimensions labeled M, N, K with corresponding tile sizes Mtile, Ntile, Ktile."}
```{.tikz}
\scalebox{0.7}{%
\begin{tikzpicture}[line join=round,font=\usefont{T1}{phv}{m}{n},x=1mm,y=1mm]
\tikzset{%
   Line/.style={draw,line width=1.25pt,black,text=black},
   LineT/.style={draw,line width=0.75pt,black,text=black},
  }
%Bmatrix
\node[Line,rectangle,anchor=south west,
minimum width=66mm,minimum height=60mm](BM)at(0,0){};
\scoped[on background layer]
\node[LineT,rectangle,anchor=south west,fill=RedFill,
minimum width=18mm,minimum height=60mm](BM1)at(18mm,0){};
\node[LineT,rectangle,anchor=south west,fill=RedFill,
minimum width=18mm,minimum height=9mm](BM2)at(18mm,30mm){};
%
\draw[thick,decorate,decoration={brace, amplitude=7pt}]([yshift=2mm]BM.north west)--
([yshift=2mm]BM.north east)node[midway,above=9pt]{N};
\draw[thick,decorate,decoration={brace, amplitude=7pt,mirror}]([xshift=-2mm]BM.north west)--
([xshift=-2mm]BM.south west)node[midway,left=9pt]{K};
\draw[thick,decorate,decoration={brace, amplitude=5pt}]([xshift=2mm]BM2.north east)--
([xshift=2mm]BM2.south east)node[midway,right=6pt]{Ktile};
\draw[thick,decorate,decoration={brace, amplitude=5pt,mirror}]([yshift=-2mm,xshift=1mm]BM2.south west)--
([yshift=-2mm,xshift=-1mm]BM2.south east)node[midway,below=6pt]{Ntile};
\node[below left=2 of BM.north east]{B matrix};
%Cmatrix
\node[Line,rectangle,anchor=north west,
minimum width=66mm,minimum height=48mm](CM)at(0,-10){};
\node[LineT,rectangle,anchor=north west,
minimum width=18mm,minimum height=48mm](CM1)at(18mm,-10){};
\node[LineT,rectangle,anchor=south west,
minimum width=66mm,minimum height=15mm](CM2)at(CM.south west){};
\node[LineT,rectangle,anchor=south west,fill=BlueL,
minimum width=18mm,minimum height=14.8mm](CM3)at(CM1.south west){};
%
\draw[thick,decorate,decoration={brace, amplitude=5pt}]([yshift=-1mm,xshift=2mm]CM3.north east)--
([yshift=1mm,xshift=2mm]CM3.south east)node[midway,right=6pt]{Mtile};
\draw[thick,decorate,decoration={brace, amplitude=5pt,mirror}]([yshift=-2mm,xshift=1mm]CM3.south west)--
([yshift=-2mm,xshift=-1mm]CM3.south east)node[midway,below=6pt]{Ntile};
\node[above right=2 of CM3.north east]{Block \textsubscript{m,n}};
%Amatrix
\node[Line,rectangle,anchor=north east,
minimum width=60mm,minimum height=48mm](AM)at(-10,-10){};
\node[LineT,rectangle,anchor=south west,fill=GreenL!40,
minimum width=60mm,minimum height=15mm](AM1)at(AM.south west){};
\node[LineT,rectangle,anchor=south west,fill=GreenL,
minimum width=9mm,minimum height=15mm](AM2)at($(AM.south west)+(21mm,0)$){};
\node[below left=2 of CM.north east]{C matrix};
\node[Line,rectangle,anchor=north east,
minimum width=60mm,minimum height=48mm](AM)at(-10,-10){};
%
\draw[thick,decorate,decoration={brace, amplitude=7pt}]([yshift=2mm]AM.north west)--
([yshift=2mm]AM.north east)node[midway,above=9pt]{K};
\draw[thick,decorate,decoration={brace, amplitude=7pt,mirror}]([xshift=-2mm]AM.north west)--
([xshift=-2mm]AM.south west)node[midway,left=9pt]{M};
\draw[thick,decorate,decoration={brace, amplitude=5pt}]([yshift=-1mm,xshift=2mm]AM2.north east)--
([yshift=1mm,xshift=2mm]AM2.south east)node[midway,right=6pt]{Mtile};
\draw[thick,decorate,decoration={brace, amplitude=5pt,mirror}]([yshift=-2mm,xshift=1mm]AM2.south west)--
([yshift=-2mm,xshift=-1mm]AM2.south east)node[midway,below=6pt]{Ktile};
\node[below left=2 of AM.north east]{A matrix};
\end{tikzpicture}}
```
:::

##### Tiling Fundamentals {#sec-ai-acceleration-tiling-fundamentals-e9e6}

Tiling is based on a simple but powerful principle: instead of operating on an entire data structure at once, computations are divided into smaller tiles that fit within the available fast memory. By structuring execution around these tiles, data reuse is maximized, reducing redundant memory accesses and improving overall efficiency.

Consider matrix multiplication, a key operation in machine learning workloads. The operation computes $C = A \times B$ where each element $C[i,j] = \sum_{k} A[i,k] \times B[k,j]$. The naive implementation shown earlier in @lst-naive_matmul demonstrates the core problem: every iteration of the innermost loop fetches elements from matrices $A$ and $B$ from memory, performs a multiplication, and updates matrix $C$. Because matrices are large, the processor repeatedly reloads the same values from memory, even though they were just used in previous computations.

This data movement overhead is expensive: fetching from DRAM is 100–1,000× slower than accessing on-chip cache or registers. The solution is tiling.

##### Performance Benefits of Tiling {#sec-ai-acceleration-performance-benefits-tiling-e7bd}

Instead of computing one element at a time and constantly moving data in and out of slow memory, tiling processes submatrices (tiles) at a time, keeping frequently used values in fast memory. The idea is to divide the matrices into smaller blocks that fit within the processor's cache or shared memory, ensuring that once a block is loaded, it is reused multiple times before moving to the next one.

@lst-tiled_matmul demonstrates how processing blocks of data improves memory locality by ensuring frequently used values remain in fast memory.

::: {#lst-tiled_matmul lst-cap="**Tiled Matrix Multiplication**: This approach divides matrices into smaller blocks to optimize memory usage by reusing data within processor cache, thereby improving computational efficiency."}
```{.python}
TILE_SIZE = 32  # Choose a tile size based on
# hardware constraints

# Spatial tiling: partition data via loop bounds.
# No explicit loads - tiles defined by index ranges.
for i in range(0, N, TILE_SIZE):
    for j in range(0, N, TILE_SIZE):
        for k in range(0, N, TILE_SIZE):
            # Each tile computed independently
            for ii in range(i, i + TILE_SIZE):
                for jj in range(j, j + TILE_SIZE):
                    for kk in range(k, k + TILE_SIZE):
                        C[ii, jj] += A[ii, kk] * B[kk, jj]
```
:::

This restructuring significantly improves performance for three main reasons:

1. **Better Memory Reuse**: Instead of fetching elements from $A$ and $B$ repeatedly from slow memory, this approach loads a small tile of data into fast memory, performs multiple computations using it, and only then moves on to the next tile. This minimizes redundant memory accesses.

2. **Reduced Memory Bandwidth Usage**: Since each tile is used multiple times before being evicted, memory traffic is reduced. Instead of repeatedly accessing DRAM, most required data is available in L1/L2 cache or shared memory, leading to faster execution.

3. **Increased Compute Efficiency**: Processors spend less time waiting for data and more time performing useful computations. In architectures like GPUs and TPUs, where thousands of parallel processing units operate simultaneously, tiling ensures that data is read and processed in a structured manner, avoiding unnecessary stalls.

This technique is particularly effective in AI accelerators, where machine learning workloads consist of large matrix multiplications and tensor transformations. Without tiling, these workloads quickly become memory-bound, meaning performance is constrained by how fast data can be retrieved rather than by the raw computational power of the processor.

##### Tiling Methods {#sec-ai-acceleration-tiling-methods-6257}

While the general principle of tiling remains the same, which involves partitioning large computations into smaller subproblems to improve memory reuse, there are different ways to apply tiling based on the structure of the computation and hardware constraints. The two primary tiling strategies are spatial tiling and temporal tiling. These strategies optimize different aspects of computation and memory access, and in practice, they are often combined to achieve the best performance.

*Spatial tiling*\index{Tiling!spatial}\index{Spatial Tiling!data partitioning} partitions data structures into smaller blocks that fit within fast memory. The tiled matrix multiplication in @lst-tiled_matmul demonstrates this approach: each tile of $A$ and $B$ is loaded into cache or shared memory before processing, ensuring that the same data does not need to be fetched repeatedly from slower memory. The tile is fully used before moving to the next block, minimizing redundant memory accesses. This strategy is particularly beneficial for large tensors that exceed fast memory capacity — by breaking computations into smaller tiles, data movement between memory levels is minimized, keeping operations localized within cache hierarchies.

*Temporal tiling*\index{Tiling!temporal} (also called loop blocking) complements spatial tiling by reorganizing the *computation order* rather than the data layout. Many ML workloads access the same data repeatedly across iterations — without temporal tiling, this results in redundant memory fetches. Temporal tiling restructures the computation to ensure that frequently used data stays in fast memory for as long as possible before the next computation begins.

A classic example where temporal tiling is beneficial is convolutional operations, where the same set of weights is applied to multiple input regions. Without loop blocking, these weights might be loaded from memory multiple times for each computation. With temporal tiling, the computation is reordered so that the weights remain in fast memory across multiple inputs, reducing unnecessary memory fetches and improving overall efficiency.

@lst-loop_blocking illustrates how loop blocking restructures computation to keep weights in fast memory across multiple inputs, reducing redundant fetches.

::: {#lst-loop_blocking lst-cap="**Temporal Tiling**: Reduces redundant memory accesses by caching weights in fast memory across multiple matrix multiplications."}
```{.python}
# Temporal tiling: reorder computation so data
# stays in fast memory across iterations.
for i in range(0, N, TILE_SIZE):
    for j in range(0, N, TILE_SIZE):
        for k in range(0, N, TILE_SIZE):
            # Explicitly load tiles into fast memory
            A_tile = A[i:i+TILE_SIZE, k:k+TILE_SIZE]
            B_tile = B[k:k+TILE_SIZE, j:j+TILE_SIZE]

            # Reuse loaded tiles for all inner iterations
            for ii in range(TILE_SIZE):
                for jj in range(TILE_SIZE):
                    for kk in range(TILE_SIZE):
                        C[i+ii, j+jj] += A_tile[ii, kk] *
                                         B_tile[kk, jj]
```
:::

Temporal tiling improves performance by ensuring that the data loaded into fast memory is used multiple times before being evicted. In this implementation, small tiles of matrices $A$ and $B$ are explicitly loaded into temporary storage before performing computations, reducing memory fetch overhead. This restructuring allows the computation to process an entire tile before moving to the next, thereby reducing the number of times data must be loaded from slower memory.

This technique is particularly useful in workloads where certain values are used repeatedly, such as convolutions, recurrent neural networks (RNNs), and self-attention mechanisms in transformers. By applying loop blocking, AI accelerators can significantly reduce memory stalls and improve execution throughput.

##### Tiling Challenges and Trade-offs {#sec-ai-acceleration-tiling-challenges-tradeoffs-e9c9}

While tiling significantly improves performance by optimizing memory reuse and reducing redundant memory accesses, it introduces several challenges and trade-offs. Selecting the right tile size is important, as it directly affects computational efficiency and memory bandwidth usage. If the tile size is too small, the benefits of tiling diminish, as memory fetches still dominate execution time. On the other hand, if the tile size is too large, it may exceed the available fast memory, causing cache thrashing and performance degradation.

Load balancing is another key concern. In architectures such as GPUs and TPUs, computations are executed in parallel across thousands of processing units. If tiles are not evenly distributed, some units may remain idle while others are overloaded, leading to suboptimal utilization of computational resources. Effective tile scheduling ensures that parallel execution remains balanced and efficient.

Data movement overhead is also an important consideration. Although tiling reduces the number of slow memory accesses, transferring tiles between different levels of memory still incurs a cost. This is especially relevant in hierarchical memory systems, where accessing data from cache is much faster than accessing it from DRAM. Efficient memory prefetching and scheduling strategies are required to minimize latency and ensure that data is available when needed.

Beyond spatial and temporal tiling, hybrid approaches combine elements of both strategies to achieve optimal performance. Hybrid tiling adapts to workload-specific constraints by dynamically adjusting tile sizes or reordering computations based on real-time execution conditions. For example, some AI accelerators use spatial tiling for matrix multiplications while employing temporal tiling for weight reuse in convolutional layers.

Other methods exist for optimizing memory usage and computational efficiency beyond tiling. Techniques such as register blocking, double buffering, and hierarchical tiling extend the basic tiling principles to further optimize execution. AI compilers and runtime systems, such as TensorFlow XLA, TVM, and MLIR, automatically select tiling strategies based on hardware constraints, enabling fine-tuned performance optimization without manual intervention.

@tbl-tiling-strategies provides a comparative overview of spatial, temporal, and hybrid tiling approaches, highlighting their respective benefits and trade-offs.

| **Aspect**             | **Spatial Tiling (Data Tiling)**                                                           | **Temporal Tiling (Loop Blocking)**                                    | **Hybrid Tiling**                                              |
|:---------------------|:-----------------------------------------------------------------------------------------|:---------------------------------------------------------------------|:-------------------------------------------------------------|
| **Primary Goal**       | Reduce memory accesses by keeping data in fast memory longer                               | Increase data reuse across loop iterations                             | Adapt dynamically to workload constraints                      |
| **Optimization Focus** | Partitioning data structures into smaller, memory-friendly blocks                          | Reordering computations to maximize reuse before eviction              | Balancing spatial and temporal reuse strategies                |
| **Memory Usage**       | Improves cache locality and reduces DRAM access                                            | Keeps frequently used data in fast memory for multiple iterations      | Minimizes data movement while ensuring high reuse              |
| **Common Use Cases**   | Matrix multiplications, CNNs, self-attention in transformers                               | Convolutions, recurrent neural networks (RNNs), iterative computations | AI accelerators with hierarchical memory, mixed workloads      |
| **Performance Gains**  | Reduced memory bandwidth requirements, better cache utilization                            | Lower memory fetch latency, improved data locality                     | Maximized efficiency across multiple hardware types            |
| **Challenges**         | Requires careful tile size selection, inefficient for workloads with minimal spatial reuse | Can increase register pressure, requires loop restructuring            | Complexity in tuning tile size and execution order dynamically |
| **Best When**          | Data is large and needs to be partitioned for efficient processing                         | The same data is accessed multiple times across iterations             | Both data partitioning and iteration-based reuse are important |

: **Tiling Strategies.** Spatial, temporal, and hybrid tiling optimize memory access patterns for improved performance. Spatial tiling maximizes data reuse within fast memory, temporal tiling exploits loop structure for reduced accesses, and hybrid tiling combines both approaches. AI compilers and runtime systems use these techniques to automatically optimize model execution on diverse hardware. {#tbl-tiling-strategies}

As machine learning models continue to grow in size and complexity, tiling remains a critical tool for improving hardware efficiency, ensuring that AI accelerators operate at their full potential. While manual tiling strategies can provide substantial benefits, modern compilers and hardware-aware optimization techniques further enhance performance by automatically selecting the most effective tiling strategies for a given workload.

### Applying Mapping Strategies to Neural Networks {#sec-ai-acceleration-applying-mapping-strategies-neural-networks-3110}

While these foundational mapping techniques apply broadly, their effectiveness varies based on the computational structure, data access patterns, and parallelization opportunities of different neural network architectures. Each architecture imposes distinct constraints on data movement, memory hierarchy, and computation scheduling, requiring tailored mapping strategies to optimize performance.

A structured approach to mapping is required to address the combinatorial explosion of choices that arise when assigning computations to AI accelerators. Rather than treating each model as a separate optimization problem, we recognize that the same principles apply across different architectures; only their priority shifts based on workload characteristics. The goal is to systematically select and apply mapping strategies that maximize efficiency for different types of machine learning models.

These principles apply to three representative AI workloads, each characterized by distinct computational demands. CNNs benefit from spatial data reuse, making weight-stationary execution and the application of tiling techniques especially effective. In contrast, Transformers are inherently memory-bound and rely on strategies such as efficient KV-cache management, fused attention mechanisms, and highly parallel execution to mitigate memory traffic. MLPs, which involve substantial matrix multiplication operations, demand the use of structured tiling, optimized weight layouts, and memory-aware execution to enhance overall performance.

Despite their differences, each of these models follows a common set of mapping principles, with variations in how optimizations are prioritized. @tbl-mapping-strategies summarizes the suitability of different optimization strategies for CNNs, Transformers, and MLPs.

| **Optimization Technique**       | **CNNs**                 | **Transformers**      | **MLPs**          | **Rationale**                                                                                                                                                       |
|:-------------------------------|:-----------------------|:--------------------|:----------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Dataflow Strategy**            | Weight Stationary        | Activation Stationary | Weight Stationary | CNNs reuse filters across spatial locations; Transformers reuse activations (KV-cache); MLPs reuse weights across batches.                                          |
| **Memory-Aware Tensor Layouts**  | NCHW (Channel-Major)     | NHWC (Row-Major)      | NHWC              | CNNs favor channel-major for convolution efficiency; Transformers and MLPs prioritize row-major for fast memory access.                                             |
| **Kernel Fusion**                | Convolution + Activation | Fused Attention       | GEMM Fusion       | CNNs optimize convolution+activation fusion; Transformers fuse attention mechanisms; MLPs benefit from fused matrix multiplications.                                |
| **Tiling for Memory Efficiency** | Spatial Tiling           | Temporal Tiling       | Blocked Tiling    | CNNs tile along spatial dimensions; Transformers use loop blocking to improve sequence memory efficiency; MLPs use blocked tiling for large matrix multiplications. |

: **Architecture-Specific Mapping Strategies.** Each neural network architecture benefits from different optimization priorities based on its computational and memory characteristics. {#tbl-mapping-strategies}

With the mapping strategies summarized in @tbl-mapping-strategies, we now examine *why* each architecture maps the way it does. The table captures the specific strategy choices; the following subsections explain the architectural insight behind each one.

#### Convolutional Neural Networks (ResNet-50)

\index{ResNet-50!weight reuse mapping}
The defining characteristic of CNNs, from a hardware mapping perspective, is spatial weight reuse. A single small filter is applied to every spatial location in the input feature map, meaning the same weights participate in hundreds or thousands of multiply-accumulate operations before the next filter is needed. This reuse pattern makes weight stationary execution the natural choice: pinning filter weights in fast on-chip memory and streaming activations through the compute units avoids repeatedly fetching the same weights from slower external memory. The result is high arithmetic intensity with modest bandwidth demand, which is precisely the profile that tensor cores and systolic arrays are designed to exploit.

This spatial regularity also enables aggressive fusion and tiling. Because convolution, batch normalization, and activation are applied at every spatial position in lockstep, compilers can fuse the entire sequence into a single kernel that never writes intermediate results to main memory. Spatial tiling then partitions the feature map into subregions sized to fit within on-chip SRAM, so the fused kernel processes each tile entirely from fast memory before moving to the next. The combination of weight stationarity, kernel fusion, and spatial tiling is what makes CNNs among the most hardware-friendly architectures, routinely achieving 70 to 80 percent of peak accelerator throughput.

#### Transformer Architectures (GPT-2/Llama)

\index{Transformer!KV-cache memory pressure}
Where CNNs are defined by weight reuse, Transformers are defined by the memory pressure of the key-value (KV) cache\index{KV Cache!transformer memory pressure}. During attention computation, every query vector must access stored key and value pairs across the entire sequence length. As sequences grow, the KV cache can consume gigabytes of high-bandwidth memory, making memory bandwidth rather than raw compute the primary bottleneck. This access pattern motivates activation stationary execution: keeping the KV cache resident in fast memory while streaming queries through minimizes the costly round trips to external DRAM that would otherwise dominate execution time.

The memory-bound nature of attention also explains why fused attention kernels, such as FlashAttention [@dao2022flashattention], deliver outsized performance gains for Transformers. \index{FlashAttention!tiled attention implementation}
By fusing the query-key dot product, softmax normalization, and value-weighted summation into a single kernel that tiles along the sequence dimension, these implementations avoid materializing the full attention matrix in main memory. This temporal tiling approach processes sequence blocks that fit within on-chip SRAM, reducing memory traffic from quadratic in sequence length to near-linear. For Transformers, the mapping strategy is primarily an exercise in memory management rather than compute scheduling.

#### Multi-Layer Perceptrons (DLRM)

\index{MLP!GEMM-dominated computation}
MLPs present the most straightforward mapping problem because their computation reduces almost entirely to dense General Matrix Multiplication (GEMM)\index{GEMM!General Matrix Multiplication}[^fn-gemm-optimization]. Each fully connected layer multiplies an activation matrix by a weight matrix, and GEMM accounts for 90 to 95 percent of MLP computation time. The weight matrix is fixed across all samples in a batch, so weight stationary execution allows the accelerator to load weights once and reuse them across every batch element, with reuse scaling linearly with batch size. This makes MLPs highly sensitive to batching: a batch size of one leaves the weight matrix underutilized, while large batches push arithmetic intensity into the compute-bound regime where accelerators operate most efficiently.

[^fn-gemm-optimization]: **GEMM (General Matrix Multiplication)**: The operation C = αAB + βC that underlies most neural network computations. The name reflects its role as the "general" case encompassing vector-matrix and matrix-vector products as special cases. GEMM accounts for 90-95% of computation time in training deep networks and is the primary target of AI hardware optimization. Optimized libraries like cuBLAS (NVIDIA) and oneDNN (Intel) achieve 80-95% of theoretical peak through register blocking, vectorization, and hierarchical tiling. Modern AI accelerators are essentially specialized GEMM engines.

Because MLP layers are typically followed by activation functions and bias additions, GEMM fusion combines these steps into a single kernel, avoiding intermediate memory writes. Blocked tiling partitions the large matrix multiplications into sub-blocks sized for the accelerator's shared memory, ensuring high cache utilization throughout computation. The simplicity of the MLP mapping, dominated by a single primitive with predictable access patterns, is precisely why hardware vendors optimize GEMM libraries so aggressively: gains in GEMM performance translate directly to MLP throughput.

### Hybrid Mapping Strategies {#sec-ai-acceleration-hybrid-mapping-strategies-3e8c}

\index{Hybrid Mapping!layer-specific strategy}
The preceding subsections treat each architecture in isolation, but real models rarely consist of a single layer type. A vision transformer, for example, begins with a convolution-like patch embedding that benefits from weight stationary mapping, proceeds through self-attention layers that require activation stationary execution for efficient KV-cache reuse, and concludes with MLP blocks whose dense GEMM operations demand blocked tiling and fusion [@dosovitskiy2021image]. No single dataflow strategy is optimal across all these layers.

Hybrid mapping addresses this heterogeneity by allowing the accelerator to switch strategies at layer boundaries. Each layer presents a different balance of compute intensity, data reuse, and memory access pattern, and the optimal mapping must shift accordingly [@sze2020efficient]. Rather than committing to one dataflow for the entire model, hybrid approaches select weight stationary execution for layers with high weight reuse, activation stationary execution for attention layers with large KV caches, and output stationary execution for layers where minimizing write traffic matters most.

Modern accelerators provide the architectural features needed to realize hybrid mapping in practice. Google TPUs switch between weight stationary and activation stationary modes depending on whether a layer is convolutional or attention-based. NVIDIA GPUs use fused kernels alongside flexible memory layouts that enable different strategies within the same model. Graphcore IPUs select execution strategies dynamically on a per-layer basis to optimize memory access. These implementations require programmable memory hierarchies, efficient interconnects, and specialized execution pipelines, reinforcing the hardware-software co-design principle.

However, hybrid mapping remains a design-time optimization. In production workloads, execution conditions change dynamically due to varying input sizes, memory contention, and hardware resource availability. Machine learning compilers and runtime systems extend these static mapping choices by introducing dynamic scheduling, memory optimizations, and automatic tuning, ensuring that deep learning workloads operate efficiently across diverse accelerators and deployment environments.

The mapping strategies and dataflow optimizations examined in preceding sections represent the "what" of efficient execution: which data to keep local, how to tile computations, and which parallelization strategies to employ. Determining optimal configurations for specific hardware and workloads, however, requires systematic automation. This is where machine learning compilers become indispensable: they transform abstract mapping principles into concrete execution plans tailored to target accelerators, bridging the gap between high-level model definitions and low-level hardware instructions.

## Compiler Support {#sec-ai-acceleration-compiler-support-172e}

Machine learning compilers automate the translation of dataflow strategies into executable code, addressing a critical challenge: the mapping decisions analyzed above must be instantiated differently for each hardware target. The gap between "knowing what optimizations exist" and "applying them correctly" is vast: a single convolution can be implemented with dozens of valid tiling strategies, kernel variants, and memory layouts, most of which perform poorly on any given hardware. Compilers navigate this complexity systematically. To see why this matters, consider what happens when you compile ResNet-50 for GPU inference:

1. **Graph optimization** fuses the 49 Conv2D-BatchNorm-ReLU sequences into 49 single kernels, eliminating 98 intermediate memory writes that would otherwise consume bandwidth
2. **Kernel selection** chooses Tensor Core implementations for the 3x3 convolutions, exploiting the high arithmetic intensity (50-200 FLOP/byte) we calculated in the Roofline analysis
3. **Memory planning** determines that intermediate activations require approximately 2.1 GB at batch size 32, fitting comfortably in the A100's 40 GB HBM
4. **Computation scheduling** overlaps memory transfers for layer N+1 with computation of layer N, hiding a substantial portion of transfer latency

```{python}
#| label: compiler-speedup-calc
#| echo: false
# ┌─────────────────────────────────────────────────────────────────────────────
# │ ML COMPILER OPTIMIZATION SPEEDUP
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: @sec-ai-acceleration-compiler-support-172e introduction
# │
# │ Why: Demonstrates the practical impact of ML compiler optimizations on
# │      ResNet-50 inference. Shows how graph optimization, kernel selection,
# │      memory planning, and computation scheduling combine to achieve 5-6x
# │      speedup without any algorithmic changes to the model.
# │
# │ Imports: mlsys.formatting (fmt)
# │ Exports: naive_inference_ms, optimized_inference_ms, compiler_speedup_str
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.formatting import fmt

# --- Inputs (ResNet-50 inference benchmarks) ---
naive_inference_ms = 47                  # Naive execution latency (ms)
optimized_inference_ms = 8               # Compiler-optimized latency (ms)

# --- Outputs (formatted strings for prose) ---
compiler_speedup = naive_inference_ms / optimized_inference_ms
compiler_speedup_str = fmt(compiler_speedup, precision=1, commas=False)  # e.g. "5.9" speedup
```

The result: inference time drops from approximately `{python} naive_inference_ms` ms (naive execution) to approximately `{python} optimized_inference_ms` ms (optimized), roughly a `{python} compiler_speedup_str` x improvement from compilation alone, before any algorithmic changes to the model. This concrete example illustrates how the dataflow strategies from the previous section, including kernel fusion (@sec-ai-acceleration-kernel-fusion-7faf) and tiling (@sec-ai-acceleration-memoryefficient-tiling-strategies-9fce), translate into real performance through systematic compiler optimization.

This process exemplifies the hardware-software co-design principle established in @sec-ai-acceleration-ai-hardware-acceleration-fundamentals-9b28, where machine learning compilers bridge high-level model representations with low-level hardware execution. The compiler optimizes models by restructuring computations, selecting efficient execution kernels, and maximizing hardware utilization [@chen2018tvm]. Unlike traditional compilers designed for general-purpose computing, ML workloads require specialized approaches for tensor computations and parallel execution.

### ML Compiler Design {#sec-ai-acceleration-compiler-design-differences-ml-workloads-0698}

\index{ML Compiler!vs traditional compiler}
Machine learning workloads introduce challenges that traditional compilers were not designed to handle. Unlike conventional software execution, which primarily involves sequential or multi-threaded program flow, machine learning models are expressed as computation graphs that describe large-scale tensor operations. These graphs require specialized optimizations that traditional compilers cannot efficiently apply [@cui_mlcompilers_2019].

@tbl-ml-vs-traditional-compilers outlines the key differences between traditional compilers and those designed for machine learning workloads. While traditional compilers optimize linear program execution through techniques like instruction scheduling and register allocation, ML compilers focus on optimizing computation graphs for efficient tensor operations. This distinction is critical, as ML compilers must incorporate domain-specific transformations such as kernel fusion, memory-aware scheduling, and hardware-accelerated execution plans to achieve high performance on specialized accelerators like GPUs and TPUs.

| **Aspect**                  | **Traditional Compiler**                                    | **Machine Learning Compiler**                                  |
|:--------------------------|:----------------------------------------------------------|:-------------------------------------------------------------|
| **Input Representation**    | Linear program code (C, Python)                             | Computational graph (ML models)                                |
| **Execution Model**         | Sequential or multi-threaded execution                      | Massively parallel tensor-based execution                      |
| **Optimization Priorities** | Instruction scheduling, loop unrolling, register allocation | Graph transformations, kernel fusion, memory-aware execution   |
| **Memory Management**       | Stack and heap memory allocation                            | Tensor layout transformations, tiling, memory-aware scheduling |
| **Target Hardware**         | CPUs (general-purpose execution)                            | GPUs, TPUs, and custom accelerators                            |
| **Compilation Output**      | CPU-specific machine code                                   | Hardware-specific execution plan (kernels, memory scheduling)  |

: **Compiler Optimization Priorities.** Traditional and machine learning compilers diverge in their optimization targets: traditional compilers prioritize efficient execution of sequential code, while ML compilers focus on optimizing tensor operations within computation graphs for specialized hardware. ML compilers incorporate domain-specific transformations such as kernel fusion and memory-aware scheduling, unlike the instruction scheduling and register allocation techniques used in conventional compilation. {#tbl-ml-vs-traditional-compilers}

Machine learning compilers must transform entire computation graphs, apply tensor-aware memory optimizations, and schedule operations across thousands of parallel processing elements. The distinction from traditional compilation is not merely quantitative (more parallelism) but qualitative: traditional compilers optimize individual instructions, while ML compilers optimize entire dataflow graphs where the dominant cost is data movement rather than computation.

::: {.callout-perspective title="The Hidden Optimization Layer"}

Most practitioners never interact directly with ML compilers, yet compiler quality often determines whether your model achieves 20% or 80% of hardware peak performance. When you call `model.compile()` in Keras, `torch.compile()` in PyTorch, or deploy through TensorRT, you are invoking multi-stage optimization pipelines that:

- **Fuse operations** you never explicitly combined (Conv2D + BatchNorm + ReLU → single kernel)
- **Reorder computations** to improve memory locality (tiling large matrix multiplies)
- **Select kernels** from libraries containing hundreds of hand-tuned implementations
- **Transform tensor layouts** between what your code expects and what hardware prefers

This matters practically: the same model definition can run 2–5× faster simply by switching compilation backends (e.g., PyTorch eager mode vs. torch.compile with different backends). When performance does not meet expectations, compiler configuration and backend selection are often the first optimization levers, requiring no changes to model architecture or training procedure.

:::

### ML Compilation Pipeline {#sec-ai-acceleration-ml-compilation-pipeline-7676}

\index{ML Compiler!compilation pipeline}
Machine learning models, as defined in modern frameworks, are initially represented in a high-level computation graph that describes operations on tensors. However, these representations are not directly executable on hardware accelerators such as GPUs, TPUs, and custom AI chips. To achieve efficient execution, models must go through a compilation process that transforms them into optimized execution plans suited for the target hardware [@GoogleXLA].

The machine learning compilation workflow proceeds through five stages that progressively lower abstraction. Graph optimization restructures the computation graph to eliminate inefficiencies. Kernel selection then maps each operation to a hardware-specific implementation optimized for the target accelerator. Memory planning optimizes tensor layouts and access patterns to reduce bandwidth consumption. Computation scheduling distributes workloads across parallel processing elements to maximize hardware utilization. Finally, code generation translates the optimized plan into machine-specific instructions for execution.

At each stage, the compiler applies the optimizations established in @sec-ai-acceleration-dataflow-optimization-strategies-ce52: kernel fusion, tiling, data movement strategies, and computation placement. This ensures that these optimizations are systematically incorporated into the final execution plan.

Machine learning acceleration thus depends as much on compiler-driven software optimizations as on hardware improvements.

### Graph Optimization {#sec-ai-acceleration-graph-optimization-f888}

\index{Graph Optimization!computation graph restructuring}
AI accelerators provide specialized hardware to speed up computation, but raw model representations are not inherently optimized for execution on these accelerators. Machine learning frameworks define models using high-level computation graphs, where nodes represent operations (such as convolutions, matrix multiplications, and activations), and edges define data dependencies. However, if executed as defined, these graphs often contain redundant operations, inefficient memory access patterns, and suboptimal execution sequences that can prevent the hardware from operating at peak efficiency.

For example, in a Transformer model, the self-attention mechanism involves repeated accesses to the same key-value pairs across multiple attention heads. If compiled naïvely, the model may reload the same data multiple times, leading to excessive memory traffic [@Shoeybi2019]. Similarly, in a CNN, applying batch normalization and activation functions as separate operations after each convolution leads to unnecessary intermediate memory writes, increasing memory bandwidth usage. These inefficiencies are addressed during graph optimization, where the compiler restructures the computation graph to eliminate unnecessary operations and improve memory locality [@chen2018tvm].

Graph optimization transforms this high-level computation graph into an optimized execution plan before hardware mapping. Rather than requiring manual optimization, the compiler systematically applies transformations that improve data movement, reduce redundant computations, and restructure operations for efficient parallel execution [@nvidia_tensorRT_2021].

At this stage, the compiler works at a hardware-agnostic level, focusing on high-level restructuring before hardware-specific optimizations are applied in later phases.

Graph optimization transforms the computation graph through a series of structured techniques designed to enhance execution efficiency. One key technique is kernel fusion, which merges consecutive operations to eliminate unnecessary memory writes and reduce the number of kernel launches. This approach is particularly effective in convolutional neural networks, where fusing convolution, batch normalization, and activation functions notably accelerates processing. Another important technique is computation reordering, which adjusts the execution order of operations to improve data locality and maximize parallel execution. For instance, in Transformer models, such reordering enables the reuse of cached key-value pairs rather than reloading them repeatedly from memory, thereby reducing latency.

Redundant computation elimination plays an equally important role. By identifying and removing duplicate or unnecessary operations, this method is especially beneficial in models with residual connections where common subexpressions might otherwise be redundantly computed. Memory-aware dataflow adjustments enhance overall performance by refining tensor layouts and optimizing memory movement. For example, tiling matrix multiplications to meet the structural requirements of systolic arrays in TPUs ensures that hardware resources are utilized optimally. This combined approach not only reduces unnecessary processing but also aligns data storage and movement with the accelerator's strengths, leading to efficient execution across diverse AI workloads. Together, these techniques prepare the model for acceleration by minimizing overhead and ensuring an optimal balance between computational and memory resources.

Modern AI compilers perform graph optimization through the use of automated pattern recognition and structured rewrite rules, systematically transforming computation graphs to maximize efficiency without manual intervention. For example, Google's XLA\index{XLA!Accelerated Linear Algebra} (Accelerated Linear Algebra) in TensorFlow (see @sec-ai-frameworks for framework integration) applies graph-level transformations such as fusion and layout optimizations that streamline execution on TPUs and GPUs. Similarly, TVM\index{TVM!Tensor Virtual Machine} (Tensor Virtual Machine) not only refines tensor layouts and adjusts computational structures but also tunes execution strategies across diverse hardware backends, which is particularly beneficial for deploying models on embedded TinyML devices with strict memory constraints.

NVIDIA's TensorRT\index{TensorRT!NVIDIA compiler}\index{NVIDIA!TensorRT}, another specialized deep learning compiler, focuses on minimizing kernel launch overhead by fusing operations and optimizing execution scheduling on GPUs, thereby improving utilization and reducing inference latency in large-scale convolutional neural network applications. MLIR\index{MLIR!Multi-Level Intermediate Representation} (Multi-Level Intermediate Representation) supports flexible graph optimization across various AI accelerators by enabling multi-stage transformations that improve execution order and memory access patterns, thus easing the transition of models from CPU-based implementations to accelerator-optimized versions. These compilers preserve the mathematical integrity of the models while rewriting the computation graph to ensure that the subsequent hardware-specific optimizations can be effectively applied. The practical impact of these transformations is substantial: without proper graph optimization, a large Transformer model running on an edge device may experience excessive memory stalls due to suboptimal data access patterns, whereas effective graph restructuring can reduce memory bandwidth consumption and latency enough to enable real-time inference on resource-constrained devices. {#sec-ai-acceleration-graph-optimization-importance-9ccb}

With the computation graph now fully optimized, the next step in compilation is kernel selection, where the compiler determines which hardware-specific implementation should be used for each operation. This ensures that the structured execution plan is translated into optimized low-level instructions for the target accelerator.

### Kernel Selection {#sec-ai-acceleration-kernel-selection-df01}

\index{Kernel Selection!hardware-specific implementation}
At this stage, the compiler translates the abstract operations in the computation graph into optimized low-level functions, ensuring that execution is performed as efficiently as possible given the constraints of the target accelerator. A kernel is a specialized implementation of a computational operation designed to run efficiently on a particular hardware architecture. Most accelerators, including GPUs, TPUs, and custom AI chips, provide multiple kernel implementations for the same operation, each optimized for different execution scenarios. Choosing the right kernel for each operation is critical for maximizing computational throughput, minimizing memory stalls, and ensuring that the accelerator's specialized processing elements are fully utilized [@nvidia_tensorRT_2021].

Kernel selection builds upon graph optimization, mapping the structured execution plan to the most efficient implementation available for each operation. Poor kernel choices can nullify the benefits of prior optimizations by introducing unnecessary computation overhead or memory bottlenecks [@chen2018tvm].

In a Transformer model, the matrix multiplications that dominate self-attention computations can be executed using different strategies depending on the available hardware. On a CPU, a general-purpose matrix multiplication routine is typically employed, exploiting vectorized execution to improve efficiency. In contrast, on a GPU, the compiler may select an implementation that leverages tensor cores to accelerate matrix multiplications using mixed-precision arithmetic. When the model is deployed on a TPU, the operation can be mapped onto a systolic array, ensuring that data flows through the accelerator in a manner that maximizes reuse and minimizes off-chip memory accesses. For inference workloads, an integer arithmetic kernel may be preferable, as it performs computations in INT8 instead of floating-point precision, thereby reducing power consumption without significantly compromising accuracy.

In many cases, compilers do not generate custom kernels from scratch but instead select from vendor-optimized kernel libraries that provide highly tuned implementations for different architectures. For instance, cuDNN\index{cuDNN!NVIDIA deep learning library} and cuBLAS\index{cuBLAS!NVIDIA linear algebra} offer optimized kernels for deep learning on NVIDIA GPUs, while oneDNN\index{oneDNN!Intel optimization library} provides optimized execution for Intel architectures. Similarly, ACL (Arm Compute Library) is optimized for Arm-based devices, and Eigen and BLIS provide efficient CPU-based implementations of deep learning operations. These libraries allow the compiler to choose pre-optimized, high-performance kernels rather than having to reinvent execution strategies for each hardware platform.

AI compilers use heuristics[^fn-heuristic-etymology], profiling, and cost models to determine the best kernel for each operation. These strategies ensure that each computation is executed in a way that maximizes throughput and minimizes memory bottlenecks.

[^fn-heuristic-etymology]: **Heuristic**: From Greek "heuriskein" (to discover), sharing roots with "eureka." A heuristic is a practical rule-of-thumb that finds good solutions quickly without exhaustively searching all possibilities. In AI compilers, heuristics encode expert knowledge about hardware behavior, enabling fast kernel selection decisions that would be intractable to compute optimally given the exponential search space of possible configurations.

In rule-based selection, the compiler applies predefined heuristics based on the known capabilities of the hardware. For instance, XLA, the compiler used in TensorFlow, automatically selects tensor core-optimized kernels for NVIDIA GPUs when mixed-precision execution is enabled. These predefined rules allow the compiler to make fast, reliable decisions about which kernel to use without requiring extensive analysis.

Profile-guided selection takes a more dynamic approach, benchmarking different kernel options and choosing the one that performs best for a given workload. TVM, an open-source AI compiler, uses AutoTVM to empirically evaluate kernel performance, tuning execution strategies based on real-world execution times. By testing different kernels before deployment, profile-guided selection helps ensure that operations are assigned to the most efficient implementation under actual execution conditions.

Another approach, cost model-based selection, relies on performance predictions to estimate execution time and memory consumption for various kernels before choosing the most efficient one. MLIR, a compiler infrastructure designed for machine learning workloads, applies this technique to determine the most effective tiling and memory access strategies [@mlir_framework_2021]. By modeling how different kernels interact with the accelerator's compute units and memory hierarchy, the compiler can select the kernel that minimizes execution cost while maximizing performance.

Many AI compilers also incorporate precision-aware kernel selection, where the selected kernel is optimized for specific numerical formats such as FP32, FP16, BF16, or INT8. Training workloads often prioritize higher precision (FP32, BF16) to maintain model accuracy, whereas inference workloads favor lower precision (FP16, INT8) to increase speed and reduce power consumption. For example, an NVIDIA GPU running inference with TensorRT can dynamically select FP16 or INT8 kernels based on a model's accuracy constraints. This trade-off between precision and performance is a key aspect of kernel selection, especially when deploying models in resource-constrained environments.

Some compilers go beyond static kernel selection and implement adaptive kernel tuning, where execution strategies are adjusted at runtime based on the system's workload and available resources. AutoTVM in TVM measures kernel performance across different workloads and dynamically refines execution strategies. TensorRT applies real-time optimizations based on batch size, memory constraints, and GPU load, adjusting kernel selection dynamically. Google's TPU compiler takes a similar approach, optimizing kernel selection based on cloud resource availability and execution environment constraints. The consequences of poor kernel selection are significant: if a Transformer model running on a GPU is assigned a non-tensor-core kernel for its matrix multiplications, it may execute at only a fraction of the possible performance. Conversely, if a model designed for FP32 execution is forced to run on an INT8-optimized kernel, it may experience numerical instability that degrades accuracy. Kernel selection is therefore as much about maintaining numerical correctness as it is about optimizing performance. {#sec-ai-acceleration-kernel-selection-importance-3c3f}

With kernel selection complete, the next stage in compilation involves memory planning and computation scheduling, where the compiler determines how data is allocated across the memory hierarchy and how kernels are launched for execution. As kernel selection determines what to execute, these subsequent phases dictate when and how those operations run, ensuring that AI accelerators operate at peak efficiency.

### Memory Planning {#sec-ai-acceleration-memory-planning-fb9f}

\index{Memory Planning!compiler phase}
The memory planning phase ensures that data is allocated and accessed in a way that minimizes memory bandwidth consumption, reduces latency, and maximizes cache efficiency [@zhang2020optimizing]. Even with the most optimized execution plan, a model can still suffer from severe performance degradation if memory is not managed efficiently.

Machine learning workloads are memory-intensive, requiring frequent movement of large tensors between different levels of the memory hierarchy. The compiler must determine how tensors are stored, how they are accessed, and how intermediate results are handled to prevent memory from becoming the bottleneck.

The memory planning phase optimizes tensor layouts, memory access patterns, and buffer reuse to prevent unnecessary stalls and memory contention during execution. Tensors are arranged in formats that align with hardware access patterns, minimizing format conversions. Memory accesses are structured to reduce cache misses and stalls, lowering overall bandwidth consumption. Buffer reuse reduces redundant memory allocations by managing intermediate results so that completed buffers are reclaimed promptly. Together, these strategies ensure that data is efficiently placed and accessed, enhancing both computational performance and energy efficiency.

Balancing memory availability, reuse, and access efficiency across multiple hierarchy levels makes memory planning one of the most complex compiler problems. AI compilers use several strategies to manage memory effectively and prevent unnecessary data movement.

Tensor layout optimization determines how tensors should be arranged in memory to maximize locality and prevent unnecessary format conversions. Different hardware accelerators have different preferred storage layouts. For instance, NVIDIA GPUs often use row-major storage (NHWC format), while TPUs favor channel-major layouts (NCHW format) to optimize memory coalescing [@abadi2016tensorflow]. The compiler automatically transforms tensor layouts based on the expected access patterns of the target hardware, ensuring that memory accesses are aligned for maximum efficiency.

Buffer allocation and reuse complements layout optimization: the compiler minimizes memory footprint by reusing intermediate storage whenever possible. Deep learning workloads generate many temporary tensors, such as activations and gradients, which can quickly overwhelm on-chip memory if not carefully managed. Instead of allocating new memory for each tensor, the compiler analyzes the computation graph to identify opportunities for buffer reuse, ensuring that intermediate values are stored and overwritten efficiently [@moreau2018relay].

Minimizing data movement between hierarchy levels is equally critical. AI accelerators typically have a mix of high-speed on-chip memory (such as caches or shared SRAM) and larger, but slower, external DRAM. If tensor data is repeatedly moved between these memory levels, the model may become memory-bound, reducing computational efficiency. To prevent this, compilers use tiling strategies that break large computations into smaller, memory-friendly chunks, allowing execution to fit within fast, local memory and reducing the need for costly off-chip memory accesses. The consequences of neglecting memory planning are concrete: a CNN running on a GPU may achieve high computational efficiency in theory, but if its convolutional feature maps are stored in an incompatible layout that necessitates repeated format conversions, the resulting overhead can negate the gains from graph optimization and kernel selection entirely. {#sec-ai-acceleration-memory-planning-importance-e987}

With memory allocation determined, the compiler must next decide when and where each computation executes.

### Computation Scheduling {#sec-ai-acceleration-computation-scheduling-7ccd}

\index{Computation Scheduling!parallel execution}
With graph optimization completed, kernels selected, and memory planning finalized, computation scheduling determines the execution order and resource assignment for each operation. This phase determines when and where each computation should be executed, ensuring that workloads are efficiently distributed across available processing elements while avoiding unnecessary stalls and resource contention [@Rajbhandari2020; @Zheng2020].

Without effective scheduling, massive parallelism goes to waste: computational units sit idle, memory bandwidth goes underutilized, and execution efficiency degrades. Computation scheduling keeps all processing elements active, manages execution dependencies correctly, and distributes workloads optimally [@Jia2019].

The scheduling phase coordinates parallel execution, synchronization, and resource allocation. Task partitioning decomposes computations into units that can be distributed among multiple compute cores. Execution order optimization determines the sequence for launching operations, maximizing hardware performance while reducing stalls. Resource allocation and synchronization ensure that compute cores, memory bandwidth, and shared caches are utilized without contention.

#### Implementation in AI Compilers {#sec-ai-acceleration-implementation-ai-compilers-ff25}

Scheduling strategies are highly dependent on the underlying hardware architecture, since different AI accelerators have unique execution models. AI compilers implement several strategies to optimize scheduling for efficient execution.

Task partitioning divides large computational graphs into smaller units that can execute in parallel. On GPUs, this typically means mapping matrix multiplications and convolutions to thousands of CUDA cores, while on TPUs, tasks are partitioned to fit within systolic arrays that operate on structured data flows [@norrie2021design]. In CPUs, partitioning is often focused on breaking computations into vectorized chunks that align with SIMD execution. In each case, the goal is to keep every core active throughout execution.

Beyond task partitioning, scheduling involves optimizing execution order to minimize dependencies and maximize throughput. Many AI models include operations that can be computed independently (e.g., different batches in a batch processing pipeline) alongside operations that have strict dependencies (e.g., recurrent layers in an RNN). AI compilers analyze these dependencies and attempt to rearrange execution where possible, reducing idle time and improving parallel efficiency. For example, in Transformer models, scheduling may prioritize preloading attention matrices into memory while earlier layers are still executing, ensuring that data is ready when needed [@Shoeybi2019].

Resource allocation and synchronization determines how compute cores share memory and coordinate execution. Modern AI accelerators often support overlapping computation and data transfers, meaning that while one task executes, the next task can begin fetching its required data. Compilers take advantage of this by scheduling tasks in a way that hides memory latency, ensuring that execution remains compute-bound rather than memory-bound [@chen2018tvm]. TensorRT and XLA, for example, employ streaming execution strategies where multiple kernels are launched in parallel, and synchronization is carefully managed to prevent execution stalls [@GoogleXLA]. Poor scheduling decisions can negate the benefits of all prior compilation phases: a CNN with highly optimized kernels and efficient memory layouts will still suffer reduced throughput if compute units remain idle between kernel launches, and a Transformer on a TPU may underperform if attention layers are not scheduled to overlap with memory transfers. {#sec-ai-acceleration-computation-scheduling-importance-04a1}

With scheduling complete, the final compilation stage translates this optimized execution plan into hardware-specific instructions.

#### Code Generation {#sec-ai-acceleration-code-generation-85c8}

\index{Code Generation!hardware-specific instructions}
Unlike the previous phases, which required AI-specific optimizations, code generation follows many of the same principles as traditional compilers. This process includes instruction selection, register allocation, and final optimization passes, ensuring that execution makes full use of hardware-specific features such as vectorized execution, memory prefetching, and instruction reordering.

For CPUs and GPUs, AI compilers typically generate machine code or optimized assembly instructions, while for TPUs, FPGAs\index{FPGA!Field-Programmable Gate Array}[^fn-fpga], and other accelerators, the output may be optimized bytecode or execution graphs that are interpreted by the hardware's runtime system.

[^fn-fpga]: **FPGA (Field-Programmable Gate Array)**: "Field-programmable" means configurable after leaving the factory, in the customer's "field" of deployment, contrasting with factory-programmed ASICs. Xilinx (now AMD) introduced the first commercial FPGA in 1985. The "gate array" refers to the matrix of logic blocks that can be wired together through programmable interconnects. FPGAs achieve 2–10× better performance per watt than GPUs for specific workloads but require hardware description languages (Verilog/VHDL), limiting adoption compared to GPU programming.

At this point, the compilation pipeline is complete: the original high-level model representation has been transformed into an optimized, executable format tailored for efficient execution on the target hardware. The combination of graph transformations, kernel selection, memory-aware execution, and parallel scheduling ensures that AI accelerators run workloads with maximum efficiency, minimal memory overhead, and optimal computational throughput.

### From Compilation to Runtime {#sec-ai-acceleration-compilationruntime-support-0206}

The compiler transforms high-level machine learning models into optimized execution plans tailored to specialized hardware. Graph optimization restructures computation, kernel selection maps operations to hardware-efficient implementations, memory planning optimizes data placement, and computation scheduling ensures efficient parallel execution. Together, these phases enable AI models to fully utilize modern accelerators with high throughput, minimal memory overhead, and efficient execution pipelines.

All compiler optimizations share a critical limitation: they occur *before* execution begins. This static nature is both a strength, enabling aggressive whole-program optimization, and a weakness, unable to adapt when reality diverges from assumptions. The compiler makes decisions based on what it *expects* to happen, not what *actually* happens. Graph restructuring, kernel selection, memory planning, and computation scheduling all produce a single, optimized execution plan based on assumptions about batch sizes, dedicated hardware availability, and clean memory state.

Production AI systems inhabit a dynamic world that rarely matches these static assumptions. Batch sizes vary from 1 (latency-sensitive single requests) to 128 (throughput-oriented batch serving) within the same deployment. GPU memory fragments during long-running inference servers, forcing suboptimal tensor layouts. Multiple workloads compete for accelerator resources in multi-tenant cloud environments. Thermal throttling reduces sustained performance below the peaks observed in short benchmarks. The runtime system bridges static optimization and dynamic reality, continuously adapting execution to actual conditions rather than assumed conditions.

## Runtime Support {#sec-ai-acceleration-runtime-support-f94f}

\index{AI Runtime!dynamic execution management}
AI runtimes bridge this gap by providing a dynamic layer of execution management that extends compile-time optimizations with real-time decision-making [@nvidia_tensorRT_2021]. Unlike traditional compiled programs that execute a fixed instruction sequence, AI workloads require adaptive control over memory allocation, kernel execution, and resource scheduling — continuously monitoring execution conditions and making on-the-fly adjustments to maintain hardware utilization despite changing production conditions.

AI runtimes manage three interrelated aspects of execution. First, kernel execution management: runtimes dynamically select and dispatch computation kernels based on the current system state to minimize latency. Second, memory adaptation: because AI workloads process large tensors with varying footprints, runtimes adjust allocation dynamically to prevent bottlenecks and excessive data movement [@deepmind_gpipe_2019]. Third, execution scaling: runtimes distribute workloads across multiple accelerators for multi-chip, multi-node, or cloud environments [@mirhoseini_device_placement_2017].

AI runtimes complement compiler-based optimizations by handling these execution aspects dynamically. Comparing AI runtimes to traditional software runtimes clarifies why machine learning workloads require specialized execution strategies.

### ML Runtime Architecture {#sec-ai-acceleration-runtime-architecture-differences-ml-systems-932e}

\index{AI Runtime!vs traditional runtime}
Traditional software runtimes are designed for managing general-purpose program execution, primarily handling sequential and multi-threaded workloads on CPUs. These runtimes allocate memory, schedule tasks, and optimize execution at the level of individual function calls and instructions. In contrast, AI runtimes are specialized for machine learning workloads, which require massively parallel computation, large-scale tensor operations, and dynamic memory management.

@tbl-runtime-comparison highlights the key differences between traditional and AI runtimes. One of the key distinctions lies in execution flow. Traditional software runtimes operate on a predictable, structured execution model where function calls and CPU threads follow a predefined control path. AI runtimes, however, execute computational graphs, requiring complex scheduling decisions that account for dependencies between tensor operations, parallel kernel execution, and efficient memory access.

| **Aspect**                  | **Traditional Runtime**                | **AI Runtime**                                          |
|:--------------------------|:-------------------------------------|:------------------------------------------------------|
| **Execution Model**         | Sequential or multi-threaded execution | Massively parallel tensor execution                     |
| **Task Scheduling**         | CPU thread management                  | Kernel dispatch across accelerators                     |
| **Memory Management**       | Static allocation (stack/heap)         | Dynamic tensor allocation, buffer reuse                 |
| **Optimization Priorities** | Low-latency instruction execution      | Minimizing memory stalls, maximizing parallel execution |
| **Adaptability**            | Mostly static execution plan           | Adapts to batch size and hardware availability          |
| **Target Hardware**         | CPUs (general-purpose execution)       | GPUs, TPUs, and custom accelerators                     |

: **Runtime Execution Models.** Traditional runtimes prioritize sequential or multi-threaded instruction processing, while AI runtimes use massively parallel tensor operations for accelerated computation on machine learning workloads. This divergence necessitates specialized AI runtime architectures designed for efficient parallelization and memory management of large-scale tensor data. {#tbl-runtime-comparison}

Memory management is another major differentiator. Traditional software runtimes handle small, frequent memory allocations, optimizing for cache efficiency and low-latency access. AI runtimes, in contrast, must dynamically allocate, reuse, and optimize large tensors, ensuring that memory access patterns align with accelerator-friendly execution. Poor memory management in AI workloads can lead to performance bottlenecks, particularly due to excessive off-chip memory transfers and inefficient cache usage.

AI runtimes are inherently designed for adaptability. While traditional runtimes often follow a mostly static execution plan, AI workloads typically operate in highly variable execution environments, such as cloud-based accelerators or multi-tenant hardware. As a result, AI runtimes must continuously adjust batch sizes, reallocate compute resources, and manage real-time scheduling decisions to maintain high throughput and minimize execution delays.

AI runtimes must oversee large-scale tensor execution, multi-device coordination, and real-time workload adaptation, all of which become acutely visible when models move from development to production.

```{python}
#| echo: false
#| label: runtime-production-tdp
# ┌─────────────────────────────────────────────────────────────────────────────
# │ A100 TDP FOR THERMAL THROTTLING EXAMPLE
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: "When Production Differs from Development" callout
# │
# │ Why: Illustrates how thermal design power differs between A100 variants
# │      (SXM vs PCIe), explaining why production performance can differ from
# │      development benchmarks due to thermal throttling.
# │
# │ Imports: mlsys.constants (A100_TDP)
# │ Exports: a100_tdp
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.constants import A100_TDP, watt

# --- Outputs (formatted strings for prose) ---
a100_tdp = f"{A100_TDP.to(watt).magnitude:.0f}"  # e.g. "400"
```

::: {.callout-perspective title="When Production Differs from Development"}

Runtime behavior often surprises engineers who optimized their models in development environments. Common production surprises include:

**Variable batch sizes**: Training uses fixed batch sizes, but production inference may receive single requests (batch=1) or bursts (batch=64+). Runtimes must handle both efficiently. Single requests need latency optimization; bursts need throughput optimization.

**Memory fragmentation**: Long-running inference servers gradually fragment GPU memory. Runtimes implement defragmentation strategies, but understanding when to restart services or pre-allocate memory pools requires awareness of these dynamics.

**Multi-tenant interference**: Cloud accelerators are often shared. Your model might run 20% slower when a neighbor's workload competes for memory bandwidth. Production systems need monitoring to detect and respond to this interference.

**Thermal throttling**: Sustained workloads may trigger thermal throttling that wasn't observed in short benchmarks. The A100 SXM operates at `{python} a100_tdp` W TDP while the A100 PCIe operates at 300W TDP; these represent different form factors with different cooling requirements, not boost versus sustained states. Production performance depends on which variant is deployed and whether thermal limits are approached.

Understanding runtime adaptation mechanisms helps engineers design systems that degrade gracefully rather than fail unexpectedly.

:::

### Dynamic Kernel Execution {#sec-ai-acceleration-dynamic-kernel-execution-33fc}

\index{Dynamic Kernel Execution!runtime adaptation}
While static compilation provides a solid foundation, efficient execution of machine learning workloads requires real-time adaptation to fluctuating conditions: available memory, data sizes, and computational loads all change during execution. The runtime continuously adjusts execution strategies to match both hardware constraints and workload characteristics.

Individual computational operations (matrix multiplications, convolutions, activation functions) must be assigned to appropriate processing units, and this mapping is not fixed. As input data, memory availability, and system load change during execution, the runtime makes real-time decisions about kernel selection, execution order, and memory management to keep workloads efficient despite shifting conditions.

For example, consider an AI accelerator executing a deep neural network (DNN) for image classification. If an incoming batch of high-resolution images requires significantly more memory than expected, a statically planned execution may cause cache thrashing or excessive off-chip memory accesses. Instead, a dynamic runtime can adjust tiling strategies on the fly, breaking down tensor operations into smaller tiles that fit within the high-speed on-chip memory. This prevents memory stalls and ensures optimal utilization of caches.

Similarly, when running a transformer-based NLP model, the sequence length of input text may vary between inference requests. A static execution plan optimized for a fixed sequence length may lead to underutilization of compute resources when processing shorter sequences or excessive memory pressure with longer sequences. Dynamic kernel execution can mitigate this by selecting different kernel implementations based on the actual sequence length, dynamically adjusting memory allocations and execution strategies to maintain efficiency.

\index{Double Buffering!latency hiding}
Overlapping computation with memory movement mitigates a common performance bottleneck: data movement between memory hierarchies limiting computation speed. AI runtimes implement asynchronous execution and double buffering so that computations proceed without waiting for memory transfers to complete. In a large-scale model, for instance, image data can be prefetched while computations are performed on the previous batch, thus maintaining a steady flow of data and avoiding pipeline stalls.

Consider the execution of convolutional layers in a CNN on a GPU. If multiple convolution kernels need scheduling, static approaches may lead to inefficient resource utilization due to variation in layer sizes and compute requirements. Dynamic scheduling allows AI runtimes to prioritize smaller kernels when compute units are partially occupied, improving hardware utilization. For instance, in NVIDIA's TensorRT runtime, fusion of small kernels into larger execution units is done dynamically to avoid launch overhead, optimizing latency-sensitive inference tasks.

Dynamic adjustment of execution strategies in response to real-time system conditions optimizes both training and inference performance across hardware platforms. Beyond execution strategy adaptation, runtimes must also select which specific kernel implementations to invoke for each operation.

### Runtime Kernel Selection {#sec-ai-acceleration-runtime-kernel-selection-1ffe}

While compilers perform an initial selection of kernels based on static analysis, AI runtimes often need to override these decisions during execution. Real-time factors, such as available memory, hardware utilization, and workload priorities, may differ significantly from the assumptions made during compilation. By dynamically selecting and switching kernels at runtime, AI runtimes can adapt to these changing conditions, ensuring that models continue to perform efficiently.

For instance, consider transformer-based language models, where a significant portion of execution time is spent on matrix multiplications. The AI runtime must determine the most efficient way to execute these operations based on the current system state. If the model is running on a GPU with specialized Tensor Cores, the runtime may switch from a standard FP32 kernel to an FP16 kernel to take advantage of hardware acceleration [@Shoeybi2019]. Conversely, if the lower precision of FP16 causes unacceptable numerical instability, the runtime can opt for mixed-precision execution, selectively using FP32 where higher precision is necessary.

Memory constraints also influence kernel selection. When memory bandwidth is limited, the runtime may adjust its execution strategy, reordering operations or changing the tiling strategy to fit computations into the available cache rather than relying on slower main memory. For example, a large matrix multiplication may be broken into smaller chunks, ensuring that the computation fits into the on-chip memory of the GPU, reducing overall latency.

Batch size also influences kernel selection. For workloads that handle a mix of small and large batches, the AI runtime may choose a latency-optimized kernel for small batches and a throughput-optimized kernel for large-scale batch processing. This adjustment ensures that the model continues to operate efficiently across different execution scenarios, without the need for manual tuning. Once the appropriate kernel is selected, the runtime must schedule its execution to maximize hardware utilization.

### Kernel Scheduling and Utilization {#sec-ai-acceleration-kernel-scheduling-utilization-99d6}

\index{Kernel Scheduling!hardware utilization}
Kernel scheduling ensures that selected kernels execute in a way that maximizes parallelism and resource utilization. Unlike traditional task schedulers that manage CPU threads, AI runtimes coordinate a much larger number of tasks across parallel execution units: GPU cores, tensor processing units, or custom AI accelerators [@jouppi2017datacenter]. Keeping these resources fully engaged prevents bottlenecks and maximizes throughput.

For example, in image recognition models that use convolutional layers, operations can be distributed across multiple processing units, enabling different filters to run concurrently. This parallelization ensures that the available hardware is fully utilized, speeding up execution. Similarly, batch normalization and activation functions must be scheduled efficiently to avoid unnecessary delays. If these operations are not interleaved with other computations, they may block the pipeline and reduce overall throughput.

Efficient kernel scheduling can also be influenced by real-time memory management. AI runtimes ensure that intermediate data, such as feature maps in deep neural networks, are preloaded into cache before they are needed. This proactive management helps prevent delays caused by waiting for data to be loaded from slower memory tiers, ensuring continuous execution.

Together, these techniques ensure optimal resource utilization and efficient parallel computation across multiple hardware accelerators.

The compiler and runtime systems examined thus far optimize execution within single accelerators, but the largest AI workloads exceed what any single chip can deliver. Single-chip optimizations achieve impressive results: ResNet-50 inference accelerates from 47 ms to 8 ms through compiler optimization alone, and the dataflow strategies we examined can push GPU utilization from 20% to 80% of peak throughput. Yet for the largest AI workloads, even perfectly optimized single-chip execution proves insufficient.

Consider the scale of training GPT-3, which required approximately $3.14 \times 10^{23}$ floating-point operations [@brown2020language], a number so large it defies intuition without concrete comparison. To grasp this magnitude: even at the H100's peak FP16 throughput of nearly 2 petaFLOPS, completing this computation on a single accelerator would require over five years of continuous operation at theoretical peak, and considerably longer at realistic utilization rates of 40–60%. Real-time inference serving for global applications like ChatGPT or Google Search demands throughput beyond any single accelerator's capacity, requiring distributed inference across hundreds of chips. These computational requirements necessitate scaling beyond single-chip systems, introducing different engineering challenges from those we have examined.

## Multi-Chip Scaling {#sec-ai-acceleration-scaling-beyond-single}

\index{Multi-Chip Scaling!beyond single accelerator}
This section provides awareness of multi-chip scaling while maintaining our focus on single-machine systems. The techniques we have covered, dataflow optimization, kernel fusion, memory hierarchy exploitation, and compiler optimization, remain the foundation for efficient execution even in distributed settings. Each individual accelerator in a multi-chip system must still be optimized using these principles. However, multi-chip architectures introduce additional concerns around communication overhead, memory coherence, and fault tolerance that transform optimization priorities. The detailed implementation of distributed training systems, including gradient synchronization protocols, parameter server architectures, and cluster-scale orchestration, is covered in advanced treatments of machine learning infrastructure.

When single-accelerator capacity proves insufficient, AI systems must scale across multiple chips. Understanding these scaling approaches is important for practitioners who will encounter multi-chip systems in production environments, even when working primarily with single-accelerator deployments.

### Multi-Chip Scaling Approaches {#sec-ai-acceleration-multichip-scaling-approaches}

Modern AI systems employ several strategies to scale beyond individual accelerators, each with distinct trade-offs.

\index{Chiplet!modular die interconnect}
One approach partitions large designs into smaller, modular dies interconnected within a single package (chiplet-based architectures). This approach bypasses manufacturing limits of monolithic chips while maintaining relatively low communication latency within the package.

When even greater compute capacity is required, systems connect multiple discrete accelerators, each with dedicated memory and compute resources. This enables workloads to be split using data parallelism\index{Data Parallelism!multi-accelerator scaling} (each accelerator processes different batches) or model parallelism\index{Model Parallelism!multi-accelerator scaling} (different accelerators handle different network layers). High-bandwidth intra-node interconnects can enable efficient gradient synchronization across the system, though realized performance depends on topology and collective communication efficiency.

At data center scale, purpose-built interconnect fabrics enable hundreds of accelerators to work together. Cluster topology and collective communication algorithms become central determinants of scaling efficiency, and near-linear scaling is achievable on some workloads when communication overhead is controlled.

The most aggressive scaling approach treats an entire silicon wafer as a unified compute fabric. Wafer-scale integration platforms (e.g., Cerebras WSE-class systems) integrate extremely large numbers of transistors and cores on a single device, reducing or eliminating inter-chip communication overhead. This approach introduces its own challenges in thermal dissipation, fault tolerance, and manufacturing yield, representing the frontier of single-system compute density.

### Why Scaling Introduces New Constraints {#sec-ai-acceleration-why-scaling-constraints}

\index{Scaling Constraints!communication overhead}
The transition from single-chip to multi-chip architectures introduces qualitatively different constraints that reshape system optimization.

\index{Amdahl's Law!distributed training limit}
Communication overhead emerges as the primary limit on scaling efficiency. Amdahl's Law[^fn-amdahls-law-distributed] quantifies how communication during gradient synchronization creates sequential bottlenecks. For hundred-billion-parameter-scale models, AllReduce operations can require exchanging hundreds of gigabytes of gradients per training step.

[^fn-amdahls-law-distributed]: Recall from @sec-ml-system-architecture that Amdahl's Law limits speedup based on the serial fraction of computation. For distributed training, this serial fraction includes gradient synchronization (a core component of distributed training in @sec-ai-training-scaling-beyond-single-node-a671), which at 5% overhead caps maximum speedup at 20× regardless of GPU count. This explains why scaling efficiency degrades at large cluster sizes and motivates algorithmic innovations like gradient compression and communication-computation overlap.

This communication overhead explains why scaling to very large accelerator counts can show diminishing returns without algorithmic innovations like gradient compression, overlap, or alternative parallelization strategies.

\index{Memory Coherence!distributed system challenge}
Memory coherence presents another challenge at scale. Ensuring all processors see consistent views of shared memory adds 10–50 ns latency per access in traditional coherence protocols. For AI accelerators with thousands of cores, this overhead becomes prohibitive, forcing explicit memory management where programmers control data placement and synchronization manually.

As systems grow larger, fault tolerance requirements increase correspondingly. Large-scale systems must handle component failures gracefully since the probability of at least one failure increases with system size. TPU Pods implement specialized consensus algorithms to maintain training consistency when optical links fail, while wafer-scale systems incorporate redundant cores to tolerate localized silicon defects.

Perhaps most significantly, the energy costs of data movement come to dominate system design. Moving data across a TPU Pod's optical interconnect can consume orders of magnitude more energy than on-chip communication within individual TPUs. This energy differential transforms distributed training into a careful balance between computation parallelism and communication efficiency, a concern that shapes both hardware architecture and algorithm design.

Data center scaling and edge deployment represent opposite ends of a deployment spectrum, yet they share the same core principles. Data center scaling asks "how do we coordinate many powerful chips?" while edge scaling asks "how do we fit useful AI into a few constrained watts?" Both questions share a common answer: match workload characteristics to hardware capabilities while minimizing data movement. The principles of compute specialization, memory hierarchy optimization, and workload mapping apply at both scales; only the constraints differ. Data centers optimize for aggregate throughput within power budgets measured in megawatts; edge devices optimize for responsiveness within power budgets measured in milliwatts. To make this concrete: the same ResNet-50 inference we analyzed throughout this chapter must also execute within a 5 W power envelope and a 30 ms latency target on a smartphone, constraints that require a radically different approach to the same acceleration principles.

## Heterogeneous SoC Design {#sec-ai-acceleration-heterogeneous-soc-ai-acceleration-b1bb}

\index{System-on-Chip!heterogeneous AI acceleration}
At the edge end of the deployment spectrum, the hardware acceleration principles established in this chapter (specialized compute units, memory hierarchy optimization, and workload mapping strategies) must operate under dramatically different constraints. A smartphone's SoC operates within a 3–7 watt sustained power budget (with brief peaks to 10–15 W), autonomous vehicles require deterministic sub-100 ms latency for perception-to-action loops, and IoT sensors must function for months to years on battery power. These constraints necessitate heterogeneous System-on-Chip (SoC) architectures that integrate CPU cores, GPU shaders, digital signal processors (DSPs), and dedicated neural processing units (NPUs) within a single chip. Orchestrating these diverse processors to achieve optimal performance under strict power, thermal, and latency requirements demands wholly different approaches than data center deployments.

::: {.callout-lighthouse title="The Case for Heterogeneous Microcontrollers"}
**The Extreme Edge**: The **Smart Doorbell** (Wake Vision) pushes heterogeneity to its logical limit. Unlike a smartphone SoC with a multi-watt budget, a doorbell camera often runs on a microcontroller with a **milliwatt budget**.

To achieve real-time person detection (30 FPS) within this envelope, modern MCUs adopt the same heterogeneous strategy as their larger mobile cousins but at a micro-scale. A typical architecture pairs a general-purpose core (e.g., Cortex-M) for system logic with a dedicated micro-NPU (e.g., Ethos-U\index{Ethos-U!ARM micro-NPU}) for CNN acceleration. The NPU executes the Wake Vision MobileNet model at 50–100$\times$ better energy efficiency than the CPU could achieve alone. Without this specialized acceleration, the "always-on" promise of the Smart Doorbell would remain physically impossible.
:::

### Mobile SoC Architecture Evolution {#sec-ai-acceleration-mobile-soc-architecture-evolution-6ca8}

\index{Mobile SoC!architecture evolution}
Qualcomm's Snapdragon AI Engine\index{Snapdragon!AI Engine}\index{Qualcomm!Snapdragon} exemplifies heterogeneous computing\index{Heterogeneous Computing!mobile SoC} for mobile AI, coordinating CPU cores, GPU shaders, a DSP\index{DSP!Digital Signal Processor}, and a dedicated NPU\index{NPU!Neural Processing Unit}[^fn-npu-architecture] across a shared memory hierarchy. Modern mobile SoCs use workload distribution so that computer vision kernels can execute on the GPU's parallel shaders, audio processing can use DSP arithmetic units, and transformer attention mechanisms can utilize NPU-optimized matrix engines. This coordination requires careful scheduling to meet real-time constraints while managing thermal throttling and battery life.

[^fn-npu-architecture]: NPUs (introduced in @sec-ml-system-architecture) excel at low-power inference on common operator patterns but have less programmability than GPUs. From an architecture perspective, NPUs achieve efficiency by hardcoding common dataflows (systolic arrays for matrix multiplication) rather than supporting general computation, trading flexibility for 10–100× better energy efficiency on supported operations.

\index{Unified Memory Architecture!mobile SoC}
While Qualcomm's approach emphasizes diverse processor specialization, vertically integrated strategies highlight how tight hardware-software co-design can enable tightly coordinated heterogeneous execution. Unified memory architectures can reduce explicit data copying overhead, and different compute blocks can be scheduled for different operator types (for example, matrix-heavy layers on an NPU, convolutional operators on a GPU, and control flow on the CPU). This coordination supports interactive on-device experiences, though realized latency depends on the full pipeline and device thermal conditions.

Beyond vertically integrated solutions, IP licensing models allow SoC designers to customize processor combinations based on target applications, mixing CPU, GPU, DSP, and NPU blocks. This modular flexibility allows automotive SoCs to emphasize deterministic real-time processing while smartphone SoCs optimize for interactive performance and battery efficiency.

### Strategies for Dynamic Workload Distribution {#sec-ai-acceleration-strategies-dynamic-workload-distribution-a421}

\index{Workload Distribution!heterogeneous processor}
With multiple specialized processors available on heterogeneous SoCs, the critical challenge becomes intelligently distributing neural network operations across these resources to maximize performance while respecting power and latency constraints.

Modern neural networks require intelligent partitioning across heterogeneous processors based on operation characteristics and current system state. Convolutional layers with regular data access patterns typically execute efficiently on GPU shader cores, while fully connected layers with irregular sparsity patterns may perform better on general-purpose CPU cores with large caches. Attention mechanisms in transformers benefit from NPU matrix engines when sequences are long, but may execute more efficiently on CPU when sequence lengths are small due to the NPU setup overhead.

Beyond static operation-to-processor mapping, heterogeneous SoCs implement dynamic processor selection governed by real-time constraints. Power budget dictates routing: during battery operation, the system may route computations to lower-power DSP cores rather than high-performance GPU cores. Thermal state introduces another dimension: when approaching thermal limits, workloads shift from the power-hungry NPU to more efficient CPU execution. Safety-critical automotive applications add latency requirements that prioritize deterministic CPU execution over potentially faster but variable NPU processing. Finally, concurrent workload interference from multiple AI applications may require load balancing across available processors to maintain Quality of Service.

Compounding the processor selection challenge, shared memory architectures require priority-based arbitration when multiple processors access LPDDR simultaneously. The Snapdragon 8 Gen 3's memory controller implements priority-based scheduling where camera processing receives higher priority than background AI tasks, ensuring real-time video processing while background neural networks adapt their execution patterns to available memory bandwidth. This arbitration becomes critical during memory-intensive operations like large language model inference, where parameter streaming from DRAM must be carefully coordinated across processors.

### Power and Thermal Management {#sec-ai-acceleration-power-thermal-management-6c00}

\index{Power Management!mobile AI}\index{Thermal Management!mobile constraints}\index{DVFS!power-performance envelope}Mobile AI workloads must maintain high performance while operating within strict power budgets and thermal envelopes. These constraints require tight coordination across heterogeneous processors.

Heterogeneous SoCs implement coordinated DVFS\index{DVFS!Dynamic Voltage Frequency Scaling} across multiple processors to optimize the power-performance envelope. When one processor increases frequency to meet latency demands, the system may reduce voltage on other processors to maintain total power budget. This coordination becomes complex in AI workloads where computational phases may shift rapidly between processors. The system must predict upcoming workload transitions to preemptively adjust operating points while avoiding voltage/frequency oscillations that degrade efficiency.

When DVFS alone cannot maintain the power envelope, mobile SoCs implement thermal throttling\index{Thermal Throttling!intelligent migration} through intelligent task migration rather than simple frequency reduction. When the NPU approaches thermal limits during intensive neural network processing, the runtime system can migrate layers to the GPU or CPU while maintaining computational throughput. This approach preserves performance during thermal events, though it requires detailed workload characterization to predict execution time and power consumption across different processors.

Beyond real-time power and thermal management, mobile AI systems must also adapt their computational strategies based on battery state and charging status. During low battery conditions, the system may switch from high-accuracy models to efficient approximations, migrate workloads from power-hungry NPU to energy-efficient DSP, or reduce inference frequency while maintaining application responsiveness. Conversely, during charging, the system can enable higher-performance models and increase processing frequency to deliver enhanced user experiences.

### Automotive Heterogeneous AI Systems {#sec-ai-acceleration-automotive-heterogeneous-ai-systems-deda}

\index{Automotive AI!real-time safety requirements}
Automotive applications introduce unique heterogeneous computing challenges that combine mobile-style power efficiency with hard real-time latency requirements and functional safety requirements. This combination demands distinct architectural approaches.

Automotive SoCs aim to provide deterministic inference latency for safety-critical functions while supporting advanced driver assistance systems (ADAS). The Snapdragon Ride platform coordinates multiple AI accelerators across safety domains. Redundant processing elements support functional safety objectives while high-performance accelerators handle perception, planning, and control algorithms. This architecture requires temporal isolation between safety-critical and convenience functions, implemented through hardware partitioning and time-triggered scheduling.

These safety requirements become even more complex when considering that modern vehicles integrate multiple AI-enabled SoCs for different domains. Vision processing SoCs handle camera-based perception, radar processing SoCs manage RF sensor data, while central compute platforms coordinate high-level decision making. These distributed systems must maintain temporal coherence across sensor modalities with microsecond-precision timing, requiring specialized inter-SoC communication protocols and distributed synchronization mechanisms.

Extending beyond the vehicle's internal sensors, vehicle-to-everything (V2X) communication adds another layer of heterogeneous processing where AI algorithms must coordinate local sensor processing with information received from other vehicles and infrastructure. This requires ultra-low latency processing chains where 5G modems, AI accelerators, and control systems operate within millisecond deadlines while maintaining functional safety requirements.

### Software Stack Challenges {#sec-ai-acceleration-software-stack-challenges-255c}

The architectural sophistication of heterogeneous SoCs creates substantial software development challenges that span programming models, memory management, and runtime optimization.

\index{OpenCL!cross-processor execution}\index{TensorFlow Lite!mobile inference}
Programming heterogeneous SoCs requires frameworks that abstract processor differences while exposing performance-critical optimization opportunities. OpenCL and Vulkan provide cross-processor execution, but achieving optimal performance requires processor-specific optimizations that complicate portable development. Modern ML frameworks like TensorFlow Lite and PyTorch Mobile implement automatic processor selection, but developers still need to understand heterogeneous execution patterns to achieve optimal results.

Shared memory architectures compound the programming challenge: memory management must account for processor-specific caching behaviors, memory access patterns, and coherency requirements. CPU caches may interfere with GPU memory access patterns, while NPU direct memory access (DMA) operations must be synchronized with CPU cache operations to maintain data consistency.

Heterogeneous SoCs address this complexity through machine learning-based runtime optimization that learns from execution patterns to improve processor selection, thermal management, and power allocation. These systems collect telemetry on workload characteristics, processor utilization, and power consumption to build models that predict optimal execution strategies for new workloads.

No single processor architecture can optimally handle the diverse computational patterns in modern AI applications, making heterogeneous acceleration the prevailing direction of computing. Understanding these coordination challenges is essential for developing efficient mobile AI systems that deliver high performance within strict power, thermal, and real-time constraints.

The complexity of hardware acceleration, spanning data center architectures to heterogeneous mobile SoCs, creates opportunities for misconception and suboptimal design decisions. The following section distills common errors that waste expensive accelerator resources and lead to deployments achieving only a fraction of theoretical performance.

## Fallacies and Pitfalls {#sec-ai-acceleration-fallacies-pitfalls-dc1f}

Hardware acceleration involves counterintuitive performance characteristics where impressive specifications mask underlying bottlenecks. The fallacies and pitfalls below capture hardware selection and optimization errors that waste expensive accelerator resources and lead to deployments that achieve only 10-30% of theoretical performance.

**Fallacy:** *More specialized hardware always provides better performance than general-purpose alternatives.*

\index{Hardware Selection!workload matching}
Engineers assume specialized accelerators automatically outperform general-purpose processors for all AI workloads. In reality, specialized hardware achieves peak performance only when workloads match architectural assumptions. As demonstrated in @sec-ai-acceleration-measuring-efficiency, operations must exceed the accelerator's ridge point to be compute-bound; an A100 GPU has a ridge point of `{python} a100_ridge` FLOP/byte, meaning operations with arithmetic intensity below this threshold are memory-bound regardless of the accelerator's `{python} a100_tflops_fp16` TFLOPS peak compute. A transformer attention softmax with AI = 2-5 FLOP/byte achieves only 4–10 TFLOPS (3% utilization) on an A100, while achieving 80–90% of a CPU's lower peak because CPUs have ridge points of 10–20 FLOP/byte. Models with irregular memory access, small batch sizes, or dynamic computation graphs may perform better on flexible processors. Effective hardware selection requires matching workload arithmetic intensity to architectural ridge points, not assuming specialization always wins.

```{python}
#| label: fp-memory-energy-calc
#| echo: false
# ┌─────────────────────────────────────────────────────────────────────────────
# │ F&P: MEMORY BANDWIDTH ENERGY COSTS
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: Pitfall about ignoring memory bandwidth limitations
# │
# │ Why: Quantifies the energy penalty of DRAM vs on-chip memory and shows
# │      how low-AI operations like LayerNorm achieve <1% utilization on
# │      high-compute accelerators.
# │
# │ Imports: mlsys.constants (ENERGY_DRAM_ACCESS_PJ, ENERGY_SRAM_L1_PJ),
# │          mlsys.formatting (fmt)
# │ Exports: fp_ridge_example_str, fp_layernorm_tflops_str,
# │          fp_layernorm_util_str
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.formatting import fmt
from mlsys.constants import ENERGY_DRAM_ACCESS_PJ, ENERGY_SRAM_L1_PJ

# --- DRAM vs on-chip energy ratio ---
dram_pj = ENERGY_DRAM_ACCESS_PJ.magnitude
sram_pj = ENERGY_SRAM_L1_PJ.magnitude
energy_ratio = int(dram_pj / sram_pj)

# --- Ridge point for hypothetical 300 TFLOPS / 2 TB/s accelerator ---
fp_ridge_example = 300 / 2
fp_ridge_example_str = fmt(fp_ridge_example, precision=0, commas=False)

# --- LayerNorm utilization example ---
layernorm_ai = 1.5
layernorm_tflops = layernorm_ai * 2000 / 1000
layernorm_util = layernorm_tflops / 300 * 100
fp_layernorm_tflops_str = fmt(layernorm_tflops, precision=0, commas=False)
fp_layernorm_util_str = fmt(layernorm_util, precision=0, commas=False)
```

**Pitfall:** *Ignoring memory bandwidth limitations when selecting acceleration strategies.*

Practitioners focus on peak TFLOPS without analyzing whether their workloads can achieve compute-bound performance. As quantified in @sec-ai-acceleration-understanding-ai-memory-wall-3ea9, accessing DRAM consumes 100-200 pJ per access versus 1-10 pJ for on-chip memory, creating orders-of-magnitude energy penalties. An accelerator advertising 300 TFLOPS with 2 TB/s bandwidth has a ridge point of `{python} fp_ridge_example_str` FLOP/byte; LayerNorm operations with AI = 1.5 FLOP/byte achieve only `{python} fp_layernorm_tflops_str` TFLOPS (`{python} fp_layernorm_util_str`% utilization). Organizations deploy expensive high-compute accelerators for memory-bound workloads, achieving 10–20% utilization when lower-cost, bandwidth-optimized alternatives would perform identically. Teams must calculate workload arithmetic intensity and compare against hardware ridge points before purchasing accelerators.

```{python}
#| label: fp-multigpu-scaling-calc
#| echo: false
# ┌─────────────────────────────────────────────────────────────────────────────
# │ F&P: MULTI-GPU SCALING OVERHEAD
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: Fallacy about linear multi-GPU scaling
# │
# │ Why: Quantifies NVLink bandwidth and gradient synchronization overhead
# │      to show why 8 GPUs never achieve 8x speedup.
# │
# │ Imports: mlsys.constants (NVLINK_A100_BW, GB, second),
# │          mlsys.formatting (fmt)
# │ Exports: fp_nvlink_bw_str, fp_sync_time_str, fp_sync_overhead_str
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.formatting import fmt
from mlsys.constants import NVLINK_A100_BW, GB, second

# --- NVLink bandwidth and sync overhead ---
nvlink_bw_gbs = NVLINK_A100_BW.to(GB / second).magnitude
gradient_size_gb = 1.0
sync_time_ms = gradient_size_gb / nvlink_bw_gbs * 1000
step_time_ms = 50
sync_overhead_pct = sync_time_ms / step_time_ms * 100

# --- Outputs ---
fp_nvlink_bw_str = fmt(nvlink_bw_gbs, precision=0, commas=False)
fp_sync_time_str = fmt(sync_time_ms, precision=2, commas=False)
fp_sync_overhead_str = fmt(sync_overhead_pct, precision=1, commas=False)
```

**Fallacy:** *Hardware acceleration benefits scale linearly with additional accelerators.*

Teams expect 8 GPUs to train 8x faster than 1 GPU. Multi-accelerator scaling introduces communication overhead that violates linear scaling assumptions. As noted in @sec-ai-acceleration-scaling-beyond-single, AllReduce operations for gradient synchronization can require exchanging hundreds of gigabytes per training step for large models. With NVLink at `{python} fp_nvlink_bw_str` GB/s bidirectional, synchronizing 1 GB of gradients requires `{python} fp_sync_time_str` ms; for a 50 ms training step, this represents `{python} fp_sync_overhead_str`% overhead with perfect overlap. Without overlap, 8-GPU setups achieve 7.5x speedup (94% efficiency) at best, and typical workloads see 6-7x (75-87% efficiency) due to load imbalance and synchronization barriers. Small models with insufficient parallel work achieve even worse scaling, sometimes seeing 3-4x speedup on 8 GPUs (37-50% efficiency).

**Fallacy:** *Peak FLOPS specifications determine real-world accelerator performance.*

\index{Peak FLOPS!misleading metric}
Vendors advertise peak FLOPS as the definitive measure of accelerator capability, but real-world performance equals Peak FLOPS x Utilization, where utilization is dictated by the Roofline Model (@sec-ai-acceleration-measuring-efficiency). An A100 advertises `{python} a100_tflops_fp16` TFLOPS at FP16, yet transformer training typically achieves only 120–180 TFLOPS (40–60% utilization) because memory-bound operations such as attention and LayerNorm drag down the average throughput. Recommendation models fare even worse, often reaching only 10–30 TFLOPS (3–10% utilization) due to sparse, irregular memory access patterns that leave compute units idle. Engineers should budget projects based on sustained throughput, measured or estimated via the Roofline Model, rather than peak marketing specifications.

```{python}
#| label: fp-small-batch-calc
#| echo: false
# ┌─────────────────────────────────────────────────────────────────────────────
# │ F&P: SMALL-BATCH INFERENCE ECONOMICS
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: Pitfall about deploying small-batch inference on high-compute GPUs
# │
# │ Why: Shows how batch size affects arithmetic intensity, demonstrating that
# │      batch=1 inference is memory-bound on both A100 and T4, making the
# │      cheaper T4 more cost-effective.
# │
# │ Imports: mlsys.constants (T4_FLOPS_FP16_TENSOR, T4_MEM_BW, TFLOPs,
# │          second, GB), mlsys.formatting (fmt)
# │ Exports: fp_ai_b1_str, fp_ai_b256_str, fp_t4_ridge_str,
# │          fp_t4_flops_str, fp_t4_bw_str
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.formatting import fmt
from mlsys.constants import T4_FLOPS_FP16_TENSOR, T4_MEM_BW, TFLOPs, second, GB

# --- Batch size arithmetic intensity comparison ---
M = N = 2048
flops_b1 = 2 * M * N
bytes_b1 = (M * N + M + N) * 2
ai_b1 = flops_b1 / bytes_b1

B = 256
flops_b256 = 2 * B * M * N
bytes_b256 = (M * N + B * M + B * N) * 2
ai_b256 = flops_b256 / bytes_b256

fp_ai_b1_str = fmt(ai_b1, precision=0, commas=False)
fp_ai_b256_str = fmt(ai_b256, precision=0, commas=False)

# --- T4 ridge point ---
t4_flops = T4_FLOPS_FP16_TENSOR.to(TFLOPs / second).magnitude
t4_bw = T4_MEM_BW.to(GB / second).magnitude
t4_ridge = t4_flops * 1000 / t4_bw
fp_t4_ridge_str = fmt(t4_ridge, precision=0, commas=False)
fp_t4_flops_str = fmt(t4_flops, precision=0, commas=False)
fp_t4_bw_str = fmt(t4_bw, precision=0, commas=False)
```

**Pitfall:** *Deploying small-batch inference workloads on high-compute accelerators.*

Teams deploy high-throughput training accelerators (A100, H100) for latency-sensitive inference with batch size 1–4. As the Roofline Model (@sec-ai-acceleration-measuring-efficiency) predicts, small batches severely reduce arithmetic intensity: a dense layer with M=N=2048 achieves AI = `{python} fp_ai_b1_str` FLOP/byte at batch=1 versus AI = `{python} fp_ai_b256_str` FLOP/byte at batch=256. At batch=1, an A100 achieves 4 TFLOPS (1.3% utilization) due to memory bottlenecks, while a lower-cost T4 achieves 3.5 TFLOPS. The T4's peak is `{python} fp_t4_flops_str` TFLOPS (FP16 Tensor Core) with a ridge point of `{python} fp_t4_ridge_str` FLOP/byte (`{python} fp_t4_flops_str` TFLOPS / `{python} fp_t4_bw_str` GB/s). Small-batch inference remains memory-bound on both accelerators, but the T4's lower cost makes it more economical. A100 instances cost 3-4x more than T4 instances for identical latency. Inference deployments should match batch size to accelerator characteristics, using high-compute accelerators only for batched serving where arithmetic intensity exceeds ridge points.

**Pitfall:** *Vendor-specific optimizations without considering long-term portability.*

\index{Vendor Lock-in!portability trade-off}\index{Hardware Abstraction Layer!portability}
Organizations optimize exclusively for specific vendors to maximize performance without considering system flexibility. As discussed in @sec-ai-acceleration-compiler-support-172e, deep integration with vendor-specific libraries (CUDA, TensorRT, XLA) and custom kernels creates lock-in. A codebase with 50+ hand-written CUDA kernels requires 6–12 engineer-months to port to a different accelerator vendor, delaying hardware upgrades and preventing multi-vendor deployments. While vendor-specific optimizations provide 20–40% performance gains, they should be isolated behind hardware abstraction layers. Maintaining portable code paths enables vendor competition, hardware flexibility, and faster adoption of emerging accelerators while still capturing most performance benefits through framework-level optimizations.

```{python}
#| label: feasibility-calc
#| echo: false
# ┌─────────────────────────────────────────────────────────────────────────────
# │ FEASIBILITY ASSESSMENT CALCULATIONS
# ├─────────────────────────────────────────────────────────────────────────────
# │ Context: "Feasibility Assessment: Can You Run It?" callout-checkpoint
# │
# │ Why: Provides worked examples for the three feasibility checks that
# │      practitioners should perform before hardware procurement: memory
# │      capacity, bandwidth, and compute. Demonstrates how to calculate
# │      whether a model will fit, meet latency targets, and handle throughput.
# │
# │ Imports: mlsys.constants (GB, BYTES_FP16), mlsys.formulas (model_memory),
# │          mlsys.formatting (fmt)
# │ Exports: headroom_str, token_latency_ms_str, frame_budget_str
# └─────────────────────────────────────────────────────────────────────────────
from mlsys.formatting import fmt
from mlsys.formulas import model_memory
from mlsys.constants import GB, BYTES_FP16

# --- Inputs (model specs and hardware constraints) ---
# Memory check: Llama-7B on 16GB GPU
llama7b_params = 7e9                     # 7B parameter model
gpu_mem_gb = 16                          # 16 GB GPU memory

# Bandwidth check: 70B model on 1TB/s GPU
model_70b_params = 70e9                  # 70B parameter model
bw_check_tbps = 1.0                      # 1 TB/s memory bandwidth

# Compute check: video at 30 FPS
video_fps = 30                           # target frames per second

# --- Outputs (formatted strings for prose) ---
# Memory check calculation
llama7b_weights_gb = model_memory(llama7b_params, BYTES_FP16, GB)
headroom_gb = gpu_mem_gb - llama7b_weights_gb
headroom_str = f"{headroom_gb}"          # e.g. "2" GB remaining for context

# Bandwidth check calculation
model_70b_size_gb = model_memory(model_70b_params, BYTES_FP16, GB)
token_latency_ms = model_70b_size_gb / (bw_check_tbps * 1e3) * 1e3
token_latency_ms_str = fmt(token_latency_ms, precision=0, commas=False)  # e.g. "140" ms

# Compute check calculation
frame_budget_ms = 1000 / video_fps
frame_budget_str = fmt(frame_budget_ms, precision=0, commas=False)  # e.g. "33" ms
```

::: {.callout-checkpoint title="Feasibility Assessment: Can You Run It?" collapse="false"}
Before procuring hardware, validate feasibility by calculating these hard constraints:

**1. Memory Capacity Check**

*   **Formula**: $M_{req} = \text{Weights} + \text{KV Cache} + \text{Activation Buffer}$
*   **Constraint**: $M_{req} < M_{device}$
*   **Example**: Running Llama-7B (14GB weights @ FP16) on a 16GB GPU leaves only `{python} headroom_str` GB for context. Long prompts will OOM (Out of Memory).

**2. Bandwidth Check**

*   **Formula**: $T_{token} = \frac{\text{Model Size}}{\text{Memory Bandwidth}}$
*   **Constraint**: $T_{token} < \text{Latency Target}$
*   **Example**: Serving a 70B model (140GB) on a GPU with 1TB/s bandwidth yields ≈ `{python} token_latency_ms_str` ms per token. If you need 50ms latency, this hardware fails regardless of compute power.

**3. Compute Check**

*   **Formula**: $T_{process} = \frac{\text{Ops}}{\text{Peak FLOPS} \times \text{Utilization}}$
*   **Constraint**: $T_{process} < \text{Throughput Target}$
*   **Example**: Processing video at 30 FPS requires completing all inference within `{python} frame_budget_str` ms.
:::

This checklist synthesizes the principles developed throughout this chapter, translating theoretical understanding into practical engineering decisions.

These fallacies and pitfalls reveal a recurring theme: optimizing for the wrong metric wastes resources. But "resources" extends beyond compute time and engineer-hours. As AI systems scale to planetary deployment — millions of GPUs consuming megawatts of power — the environmental cost of suboptimal hardware choices accumulates at societal scale. The same architectural principles that maximize performance per watt also minimize carbon per inference, making efficiency optimization both an engineering imperative and an environmental one.

## Hardware Sustainability {#sec-ai-acceleration-sustainability}

\index{Hardware Sustainability!carbon footprint}
Beyond raw performance, we must evaluate hardware through the lens of *silicon sustainability*\index{Sustainability!silicon design}. In the era of planetary-scale AI, performance per watt\index{Performance per Watt!efficiency metric}\index{Energy Efficiency!TFLOPS per Watt} is not merely a mobile constraint but a global environmental mandate. Quantifying *the carbon ROI of specialized silicon* makes the case concrete.

::: {.callout-notebook title="The Carbon ROI of Specialized Silicon"}

**The Problem**: Should you run your inference fleet on generic CPUs or invest in specialized NPUs (Neural Processing Units)?

**The Physics**: Specialized hardware achieves higher arithmetic intensity while using fewer transistors for control logic.

*   **CPU Inference**: 100 Watts for 1 TFLOP (Efficiency = 0.01 TFLOPS/W).
*   **NPU Inference**: 5 Watts for 10 TFLOPS (Efficiency = 2.0 TFLOPS/W).
*   **The Gap**: The NPU is **200× more energy-efficient** per operation.

**The Calculation**:

1.  **Workload**: 1 Billion inferences per day.
2.  **CPU Energy**: ~2,400 kWh/day.
3.  **NPU Energy**: ~12 kWh/day.
4.  **Carbon Savings**: At 0.4 kg CO2/kWh, switching to NPUs saves **~350 metric tons of CO2 per year**.

**The Systems Conclusion**: Custom silicon is the ultimate "Green" technology for ML. Investing in specialized accelerators is not just about speed; it is the single most effective way to reduce the carbon footprint of intelligence.
:::

The sustainability perspective reinforces a theme that has recurred throughout this chapter: hardware selection is never a purely technical decision. Performance per watt, carbon cost, and total cost of ownership must all enter the decision framework alongside peak FLOPS and memory bandwidth. With these considerations in place, we can now synthesize the principles that span from silicon physics to system-level optimization.

## Summary {#sec-ai-acceleration-summary-a5f8}

The preceding sections established a decision framework for hardware selection and a sustainability perspective grounding these choices in broader responsibility. Hardware acceleration emerged as the force that transformed machine learning from academic curiosity to practical reality, reshaping how we design both computational systems and the algorithms that run on them. The evolution from general-purpose processors to specialized AI accelerators reflects a shift toward domain-specific computing where hardware and software are co-designed to optimize specific computational patterns. The progression from CPUs through GPUs to specialized TPUs, NPUs, and wafer-scale systems demonstrates how understanding workload characteristics drives architectural innovation, creating opportunities for orders-of-magnitude performance improvements through targeted specialization.

The technical challenges of AI acceleration span multiple layers of the computing stack, from low-level memory hierarchy optimization to high-level compiler transformations and runtime orchestration. Memory bandwidth limitations create bottlenecks that require targeted techniques like data tiling, kernel fusion, and hierarchy-aware scheduling to overcome. Mapping neural network computations to hardware involves complex trade-offs between different dataflow patterns, memory allocation strategies, and execution scheduling approaches that must balance computational efficiency with resource utilization.

Building on these foundational concepts, the emergence of multi-chip and distributed acceleration systems introduces additional complexities around communication overhead, memory coherence, and workload partitioning that require careful system-level optimization.

::: {.callout-takeaways}

* **The Roofline model identifies performance bottlenecks**: Plotting arithmetic intensity against throughput reveals whether workloads are memory-bound (attention, embeddings) requiring bandwidth optimization, or compute-bound (convolutions, GEMMs) requiring FLOPS optimization.

* **Memory bandwidth constrains performance**: GPU compute capacity has grown orders of magnitude faster than memory bandwidth over the past two decades. Most inference workloads are memory-bound, making data movement optimization the primary concern.

* **Hardware-software co-design can achieve 10–100× performance improvements**: Matching algorithm patterns to architectural capabilities (systolic arrays for dense GEMM, sparse accelerators for pruned models) typically outperforms raw hardware upgrades.

* **Tensor Cores require specific conditions**: FP16 inputs, appropriate tensor dimensions, and sufficient batch size are necessary for peak utilization. Batch size directly affects arithmetic intensity and determines whether workloads reach the compute-bound regime.

* **Arithmetic intensity determines optimization strategy**: Operations with low arithmetic intensity (1–2 FLOP/byte, like LayerNorm) are memory-bound; operations with high intensity (50–200 FLOP/byte, like convolutions) are compute-bound. The ridge point (e.g., `{python} a100_ridge` FLOP/byte for A100) marks the transition.

:::

Engineers who internalize the Roofline model and arithmetic intensity analysis gain a powerful diagnostic framework: when inference runs slower than expected, they can immediately determine whether the bottleneck lies in compute throughput, memory bandwidth, or software overhead, and then select the appropriate optimization strategy. This systems-level understanding transforms hardware selection from vendor comparison into principled engineering.

::: {.callout-chapter-connection title="From Optimization to Validation"}

We have now optimized the full D·A·M stack: data selection minimized training requirements, model compression reduced algorithmic complexity, and hardware acceleration maximized machine throughput. Optimization without measurement, however, is guesswork. In @sec-benchmarking-ai, we move from theoretical FLOPs to measured latency, applying the Roofline Model and statistical methods to validate our optimization claims against reality.

:::

::: { .quiz-end }
:::
