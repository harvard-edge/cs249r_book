name: 'ğŸ“š Quarto Build'

# Set retention period to 7 days
env:
  GITHUB_ACTIONS_RETENTION_DAYS: 7

# This workflow builds a Quarto project and deploys it to either a development site or GitHub Pages
# It handles both Windows and Linux environments with extensive caching for better performance
on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
        description: 'Build environment (development/production/test)'
      os:
        required: true
        type: string
        description: 'Operating system to run on (ubuntu-latest/windows-latest)'
      quarto-version:
        required: false
        type: string
        default: '1.7.31'
        description: 'Version of Quarto to use'
      r-version:
        required: false
        type: string
        default: '4.3.2'
        description: 'Version of R to use'
      target:
        required: false
        type: string
        default: ''
        description: 'Target branch (dev/main) - determines build behavior'
      format:
        required: false
        type: string
        default: 'all'
        description: 'Format to build (html/pdf/epub/all)'
      deploy:
        required: false
        type: boolean
        default: true
        description: 'Whether to deploy the build or just validate'
    secrets:
      SSH_DEPLOY_KEY:
        required: false
        
permissions:
  contents: write
  pages: write

jobs:
  build:
    runs-on: ${{ inputs.os }}
    timeout-minutes: 120  # â° Set job timeout to 60 minutes
    environment:
      name: ${{ inputs.environment }}
    env:
      R_LIBS_USER: ${{ github.workspace }}/.r-lib
      QUARTO_LOG_LEVEL: INFO

    steps:
      - name: ğŸ” Validate inputs
        shell: pwsh
        run: |
          Write-Output "ğŸ”„ Validating workflow inputs..."
          Write-Output "ğŸ‘‰ Target: ${{ inputs.target }}"
          Write-Output "ğŸ‘‰ OS: ${{ inputs.os }}"
          Write-Output "ğŸ‘‰ Environment: ${{ inputs.environment }}"
          Write-Output "ğŸ‘‰ Format: ${{ inputs.format }}"
          Write-Output "ğŸ‘‰ Deploy: ${{ inputs.deploy }}"
          
          $valid_formats = @("html", "pdf", "epub", "all")
          if ("${{ inputs.format }}" -notin $valid_formats) {
            Write-Error "âŒ Format must be one of: $($valid_formats -join ', ')"
            exit 1
          }
          
          Write-Output "âœ… Input validation passed"

      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ“¦ Setup Quarto
        uses: quarto-dev/quarto-actions/setup@v2
        with:
          version: ${{ inputs.quarto-version }}
        # Outputs quarto version information after installation
        id: quarto-setup

      - name: ğŸ“‹ Quarto Setup Info
        shell: bash
        run: |
          echo "ğŸ”„ Checking Quarto installation..."
          quarto check
          echo "ğŸ“Š Quarto version info:"
          quarto --version
          echo "ğŸ“ Quarto installation location:"
          which quarto || where.exe quarto

      - name: ğŸ Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: ğŸ’¾ Cache Python packages
        uses: actions/cache@v4
        id: cache-python-packages
        with:
          path: |
            ~/.cache/pip
            ~\AppData\Local\pip\Cache
          key: python-pkgs-${{ runner.os }}-${{ hashFiles('tools/dependencies/requirements.txt') }}
          restore-keys: |
            python-pkgs-${{ runner.os }}-

      - name: ğŸ“¦ Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install -r tools/dependencies/requirements.txt

      # Note: NLTK data is downloaded automatically by section_id_manager.py when needed

      # Cache Linux system packages without hardcoded paths
      - name: ğŸ’¾ Cache APT packages
        if: runner.os == 'Linux'
        uses: actions/cache@v4
        id: cache-apt
        with:
          path: ~/.apt-cache
          key: apt-${{ runner.os }}-${{ hashFiles('.github/workflows/*.yml') }}
          restore-keys: |
            apt-${{ runner.os }}-

      - name: ğŸ› ï¸ Install Linux Dependencies
        if: runner.os == 'Linux' && steps.cache-apt.outputs.cache-hit != 'true'
        shell: bash
        run: |
          echo "ğŸ”„ Installing Linux dependencies..."
          echo "ğŸ“¦ Creating APT cache directory"
          mkdir -p ~/.apt-cache

          echo "ğŸ“¦ Updating package lists"
          sudo apt-get update

          echo "ğŸ“¦ Installing required system libraries"
          sudo apt-get -o dir::cache::archives="$HOME/.apt-cache" install -y \
            fonts-dejavu \
            fonts-freefont-ttf \
            gdk-pixbuf2.0-bin \
            libcairo2 \
            libfontconfig1 \
            libfreetype6 \
            libpango-1.0-0 \
            libpangocairo-1.0-0 \
            libpangoft2-1.0-0 \
            libxml2-dev \
            libcurl4-openssl-dev \
            libjpeg-dev \
            libtiff5-dev \
            libpng-dev

          echo "âœ… Linux dependencies installed"
                
      - name: ğŸ¨ Install Inkscape and font dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          # First remove any existing Inkscape
          sudo apt-get remove -y inkscape || true
          # Install Inkscape from PPA for more reliable version
          echo "ğŸ“¦ Installing Inkscape from PPA..."
          sudo add-apt-repository ppa:inkscape.dev/stable -y
          sudo apt-get update
          sudo apt-get install -y inkscape
          
          # Install font dependencies
          echo "ğŸ“¦ Installing font dependencies..."
          sudo apt-get install -y \
            fonts-freefont-ttf \
            fonts-liberation \
            fontconfig
          
          # Update font cache after installing Inkscape and fonts
          echo "ğŸ§¹ Updating font cache..."
          sudo fc-cache -fv
          
          # Verify Inkscape installation
          echo "ğŸ“Š Inkscape version:"
          inkscape --version
          
          # Test SVG to PDF conversion with the new Inkscape
          echo "ğŸ§ª Testing Inkscape SVG to PDF conversion..."
          echo '<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><circle cx="50" cy="50" r="40" fill="red"/></svg>' > test.svg
          inkscape --export-type=pdf --export-filename=test.pdf test.svg
          
          # Verify if the PDF was created
          if [ -f test.pdf ]; then
            echo "âœ… Inkscape SVG to PDF conversion successful!"
            ls -lh test.pdf
          else
            echo "âŒ Inkscape SVG to PDF conversion failed."
            echo "ğŸ” Checking Inkscape installation..."
            dpkg -l | grep inkscape
            which inkscape
            ldd $(which inkscape) | grep "not found" || echo "All dependencies resolved"
          fi
          
      - name: ğŸ¨ Install Inkscape (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # Use winget (Windows default package manager) if available, otherwise fallback to chocolatey
          try {
            winget install Inkscape.Inkscape --accept-source-agreements --accept-package-agreements
            Write-Output "âœ… Inkscape installed via winget"
          } catch {
            Write-Output "ğŸ”„ winget not available, using chocolatey..."
            choco install inkscape -y
          }
          
          # Add Inkscape to PATH (both installation methods use the same path)
          echo "C:\Program Files\Inkscape\bin" | Out-File -Append -Encoding ascii $env:GITHUB_PATH
          
          # Verify Inkscape installation
          inkscape --version

      # Install TeX Live packages (Cross-platform)
      - name: ğŸ“¦ Install TeX Live packages
        if: (inputs.format == 'pdf' || inputs.format == 'epub' || inputs.format == 'all')
        uses: zauguin/install-texlive@v4
        with:
          package_file: tools/dependencies/tl_packages
          texlive_version: 2025
          cache_version: 1
         
      - name: ğŸ“Š Setup R
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: ${{ inputs.r-version }}
          use-public-rspm: true

      - name: ğŸ“‹ R Setup Info
        shell: Rscript {0}
        run: |
          cat("ğŸ”„ R Version Information:\n")
          cat(paste("R version:", R.version$version.string, "\n"))
          cat(paste("R home:", R.home(), "\n"))
          cat(paste("R library paths:", paste(.libPaths(), collapse=", "), "\n"))

      # Cache R packages using standard paths
      - name: ğŸ’¾ Cache R packages
        uses: actions/cache@v4
        id: cache-r-packages
        with:
          path: |
            ${{ env.R_LIBS_USER }}
          key: r-pkgs-${{ runner.os }}-${{ inputs.r-version }}-${{ hashFiles('tools/dependencies/install_packages.R', '**/*.qmd') }}
          restore-keys: |
            r-pkgs-${{ runner.os }}-${{ inputs.r-version }}-

      - name: ğŸ“¦ Install R packages
        if: steps.cache-r-packages.outputs.cache-hit != 'true'
        shell: Rscript {0}
        run: |
          # Set options for better package installation
          options(repos = c(CRAN = "https://cran.rstudio.com"))
          
          cat("ğŸ”„ Installing R packages...\n")
          cat(paste("R library path:", Sys.getenv("R_LIBS_USER"), "\n"))
          
          # Create and set library path
          lib_path <- Sys.getenv("R_LIBS_USER")
          dir.create(lib_path, showWarnings = FALSE, recursive = TRUE)
          .libPaths(lib_path)
          
          # Install packages
          cat("ğŸ“¦ Installing remotes package...\n")
          install.packages("remotes")
          
          if (file.exists("tools/dependencies/install_packages.R")) {
            cat("ğŸ“¦ Installing packages from tools/dependencies/install_packages.R...\n")
            source("tools/dependencies/install_packages.R")
          } else {
            cat("âš ï¸ No tools/dependencies/install_packages.R found, installing common packages\n")
            pkgs <- c("rmarkdown", "knitr", "tidyverse", "ggplot2", "bookdown")
            cat(paste("ğŸ“¦ Installing packages:", paste(pkgs, collapse=", "), "\n"))
            install.packages(pkgs)
          }
          
          cat("âœ… R package installation complete\n")
          cat("ğŸ“Š Installed packages:\n")
          ip <- installed.packages()[, c("Package", "Version")]
          print(head(ip, 10))
          cat(paste("Total packages installed:", nrow(ip), "\n"))

      # Install before render cause we need it for rendering
      - name: ğŸ“¦ Install Ghostscript (Linux)
        if: runner.os == 'Linux' && (inputs.format == 'pdf' || inputs.format == 'all')
        run: sudo apt-get install -y ghostscript

      - name: ğŸ“¦ Install Ghostscript (Windows)
        if: runner.os == 'Windows' && (inputs.format == 'pdf' || inputs.format == 'all')
        shell: pwsh
        run: |
          # Use winget if available, otherwise fallback to chocolatey
          try {
            winget install ArtifexSoftware.GhostScript --accept-source-agreements --accept-package-agreements
            Write-Output "âœ… Ghostscript installed via winget"
          } catch {
            Write-Output "ğŸ”„ winget not available, using chocolatey..."
            choco install ghostscript -y
          }
          
          # Add Ghostscript to PATH (both installation methods use the same path)
          $gsPath = Get-ChildItem "C:\Program Files\gs" | Sort-Object Name -Descending | Select-Object -First 1
          $binPath = Join-Path $gsPath.FullName "bin"
          echo "Adding Ghostscript path: $binPath"
          echo "$binPath" | Out-File -Append -FilePath $env:GITHUB_PATH

      - name: ğŸ”¨ Build HTML (copy config and render)
        if: inputs.format == 'html' || inputs.format == 'all'
        shell: bash
        run: |
          echo "ğŸš€ Setting up HTML configuration..."
          cd book
          rm -f _quarto.yml
          cp config/_quarto-html.yml _quarto.yml
          echo "âœ… Configuration set to HTML"
          
          echo "ğŸ”¨ Building HTML..."
          quarto render --to html
        
      - name: ğŸ”¨ Build PDF (copy config and render)
        if: inputs.format == 'pdf' || inputs.format == 'all'
        shell: bash
        run: |
          echo "ğŸš€ Setting up PDF configuration..."
          cd book
          rm -f _quarto.yml
          cp config/_quarto-pdf.yml _quarto.yml
          echo "âœ… Configuration set to PDF"
          
          echo "ğŸ”¨ Building PDF..."
          quarto render --to titlepage-pdf

      - name: ğŸ”¨ Build EPUB (copy config and render)
        if: inputs.format == 'epub' || inputs.format == 'all'
        shell: bash
        run: |
          echo "ğŸš€ Setting up EPUB configuration..."
          cd book
          rm -f _quarto.yml
          cp config/_quarto-epub.yml _quarto.yml
          echo "âœ… Configuration set to EPUB"
          
          echo "ğŸ”¨ Building EPUB..."
          quarto render --to epub     
      
      - name: ğŸ“‹ Check Quarto Build Output
        shell: bash
        run: |
          echo "ğŸ”„ Checking Quarto build output..."

          # HTML check
          if [[ "${{ inputs.format }}" == "html" || "${{ inputs.format }}" == "all" ]]; then
            if [ -d "build/html" ]; then
              echo "âœ… build/html directory exists"
              echo "ğŸ“Š Files in build/html directory:"
              ls -la build/html | head -n 20
              echo "ğŸ“Š Total files in build/html:"
              find build/html -type f | wc -l
            else
              echo "âŒ build/html directory not found!"
            fi
          fi

          # PDF check
          if [[ "${{ inputs.format }}" == "pdf" || "${{ inputs.format }}" == "all" ]]; then
            if [ -d "build/pdf" ]; then
              echo "âœ… build/pdf directory exists"
              echo "ğŸ“Š Files in build/pdf directory:"
              ls -la build/pdf | head -n 20
              echo "ğŸ“Š Total files in build/pdf:"
              find build/pdf -type f | wc -l
              
              if [ -f "build/pdf/Machine-Learning-Systems.pdf" ]; then
                echo "âœ… PDF file exists"
                echo "ğŸ“Š PDF file size:"
                du -h "build/pdf/Machine-Learning-Systems.pdf"
              else
                echo "âš ï¸ PDF file not found!"
              fi
            else
              echo "âŒ build/pdf directory not found!"
            fi
          fi

          # EPUB check (disabled for now)
          # if [[ "${{ inputs.format }}" == "epub" || "${{ inputs.format }}" == "all" ]]; then
          #   if [ -d "build/epub" ]; then
          #     echo "âœ… build/epub directory exists"
          #     echo "ğŸ“Š Files in build/epub directory:"
          #     ls -la build/epub | head -n 20
          #     echo "ğŸ“Š Total files in build/epub:"
          #     find build/epub -type f | wc -l
          #     
          #     if [ -f "build/epub/Machine-Learning-Systems.epub" ]; then
          #       echo "âœ… EPUB file exists"
          #       echo "ğŸ“Š EPUB file size:"
          #       du -h "build/epub/Machine-Learning-Systems.epub"
          #     else
          #       echo "âš ï¸ EPUB file not found!"
          #     fi
          #   else
          #     echo "âŒ build/epub directory not found!"
          #   fi
          # fi

      - name: ğŸ“‰ Compress PDF with Ghostscript (Linux)
        if: runner.os == 'Linux' && (inputs.format == 'pdf' || inputs.format == 'all')
        run: |
          if [ -f "build/pdf/Machine-Learning-Systems.pdf" ]; then
            gs \
              -sDEVICE=pdfwrite \
              -dCompatibilityLevel=1.4 \
              -dPDFSETTINGS=/ebook \
              -dNOPAUSE \
              -dQUIET \
              -dBATCH \
              -sOutputFile="./build/pdf/ebook.pdf" \
              "./build/pdf/Machine-Learning-Systems.pdf"

            # Replace original with compressed
            mv ./build/pdf/ebook.pdf ./build/pdf/Machine-Learning-Systems.pdf
          else
            echo "âš ï¸ PDF file not found for compression"
          fi

      - name: ğŸ“‰ Compress PDF with Ghostscript (Windows)
        if: runner.os == 'Windows' && (inputs.format == 'pdf' || inputs.format == 'all')
        shell: pwsh
        run: |
          $input = "./build/pdf/Machine-Learning-Systems.pdf"
          $output = "./build/pdf/ebook.pdf"

          if (!(Test-Path $input)) {
            Write-Warning "âš ï¸ Input PDF not found! Skipping compression..."
            exit 0  # Non-zero exit would fail the workflow
          }

          Write-Output "ğŸ“‰ Compressing PDF using Ghostscript..."

          # Unless you are a sucker for pain, don't try to line-break this command (it was a nightmare)
          # Note that compatability should be written as -dCompatibilityLevel:1.4, not -dCompatibilityLevel=1.4!!!
          & gswin64c -sDEVICE=pdfwrite -dCompatibilityLevel:1.4 -dPDFSETTINGS=/ebook -dNOPAUSE -dBATCH -sOutputFile="$output" "$input"

          if (Test-Path $output) {
            $afterSize = (Get-Item $output).Length / 1MB
            Write-Output ("ğŸ“ Compressed PDF size: {0:N2} MB" -f $afterSize)
            Write-Output "âœ… Compression successful"
            Move-Item -Force $output $input
          } else {
            Write-Warning "âš ï¸ Compression failed but continuing"
          }
          
      - name: ğŸ“¤ Upload build artifacts
        if: github.event_name == 'pull_request' || inputs.deploy == false || inputs.format != 'html'
        uses: actions/upload-artifact@v4
        with:
          name: build-${{ inputs.os }}-${{ inputs.format }}
          path: |
            build/html
            build/pdf
            build/epub

      - name: ğŸš€ Stage to Dev Site
        if: inputs.target == 'dev' && inputs.deploy == true && inputs.format == 'html' && runner.os == 'Linux'
        shell: bash
        env:
          SSH_DEPLOY_KEY: ${{ secrets.SSH_DEPLOY_KEY }}
        run: |
          echo "ğŸ” Starting ssh-agent..."
          eval "$(ssh-agent -s)"
          echo "$SSH_DEPLOY_KEY" | tr -d '\r' | ssh-add - > /dev/null

          git config --global user.email "khoshnevis.naeem@gmail.com"
          git config --global user.name "github-actions"

          echo "ğŸ”„ Cloning target repo..."
          git clone --depth=1 git@github.com:harvard-edge/cs249r_book_dev.git target-repo
          cd target-repo
          git checkout main
          git pull origin main

          echo "ğŸ§¹ Cleaning existing docs/"
          rm -rf docs
          cp -r "${GITHUB_WORKSPACE}/build/html" docs
          rm -f docs/CNAME  # remove if present

          echo "ğŸ” Validating deployment content..."
          test -f docs/index.html || (echo "âŒ index.html missing" && exit 1)
          [ "$(ls -1 docs | wc -l)" -gt 3 ] || (echo "âŒ docs/ too empty â€” something went wrong" && exit 1)

          echo "ğŸ“¦ Committing and pushing changes..."
          git add docs
          git commit -m "ğŸ“š Push dev branch build (manual version)" || echo "ğŸŸ¡ Nothing to commit"
          git push origin main

      - name: ğŸ“‹ Dev Deployment Info
        if: inputs.target == 'dev' && runner.os == 'Linux' && inputs.deploy == true
        shell: bash
        run: |
          echo "ğŸ”„ Development deployment information:"
          echo "ğŸ“Š Deployed to repository: harvard-edge/cs249r_book_dev"
          echo "ğŸ“Š Target branch: main"
          echo "ğŸ“Š Target directory: docs"
          echo "ğŸ“Š Source directory: build/html"
          echo "âœ… Deployment should be complete"

      # Deploy to GitHub Pages
      - name: ğŸš€ Deploy to GitHub Pages
        if: inputs.target == 'main' && runner.os == 'Linux' && inputs.deploy == true && inputs.format == 'html'
        shell: bash
        run: |
          echo "ğŸš€ Deploying to GitHub Pages..."
          
          # Clone gh-pages branch
          git clone --depth=1 --branch=gh-pages https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git gh-pages-repo
          
          # Clear existing content
          cd gh-pages-repo
          rm -rf *
          
          # Copy new content
          cp -r ../build/html/* .
          
          # Copy PDF if it exists (for download)
          if [ -f "../build/pdf/Machine-Learning-Systems.pdf" ]; then
            echo "ğŸ“„ Adding PDF to deployment..."
            mkdir -p assets
            cp "../build/pdf/Machine-Learning-Systems.pdf" assets/
            echo "âœ… PDF added: assets/Machine-Learning-Systems.pdf"
          else
            echo "âš ï¸ PDF not found in build/pdf/"
          fi
          
          # Configure git
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          
          # Commit and push
          git add .
          git commit -m "Deploy from commit ${GITHUB_SHA}" || echo "No changes to commit"
          git push origin gh-pages
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ“‹ GitHub Pages Deployment Info
        if: inputs.target == 'main' && runner.os == 'Linux' && inputs.deploy == true
        shell: bash
        run: |
          echo "ğŸ”„ GitHub Pages deployment information:"
          echo "ğŸ“Š Deployed to: gh-pages branch"
          echo "ğŸ“Š Source directory: build/html"
          echo "âœ… Deployment should be complete"
          echo "ğŸŒ Site should be available at: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}"

      - name: ğŸ“‹ Build Summary
        shell: pwsh
        run: |
          # Create a variable for the TeX Live status
          $texLiveStatus = if ("${{ inputs.format }}" -eq "pdf" -or "${{ inputs.format }}" -eq "all") {
            "Installed via zauguin/install-texlive@v4 (Cross-platform)"
          } else {
            "Skipped (not needed for HTML only)"
          }
          
          @"
          ## ğŸ“Š Build Status Summary
          ğŸ¯ Target: ${{ inputs.target }}
          ğŸ’» OS: ${{ inputs.os }}
          ğŸ”§ Environment: ${{ inputs.environment }}
          ğŸ“š Quarto Version: ${{ inputs.quarto-version }}
          ğŸ”¬ R Version: ${{ inputs.r-version }}
          ğŸ“„ Format: ${{ inputs.format }}
          ğŸš€ Deploy: ${{ inputs.deploy }}
          ğŸ§© Cache Status:
            - TeX Live: $texLiveStatus
            - R Packages: ${{ steps.cache-r-packages.outputs.cache-hit == 'true' && 'âœ… Hit' || 'âŒ Miss' }}
            - Python Packages: ${{ steps.cache-python-packages.outputs.cache-hit == 'true' && 'âœ… Hit' || 'âŒ Miss' }}
          â° Completed at: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")
          "@ | Add-Content $env:GITHUB_STEP_SUMMARY 