name: 'ğŸ“š Book Â· ğŸš€ Publish (Live)'

# Shared concurrency group prevents gh-pages conflicts with other live workflows
concurrency:
  group: gh-pages-deploy
  cancel-in-progress: false

# =============================================================================
# CONFIGURABLE VARIABLES - Edit these to customize the workflow
# =============================================================================

# AI Model Configuration
env:
  DEFAULT_AI_MODEL: "gemma2:9b"            # Default Ollama model (9b fits on GitHub runners)
  FALLBACK_AI_MODEL: "llama3.2:3b"         # Fallback if default model fails (smaller)
  OLLAMA_TIMEOUT: "300"                    # Timeout for Ollama operations (seconds)
  OLLAMA_RETRIES: "3"                      # Number of retries for Ollama calls
  BUILD_TIMEOUT: "3600"                    # Timeout for build operations (1 hour)

  # ==========================================================================
  # PATH CONFIGURATION - Uses GitHub Repository Variables (Settings > Variables)
  # ==========================================================================
  # MLSysBook content lives under book/ to accommodate TinyTorch at root
  # Use ${{ vars.BOOK_ROOT }}, ${{ vars.BOOK_QUARTO }}, etc. in workflow steps
  # Variables: BOOK_ROOT, BOOK_DOCKER, BOOK_TOOLS, BOOK_QUARTO, BOOK_DEPS

  # Quarto Configuration Files
  QUARTO_HTML_CONFIG: "_quarto-html.yml"  # HTML build configuration file
  QUARTO_PDF_CONFIG: "_quarto-pdf.yml"    # PDF build configuration file
  QUARTO_MAIN_CONFIG: "_quarto.yml"       # Main Quarto configuration file

# =============================================================================
# ARTIFACT COORDINATION SYSTEM
# =============================================================================
# The ğŸ“‹ Quarto Build Container workflow creates build artifacts and an artifact manifest:
#
# artifact-manifest: JSON file declaring the names of HTML, PDF, and EPUB artifacts
# main-html-linux: Contains build/html/ (web version)
# main-pdf-linux:  Contains build/pdf/Machine-Learning-Systems.pdf
# main-epub-linux: Contains build/epub/Machine-Learning-Systems.epub
# main-html-windows: Contains build/html/ (web version)
# main-pdf-windows: Contains build/pdf/Machine-Learning-Systems.pdf
# main-epub-windows: Contains build/epub/Machine-Learning-Systems.epub
#
# This workflow downloads the artifact manifest first to get the exact names,
# then downloads the HTML, PDF, and EPUB artifacts using those names for coordination.
# Quarto Build Container now uses dynamic matrix generation and explicit naming contracts.
#
# Artifact manifest structure:
# {
#   "html_artifact_name": "main-html-linux",
#   "pdf_artifact_name": "main-pdf-linux",
#   "epub_artifact_name": "main-epub-linux",
#   "build_timestamp": "20250115-143022",
#   "commit_sha": "abc123...",
#   "workflow_run_id": "12345",
#   "detailed_manifest": "build-manifest-detailed",
#   "parallel_builds": true,
#   "extensible": true
# }
# =============================================================================

# Available AI Models (uncomment to use different models):
# - gemma2:9b      (fast, good quality - recommended)
# - gemma2:27b     (better quality, slower)
# - llama3.1:8b    (good balance)
# - llama3.1:70b   (best quality, slowest)
# - mistral:7b     (fast, good for analysis)
# - codellama:7b   (good for code-related changes)

# Manual trigger only - big red button!
# Only allow manual triggers from main and dev branches
#
# ğŸ¯ PUBLISHING BEHAVIOR:
# â”œâ”€â”€ With dev_commit specified (e.g., "b5b452e"):
# â”‚   â”œâ”€â”€ Merges EXACTLY that commit into main
# â”‚   â”œâ”€â”€ Includes content + workflow files from that point in time
# â”‚   â””â”€â”€ Warning: You get the old workflow version too!
# â”‚
# â””â”€â”€ Without dev_commit (empty):
#     â”œâ”€â”€ Merges latest dev branch into main
#     â”œâ”€â”€ Includes newest content + newest workflow files
#     â””â”€â”€ Recommended for most releases
#
# ğŸŒ¿ BRANCH CONTROL:
# Quarto Build Container workflow will automatically build from the main branch
# after the merge. The quarto build workflow can also be called manually with
# custom branch targets if needed for testing or special builds.

# Concurrency control: strict for production, flexible for testing
# Concurrency disabled - allow unlimited parallel builds

on:
  workflow_dispatch:
    inputs:
      description:
        description: 'What are you publishing? [Content updates and improvements]'
        required: false
        default: 'Content updates and improvements'
      release_type:
        description: 'Release type [patch]'
        required: true
        type: choice
        options:
          - 'patch'
          - 'minor'
          - 'major'
        default: 'patch'
      dev_commit:
        description: 'Specific dev commit to publish (WARNING: includes old workflow files!) [latest dev]'
        required: false
        default: ''
      confirm:
        description: 'Type "PUBLISH" to confirm (safety check) [required]'
        required: true
        default: ''
      ai_generated_notes:
        description: 'Generate AI-enhanced release notes? [yes]'
        required: true
        type: choice
        options:
          - 'yes'
          - 'no'
        default: 'yes'
      commit_status_timeout:
        description: 'Number of status check attempts [180 = 3 hours at 60s intervals]'
        required: false
        default: '180'
      commit_status_interval:
        description: 'Seconds between status checks [60]'
        required: false
        default: '60'
      previous_version:
        description: 'Previous version to increment from (format: book-vX.Y.Z) [auto-detect from latest git tag]'
        required: false
        default: ''
      testing_mode:
        description: 'Enable testing mode (allows parallel runs, skips actual deployment) [no]'
        required: false
        type: choice
        options:
          - 'no'
          - 'yes'
        default: 'no'

permissions:
  contents: write
  actions: read
  packages: read

jobs:
  debug-log:
    name: 'ğŸ“‹ Debug & Audit Log'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: always()

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ“‹ Log Workflow Inputs & Context
        run: |
          echo "## ğŸ“‹ Workflow Debug & Audit Log" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow Attempt:** ${{ github.run_attempt }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "=== ğŸ“‹ WORKFLOW DEBUG & AUDIT LOG ==="
          echo "ğŸ• Workflow started at: $(date -u)"
          echo "ğŸ”„ Run ID: ${{ github.run_id }}"
          echo "ğŸ”„ Run Attempt: ${{ github.run_attempt }}"
          echo "ğŸ‘¤ Triggered by: ${{ github.actor }}"
          echo "ğŸŒ Repository: ${{ github.repository }}"
          echo ""

          echo "=== ğŸ“ USER INPUTS ==="
          echo "Description: '${{ github.event.inputs.description }}'"
          echo "Release Type: '${{ github.event.inputs.release_type }}'"
          echo "Dev Commit: '${{ github.event.inputs.dev_commit }}'"
          echo "Confirmation: '${{ github.event.inputs.confirm }}'"
          echo "AI Generated Notes: '${{ github.event.inputs.ai_generated_notes }}'"
          echo "Status Check Timeout: '${{ github.event.inputs.commit_status_timeout }}' attempts"
          echo "Status Check Interval: '${{ github.event.inputs.commit_status_interval }}' seconds"
          echo ""

          echo "### ğŸ“ User Inputs:" >> $GITHUB_STEP_SUMMARY
          echo "- **Description:** ${{ github.event.inputs.description }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release Type:** ${{ github.event.inputs.release_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Dev Commit:** ${{ github.event.inputs.dev_commit }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Confirmation:** ${{ github.event.inputs.confirm }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AI Generated Notes:** ${{ github.event.inputs.ai_generated_notes }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status Check Timeout:** ${{ github.event.inputs.commit_status_timeout }} attempts" >> $GITHUB_STEP_SUMMARY
          echo "- **Status Check Interval:** ${{ github.event.inputs.commit_status_interval }} seconds" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: ğŸ” Log Git & Environment Context
        run: |
          echo "=== ğŸ” GIT CONTEXT ==="
          echo "Branch: ${{ github.ref_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "SHA: ${{ github.sha }}"
          echo "Event: ${{ github.event_name }}"
          echo ""

          echo "Git Status:"
          git status --porcelain || echo "No git status available"
          echo ""

          echo "Recent Commits (last 5):"
          git log --oneline -5 || echo "No git log available"
          echo ""

          echo "Remote branches:"
          git branch -r | head -10 || echo "No remote branches info"
          echo ""

          echo "Latest tags:"
          git tag --sort=-version:refname | head -10 || echo "No tags found"
          echo ""

          echo "### ğŸ” Git Context:" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **SHA:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Event:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: ğŸ› ï¸ Log Environment & AI Configuration
        run: |
          echo "=== ğŸ› ï¸ ENVIRONMENT ==="
          echo "Runner OS: ${{ runner.os }}"
          echo "Default AI Model: ${{ env.DEFAULT_AI_MODEL }}"
          echo "Fallback AI Model: ${{ env.FALLBACK_AI_MODEL }}"
          echo "Ollama Timeout: ${{ env.OLLAMA_TIMEOUT }}"
          echo "Ollama Retries: ${{ env.OLLAMA_RETRIES }}"
          echo "Build Timeout: ${{ env.BUILD_TIMEOUT }}"
          echo ""

          echo "=== ğŸ§ª VALIDATION CHECKS ==="
          echo "Confirmation Valid: ${{ github.event.inputs.confirm == 'PUBLISH' }}"
          echo "Branch Valid: ${{ github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev' }}"
          echo "Will Proceed: ${{ github.event.inputs.confirm == 'PUBLISH' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev') }}"
          echo ""

          echo "### ğŸ› ï¸ Environment:" >> $GITHUB_STEP_SUMMARY
          echo "- **Runner OS:** ${{ runner.os }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AI Model:** ${{ env.DEFAULT_AI_MODEL }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Valid Confirmation:** ${{ github.event.inputs.confirm == 'PUBLISH' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Valid Branch:** ${{ github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Will Proceed:** ${{ github.event.inputs.confirm == 'PUBLISH' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev') }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: ğŸ“Š Log Previous Releases
        run: |
          echo "=== ğŸ“Š RELEASE HISTORY ==="
          echo "Checking existing releases..."

          # Get latest releases
          RELEASES=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases?per_page=5" \
            | jq -r '.[] | "\(.tag_name) - \(.published_at // "draft") - \(.draft)"' 2>/dev/null || echo "Unable to fetch releases")

          echo "Recent releases:"
          echo "$RELEASES"
          echo ""

          # Get latest tags
          echo "Latest tags:"
          git tag --sort=-version:refname | head -5 || echo "No tags found"
          echo ""

          echo "### ğŸ“Š Release History:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "$RELEASES" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

  validate-inputs:
    name: 'ğŸ” Validate Inputs'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: github.event.inputs.confirm == 'PUBLISH' && github.event.inputs.testing_mode != 'yes' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev')
    outputs:
      new_version: ${{ steps.version.outputs.new_version }}
      previous_version: ${{ steps.version.outputs.previous_version }}
      release_type: ${{ steps.version.outputs.release_type }}

    steps:
      - name: ğŸ”’ Check Branch Restriction
        run: |
          echo "ğŸ”’ Checking branch restrictions..."
          echo "Current branch: ${{ github.ref_name }}"
          echo "Current ref: ${{ github.ref }}"

          if [[ "${{ github.ref }}" != "refs/heads/main" && "${{ github.ref }}" != "refs/heads/dev" ]]; then
            echo "âŒ ERROR: This workflow can only be triggered from 'main' or 'dev' branches"
            echo "âŒ Current branch: ${{ github.ref_name }}"
            echo "âŒ Please switch to 'main' or 'dev' branch before running this workflow"
            exit 1
          fi

          echo "âœ… Branch check passed - running from ${{ github.ref_name }}"

      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ” Validate dev commit
        run: |
          echo "ğŸ” Validating dev commit..."

          # Get the commit to validate and trim whitespace
          COMMIT_SHA=$(echo "${{ github.event.inputs.dev_commit }}" | xargs)

          if [ -n "$COMMIT_SHA" ]; then
            echo "ğŸ“Œ Using specified commit: $COMMIT_SHA"

            # Verify commit exists and is from dev branch
            if ! git cat-file -e "$COMMIT_SHA" 2>/dev/null; then
              echo "âŒ Commit $COMMIT_SHA does not exist!"
              exit 1
            fi

            if ! git merge-base --is-ancestor "$COMMIT_SHA" origin/dev; then
              echo "âŒ Commit $COMMIT_SHA is not in dev branch!"
              exit 1
            fi

            echo "âœ… Commit $COMMIT_SHA is valid and from dev branch"
          else
            echo "ğŸ“Œ Using latest dev commit (no specific commit specified)"
          fi

          echo "âœ… Ready to publish"

      - name: ğŸ·ï¸ Calculate Next Version
        id: version
        run: |
          echo "ğŸ”„ Getting latest release version..."

          # Use provided previous version or auto-detect
          if [ -n "${{ github.event.inputs.previous_version }}" ]; then
            LATEST_VERSION="${{ github.event.inputs.previous_version }}"
            echo "ğŸ“Œ Using provided previous version: $LATEST_VERSION"
          else
            # Get latest git tag version, default to book-v0.0.0 if no tags exist
            LATEST_VERSION=$(git tag -l "book-v*" | sort -V | tail -n1)
            if [ -z "$LATEST_VERSION" ]; then
              LATEST_VERSION="book-v0.0.0"
              echo "ğŸ“Š No git tags found, using default: $LATEST_VERSION"
            else
              echo "ğŸ“Š Auto-detected latest git tag: $LATEST_VERSION"
            fi
          fi

          # Remove 'book-v' prefix for calculation
          VERSION_NUM=${LATEST_VERSION#book-v}

          # Split version into components
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_NUM"

          # Handle empty or invalid versions
          MAJOR=${MAJOR:-0}
          MINOR=${MINOR:-0}
          PATCH=${PATCH:-0}

          echo "ğŸ“Š Previous version components: $MAJOR.$MINOR.$PATCH"

          # Calculate new version based on release type
          case "${{ github.event.inputs.release_type }}" in
            "major")
              NEW_MAJOR=$((MAJOR + 1))
              NEW_MINOR=0
              NEW_PATCH=0
              ;;
            "minor")
              NEW_MAJOR=$MAJOR
              NEW_MINOR=$((MINOR + 1))
              NEW_PATCH=0
              ;;
            "patch")
              NEW_MAJOR=$MAJOR
              NEW_MINOR=$MINOR
              NEW_PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="book-v$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
          echo "ğŸ¯ New version: $NEW_VERSION (${{ github.event.inputs.release_type }} release)"
          echo "ğŸ“‹ Description: ${{ github.event.inputs.description }}"

          # Export for other steps
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "release_type=${{ github.event.inputs.release_type }}" >> $GITHUB_OUTPUT
          echo "previous_version=$LATEST_VERSION" >> $GITHUB_OUTPUT

  pre-flight-checks:
    name: 'ğŸ›« Pre-Flight Validation'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: validate-inputs
    if: github.event.inputs.confirm == 'PUBLISH' && github.event.inputs.testing_mode != 'yes'

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ” Validate Dev Branch Content
        run: |
          echo "ğŸ” Validating dev branch content before merge..."

          # Switch to dev branch and pull latest
          git checkout dev
          git pull origin dev

          # Check if dev commit exists and is valid
          if [ -n "${{ github.event.inputs.dev_commit }}" ]; then
            DEV_COMMIT=$(echo "${{ github.event.inputs.dev_commit }}" | xargs)
            echo "ğŸ“Œ Validating specific commit: $DEV_COMMIT"

            if ! git cat-file -e "$DEV_COMMIT" 2>/dev/null; then
              echo "âŒ Commit $DEV_COMMIT does not exist!"
              exit 1
            fi

            if ! git merge-base --is-ancestor "$DEV_COMMIT" HEAD; then
              echo "âŒ Commit $DEV_COMMIT is not in current dev branch!"
              exit 1
            fi

            # Checkout the specific commit for validation
            git checkout "$DEV_COMMIT"
          fi

          echo "âœ… Dev branch content validated"

      - name: ğŸ“š Validate Quarto Project Structure
        run: |
          echo "ğŸ“š Validating Quarto project structure..."

          cd ${{ vars.BOOK_QUARTO }}

          # Check critical files exist using environment variables
          # Note: paths are relative to ${{ vars.BOOK_QUARTO }}/ after the cd above
          REQUIRED_FILES=("${{ env.QUARTO_MAIN_CONFIG }}" "config/${{ env.QUARTO_HTML_CONFIG }}" "config/${{ env.QUARTO_PDF_CONFIG }}")
          for file in "${REQUIRED_FILES[@]}"; do
            if [ ! -f "$file" ]; then
              echo "âŒ Required file missing: $file"
              exit 1
            fi
            echo "âœ… Found: $file"
          done

          # Validate Quarto configuration
          if command -v quarto >/dev/null 2>&1; then
            echo "ğŸ” Checking Quarto configuration..."
            if ! quarto check; then
              echo "âš ï¸ Quarto check reported issues, but continuing..."
            fi
          else
            echo "â„¹ï¸ Quarto not available for validation in this environment"
          fi

          echo "âœ… Quarto project structure validated"

      - name: ğŸ§ª Test Build Prerequisites
        run: |
          echo "ğŸ§ª Testing build prerequisites..."

          # Check disk space (PDF builds need significant space)
          echo "ğŸ’¾ Checking disk space..."
          df -h

          AVAILABLE_GB=$(df / | awk 'NR==2 {print int($4/1024/1024)}')
          echo "ğŸ“Š Available disk space: ${AVAILABLE_GB}GB"

          if [ "$AVAILABLE_GB" -lt 5 ]; then
            echo "âŒ Insufficient disk space! Need at least 5GB, have ${AVAILABLE_GB}GB"
            exit 1
          fi

          echo "âœ… Sufficient disk space available"

          # Test GitHub API access
          echo "ğŸ” Testing GitHub API access..."
          if ! curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
               "https://api.github.com/repos/${{ github.repository }}" >/dev/null; then
            echo "âŒ GitHub API access failed!"
            exit 1
          fi
          echo "âœ… GitHub API access confirmed"

          echo "âœ… All prerequisites validated"

      - name: ğŸ¤– Test AI System Availability
        if: github.event.inputs.ai_generated_notes == 'yes'
        run: |
          echo "ğŸ¤– Testing if AI system can be installed for release notes..."

          # Quick test: Can we download Ollama installer?
          echo "ğŸ” Checking Ollama availability..."
          if curl -fsSL --max-time 30 https://ollama.ai/install.sh > /dev/null; then
            echo "âœ… Ollama installer is accessible"
            echo "ğŸ¤– AI-enhanced release notes will be available"
          else
            echo "âš ï¸ Ollama installer not accessible"
            echo "ğŸ“‹ Will use git-log-only release notes instead"
            echo "ğŸ’¡ This is not a failure - release notes will still be generated"
          fi

          echo "âœ… AI system availability check complete"

      - name: ğŸ“‹ Pre-Flight Summary
        run: |
          echo "## ğŸ›« Pre-Flight Validation Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** All checks passed âœ…" >> $GITHUB_STEP_SUMMARY
          echo "**Dev Commit:** ${{ github.event.inputs.dev_commit || 'latest' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Target Version:** ${{ needs.validate-inputs.outputs.new_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Validation Time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âœ… Validated:" >> $GITHUB_STEP_SUMMARY
          echo "- Dev branch content and commit validity" >> $GITHUB_STEP_SUMMARY
          echo "- Quarto project structure and configuration" >> $GITHUB_STEP_SUMMARY
          echo "- Build prerequisites (disk space, API access)" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event.inputs.ai_generated_notes }}" = "yes" ]; then
            echo "- AI system (Ollama) installation and testing" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ğŸš€ **Ready to proceed with merge and publication!**" >> $GITHUB_STEP_SUMMARY

  update-version:
    name: 'ğŸ“ Update Version Number'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [validate-inputs, pre-flight-checks]
    if: github.event.inputs.confirm == 'PUBLISH' && github.event.inputs.testing_mode != 'yes'

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ“ Update Version in index.qmd
        run: |
          echo "ğŸ“ Updating version number in ${{ vars.BOOK_QUARTO }}/index.qmd..."
          echo "ğŸ¯ This automatically updates the version displayed on the website"
          echo "ğŸ”— The version links to GitHub releases via assets/scripts/version-link.js"
          echo ""

          # Switch to dev branch first to update the file
          git checkout dev
          git pull origin dev

          # Find and update the doi line with the new version
          # The doi field is repurposed to show version (with custom label "Version")
          # JavaScript makes it link to releases page instead of DOI registry
          sed -i "s|doi: \".*\"|doi: \"${{ needs.validate-inputs.outputs.new_version }}\"|g" ${{ vars.BOOK_QUARTO }}/index.qmd

          echo "âœ… Version updated to ${{ needs.validate-inputs.outputs.new_version }}"
          echo "ğŸ“„ Updated line:"
          cat ${{ vars.BOOK_QUARTO }}/index.qmd | grep "doi:" || echo "Could not verify doi field"

          # Commit the version update
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add ${{ vars.BOOK_QUARTO }}/index.qmd
          git commit -m "chore: update version to ${{ needs.validate-inputs.outputs.new_version }}" || echo "No changes to commit"
          git push origin dev

          echo "âœ… Version committed to dev branch"
          echo "ğŸ”„ Next step: merge-to-main will include this version update"

  merge-to-main:
    name: 'ğŸ”„ Merge to Main'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [validate-inputs, pre-flight-checks, update-version]
    if: github.event.inputs.confirm == 'PUBLISH' && github.event.inputs.testing_mode != 'yes'

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ” Check for workflow file changes
        run: |
          echo "ğŸ” Checking if workflow files will be modified in merge..."

          # Check if workflow files are in the dev branch changes
          if git diff --name-only origin/main..origin/dev | grep -q "\.github/workflows/"; then
            echo "âš ï¸  Workflow files detected in dev branch!"
            echo "ğŸ“‹ This will cause permission issues with publish-live workflow."
            echo "ğŸ’¡ Please manually merge workflow changes first:"
            echo "   1. Create PR for workflow changes"
            echo "   2. Review and merge to main"
            echo "   3. Then run publish-live for content only"
            echo ""
            echo "ğŸ” Workflow files in dev branch:"
            git diff --name-only origin/main..origin/dev | grep "\.github/workflows/"
            echo ""
            echo "âŒ Stopping to prevent permission issues"
            exit 1
          else
            echo "âœ… No workflow files detected - safe to proceed"
          fi

      - name: ğŸ”„ Merge dev to main
        run: |
          echo "ğŸ”„ Configuring git..."
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          echo "ğŸ”„ Fetching latest changes (including version update)..."
          git fetch origin dev
          git fetch origin main

          echo "ğŸ”„ Switching to main branch..."
          git checkout main
          git pull origin main

          # Safety check: Ensure main isn't ahead of specified dev commit
          if [ -n "${{ github.event.inputs.dev_commit }}" ]; then
            DEV_COMMIT=$(echo "${{ github.event.inputs.dev_commit }}" | xargs)
            echo "ğŸ” Checking if main is ahead of specified commit $DEV_COMMIT..."

            # Check if dev_commit is an ancestor of current main
            if git merge-base --is-ancestor "$DEV_COMMIT" HEAD; then
              echo "âš ï¸ MAIN IS AHEAD OF SPECIFIED COMMIT!"
              echo "ğŸ“Š Current main includes changes newer than $DEV_COMMIT"
              echo ""
              echo "ğŸ›‘ This would create a mixed state (old dev + new main changes)"
              echo "ğŸ“‹ Options to resolve:"
              echo "   A) Use latest dev instead (leave dev_commit empty)"
              echo "   B) Reset main to match dev commit (destructive):"
              echo "      git checkout main && git reset --hard $DEV_COMMIT && git push --force-with-lease"
              echo "   C) Merge dev branch normally first, then publish"
              echo ""
              echo "âŒ Stopping to prevent untested mixed state"
              exit 1
            else
              echo "âœ… Safe to merge: $DEV_COMMIT is newer than current main"
            fi
          fi

          echo "ğŸ” Checking for potential merge conflicts..."
          # Test merge without committing
          if ! git merge --no-commit --no-ff origin/dev 2>/dev/null; then
            echo "âŒ MERGE CONFLICTS DETECTED!"
            echo "ğŸ›‘ Automated merge cannot proceed due to conflicts."
            echo "ğŸ“‹ Please resolve conflicts manually:"
            echo "   1. git checkout main"
            echo "   2. git pull origin main"
            echo "   3. git merge dev"
            echo "   4. Resolve conflicts and commit"
            echo "   5. git push origin main"
            git merge --abort
            exit 1
          fi
          git reset --hard HEAD  # Clean up test merge

          echo "âœ… No conflicts detected. Proceeding with merge..."
          echo "ğŸ”„ Merging dev into main..."

          # Debug: Show what dev_commit input was received
          DEV_COMMIT_INPUT="${{ github.event.inputs.dev_commit }}"
          echo "ğŸ” DEBUG: dev_commit input = '$DEV_COMMIT_INPUT'"
          echo "ğŸ” DEBUG: Input length = ${#DEV_COMMIT_INPUT}"

          # Determine which commit to merge
          if [ -n "${{ github.event.inputs.dev_commit }}" ]; then
            MERGE_COMMIT=$(echo "${{ github.event.inputs.dev_commit }}" | xargs)
            echo "ğŸ“Œ SPECIFIC COMMIT MODE: Merging exact commit: $MERGE_COMMIT"
            echo "âš ï¸  This includes content + workflow files from that point in time"
          else
            MERGE_COMMIT="origin/dev"
            echo "ğŸ“Š LATEST DEV MODE: Merging latest dev commit"
            echo "âœ… This includes newest content + newest workflow files"
          fi

          echo "ğŸ¯ Final merge target: $MERGE_COMMIT"

          git merge "$MERGE_COMMIT" --no-ff -m "ğŸš€ Release ${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}

          Merged dev branch to main for publication.

          Release Type: ${{ github.event.inputs.release_type }}
          Published by: ${{ github.actor }}
          Dev Commit: ${MERGE_COMMIT}
          Specific Commit: ${{ github.event.inputs.dev_commit || 'latest dev' }}
          Description: ${{ github.event.inputs.description }}"

          echo "âœ… Merge completed successfully!"

      - name: ğŸš€ Push merge to main
        run: |
          echo "ğŸš€ Pushing merge to main branch..."
          git push origin main

          echo "âœ… Main branch updated successfully!"
          echo "ğŸ“‹ Next step: Monitor production build, then create release tag"

  trigger-production-build:
    name: 'ğŸš€ Trigger Production Build'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: merge-to-main
    if: github.event.inputs.confirm == 'PUBLISH' && github.event.inputs.testing_mode != 'yes'
    outputs:
      commit_sha: ${{ steps.commit.outputs.commit_sha }}

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸš€ Get Current Commit SHA
        id: commit
        run: |
          # Get the latest commit SHA from main branch
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "ğŸ“Œ Current commit SHA: $COMMIT_SHA"

  # Matrix-driven production build (clean and simple!)
  call-production-build:
    name: 'ğŸš€ Call Production Build Matrix'
    needs: [merge-to-main, trigger-production-build]
    uses: ./.github/workflows/book-build-container.yml
    with:
      build_linux: true    # Production builds Linux only for now
      build_windows: false
      build_html: true     # HTML + PDF + EPUB for production
      build_pdf: true
      build_epub: true
      target: main
      container_registry: 'ghcr.io'
      container_tag: 'latest'


  create-tag:
    name: 'ğŸ·ï¸ Create Release Tag (Final Step)'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [validate-inputs, download-and-deploy-artifacts]
    if: github.event.inputs.confirm == 'PUBLISH' && github.event.inputs.testing_mode != 'yes'

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ”„ Sync with latest main
        run: |
          echo "ğŸ”„ Configuring git..."
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          echo "ğŸ”„ Switching to main and pulling latest changes..."
          git checkout main
          git pull origin main

          echo "âœ… Synced with latest main branch"

      - name: ğŸ·ï¸ Create Release Tag
        run: |
          echo "ğŸ·ï¸ Creating release tag ${{ needs.validate-inputs.outputs.new_version }}..."
          echo "âœ… Build AND deployment completed successfully - safe to create release tag"

          # Check if tag already exists locally
          if git tag -l "${{ needs.validate-inputs.outputs.new_version }}" | grep -q "${{ needs.validate-inputs.outputs.new_version }}"; then
            echo "âš ï¸ Tag ${{ needs.validate-inputs.outputs.new_version }} already exists locally"
            echo "ğŸ”„ Removing existing tag to recreate it..."
            git tag -d ${{ needs.validate-inputs.outputs.new_version }}
          fi

          # Check if tag exists on remote
          if git ls-remote --tags origin | grep -q "refs/tags/${{ needs.validate-inputs.outputs.new_version }}$"; then
            echo "âš ï¸ Tag ${{ needs.validate-inputs.outputs.new_version }} already exists on remote"
            echo "ğŸ”„ Removing remote tag to recreate it..."
            git push origin --delete ${{ needs.validate-inputs.outputs.new_version }}
          fi

          # Create the tag on the latest main commit
          git tag -a ${{ needs.validate-inputs.outputs.new_version }} -m "Release ${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}"
          echo "âœ… Tag created successfully!"

      - name: ğŸš€ Push tag for release tracking
        run: |
          echo "ğŸš€ Pushing release tag for version tracking..."
          git push origin ${{ needs.validate-inputs.outputs.new_version }}

          echo "âœ… Release tag pushed successfully!"
          echo "ğŸ·ï¸ Tag: ${{ needs.validate-inputs.outputs.new_version }}"
          echo "ğŸ“‹ Description: ${{ github.event.inputs.description }}"
          echo "ğŸ“Š This tag marks a successful build and tested release"

  download-and-deploy-artifacts:
    name: 'ğŸ“¦ Download Artifacts & Deploy to GitHub Pages'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: call-production-build
    if: github.event.inputs.confirm == 'PUBLISH' && github.event.inputs.testing_mode != 'yes'
    permissions:
      contents: write # Allow write access to repository for gh-pages push
      pages: write    # Allow GitHub Pages deployment
      actions: read   # Allow reading of workflow artifacts

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ” Validate API Contract
        run: |
          echo "ğŸ” Validating artifact names from API..."

          HTML_ARTIFACT="${{ needs.call-production-build.outputs.linux_html_artifact }}"
          PDF_ARTIFACT="${{ needs.call-production-build.outputs.linux_pdf_artifact }}"
          EPUB_ARTIFACT="${{ needs.call-production-build.outputs.linux_epub_artifact }}"

          echo "ğŸ“„ HTML artifact name: '$HTML_ARTIFACT'"
          echo "ğŸ“‘ PDF artifact name: '$PDF_ARTIFACT'"
          echo "ğŸ“š EPUB artifact name: '$EPUB_ARTIFACT'"

          # Fail explicitly if API didn't provide artifact names
          if [ -z "$HTML_ARTIFACT" ]; then
            echo "âŒ CRITICAL: HTML artifact name not provided by build workflow API!"
            echo "ğŸ”§ This indicates the workflow output contract is broken."
            exit 1
          fi

          if [ -z "$PDF_ARTIFACT" ]; then
            echo "âŒ CRITICAL: PDF artifact name not provided by build workflow API!"
            echo "ğŸ”§ This indicates the workflow output contract is broken."
            exit 1
          fi

          if [ -z "$EPUB_ARTIFACT" ]; then
            echo "âŒ CRITICAL: EPUB artifact name not provided by build workflow API!"
            echo "ğŸ”§ This indicates the workflow output contract is broken."
            exit 1
          fi

          echo "âœ… API contract validated - all artifact names provided"

      - name: ğŸ“¦ Download HTML Artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.call-production-build.outputs.linux_html_artifact }}
          path: ./html-temp

      - name: ğŸ“¦ Download PDF Artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.call-production-build.outputs.linux_pdf_artifact }}
          path: ./pdf-temp

      - name: ğŸ“¦ Download EPUB Artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.call-production-build.outputs.linux_epub_artifact }}
          path: ./epub-temp
        continue-on-error: true

      - name: ğŸ“‹ Verify Downloaded Artifacts
        run: |
          echo "ğŸ“¦ Verifying downloaded artifacts..."

          # Find HTML build directory - check if html-temp has content
          if [ ! -d "html-temp" ] || [ -z "$(ls -A html-temp 2>/dev/null)" ]; then
            echo "âŒ HTML build directory not found or empty!"
            echo "ğŸ“Š HTML artifact contents:"
            find html-temp -type f -o -type d | head -20
            exit 1
          fi

          # Look for the actual HTML build structure
          HTML_BUILD_DIR="html-temp"
          if [ -d "html-temp/html" ]; then
            HTML_BUILD_DIR="html-temp/html"
            echo "âœ… HTML build found in subdirectory: $HTML_BUILD_DIR"
          else
            echo "âœ… HTML build found at root level: $HTML_BUILD_DIR"
          fi

          echo "ğŸ“Š HTML structure preview:"
          ls -la "$HTML_BUILD_DIR" | head -5

          # Find PDF file
          PDF_FILE=$(find pdf-temp -name "Machine-Learning-Systems.pdf" -type f | head -1)
          if [ -z "$PDF_FILE" ] || [ ! -f "$PDF_FILE" ]; then
            echo "âŒ PDF file not found in extracted artifacts!"
            echo "ğŸ“Š PDF artifact contents:"
            find pdf-temp -type f -o -type d | head -20
            exit 1
          fi

          echo "âœ… PDF found: $PDF_FILE"
          echo "ğŸ“Š PDF size: $(du -h "$PDF_FILE" | cut -f1)"

          # Find EPUB file if available
          EPUB_FILE=""
          if [ -d "epub-temp" ]; then
            EPUB_FILE=$(find epub-temp -name "Machine-Learning-Systems.epub" -type f | head -1)
            if [ -z "$EPUB_FILE" ] || [ ! -f "$EPUB_FILE" ]; then
              # Try alternative EPUB filenames
              EPUB_FILE=$(find epub-temp -name "*.epub" -type f | head -1)
              if [ -n "$EPUB_FILE" ] && [ -f "$EPUB_FILE" ]; then
                echo "âœ… EPUB found (alternative name): $EPUB_FILE"
                echo "ğŸ“Š EPUB size: $(du -h "$EPUB_FILE" | cut -f1)"
              else
                echo "âš ï¸ EPUB file not found in extracted artifacts - will skip EPUB deployment"
                EPUB_FILE=""
              fi
            else
              echo "âœ… EPUB found: $EPUB_FILE"
              echo "ğŸ“Š EPUB size: $(du -h "$EPUB_FILE" | cut -f1)"
            fi
          else
            echo "âš ï¸ No EPUB artifact extracted - will skip EPUB deployment"
          fi

          # Prepare combined site
          echo "ğŸ”„ Preparing combined HTML site with PDF and EPUB..."
          mkdir -p combined-site

          # Copy HTML content
          cp -r "$HTML_BUILD_DIR"/* combined-site/

          # Create assets and downloads directories
          mkdir -p combined-site/assets/downloads

          # Copy PDF if available
          if [ -n "$PDF_FILE" ] && [ -f "$PDF_FILE" ]; then
            PDF_SIZE_MB=$(du -m "$PDF_FILE" | cut -f1)
            echo "ğŸ“Š PDF size: ${PDF_SIZE_MB}MB"

            # Deploy PDF to both GitHub Pages and GitHub Release
            cp "$PDF_FILE" combined-site/assets/downloads/Machine-Learning-Systems.pdf
            echo "âœ… PDF deployed to GitHub Pages (${PDF_SIZE_MB}MB)"

            # Also copy PDF for GitHub release
            cp "$PDF_FILE" "Machine-Learning-Systems.pdf"
            echo "âœ… PDF prepared for release"
          else
            echo "âŒ PDF file not found - skipping PDF deployment"
          fi

          # Copy EPUB if available
          if [ -n "$EPUB_FILE" ] && [ -f "$EPUB_FILE" ]; then
            EPUB_SIZE_MB=$(du -m "$EPUB_FILE" | cut -f1)
            echo "ğŸ“Š EPUB size: ${EPUB_SIZE_MB}MB"

            # Deploy EPUB to both GitHub Pages and GitHub Release
            cp "$EPUB_FILE" combined-site/assets/downloads/Machine-Learning-Systems.epub
            echo "âœ… EPUB deployed to GitHub Pages (${EPUB_SIZE_MB}MB)"

            # Also copy EPUB for GitHub release
            cp "$EPUB_FILE" "Machine-Learning-Systems.epub"
            echo "âœ… EPUB prepared for release"
          else
            echo "âŒ EPUB file not found - skipping EPUB deployment"
          fi

          echo "ğŸ“Š Combined site structure:"
          ls -la combined-site/ | head -10
          echo "ğŸ“Š Assets directory:"
          ls -la combined-site/assets/

          # Summary of what was prepared
          echo "ğŸ“‹ Asset preparation complete:"
          if [ -f "Machine-Learning-Systems.pdf" ]; then
            echo "  âœ… PDF: Ready for deployment"
          else
            echo "  âŒ PDF: Not available"
          fi
          if [ -f "Machine-Learning-Systems.epub" ]; then
            echo "  âœ… EPUB: Ready for deployment"
          else
            echo "  âŒ EPUB: Not available"
          fi

      - name: ğŸš€ Deploy Combined Site to GitHub Pages (Production)
        run: |
          echo "ğŸš€ Deploying combined HTML + PDF + EPUB site to GitHub Pages..."
          echo "ğŸŒ Production URL: https://harvard-edge.github.io/cs249r_book/"

          # Clone gh-pages branch
          git clone --depth=1 --branch=gh-pages https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git gh-pages-repo

          cd gh-pages-repo

          # Configure git identity inside the repository
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # =================================================================
          # SUBDIRECTORY DEPLOYMENT: Book deploys to /book/
          # =================================================================
          # Each subsite has its own directory (no conflicts, no preservation needed):
          #   /book/      - Main textbook (this workflow)
          #   /tinytorch/ - TinyTorch framework (tinytorch-publish-live.yml)
          #   /kits/      - Hardware Kits (kits-publish-live.yml)
          #   /collabs/   - Collaborations (collabs-publish-live.yml)
          # =================================================================

          # Clear only the book/ subdirectory (preserves other subsites)
          echo "ğŸ—‘ï¸ Clearing existing book/ directory..."
          rm -rf book/

          # Clean up stale root-level files from old deployment structure
          echo "ğŸ§¹ Removing stale root-level files..."
          rm -rf contents/ assets/ site_libs/ tools/
          rm -f _redirects netlify.toml search.json sitemap.xml site.webmanifest 404.html
          
          # Remove development artifacts and symlinks that break GitHub Pages
          echo "ğŸ§¹ Removing development artifacts..."
          rm -rf __pycache__/ .vscode/ .tito/ benchmark_results/ mlsysbook.egg-info/
          rm -f .luarc.json
          rm -rf .claude .github  # Remove symlinks and dev-only directories
          echo "âœ… Stale files removed"

          # Create book directory and copy new content
          echo "ğŸ“¦ Deploying textbook to /book/..."
          mkdir -p book
          cp -r ../combined-site/* book/

          # Ensure CNAME file exists at root for custom domain
          if [ ! -f "CNAME" ]; then
            echo "mlsysbook.ai" > CNAME
            echo "âœ… CNAME file created for mlsysbook.ai"
          else
            echo "âœ… CNAME file already exists"
          fi

          # Ensure .nojekyll exists at root
          touch .nojekyll

          # Create root index.html that redirects to /book/
          cat > index.html << 'EOF'
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <meta http-equiv="refresh" content="0;url=/book/">
            <link rel="canonical" href="https://mlsysbook.ai/book/">
            <title>Redirecting to ML Systems Textbook...</title>
          </head>
          <body>
            <p>Redirecting to <a href="/book/">ML Systems Textbook</a>...</p>
          </body>
          </html>
          EOF
          echo "âœ… Root redirect to /book/ created"

          echo "ğŸ“Š Deployed content structure:"
          ls -la | head -15
          echo "ğŸ“Š Book directory contents:"
          ls -la book/ | head -10

          # Add all files to git
          git add .

          # Check if there are actually changes to commit
          echo "ğŸ” Checking for changes to deploy..."
          if git diff --cached --quiet; then
            echo "âŒ CRITICAL: No changes detected in staging area!"
            echo "ğŸ”§ This indicates the site content wasn't properly copied or is identical to existing content."
            echo "ğŸ“Š Current directory contents:"
            ls -la | head -10
            exit 1
          else
            echo "âœ… Changes detected - proceeding with deployment"
            CHANGED_FILES=$(git diff --cached --name-only | wc -l)
            echo "ğŸ“Š Files to be deployed: $CHANGED_FILES"
          fi

          # Commit with comprehensive validation
          echo "ğŸ“ Creating deployment commit..."
          COMMIT_MSG="ğŸš€ Deploy release ${{ needs.validate-inputs.outputs.new_version }} to /book/ from commit ${{ github.sha }}

          Combined HTML site with PDF and EPUB assets for download.

          - HTML: Interactive web textbook at /book/
          - PDF: /book/assets/downloads/Machine-Learning-Systems.pdf
          - EPUB: /book/assets/downloads/Machine-Learning-Systems.epub (if available)
          - Release: ${{ needs.validate-inputs.outputs.new_version }}
          - Files updated: $CHANGED_FILES"

          if git commit -m "$COMMIT_MSG"; then
            echo "âœ… Commit created successfully"
            COMMIT_HASH=$(git rev-parse HEAD)
            echo "ğŸ“‹ Commit hash: $COMMIT_HASH"
          else
            echo "âŒ CRITICAL: Failed to create commit!"
            echo "ğŸ”§ Git status:"
            git status
            exit 1
          fi

          # Push with validation
          echo "ğŸš€ Pushing to gh-pages branch..."
          if git push origin gh-pages; then
            echo "âœ… Push successful!"

            # Verify the push actually updated the remote
            echo "ğŸ” Verifying remote update..."
            REMOTE_HASH=$(git ls-remote origin gh-pages | cut -f1)
            if [ "$COMMIT_HASH" = "$REMOTE_HASH" ]; then
              echo "âœ… Remote branch updated successfully"
              echo "ğŸ“‹ Remote commit hash matches local: $REMOTE_HASH"
            else
              echo "âš ï¸ WARNING: Remote hash doesn't match local commit"
              echo "ğŸ“‹ Local: $COMMIT_HASH"
              echo "ğŸ“‹ Remote: $REMOTE_HASH"
            fi
          else
            echo "âŒ CRITICAL: Failed to push to gh-pages!"
            echo "ğŸ”§ This could be due to permissions or network issues."
            exit 1
          fi

          echo ""
          echo "ğŸ‰ GitHub Pages deployment completed successfully!"
          echo "ğŸ“Š Deployment Summary:"
          echo "  - Files updated: $CHANGED_FILES"
          echo "  - Commit hash: $COMMIT_HASH"
          echo "  - Branch: gh-pages"
          echo "  - Deploy path: /book/"
          echo ""
          echo "ğŸŒ Site URLs:"
          echo "  - Textbook: https://mlsysbook.ai/book/"
          echo "  - TinyTorch: https://mlsysbook.ai/tinytorch/"
          echo "  - Hardware Kits: https://mlsysbook.ai/kits/"
          echo "  - Root (redirects to /book/): https://mlsysbook.ai/"
          echo ""
          echo "ğŸ“„ Direct Asset Links:"
          echo "  - PDF: https://mlsysbook.ai/book/assets/downloads/Machine-Learning-Systems.pdf"
          echo "  - EPUB: https://mlsysbook.ai/book/assets/downloads/Machine-Learning-Systems.epub"
          echo ""
          echo "â° Note: Changes may take 1-5 minutes to appear due to CDN caching."
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ“¤ Upload PDF Artifact for GitHub Release
        uses: actions/upload-artifact@v4
        with:
          name: pdf-artifact
          path: Machine-Learning-Systems.pdf

      - name: ğŸ“¤ Upload EPUB Artifact for GitHub Release
        if: success()
        run: |
          if [ -f "Machine-Learning-Systems.epub" ]; then
            echo "âœ… EPUB file found for upload"
          else
            echo "âš ï¸ No EPUB file found - creating empty artifact to prevent workflow failure"
            touch Machine-Learning-Systems.epub
          fi

      - name: ğŸ“¤ Upload EPUB Artifact
        uses: actions/upload-artifact@v4
        with:
          name: epub-artifact
          path: Machine-Learning-Systems.epub
          if-no-files-found: warn

  generate-release-notes:
    name: 'ğŸ“ Generate Release Notes'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [validate-inputs, download-and-deploy-artifacts]
    if: github.event.inputs.confirm == 'PUBLISH' && github.event.inputs.testing_mode != 'yes'

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ“„ Download PDF from previous job
        uses: actions/download-artifact@v4
        with:
          name: pdf-artifact
          path: ./

      - name: ğŸ“ Generate Release Notes
        run: |
          echo "ğŸ“ Generating release notes..."
          echo "ğŸ¤– AI Enhancement Mode: ${{ github.event.inputs.ai_generated_notes }}"
          if [ "${{ github.event.inputs.ai_generated_notes }}" = "yes" ]; then
            echo "   âœ… Will use AI to enhance git log (if AI system is available)"
          else
            echo "   ğŸ“‹ Will use git log only (clean, reliable format)"
          fi
          echo ""

          # Generate git log between versions
          PREVIOUS_VERSION="${{ needs.validate-inputs.outputs.previous_version }}"
          CURRENT_VERSION="${{ needs.validate-inputs.outputs.new_version }}"

          echo "ğŸ“Š Generating git log from $PREVIOUS_VERSION to current commit..."

          # Create detailed git log
          echo "# Release Notes for $CURRENT_VERSION" > git_changes.md
          echo "" >> git_changes.md
          echo "## Changes since $PREVIOUS_VERSION" >> git_changes.md
          echo "" >> git_changes.md

          # Get commit log with details
          if git rev-parse "$PREVIOUS_VERSION" >/dev/null 2>&1; then
            echo "âœ… Previous version tag $PREVIOUS_VERSION found"

            # Summary format for AI processing
            git log --oneline ${PREVIOUS_VERSION}..HEAD > git_log_summary.txt

            # Detailed format for inclusion in release
            echo "### Commit Summary:" >> git_changes.md
            git log --oneline ${PREVIOUS_VERSION}..HEAD >> git_changes.md
            echo "" >> git_changes.md

            echo "### Detailed Changes:" >> git_changes.md
            git log --pretty=format:"- **%s** (%h) by %an%n  %b" ${PREVIOUS_VERSION}..HEAD >> git_changes.md

            echo "ğŸ“Š Found $(git rev-list --count ${PREVIOUS_VERSION}..HEAD) commits since $PREVIOUS_VERSION"
          else
            echo "âš ï¸ Previous version tag $PREVIOUS_VERSION not found, using all commits"
            git log --oneline -20 > git_log_summary.txt
            echo "### Recent Commits:" >> git_changes.md
            git log --oneline -20 >> git_changes.md
          fi

          echo "âœ… Git log generated and saved to files"

          if [ "${{ github.event.inputs.ai_generated_notes }}" = "yes" ]; then
            echo ""
            echo "ğŸ¤– AI Enhancement Mode Selected - installing Ollama for release notes..."

            # Install Ollama for this job (each job runs in isolation)
            echo "ğŸ¤– Installing Ollama..."
            if curl -fsSL https://ollama.ai/install.sh | sh; then
              echo "âœ… Ollama installed successfully"

              # Start Ollama service
              echo "ğŸš€ Starting Ollama service..."
              ollama serve &

              # Wait for service to be ready
              echo "â³ Waiting for Ollama service..."
              OLLAMA_READY=false
              for i in {1..30}; do
                if ollama list >/dev/null 2>&1; then
                  echo "âœ… Ollama service ready after ${i}0 seconds"
                  OLLAMA_READY=true
                  break
                fi
                echo "â³ Waiting... (${i}/30)"
                sleep 10
              done

              if [ "$OLLAMA_READY" = "true" ]; then
                # Pull the model
                MODEL="${{ env.DEFAULT_AI_MODEL }}"
                echo "ğŸ“¦ Pulling AI model: $MODEL"
                if timeout ${{ env.OLLAMA_TIMEOUT }} ollama pull $MODEL; then
                  echo "âœ… Model $MODEL ready for release notes generation"
                  AI_GENERATION_FAILED=false
                else
                  echo "âš ï¸ Model pull failed, using git log only"
                  AI_GENERATION_FAILED=true
                fi
              else
                echo "âš ï¸ Ollama service failed to start, using git log only"
                AI_GENERATION_FAILED=true
              fi
            else
              echo "âš ï¸ Ollama installation failed, using git log only"
              AI_GENERATION_FAILED=true
            fi

            # Generate AI-enhanced release notes using git log
            if [ "$AI_GENERATION_FAILED" != "true" ]; then
              echo "ğŸ“ Generating AI-enhanced release notes from git log..."

              # Create AI prompt with git log content
              {
                echo "Generate release notes for MLSysBook ${{ needs.validate-inputs.outputs.new_version }} - an open-source Machine Learning Systems textbook."
                echo ""
                echo "AUDIENCE: Students, researchers, practitioners, contributors, and educators using the textbook"
                echo "PURPOSE: Professional announcement of improvements and enhancements in this release"
                echo ""
                echo "RELEASE DESCRIPTION: ${{ github.event.inputs.description }}"
                echo "RELEASE TYPE: ${{ github.event.inputs.release_type }}"
                echo ""
                echo "COMMITS:"
                cat git_log_summary.txt
                echo ""
                echo "STYLE REQUIREMENTS:"
                echo "- Academic, professional tone following established MLSysBook release pattern"
                echo "- Focus on USER VALUE: what readers, educators, and students gain"
                echo "- Educational impact: how this improves learning outcomes"
                echo "- Clear structure with appropriate emojis for readability"
                echo "- NO development metrics (commits, technical debt, internal processes)"
                echo "- Write like a scholarly publication announcement, not marketing material"
                echo ""
                echo "LANGUAGE GUIDELINES:"
                echo "EXCELLENT examples of user-focused language:"
                echo "âœ… 'Enhanced visualizations with improved clarity and understanding'"
                echo "âœ… 'Streamlined mathematical notation for better accessibility'"
                echo "âœ… 'Updated code examples reflecting latest ML frameworks'"
                echo "âœ… 'Improved accessibility features for diverse learners'"
                echo "âœ… 'Faster build process for reliable access'"
                echo ""
                echo "AVOID these generic/internal phrases:"
                echo "âŒ 'Various improvements across chapters'"
                echo "âŒ 'Enhanced development workflow'"
                echo "âŒ 'Updated content structure'"
                echo "âŒ 'Fixed issues and bugs'"
                echo "âŒ 'Improved codebase quality'"
                echo "âŒ ANY mention of specific chapter names or numbers"
                echo ""
                echo "REQUIRED STRUCTURE:"
                echo "# Release ${{ needs.validate-inputs.outputs.new_version }}: [Professional Title Based on Main Theme]"
                echo "IMPORTANT: Use the EXACT version number ${{ needs.validate-inputs.outputs.new_version }} in the title"
                echo ""
                echo "[Professional intro paragraph explaining this release's educational focus and value]"
                echo ""
                echo "## âœ¨ Major Features"
                echo ""
                echo "### ğŸ“– Content Improvements"
                echo "* [3-5 specific content enhancements that improve learning experience]"
                echo "* Focus on: visualizations, explanations, examples, mathematical clarity"
                echo ""
                echo "### ğŸ› ï¸ Technical Excellence"
                echo "* [3-5 infrastructure improvements that users actually notice]"
                echo "* Focus on: accessibility, performance, reliability, user experience"
                echo ""
                echo "### ğŸ“ Educational Innovation"
                echo "* [2-3 improvements specifically for educators and learners]"
                echo "* Focus on: teaching features, learning aids, practical applications"
                echo ""
                echo "## ğŸŒŸ Key Achievements"
                echo "[Highlight the most impactful improvements for different user groups]"
                echo ""
                echo "## ğŸ”¬ Educational Impact"
                echo "[Explain how these changes improve learning outcomes and educational value]"
                echo ""
                echo "## ğŸŒ Access Your Enhanced Textbook"
                echo "- ğŸ“– **Online Version**: [mlsysbook.ai](https://mlsysbook.ai)"
                echo "- ğŸ“„ **PDF Download**: Available from release assets"
                echo "- ğŸ“š **EPUB Version**: Available from release assets"
                echo "- ğŸ§ª **Labs & Exercises**: Hands-on learning materials"
                echo ""
                echo "## ğŸ“ Community & Contributions"
                echo "This release incorporates feedback from educators, students, and practitioners. We welcome continued engagement through our [GitHub repository](https://github.com/harvard-edge/cs249r_book)."
                echo ""
                echo "---"
                echo "*Development Period*: [Timeframe based on release type]"
                echo "*Repository*: [harvard-edge/cs249r_book](https://github.com/harvard-edge/cs249r_book)"
                echo "*Focus*: [Main theme of this release]"
              } > ai_prompt.txt

              # Generate AI release notes
              if ollama run $MODEL < ai_prompt.txt > ai_release_notes.md 2>/dev/null; then
                echo "âœ… AI release notes generated successfully"

                # Use AI-generated notes directly (they include proper header)
                {
                  cat ai_release_notes.md
                  echo ""
                  echo "---"
                  echo ""
                  echo "## Full Change Log"
                  echo ""
                  cat git_changes.md
                } > "release_notes_${{ needs.validate-inputs.outputs.new_version }}.md"
              else
                echo "âš ï¸ AI generation failed, using git log only"
                AI_GENERATION_FAILED=true
              fi
            fi

            # If AI generation failed, fall back to git log only
            if [ "$AI_GENERATION_FAILED" = "true" ]; then
              echo "ğŸ“‹ Falling back to git log only release notes"
              {
                echo "# Release ${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}"
                echo ""
                echo "## Overview"
                echo "This ${{ github.event.inputs.release_type }} release includes the following changes:"
                echo ""
                cat git_changes.md
              } > "release_notes_${{ needs.validate-inputs.outputs.new_version }}.md"
            fi
          else
            echo ""
            echo "ğŸ“‹ Git Log Only Mode - creating clean release notes from git history"

            # Create release notes from git log only
            {
              echo "# Release ${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}"
              echo ""
              echo "## Overview"
              echo "This ${{ github.event.inputs.release_type }} release includes the following changes:"
              echo ""
              cat git_changes.md
            } > "release_notes_${{ needs.validate-inputs.outputs.new_version }}.md"
          fi

          # Show final release notes
          if [ -f "release_notes_${{ needs.validate-inputs.outputs.new_version }}.md" ]; then
            echo "âœ… Release notes generated successfully"
            echo "ğŸ“„ Release notes file details:"
            ls -la "release_notes_${{ needs.validate-inputs.outputs.new_version }}.md"
            echo "ğŸ“ Release notes content (first 50 lines):"
            head -50 "release_notes_${{ needs.validate-inputs.outputs.new_version }}.md"
          else
            echo "âŒ Failed to generate release notes - creating basic fallback"
            # Create a basic fallback release notes file
            {
              echo "# Release ${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}"
              echo ""
              echo "## Release Information"
              echo "- **Version**: ${{ needs.validate-inputs.outputs.new_version }}"
              echo "- **Type**: ${{ github.event.inputs.release_type }} release"
              echo "- **Description**: ${{ github.event.inputs.description }}"
              echo ""
              echo "## Changes"
              echo "Please see the git commit history for detailed changes."
            } > "release_notes_${{ needs.validate-inputs.outputs.new_version }}.md"
            echo "âœ… Basic release notes created as fallback"
          fi

      - name: ğŸ“¤ Upload Release Notes Artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-notes
          path: release_notes_${{ needs.validate-inputs.outputs.new_version }}.md

      - name: ğŸ“¤ Upload Git Log Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: git-changes
          path: |
            git_changes.md
            git_log_summary.txt
            ai_release_notes.md

  create-release:
    name: 'ğŸ“¦ Create GitHub Release'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [validate-inputs, generate-release-notes, create-tag]
    if: github.event.inputs.confirm == 'PUBLISH' && github.event.inputs.testing_mode != 'yes'

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ“„ Download PDF from previous job
        uses: actions/download-artifact@v4
        with:
          name: pdf-artifact
          path: ./

      - name: ğŸ“š Download EPUB from previous job
        uses: actions/download-artifact@v4
        with:
          name: epub-artifact
          path: ./

      - name: ğŸ“ Download release notes
        uses: actions/download-artifact@v4
        with:
          name: release-notes
          path: ./

      - name: ğŸ“¦ Create GitHub Release with PDF
        run: |
          echo "ğŸ“¦ Creating GitHub Release ${{ needs.validate-inputs.outputs.new_version }}..."
          echo "ğŸ“‹ Release details:"
          echo "  - Tag: ${{ needs.validate-inputs.outputs.new_version }}"
          echo "  - Name: ${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}"
          echo "  - Repository: ${{ github.repository }}"

          # Use the AI-generated release notes
          RELEASE_NOTES_FILE="release_notes_${{ needs.validate-inputs.outputs.new_version }}.md"

          if [ -f "$RELEASE_NOTES_FILE" ]; then
            echo "ğŸ“„ Using AI-generated release notes:"
            cat "$RELEASE_NOTES_FILE"
          else
            echo "âŒ Release notes file not found!"
            exit 1
          fi

          # Create the release as a DRAFT for manual editing
          echo "ğŸš€ Creating GitHub release as DRAFT..."

          # Properly escape the release notes for JSON
          ESCAPED_BODY=$(cat "$RELEASE_NOTES_FILE" | jq -Rs .)

          # Create JSON payload using jq to ensure proper escaping
          JSON_PAYLOAD=$(jq -n \
            --arg tag "${{ needs.validate-inputs.outputs.new_version }}" \
            --arg name "${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}" \
            --argjson body "$ESCAPED_BODY" \
            '{
              tag_name: $tag,
              name: $name,
              body: $body,
              draft: true,
              prerelease: false
            }')

          RELEASE_RESPONSE=$(curl -s \
            -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Content-Type: application/json" \
            "https://api.github.com/repos/${{ github.repository }}/releases" \
            -d "$JSON_PAYLOAD")

          echo "ğŸ“Š API Response:"
          echo "$RELEASE_RESPONSE" | jq '.'

          RELEASE_ID=$(echo "$RELEASE_RESPONSE" | jq -r '.id')
          RELEASE_URL=$(echo "$RELEASE_RESPONSE" | jq -r '.html_url')

          if [ "$RELEASE_ID" != "null" ] && [ -n "$RELEASE_ID" ]; then
            echo "âœ… Draft release created successfully!"
            echo "ğŸ“Š Release ID: $RELEASE_ID"
            echo "ğŸ”— Release URL: $RELEASE_URL"
            echo "ğŸ“ Next step: Edit release notes manually and publish"
            echo "release_id=$RELEASE_ID" >> $GITHUB_ENV
            echo "release_url=$RELEASE_URL" >> $GITHUB_ENV
          else
            echo "âŒ Failed to create release!"
            echo "ğŸ“Š Error details:"
            echo "$RELEASE_RESPONSE" | jq -r '.message // "Unknown error"'
            echo "$RELEASE_RESPONSE" | jq -r '.errors[]?.message // empty'
            exit 1
          fi

      - name: ğŸ“„ Upload PDF to Release Assets
        run: |
          echo "ğŸ“„ Uploading PDF to release assets..."

          if [ ! -f "Machine-Learning-Systems.pdf" ]; then
            echo "âŒ PDF file not found!"
            exit 1
          fi

          echo "ğŸ“Š PDF size: $(du -h Machine-Learning-Systems.pdf | cut -f1)"

          # Upload the PDF to the release
          UPLOAD_RESPONSE=$(curl -s \
            -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Content-Type: application/pdf" \
            --data-binary @Machine-Learning-Systems.pdf \
            "https://uploads.github.com/repos/${{ github.repository }}/releases/${{ env.release_id }}/assets?name=Machine-Learning-Systems.pdf")

          echo "ğŸ“Š Upload Response:"
          echo "$UPLOAD_RESPONSE" | jq '.'

          UPLOAD_ID=$(echo "$UPLOAD_RESPONSE" | jq -r '.id')

          if [ "$UPLOAD_ID" != "null" ] && [ -n "$UPLOAD_ID" ]; then
            echo "âœ… PDF uploaded successfully to release!"
            echo "ğŸ“Š Asset ID: $UPLOAD_ID"
            echo "ğŸ”— Download URL: https://github.com/${{ github.repository }}/releases/download/${{ needs.validate-inputs.outputs.new_version }}/Machine-Learning-Systems.pdf"
          else
            echo "âŒ Failed to upload PDF to release!"
            echo "ğŸ“Š Error details:"
            echo "$UPLOAD_RESPONSE" | jq -r '.message // "Unknown error"'
            exit 1
          fi

      - name: ğŸ“š Upload EPUB to Release Assets
        run: |
          echo "ğŸ“š Checking for EPUB file to upload..."

          if [ ! -f "Machine-Learning-Systems.epub" ]; then
            echo "âš ï¸ EPUB file not found - skipping EPUB upload"
            exit 0
          fi

          # Check if it's an empty file (created as placeholder)
          if [ ! -s "Machine-Learning-Systems.epub" ]; then
            echo "âš ï¸ EPUB file is empty (placeholder) - skipping EPUB upload"
            exit 0
          fi

          echo "ğŸ“š Uploading EPUB to release assets..."
          echo "ğŸ“Š EPUB size: $(du -h Machine-Learning-Systems.epub | cut -f1)"

          # Upload the EPUB to the release
          UPLOAD_RESPONSE=$(curl -s \
            -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Content-Type: application/epub+zip" \
            --data-binary @Machine-Learning-Systems.epub \
            "https://uploads.github.com/repos/${{ github.repository }}/releases/${{ env.release_id }}/assets?name=Machine-Learning-Systems.epub")

          echo "ğŸ“Š Upload Response:"
          echo "$UPLOAD_RESPONSE" | jq '.'

          UPLOAD_ID=$(echo "$UPLOAD_RESPONSE" | jq -r '.id')

          if [ "$UPLOAD_ID" != "null" ] && [ -n "$UPLOAD_ID" ]; then
            echo "âœ… EPUB uploaded successfully to release!"
            echo "ğŸ“Š Asset ID: $UPLOAD_ID"
            echo "ğŸ”— Download URL: https://github.com/${{ github.repository }}/releases/download/${{ needs.validate-inputs.outputs.new_version }}/Machine-Learning-Systems.epub"
          else
            echo "âš ï¸ Failed to upload EPUB to release (continuing anyway)!"
            echo "ğŸ“Š Error details:"
            echo "$UPLOAD_RESPONSE" | jq -r '.message // "Unknown error"'
          fi

  summary:
    name: 'ğŸ“‹ Publication Summary'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [validate-inputs, create-release]
    if: github.event.inputs.confirm == 'PUBLISH' && github.event.inputs.testing_mode != 'yes'

    steps:
      - name: ğŸ“‹ Publication Summary
        run: |
          echo "## ğŸ“š Textbook Publication Complete! ğŸ‰" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version Released:** ${{ needs.validate-inputs.outputs.new_version }} (${{ needs.validate-inputs.outputs.release_type }})" >> $GITHUB_STEP_SUMMARY
          echo "**Previous Version:** ${{ needs.validate-inputs.outputs.previous_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Content Published:** ${{ github.event.inputs.description }}" >> $GITHUB_STEP_SUMMARY
          echo "**Published by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Source Commit:** ${{ github.event.inputs.dev_commit || 'latest' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Publication Time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "**Release ID:** ${{ env.release_id || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Release URL:** ${{ env.release_url || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ” Debug Information:" >> $GITHUB_STEP_SUMMARY
          echo "- **Workflow Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Run Attempt:** ${{ github.run_attempt }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit SHA:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AI Generated Notes:** ${{ github.event.inputs.ai_generated_notes }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“ Changes:" >> $GITHUB_STEP_SUMMARY
          echo "${{ github.event.inputs.description }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ”„ What happened:" >> $GITHUB_STEP_SUMMARY
          echo "1. âœ… Verified dev branch tests passed" >> $GITHUB_STEP_SUMMARY
          echo "2. âœ… Calculated new version number" >> $GITHUB_STEP_SUMMARY
          echo "3. âœ… Merged dev â†’ main branch" >> $GITHUB_STEP_SUMMARY
          echo "4. âœ… Pushed to main (triggered production build)" >> $GITHUB_STEP_SUMMARY
          echo "5. âœ… Waited for build completion (up to 3 hours)" >> $GITHUB_STEP_SUMMARY
          echo "6. âœ… Created release tag ${{ needs.validate-inputs.outputs.new_version }} (after successful build)" >> $GITHUB_STEP_SUMMARY
          echo "7. âœ… Created GitHub Release (DRAFT - edit manually)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ—ï¸ Build Process:" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“‹ **Quarto Build Container Workflow**: Triggered by main branch push" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ”¨ **Build Jobs**: HTML + PDF + EPUB generation on Linux (parallel builds)" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“„ **PDF Processing**: Generated, compressed with Ghostscript, stored in build/pdf/" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“¦ **Artifacts**: main-html-linux (web content) + main-pdf-linux (PDF file) + main-epub-linux (EPUB file)" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ”„ **Integration**: Downloaded all artifacts and combined into unified deployment" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸŒ **Deployment**: Combined HTML + PDF + EPUB deployed to GitHub Pages (gh-pages branch)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸŒ Access Your Published Textbook:" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“– [Interactive Web Textbook](https://mlsysbook.ai/book/)" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ”¥ [TinyTorch Framework](https://mlsysbook.ai/tinytorch/)" >> $GITHUB_STEP_SUMMARY
          echo "- âš™ï¸ [Hardware Kits](https://mlsysbook.ai/kits/)" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“¦ [Version Release Notes](https://github.com/${{ github.repository }}/releases/tag/${{ needs.validate-inputs.outputs.new_version }})" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“„ [Download Complete PDF](https://github.com/${{ github.repository }}/releases/download/${{ needs.validate-inputs.outputs.new_version }}/Machine-Learning-Systems.pdf)" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“š [Download EPUB eBook](https://github.com/${{ github.repository }}/releases/download/${{ needs.validate-inputs.outputs.new_version }}/Machine-Learning-Systems.epub)" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“„ [Direct PDF Access](https://mlsysbook.ai/book/assets/downloads/Machine-Learning-Systems.pdf)" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“š [Direct EPUB Access](https://mlsysbook.ai/book/assets/downloads/Machine-Learning-Systems.epub)" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“ [Share with Students](https://mlsysbook.ai/book/)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“Š Build Status:" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“‹ **Quarto Build Container Workflow**: Should be running/completed" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ—ï¸ **Quarto Build**: HTML + PDF + EPUB generation" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“„ **PDF Assets**: Available at `/assets/downloads/Machine-Learning-Systems.pdf`" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“š **EPUB Assets**: Available at `/assets/downloads/Machine-Learning-Systems.epub`" >> $GITHUB_STEP_SUMMARY

  cleanup-on-failure:
    name: 'ğŸ§¹ Cleanup Failed Release'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [validate-inputs]
    if: always() && github.event.inputs.confirm == 'PUBLISH' && (failure() || cancelled())

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ§¹ Clean up failed release artifacts
        run: |
          echo "ğŸ§¹ Cleaning up artifacts from failed release..."

          # Get the version that was being released
          if [ -n "${{ needs.validate-inputs.outputs.new_version }}" ]; then
            VERSION_TAG="${{ needs.validate-inputs.outputs.new_version }}"
            echo "ğŸ¯ Cleaning up version: $VERSION_TAG"
          else
            echo "âš ï¸ No version information available, skipping cleanup"
            exit 0
          fi

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check and remove local tag
          if git tag -l "$VERSION_TAG" | grep -q "$VERSION_TAG"; then
            echo "ğŸ—‘ï¸ Removing local tag: $VERSION_TAG"
            git tag -d "$VERSION_TAG"
          else
            echo "â„¹ï¸ Local tag $VERSION_TAG does not exist"
          fi

          # Check and remove remote tag if it exists
          if git ls-remote --tags origin | grep -q "refs/tags/$VERSION_TAG$"; then
            echo "ğŸ—‘ï¸ Removing remote tag: $VERSION_TAG"
            git push origin --delete "$VERSION_TAG" || echo "âš ï¸ Failed to delete remote tag (may not exist)"
          else
            echo "â„¹ï¸ Remote tag $VERSION_TAG does not exist"
          fi

          # Check for any draft releases and delete them
          echo "ğŸ” Checking for draft releases..."
          DRAFT_RELEASE=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases" \
            | jq -r ".[] | select(.tag_name == \"$VERSION_TAG\" and .draft == true) | .id")

          if [ "$DRAFT_RELEASE" != "null" ] && [ -n "$DRAFT_RELEASE" ]; then
            echo "ğŸ—‘ï¸ Deleting draft release: $DRAFT_RELEASE"
            curl -s \
              -X DELETE \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/releases/$DRAFT_RELEASE"
            echo "âœ… Draft release deleted"
          else
            echo "â„¹ï¸ No draft release found for $VERSION_TAG"
          fi

          echo "âœ… Cleanup completed! Repository is ready for retry."

      - name: ğŸ“Š Cleanup Summary
        run: |
          echo "## ğŸ§¹ Failed Release Cleanup Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.validate-inputs.outputs.new_version || 'Unknown' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Cleanup Time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ” Original Inputs (for debugging):" >> $GITHUB_STEP_SUMMARY
          echo "- **Description:** ${{ github.event.inputs.description }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release Type:** ${{ github.event.inputs.release_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Dev Commit:** ${{ github.event.inputs.dev_commit }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Confirmation:** ${{ github.event.inputs.confirm }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AI Generated Notes:** ${{ github.event.inputs.ai_generated_notes }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status Check Timeout:** ${{ github.event.inputs.commit_status_timeout }} attempts" >> $GITHUB_STEP_SUMMARY
          echo "- **Status Check Interval:** ${{ github.event.inputs.commit_status_interval }} seconds" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Run Attempt:** ${{ github.run_attempt }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ—‘ï¸ Cleaned Up:" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Local git tags removed" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Remote git tags removed (if they existed)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Draft GitHub releases removed (if they existed)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ”„ Ready for Retry:" >> $GITHUB_STEP_SUMMARY
          echo "You can now safely re-run the publish workflow with the same version number." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ› Troubleshooting:" >> $GITHUB_STEP_SUMMARY
          echo "If you continue to have issues, check the workflow logs for the failed step." >> $GITHUB_STEP_SUMMARY

  cleanup-on-timeout:
    name: 'â° Cleanup Timed Out Release'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [validate-inputs, trigger-production-build]
    if: always() && github.event.inputs.confirm == 'PUBLISH' && (needs.trigger-production-build.result == 'failure' || needs.trigger-production-build.result == 'timeout')

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ§¹ Clean up timed out release artifacts
        run: |
          echo "â° Cleaning up artifacts from timed out release..."

          # Get the version that was being released
          if [ -n "${{ needs.validate-inputs.outputs.new_version }}" ]; then
            VERSION_TAG="${{ needs.validate-inputs.outputs.new_version }}"
            echo "ğŸ¯ Cleaning up version: $VERSION_TAG"
          else
            echo "âš ï¸ No version information available, skipping cleanup"
            exit 0
          fi

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check and remove local tag
          if git tag -l "$VERSION_TAG" | grep -q "$VERSION_TAG"; then
            echo "ğŸ—‘ï¸ Removing local tag: $VERSION_TAG"
            git tag -d "$VERSION_TAG"
          else
            echo "â„¹ï¸ Local tag $VERSION_TAG does not exist"
          fi

          # Check and remove remote tag if it exists
          if git ls-remote --tags origin | grep -q "refs/tags/$VERSION_TAG$"; then
            echo "ğŸ—‘ï¸ Removing remote tag: $VERSION_TAG"
            git push origin --delete "$VERSION_TAG" || echo "âš ï¸ Failed to delete remote tag (may not exist)"
          else
            echo "â„¹ï¸ Remote tag $VERSION_TAG does not exist"
          fi

          # Check for any draft releases and delete them
          echo "ğŸ” Checking for draft releases..."
          DRAFT_RELEASE=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases" \
            | jq -r ".[] | select(.tag_name == \"$VERSION_TAG\" and .draft == true) | .id")

          if [ "$DRAFT_RELEASE" != "null" ] && [ -n "$DRAFT_RELEASE" ]; then
            echo "ğŸ—‘ï¸ Deleting draft release: $DRAFT_RELEASE"
            curl -s \
              -X DELETE \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/releases/$DRAFT_RELEASE"
            echo "âœ… Draft release deleted"
          else
            echo "â„¹ï¸ No draft release found for $VERSION_TAG"
          fi

          echo "âœ… Cleanup completed! Repository is ready for retry."

      - name: ğŸ”„ Rollback Main Branch (if needed)
        run: |
          echo "ğŸ”„ Checking if main branch rollback is needed..."

          # Only rollback if merge succeeded but later steps failed
          if [ "${{ needs.merge-to-main.result }}" = "success" ] && [ "${{ needs.create-tag.result }}" != "success" ]; then
            echo "âš ï¸ Merge succeeded but tag creation failed - considering rollback"
            echo "ğŸ” Checking if main branch needs to be rolled back..."

            # Get the commit before the merge
            MERGE_COMMIT=$(git log --oneline -1 --grep="Release $VERSION_TAG" --format="%H" || echo "")

            if [ -n "$MERGE_COMMIT" ]; then
              PARENT_COMMIT=$(git log --format="%P" -n 1 "$MERGE_COMMIT" | cut -d' ' -f1)
              echo "ğŸ” Found merge commit: $MERGE_COMMIT"
              echo "ğŸ” Parent commit: $PARENT_COMMIT"

              echo "âš ï¸ To manually rollback main branch, run:"
              echo "   git checkout main"
              echo "   git reset --hard $PARENT_COMMIT"
              echo "   git push origin main --force-with-lease"
              echo ""
              echo "âš ï¸ AUTOMATED ROLLBACK DISABLED - Manual intervention required"
              echo "ğŸ›¡ï¸ This prevents accidental data loss"
            else
              echo "â„¹ï¸ No merge commit found - no rollback needed"
            fi
          else
            echo "â„¹ï¸ No rollback needed - merge did not complete successfully"
          fi

      - name: ğŸ“Š Cleanup Summary
        run: |
          echo "## ğŸ§¹ Failed Release Cleanup Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.validate-inputs.outputs.new_version || 'Unknown' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Cleanup Time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ” Original Inputs (for debugging):" >> $GITHUB_STEP_SUMMARY
          echo "- **Description:** ${{ github.event.inputs.description }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release Type:** ${{ github.event.inputs.release_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Dev Commit:** ${{ github.event.inputs.dev_commit }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Confirmation:** ${{ github.event.inputs.confirm }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AI Generated Notes:** ${{ github.event.inputs.ai_generated_notes }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status Check Timeout:** ${{ github.event.inputs.commit_status_timeout }} attempts" >> $GITHUB_STEP_SUMMARY
          echo "- **Status Check Interval:** ${{ github.event.inputs.commit_status_interval }} seconds" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Run Attempt:** ${{ github.run_attempt }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ—‘ï¸ Cleaned Up:" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Local git tags removed" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Remote git tags removed (if they existed)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Draft GitHub releases removed (if they existed)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ”„ Ready for Retry:" >> $GITHUB_STEP_SUMMARY
          echo "You can now safely re-run the publish workflow with the same version number." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ› Troubleshooting:" >> $GITHUB_STEP_SUMMARY
          echo "If you continue to have issues, check the workflow logs for the failed step." >> $GITHUB_STEP_SUMMARY

  testing-mode-summary:
    name: 'ğŸ§ª Testing Mode Summary'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event.inputs.confirm == 'PUBLISH' && github.event.inputs.testing_mode == 'yes'
    needs: [validate-inputs, call-production-build]

    steps:
      - name: ğŸ§ª Testing Mode Complete
        run: |
          echo "## ğŸ§ª Testing Mode Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** âœ… Testing workflow completed successfully" >> $GITHUB_STEP_SUMMARY
          echo "**Mode:** Testing (no actual deployment)" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“‹ What was tested:" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Input validation" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Build workflow triggering" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Build completion detection" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Artifact availability" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸš€ To run actual deployment:" >> $GITHUB_STEP_SUMMARY
          echo "- Set **testing_mode** to **no**" >> $GITHUB_STEP_SUMMARY
          echo "- Re-run with same parameters" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ” Debug Information:" >> $GITHUB_STEP_SUMMARY
          echo "- **Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Description:** ${{ github.event.inputs.description }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release Type:** ${{ github.event.inputs.release_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Dev Commit:** ${{ github.event.inputs.dev_commit }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Concurrency Group:** publish-live-test-${{ github.run_number }}-${{ github.event.inputs.dev_commit }}" >> $GITHUB_STEP_SUMMARY

          echo "âœ… Testing mode completed successfully!"
          echo "ğŸ§ª This run tested the workflow without actual deployment"
          echo "ğŸ”„ Run ID: ${{ github.run_id }}"
          echo "ğŸ‘¤ Triggered by: ${{ github.actor }}"
          echo "ğŸŒ Branch: ${{ github.ref_name }}"

  fail-validation:
    name: 'âŒ Validation Failed'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event.inputs.confirm != 'PUBLISH'

    steps:
      - name: âŒ Invalid confirmation
        run: |
          echo "## âŒ Publication Validation Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Reason:** Invalid confirmation" >> $GITHUB_STEP_SUMMARY
          echo "**Expected:** PUBLISH" >> $GITHUB_STEP_SUMMARY
          echo "**Received:** ${{ github.event.inputs.confirm }}" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ” Debug Information:" >> $GITHUB_STEP_SUMMARY
          echo "- **Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Description:** ${{ github.event.inputs.description }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release Type:** ${{ github.event.inputs.release_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Dev Commit:** ${{ github.event.inputs.dev_commit }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AI Generated Notes:** ${{ github.event.inputs.ai_generated_notes }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "âŒ Publication cancelled - invalid confirmation"
          echo "ğŸ”’ You must type exactly 'PUBLISH' to confirm"
          echo "ğŸ“ You entered: '${{ github.event.inputs.confirm }}'"
          echo "ğŸ‘¤ Triggered by: ${{ github.actor }}"
          echo "ğŸŒ Branch: ${{ github.ref_name }}"
          echo "ğŸ”„ Run ID: ${{ github.run_id }}"
          exit 1
