name: 'üöÄ Publish Live'

# =============================================================================
# CONFIGURABLE VARIABLES - Edit these to customize the workflow
# =============================================================================

# AI Model Configuration
env:
  DEFAULT_AI_MODEL: "gemma2:9b"           # Default Ollama model
  FALLBACK_AI_MODEL: "gemma2:27b"         # Fallback if default fails
  OLLAMA_TIMEOUT: "300"                    # Timeout for Ollama operations (seconds)
  OLLAMA_RETRIES: "3"                      # Number of retries for Ollama calls
  BUILD_TIMEOUT: "3600"                    # Timeout for build operations (1 hour)

# =============================================================================
# ARTIFACT STRUCTURE DOCUMENTATION
# =============================================================================
# The üéÆ Controller workflow creates the following artifacts:
# 
# build-ubuntu-latest-html: Contains build/html/ (web version)
# build-ubuntu-latest-pdf:  Contains build/pdf/Machine-Learning-Systems.pdf
# build-windows-latest-html: Contains build/html/ (web version)  
# build-windows-latest-pdf: Contains build/pdf/Machine-Learning-Systems.pdf
#
# This workflow specifically looks for build-ubuntu-latest-pdf to get the Linux-built PDF
# for consistency and reliability. The PDF is compressed with Ghostscript for optimal size.
#
# Expected file structure in build-ubuntu-latest-pdf artifact:
# build/pdf/Machine-Learning-Systems.pdf
# =============================================================================

# Available AI Models (uncomment to use different models):
# - gemma2:9b      (fast, good quality - recommended)
# - gemma2:27b     (better quality, slower)
# - llama3.1:8b    (good balance)
# - llama3.1:70b   (best quality, slowest)
# - mistral:7b     (fast, good for analysis)
# - codellama:7b   (good for code-related changes)

# Manual trigger only - big red button!
# Only allow manual triggers from main and dev branches
on:
  workflow_dispatch:
    inputs:
      description:
        description: 'What are you publishing? (brief description)'
        required: true
        default: ''
      release_type:
        description: 'Release type'
        required: true
        type: choice
        options:
          - 'patch'
          - 'minor' 
          - 'major'
        default: 'minor'
      dev_commit:
        description: 'Specific dev commit to publish (required)'
        required: true
        default: ''
      confirm:
        description: 'Type "PUBLISH" to confirm'
        required: true
        default: ''
      ai_generated_notes:
        description: 'Generate AI release notes?'
        required: true
        type: choice
        options:
          - 'true'
          - 'false'
        default: 'true'

permissions:
  contents: write
  actions: read

jobs:
  validate-inputs:
    name: 'üîç Validate Inputs'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: github.event.inputs.confirm == 'PUBLISH' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev')
    outputs:
      new_version: ${{ steps.version.outputs.new_version }}
      previous_version: ${{ steps.version.outputs.previous_version }}
      release_type: ${{ steps.version.outputs.release_type }}
    
    steps:
      - name: üîí Check Branch Restriction
        run: |
          echo "üîí Checking branch restrictions..."
          echo "Current branch: ${{ github.ref_name }}"
          echo "Current ref: ${{ github.ref }}"
          
          if [[ "${{ github.ref }}" != "refs/heads/main" && "${{ github.ref }}" != "refs/heads/dev" ]]; then
            echo "‚ùå ERROR: This workflow can only be triggered from 'main' or 'dev' branches"
            echo "‚ùå Current branch: ${{ github.ref_name }}"
            echo "‚ùå Please switch to 'main' or 'dev' branch before running this workflow"
            exit 1
          fi
          
          echo "‚úÖ Branch check passed - running from ${{ github.ref_name }}"

      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üîç Validate dev commit
        run: |
          echo "üîç Validating dev commit..."
          
          # Get the commit to validate and trim whitespace
          COMMIT_SHA=$(echo "${{ github.event.inputs.dev_commit }}" | xargs)
          echo "üìå Using specified commit: $COMMIT_SHA"
          
          # Verify commit exists and is from dev branch
          if ! git cat-file -e "$COMMIT_SHA" 2>/dev/null; then
            echo "‚ùå Commit $COMMIT_SHA does not exist!"
            exit 1
          fi
          
          if ! git merge-base --is-ancestor "$COMMIT_SHA" origin/dev; then
            echo "‚ùå Commit $COMMIT_SHA is not in dev branch!"
            exit 1
          fi
          
          echo "‚úÖ Commit $COMMIT_SHA is valid and from dev branch"
          echo "‚úÖ Ready to publish (workflow validation skipped)"

      - name: üè∑Ô∏è Calculate Next Version
        id: version
        run: |
          echo "üîÑ Getting latest release version..."
          
          # Use provided previous version or auto-detect
          if [ -n "${{ github.event.inputs.previous_version }}" ]; then
            LATEST_VERSION="${{ github.event.inputs.previous_version }}"
            echo "üìå Using provided previous version: $LATEST_VERSION"
          else
            # Get latest release version, default to v0.0.0 if no releases exist
            LATEST_VERSION=$(curl -s \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/releases/latest" \
              | jq -r '.tag_name // "v0.0.0"')
            echo "üìä Auto-detected latest version: $LATEST_VERSION"
          fi
          
          # Remove 'v' prefix for calculation
          VERSION_NUM=${LATEST_VERSION#v}
          
          # Split version into components
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_NUM"
          
          # Handle empty or invalid versions
          MAJOR=${MAJOR:-0}
          MINOR=${MINOR:-0}
          PATCH=${PATCH:-0}
          
          echo "üìä Previous version components: $MAJOR.$MINOR.$PATCH"
          
          # Calculate new version based on release type
          case "${{ github.event.inputs.release_type }}" in
            "major")
              NEW_MAJOR=$((MAJOR + 1))
              NEW_MINOR=0
              NEW_PATCH=0
              ;;
            "minor")
              NEW_MAJOR=$MAJOR
              NEW_MINOR=$((MINOR + 1))
              NEW_PATCH=0
              ;;
            "patch")
              NEW_MAJOR=$MAJOR
              NEW_MINOR=$MINOR
              NEW_PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="v$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
          echo "üéØ New version: $NEW_VERSION (${{ github.event.inputs.release_type }} release)"
          echo "üìã Description: ${{ github.event.inputs.description }}"
          
          # Export for other steps
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "release_type=${{ github.event.inputs.release_type }}" >> $GITHUB_OUTPUT
          echo "previous_version=$LATEST_VERSION" >> $GITHUB_OUTPUT

  merge-to-main:
    name: 'üîÑ Merge to Main'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: validate-inputs
    if: github.event.inputs.confirm == 'PUBLISH'
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üîÑ Merge dev to main
        run: |
          echo "üîÑ Configuring git..."
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          echo "üîÑ Switching to main branch..."
          git checkout main
          git pull origin main
          
          echo "üîç Checking for potential merge conflicts..."
          # Test merge without committing
          if ! git merge --no-commit --no-ff origin/dev 2>/dev/null; then
            echo "‚ùå MERGE CONFLICTS DETECTED!"
            echo "üõë Automated merge cannot proceed due to conflicts."
            echo "üìã Please resolve conflicts manually:"
            echo "   1. git checkout main"
            echo "   2. git pull origin main" 
            echo "   3. git merge dev"
            echo "   4. Resolve conflicts and commit"
            echo "   5. git push origin main"
            git merge --abort
            exit 1
          fi
          git reset --hard HEAD  # Clean up test merge
          
          echo "‚úÖ No conflicts detected. Proceeding with merge..."
          echo "üîÑ Merging dev into main..."
          
          # Determine which commit to merge
          if [ -n "${{ github.event.inputs.dev_commit }}" ]; then
            MERGE_COMMIT=$(echo "${{ github.event.inputs.dev_commit }}" | xargs)
            echo "üìå Merging specific commit: $MERGE_COMMIT"
          else
            MERGE_COMMIT="origin/dev"
            echo "üìä Merging latest dev: $MERGE_COMMIT"
          fi
          
          git merge "$MERGE_COMMIT" --no-ff -m "üöÄ Release ${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}

          Merged dev branch to main for publication.
          
          Release Type: ${{ github.event.inputs.release_type }}
          Published by: ${{ github.actor }}
          Dev Commit: ${MERGE_COMMIT}
          Specific Commit: ${{ github.event.inputs.dev_commit || 'latest' }}
          Description: ${{ github.event.inputs.description }}"
          
          echo "‚úÖ Merge completed successfully!"

      - name: üöÄ Push merge to main
        run: |
          echo "üöÄ Pushing merge to main branch..."
          git push origin main
          
          echo "‚úÖ Main branch updated successfully!"
          echo "üìã Next step: Tag creation and production deployment"

  create-tag:
    name: 'üè∑Ô∏è Create Release Tag'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [validate-inputs, merge-to-main]
    if: github.event.inputs.confirm == 'PUBLISH'
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üîÑ Sync with latest main
        run: |
          echo "üîÑ Configuring git..."
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          echo "üîÑ Switching to main and pulling latest changes..."
          git checkout main
          git pull origin main
          
          echo "‚úÖ Synced with latest main branch"

      - name: üè∑Ô∏è Create Release Tag
        run: |
          echo "üè∑Ô∏è Creating release tag ${{ needs.validate-inputs.outputs.new_version }}..."
          
          # Check if tag already exists locally
          if git tag -l "${{ needs.validate-inputs.outputs.new_version }}" | grep -q "${{ needs.validate-inputs.outputs.new_version }}"; then
            echo "‚ö†Ô∏è Tag ${{ needs.validate-inputs.outputs.new_version }} already exists locally"
            echo "üîÑ Removing existing tag to recreate it..."
            git tag -d ${{ needs.validate-inputs.outputs.new_version }}
          fi
          
          # Check if tag exists on remote
          if git ls-remote --tags origin | grep -q "refs/tags/${{ needs.validate-inputs.outputs.new_version }}$"; then
            echo "‚ö†Ô∏è Tag ${{ needs.validate-inputs.outputs.new_version }} already exists on remote"
            echo "üîÑ Removing remote tag to recreate it..."
            git push origin --delete ${{ needs.validate-inputs.outputs.new_version }}
          fi
          
          # Create the tag on the latest main commit
          git tag -a ${{ needs.validate-inputs.outputs.new_version }} -m "Release ${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}"
          echo "‚úÖ Tag created successfully!"

      - name: üöÄ Push tag and trigger production deployment
        run: |
          echo "üöÄ Pushing release tag to trigger production deployment..."
          git push origin ${{ needs.validate-inputs.outputs.new_version }}
          
          echo "üìä Release tag pushed! This will trigger:"
          echo "  ‚úÖ Production build workflow (HTML + PDF generation)"
          echo "  ‚úÖ GitHub Pages deployment with textbook content"
          echo "  ‚úÖ Live academic website update"
          echo ""
          echo "üåê Your textbook will be live at: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}"
          echo "üìö Students can access the updated content immediately"

  monitor-build:
    name: '‚è≥ Monitor Production Build'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    needs: create-tag
    if: github.event.inputs.confirm == 'PUBLISH'
    
    steps:
      - name: ‚è≥ Wait for Production Build (Commit Status Monitoring)
        run: |
          echo "‚è≥ Waiting for production build to complete (max 1 hour)..."
          echo "üîç Monitoring commit status checks in real-time..."
          
          # Get the latest commit SHA from main branch
          COMMIT_SHA=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/commits/main" \
            | jq -r '.sha')
          
          echo "üìå Monitoring commit: $COMMIT_SHA"
          echo "üéØ Required status checks: ci/quarto-build-ubuntu-latest-html, ci/quarto-build-ubuntu-latest-pdf"
          
          sleep 30  # Give the build a moment to start
          
          # Wait for all required status checks to complete
          for i in {1..120}; do  # 120 attempts √ó 30 seconds = 1 hour
            echo "üîç Checking commit status (attempt $i/120)..."
            
            # Get commit status
            STATUS_RESPONSE=$(curl -s \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/commits/$COMMIT_SHA/status")
            
            # Check overall status
            OVERALL_STATE=$(echo "$STATUS_RESPONSE" | jq -r '.state')
            TOTAL_COUNT=$(echo "$STATUS_RESPONSE" | jq -r '.total_count')
            
            echo "üìä Overall status: $OVERALL_STATE ($TOTAL_COUNT checks)"
            
            # Get individual status checks
            STATUSES=$(echo "$STATUS_RESPONSE" | jq -r '.statuses')
            
            # Check for our specific quarto-build status checks
            HTML_STATUS=$(echo "$STATUSES" | jq -r '.[] | select(.context == "ci/quarto-build-ubuntu-latest-html") | .state' | head -1)
            PDF_STATUS=$(echo "$STATUSES" | jq -r '.[] | select(.context == "ci/quarto-build-ubuntu-latest-pdf") | .state' | head -1)
            
            echo "üìã Build status checks:"
            echo "  - HTML Build (Linux): ${HTML_STATUS:-pending}"
            echo "  - PDF Build (Linux): ${PDF_STATUS:-pending}"
            
            # Show detailed status for each check
            echo "$STATUSES" | jq -r '.[] | select(.context | startswith("ci/quarto-build")) | "  - \(.context): \(.state) - \(.description)"' | head -4
            
            # Check if all required builds are successful
            if [ "$HTML_STATUS" = "success" ] && [ "$PDF_STATUS" = "success" ]; then
              echo "‚úÖ All production builds completed successfully!"
              echo "üìä HTML Build: ‚úÖ Success"
              echo "üìä PDF Build: ‚úÖ Success"
              echo "üîó View commit status: https://github.com/${{ github.repository }}/commit/$COMMIT_SHA"
              break
            fi
            
            # Check for any failures
            if [ "$HTML_STATUS" = "failure" ] || [ "$PDF_STATUS" = "failure" ]; then
              echo "‚ùå Production build failed!"
              echo "üìä HTML Build: ${HTML_STATUS:-pending}"
              echo "üìä PDF Build: ${PDF_STATUS:-pending}"
              echo "üîó View commit status: https://github.com/${{ github.repository }}/commit/$COMMIT_SHA"
              exit 1
            fi
            
            # Show current status with time elapsed
            ELAPSED_MINUTES=$((i * 30 / 60))
            ELAPSED_HOURS=$((ELAPSED_MINUTES / 60))
            REMAINING_MINUTES=$((ELAPSED_MINUTES % 60))
            
            if [ $ELAPSED_HOURS -gt 0 ]; then
              TIME_DISPLAY="${ELAPSED_HOURS}h ${REMAINING_MINUTES}m"
            else
              TIME_DISPLAY="${ELAPSED_MINUTES}m"
            fi
            
            echo "‚è≥ Build still in progress... (attempt $i/120, ~${TIME_DISPLAY} elapsed)"
            
            # Show build progress indicators with heartbeat-style updates
            if [ $i -eq 1 ]; then
              echo "üìã Expected build timeline (Linux only):"
              echo "  0-10m: Initial setup and quality checks"
              echo "  10-25m: Quarto build (HTML + PDF generation)"
              echo "  25-35m: PDF compression and processing"
              echo "  35-45m: GitHub Pages deployment"
              echo "  45-60m: Asset copying and finalization"
            fi
            
            # Show heartbeat-style progress every 4th attempt (every 2 minutes)
            if [ $((i % 4)) -eq 0 ]; then
              echo "üíì Build heartbeat: $(date)"
              echo "üìä Current build status: Monitoring commit checks"
              echo "‚è∞ Time elapsed: ${TIME_DISPLAY}"
              echo "üìà HTML: ${HTML_STATUS:-pending} | PDF: ${PDF_STATUS:-pending}"
              echo "üîó Monitor: https://github.com/${{ github.repository }}/commit/$COMMIT_SHA"
              echo "---"
            fi
            
            sleep 30
          done
          
          # If we get here, check final status
          if [ "$HTML_STATUS" != "success" ] || [ "$PDF_STATUS" != "success" ]; then
            echo "‚ö†Ô∏è Build may still be in progress or failed after 1 hour"
            echo "üìä Final status: HTML=$HTML_STATUS, PDF=$PDF_STATUS"
            echo "üîó Check status: https://github.com/${{ github.repository }}/commit/$COMMIT_SHA"
            exit 1
          fi

  download-pdf:
    name: 'üìÑ Download PDF'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: monitor-build
    if: github.event.inputs.confirm == 'PUBLISH'
    
    steps:
      - name: üìÑ Download Built PDF from Artifacts
        run: |
          echo "üìÑ Downloading built PDF from artifacts..."
          echo "üîç Looking for Linux PDF build artifacts..."
          echo "üìã Expected artifact: build-ubuntu-latest-pdf"
          echo "üìã Expected file: build/pdf/Machine-Learning-Systems.pdf"
          
          # Download the latest successful build artifacts
          LATEST_BUILD=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs?branch=main&status=success&per_page=1" \
            | jq -r '.workflow_runs[0].id')
          
          if [ "$LATEST_BUILD" = "null" ] || [ -z "$LATEST_BUILD" ]; then
            echo "‚ùå No successful builds found!"
            exit 1
          fi
          
          echo "üìä Found latest successful build: $LATEST_BUILD"
          
          # Download artifacts from the latest build
          ARTIFACTS_RESPONSE=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/$LATEST_BUILD/artifacts")
          
          echo "üìä Available artifacts:"
          echo "$ARTIFACTS_RESPONSE" | jq -r '.artifacts[] | "  - \(.name) (ID: \(.id))"'
          
          # Find the Linux PDF artifact specifically
          LINUX_PDF_ARTIFACT=$(echo "$ARTIFACTS_RESPONSE" | jq -r '.artifacts[] | select(.name == "build-ubuntu-latest-pdf") | .id' | head -1)
          
          if [ "$LINUX_PDF_ARTIFACT" = "null" ] || [ -z "$LINUX_PDF_ARTIFACT" ]; then
            echo "‚ùå Linux PDF artifact 'build-ubuntu-latest-pdf' not found!"
            echo "üîç Looking for any PDF artifact as fallback..."
            
            # Fallback: look for any PDF artifact
            PDF_ARTIFACT=$(echo "$ARTIFACTS_RESPONSE" | jq -r '.artifacts[] | select(.name | contains("pdf")) | .id' | head -1)
            
            if [ "$PDF_ARTIFACT" = "null" ] || [ -z "$PDF_ARTIFACT" ]; then
              echo "‚ùå No PDF artifact found in build $LATEST_BUILD"
              exit 1
            fi
            
            echo "‚ö†Ô∏è Using fallback PDF artifact: $PDF_ARTIFACT"
            LINUX_PDF_ARTIFACT=$PDF_ARTIFACT
          else
            echo "‚úÖ Found Linux PDF artifact: build-ubuntu-latest-pdf (ID: $LINUX_PDF_ARTIFACT)"
          fi
          
          # Download the artifact
          echo "üì• Downloading PDF artifact..."
          curl -L \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/$LATEST_BUILD/artifacts/$LINUX_PDF_ARTIFACT/zip" \
            -o pdf-artifact.zip
          
          # Extract the PDF
          echo "üì¶ Extracting PDF artifact..."
          unzip -q pdf-artifact.zip
          
          # Find the PDF file in the expected location
          PDF_FILE=$(find . -name "Machine-Learning-Systems.pdf" -type f | head -1)
          
          if [ -z "$PDF_FILE" ] || [ ! -f "$PDF_FILE" ]; then
            echo "‚ùå PDF file not found in extracted artifacts!"
            echo "üìä Extracted files and directories:"
            find . -type f -o -type d | head -20
            echo "üìä Looking in build/pdf directory..."
            if [ -d "build/pdf" ]; then
              ls -la build/pdf/
            fi
            exit 1
          fi
          
          echo "‚úÖ PDF found: $PDF_FILE"
          echo "üìä PDF size: $(du -h "$PDF_FILE" | cut -f1)"
          
          # Copy to a standard location
          cp "$PDF_FILE" "Machine-Learning-Systems.pdf"
          echo "‚úÖ PDF ready for release: Machine-Learning-Systems.pdf"
          
          # Upload PDF as artifact for next jobs
          echo "üì§ Uploading PDF as artifact..."
          echo "Machine-Learning-Systems.pdf" > pdf-files.txt

      - name: üì§ Upload PDF Artifact
        uses: actions/upload-artifact@v4
        with:
          name: pdf-artifact
          path: Machine-Learning-Systems.pdf
          retention-days: 1

  generate-release-notes:
    name: 'üìù Generate Release Notes'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [validate-inputs, download-pdf]
    if: github.event.inputs.confirm == 'PUBLISH'
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üìÑ Download PDF from previous job
        uses: actions/download-artifact@v4
        with:
          name: pdf-artifact
          path: ./

      - name: üìù Generate Release Notes
        run: |
          echo "üìù Generating release notes..."
          
          # Check if AI generation is enabled
          # Generate changelog first (this will be used for release notes)
          echo "üìù Generating changelog entries..."
          python tools/scripts/maintenance/change_log.py \
            --incremental \
            --verbose
          
          # Keep changelog for debugging
          echo "üìã Changelog generated - keeping for debugging"
          ls -la CHANGELOG.md
          
          if [ "${{ github.event.inputs.ai_generated_notes }}" = "true" ]; then
            echo "ü§ñ AI generation enabled - attempting AI-powered release notes..."
            
            # Install Python dependencies
            python -m pip install --upgrade pip
            python -m pip install requests
            
            # Install Ollama
            echo "ü§ñ Installing Ollama..."
            curl -fsSL https://ollama.ai/install.sh | sh
            
            # Start Ollama service
            echo "üöÄ Starting Ollama service..."
            ollama serve &
            sleep 10  # Wait for service to start
            
            # Pull the default model
            MODEL="${{ env.DEFAULT_AI_MODEL }}"
            echo "üì¶ Pulling AI model: $MODEL"
            ollama pull $MODEL
            
            # Test Ollama connection
            echo "üß™ Testing Ollama connection..."
            if ollama list | grep -q "$MODEL"; then
              echo "‚úÖ Ollama model ready: $MODEL"
            else
              echo "‚ùå Failed to pull model: $MODEL, trying fallback..."
              MODEL="${{ env.FALLBACK_AI_MODEL }}"
              ollama pull $MODEL
              if ! ollama list | grep -q "$MODEL"; then
                echo "‚ùå Fallback model also failed, using manual notes"
                AI_GENERATION_FAILED=true
              fi
            fi
            
            # Generate release notes using AI if available
            if [ "$AI_GENERATION_FAILED" != "true" ]; then
              echo "üìù Generating release notes with AI..."
              python tools/scripts/maintenance/release_notes.py \
                --version ${{ needs.validate-inputs.outputs.new_version }} \
                --previous-version ${{ needs.validate-inputs.outputs.previous_version }} \
                --description "${{ github.event.inputs.description }}" \
                --verbose
              
              # Check if AI release notes were generated
              if [ -f "release_notes_v${{ needs.validate-inputs.outputs.new_version }}.md" ]; then
                echo "‚úÖ AI release notes generated successfully"
                echo "üìÑ Release notes file details:"
                ls -la "release_notes_v${{ needs.validate-inputs.outputs.new_version }}.md"
                echo "üìù Release notes content:"
                cat "release_notes_v${{ needs.validate-inputs.outputs.new_version }}.md"
              else
                echo "‚ö†Ô∏è AI release notes generation failed, using manual template"
                AI_GENERATION_FAILED=true
              fi
            fi
          else
            echo "üìù AI generation disabled - using manual template"
            AI_GENERATION_FAILED=true
          fi
          
          # Create manual release notes if AI failed or disabled
          if [ "$AI_GENERATION_FAILED" = "true" ]; then
            echo "üìù Creating manual release notes template..."
            python tools/scripts/maintenance/release_notes.py \
              --version ${{ needs.validate-inputs.outputs.new_version }} \
              --previous-version ${{ needs.validate-inputs.outputs.previous_version }} \
              --description "${{ github.event.inputs.description }}" \
              --verbose
            
            # Show manual release notes details
            if [ -f "release_notes_v${{ needs.validate-inputs.outputs.new_version }}.md" ]; then
              echo "‚úÖ Manual release notes generated successfully"
              echo "üìÑ Release notes file details:"
              ls -la "release_notes_v${{ needs.validate-inputs.outputs.new_version }}.md"
              echo "üìù Release notes content:"
              cat "release_notes_v${{ needs.validate-inputs.outputs.new_version }}.md"
            else
              echo "‚ùå Failed to generate manual release notes"
            fi
          fi

      - name: üì§ Upload Release Notes Artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-notes
          path: release_notes_v${{ needs.validate-inputs.outputs.new_version }}.md
          retention-days: 1

      - name: üì§ Upload Changelog Artifact
        uses: actions/upload-artifact@v4
        with:
          name: changelog
          path: CHANGELOG.md
          retention-days: 7

  create-release:
    name: 'üì¶ Create GitHub Release'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [validate-inputs, generate-release-notes]
    if: github.event.inputs.confirm == 'PUBLISH'
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üìÑ Download PDF from previous job
        uses: actions/download-artifact@v4
        with:
          name: pdf-artifact
          path: ./

      - name: üìù Download release notes
        uses: actions/download-artifact@v4
        with:
          name: release-notes
          path: ./

      - name: üì¶ Create GitHub Release with PDF
        run: |
          echo "üì¶ Creating GitHub Release ${{ needs.validate-inputs.outputs.new_version }}..."
          echo "üìã Release details:"
          echo "  - Tag: ${{ needs.validate-inputs.outputs.new_version }}"
          echo "  - Name: ${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}"
          echo "  - Repository: ${{ github.repository }}"
          
          # Use the AI-generated release notes
          RELEASE_NOTES_FILE="release_notes_${{ needs.validate-inputs.outputs.new_version }}.md"
          
          if [ -f "$RELEASE_NOTES_FILE" ]; then
            echo "üìÑ Using AI-generated release notes:"
            cat "$RELEASE_NOTES_FILE"
          else
            echo "‚ùå Release notes file not found!"
            exit 1
          fi
          
          # Create the release as a DRAFT for manual editing
          echo "üöÄ Creating GitHub release as DRAFT..."
          RELEASE_RESPONSE=$(curl -s \
            -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases" \
            -d "{
              \"tag_name\": \"${{ needs.validate-inputs.outputs.new_version }}\",
              \"name\": \"${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}\",
              \"body\": \"$(cat $RELEASE_NOTES_FILE | sed 's/"/\\"/g' | tr '\n' '\\n')\",
              \"draft\": true,
              \"prerelease\": false
            }")
          
          echo "üìä API Response:"
          echo "$RELEASE_RESPONSE" | jq '.'
          
          RELEASE_ID=$(echo "$RELEASE_RESPONSE" | jq -r '.id')
          RELEASE_URL=$(echo "$RELEASE_RESPONSE" | jq -r '.html_url')
          
          if [ "$RELEASE_ID" != "null" ] && [ -n "$RELEASE_ID" ]; then
            echo "‚úÖ Draft release created successfully!"
            echo "üìä Release ID: $RELEASE_ID"
            echo "üîó Release URL: $RELEASE_URL"
            echo "üìù Next step: Edit release notes manually and publish"
            echo "release_id=$RELEASE_ID" >> $GITHUB_ENV
            echo "release_url=$RELEASE_URL" >> $GITHUB_ENV
          else
            echo "‚ùå Failed to create release!"
            echo "üìä Error details:"
            echo "$RELEASE_RESPONSE" | jq -r '.message // "Unknown error"'
            echo "$RELEASE_RESPONSE" | jq -r '.errors[]?.message // empty'
            exit 1
          fi

      - name: üìÑ Upload PDF to Release Assets
        run: |
          echo "üìÑ Uploading PDF to release assets..."
          
          if [ ! -f "Machine-Learning-Systems.pdf" ]; then
            echo "‚ùå PDF file not found!"
            exit 1
          fi
          
          echo "üìä PDF size: $(du -h Machine-Learning-Systems.pdf | cut -f1)"
          
          # Upload the PDF to the release
          UPLOAD_RESPONSE=$(curl -s \
            -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Content-Type: application/pdf" \
            --data-binary @Machine-Learning-Systems.pdf \
            "https://uploads.github.com/repos/${{ github.repository }}/releases/${{ env.release_id }}/assets?name=Machine-Learning-Systems.pdf")
          
          echo "üìä Upload Response:"
          echo "$UPLOAD_RESPONSE" | jq '.'
          
          UPLOAD_ID=$(echo "$UPLOAD_RESPONSE" | jq -r '.id')
          
          if [ "$UPLOAD_ID" != "null" ] && [ -n "$UPLOAD_ID" ]; then
            echo "‚úÖ PDF uploaded successfully to release!"
            echo "üìä Asset ID: $UPLOAD_ID"
            echo "üîó Download URL: https://github.com/${{ github.repository }}/releases/download/${{ needs.validate-inputs.outputs.new_version }}/Machine-Learning-Systems.pdf"
          else
            echo "‚ùå Failed to upload PDF to release!"
            echo "üìä Error details:"
            echo "$UPLOAD_RESPONSE" | jq -r '.message // "Unknown error"'
            exit 1
          fi

  summary:
    name: 'üìã Publication Summary'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [validate-inputs, create-release]
    if: github.event.inputs.confirm == 'PUBLISH'
    
    steps:
      - name: üìã Publication Summary
        run: |
          echo "## üìö Textbook Publication Complete! üéâ" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version Released:** ${{ needs.validate-inputs.outputs.new_version }} (${{ needs.validate-inputs.outputs.release_type }})" >> $GITHUB_STEP_SUMMARY
          echo "**Previous Version:** ${{ needs.validate-inputs.outputs.previous_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Content Published:** ${{ github.event.inputs.description }}" >> $GITHUB_STEP_SUMMARY
          echo "**Published by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Source Commit:** ${{ github.event.inputs.dev_commit || 'latest' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Publication Time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "**Release ID:** ${{ env.release_id || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Release URL:** ${{ env.release_url || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìù Changes:" >> $GITHUB_STEP_SUMMARY
          echo "${{ github.event.inputs.description }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîÑ What happened:" >> $GITHUB_STEP_SUMMARY
          echo "1. ‚úÖ Verified dev branch tests passed" >> $GITHUB_STEP_SUMMARY
          echo "2. ‚úÖ Calculated new version number" >> $GITHUB_STEP_SUMMARY
          echo "3. ‚úÖ Merged dev ‚Üí main branch" >> $GITHUB_STEP_SUMMARY
          echo "4. ‚úÖ Created release tag ${{ needs.validate-inputs.outputs.new_version }}" >> $GITHUB_STEP_SUMMARY
          echo "5. ‚úÖ Pushed to main (triggered production build)" >> $GITHUB_STEP_SUMMARY
          echo "6. ‚úÖ Waited for build completion (up to 1 hour)" >> $GITHUB_STEP_SUMMARY
          echo "7. ‚úÖ Created GitHub Release (DRAFT - edit manually)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üèóÔ∏è Build Process:" >> $GITHUB_STEP_SUMMARY
          echo "- üìö **Controller Workflow**: Triggered by main branch push" >> $GITHUB_STEP_SUMMARY
          echo "- üî® **Build Jobs**: HTML + PDF generation on Linux only" >> $GITHUB_STEP_SUMMARY
          echo "- üìÑ **PDF Processing**: Generated, compressed with Ghostscript, stored in build/pdf/" >> $GITHUB_STEP_SUMMARY
          echo "- üì¶ **Artifacts**: build-ubuntu-latest-pdf contains Machine-Learning-Systems.pdf" >> $GITHUB_STEP_SUMMARY
          echo "- üåê **Deployment**: GitHub Pages with PDF download available" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üåê Access Your Published Textbook:" >> $GITHUB_STEP_SUMMARY
          echo "- üìñ [Interactive Web Textbook](https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }})" >> $GITHUB_STEP_SUMMARY
          echo "- üì¶ [Version Release Notes](https://github.com/${{ github.repository }}/releases/tag/${{ needs.validate-inputs.outputs.new_version }})" >> $GITHUB_STEP_SUMMARY
          echo "- üìÑ [Download Complete PDF](https://github.com/${{ github.repository }}/releases/download/${{ needs.validate-inputs.outputs.new_version }}/Machine-Learning-Systems.pdf)" >> $GITHUB_STEP_SUMMARY
          echo "- üìÑ [Direct PDF Access](https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/assets/Machine-Learning-Systems.pdf)" >> $GITHUB_STEP_SUMMARY
          echo "- üéì [Share with Students](https://mlsysbook.ai)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìä Build Status:" >> $GITHUB_STEP_SUMMARY
          echo "- üéÆ **Controller Workflow**: Should be running/completed" >> $GITHUB_STEP_SUMMARY
          echo "- üìö **Quarto Build**: HTML + PDF generation" >> $GITHUB_STEP_SUMMARY
          echo "- üìÑ **PDF Assets**: Available at `/assets/Machine-Learning-Systems.pdf`" >> $GITHUB_STEP_SUMMARY

  cleanup-on-failure:
    name: 'üßπ Cleanup Failed Release'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [validate-inputs, merge-to-main, create-tag, monitor-build, download-pdf, generate-release-notes, create-release]
    if: always() && github.event.inputs.confirm == 'PUBLISH' && (failure() || cancelled())
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üßπ Clean up failed release artifacts
        run: |
          echo "üßπ Cleaning up artifacts from failed release..."
          
          # Get the version that was being released
          if [ -n "${{ needs.validate-inputs.outputs.new_version }}" ]; then
            VERSION_TAG="${{ needs.validate-inputs.outputs.new_version }}"
            echo "üéØ Cleaning up version: $VERSION_TAG"
          else
            echo "‚ö†Ô∏è No version information available, skipping cleanup"
            exit 0
          fi
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Check and remove local tag
          if git tag -l "$VERSION_TAG" | grep -q "$VERSION_TAG"; then
            echo "üóëÔ∏è Removing local tag: $VERSION_TAG"
            git tag -d "$VERSION_TAG"
          else
            echo "‚ÑπÔ∏è Local tag $VERSION_TAG does not exist"
          fi
          
          # Check and remove remote tag if it exists
          if git ls-remote --tags origin | grep -q "refs/tags/$VERSION_TAG$"; then
            echo "üóëÔ∏è Removing remote tag: $VERSION_TAG"
            git push origin --delete "$VERSION_TAG" || echo "‚ö†Ô∏è Failed to delete remote tag (may not exist)"
          else
            echo "‚ÑπÔ∏è Remote tag $VERSION_TAG does not exist"
          fi
          
          # Check for any draft releases and delete them
          echo "üîç Checking for draft releases..."
          DRAFT_RELEASE=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases" \
            | jq -r ".[] | select(.tag_name == \"$VERSION_TAG\" and .draft == true) | .id")
          
          if [ "$DRAFT_RELEASE" != "null" ] && [ -n "$DRAFT_RELEASE" ]; then
            echo "üóëÔ∏è Deleting draft release: $DRAFT_RELEASE"
            curl -s \
              -X DELETE \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/releases/$DRAFT_RELEASE"
            echo "‚úÖ Draft release deleted"
          else
            echo "‚ÑπÔ∏è No draft release found for $VERSION_TAG"
          fi
          
          echo "‚úÖ Cleanup completed! Repository is ready for retry."

      - name: üìä Cleanup Summary
        run: |
          echo "## üßπ Failed Release Cleanup Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.validate-inputs.outputs.new_version || 'Unknown' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Cleanup Time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üóëÔ∏è Cleaned Up:" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Local git tags removed" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Remote git tags removed (if they existed)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Draft GitHub releases removed (if they existed)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîÑ Ready for Retry:" >> $GITHUB_STEP_SUMMARY
          echo "You can now safely re-run the publish workflow with the same version number." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üêõ Troubleshooting:" >> $GITHUB_STEP_SUMMARY
          echo "If you continue to have issues, check the workflow logs for the failed step." >> $GITHUB_STEP_SUMMARY

  fail-validation:
    name: '‚ùå Validation Failed'
    runs-on: ubuntu-latest
    if: github.event.inputs.confirm != 'PUBLISH'
    
    steps:
      - name: ‚ùå Invalid confirmation
        run: |
          echo "‚ùå Publication cancelled - invalid confirmation"
          echo "üîí You must type exactly 'PUBLISH' to confirm"
          echo "üìù You entered: '${{ github.event.inputs.confirm }}'"
          exit 1 