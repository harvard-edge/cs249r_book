name: 'üöÄ Publish Live'

# =============================================================================
# CONFIGURABLE VARIABLES - Edit these to customize the workflow
# =============================================================================

# AI Model Configuration
env:
  DEFAULT_AI_MODEL: "gemma2:9b"            # Default Ollama model
  FALLBACK_AI_MODEL: "gemma2:9b"         # Fallback if default model fails
  OLLAMA_TIMEOUT: "300"                    # Timeout for Ollama operations (seconds)
  OLLAMA_RETRIES: "3"                      # Number of retries for Ollama calls
  BUILD_TIMEOUT: "3600"                    # Timeout for build operations (1 hour)
  
  # Quarto Configuration Files
  QUARTO_HTML_CONFIG: "_quarto-html.yml"  # HTML build configuration file
  QUARTO_PDF_CONFIG: "_quarto-pdf.yml"    # PDF build configuration file
  QUARTO_MAIN_CONFIG: "_quarto.yml"       # Main Quarto configuration file

# =============================================================================
# ARTIFACT COORDINATION SYSTEM
# =============================================================================
# The üìã Quarto Build Container workflow creates build artifacts and an artifact manifest:
# 
# artifact-manifest: JSON file declaring the names of HTML, PDF, and EPUB artifacts
# main-html-linux: Contains build/html/ (web version)
# main-pdf-linux:  Contains build/pdf/Machine-Learning-Systems.pdf
# main-epub-linux: Contains build/epub/Machine-Learning-Systems.epub
# main-html-windows: Contains build/html/ (web version)  
# main-pdf-windows: Contains build/pdf/Machine-Learning-Systems.pdf
# main-epub-windows: Contains build/epub/Machine-Learning-Systems.epub
#
# This workflow downloads the artifact manifest first to get the exact names,
# then downloads the HTML, PDF, and EPUB artifacts using those names for coordination.
# Quarto Build Container now uses dynamic matrix generation and explicit naming contracts.
#
# Artifact manifest structure:
# {
#   "html_artifact_name": "main-html-linux",
#   "pdf_artifact_name": "main-pdf-linux",
#   "epub_artifact_name": "main-epub-linux", 
#   "build_timestamp": "20250115-143022",
#   "commit_sha": "abc123...",
#   "workflow_run_id": "12345",
#   "detailed_manifest": "build-manifest-detailed",
#   "parallel_builds": true,
#   "extensible": true
# }
# =============================================================================

# Available AI Models (uncomment to use different models):
# - gemma2:9b      (fast, good quality - recommended)
# - gemma2:27b     (better quality, slower)
# - llama3.1:8b    (good balance)
# - llama3.1:70b   (best quality, slowest)
# - mistral:7b     (fast, good for analysis)
# - codellama:7b   (good for code-related changes)

# Manual trigger only - big red button!
# Only allow manual triggers from main and dev branches
#
# üéØ PUBLISHING BEHAVIOR:
# ‚îú‚îÄ‚îÄ With dev_commit specified (e.g., "b5b452e"):
# ‚îÇ   ‚îú‚îÄ‚îÄ Merges EXACTLY that commit into main
# ‚îÇ   ‚îú‚îÄ‚îÄ Includes content + workflow files from that point in time
# ‚îÇ   ‚îî‚îÄ‚îÄ Warning: You get the old workflow version too!
# ‚îÇ
# ‚îî‚îÄ‚îÄ Without dev_commit (empty):
#     ‚îú‚îÄ‚îÄ Merges latest dev branch into main  
#     ‚îú‚îÄ‚îÄ Includes newest content + newest workflow files
#     ‚îî‚îÄ‚îÄ Recommended for most releases
#
# üåø BRANCH CONTROL:
# Quarto Build Container workflow will automatically build from the main branch
# after the merge. The quarto build workflow can also be called manually with
# custom branch targets if needed for testing or special builds.

# Concurrency control: strict for production, flexible for testing
concurrency:
  group: ${{ github.event.inputs.testing_mode == 'yes' && format('publish-live-test-{0}-{1}', github.run_number, github.event.inputs.dev_commit) || 'publish-live' }}
  cancel-in-progress: ${{ github.event.inputs.testing_mode != 'yes' }}

on:
  workflow_dispatch:
    inputs:
      description:
        description: 'What are you publishing? [Content updates and improvements]'
        required: false
        default: 'Content updates and improvements'
      release_type:
        description: 'Release type [patch]'
        required: true
        type: choice
        options:
          - 'patch'
          - 'minor' 
          - 'major'
        default: 'patch'
      dev_commit:
        description: 'Specific dev commit to publish (WARNING: includes old workflow files!) [latest dev]'
        required: false
        default: ''
      confirm:
        description: 'Type "PUBLISH" to confirm (safety check) [required]'
        required: true
        default: ''
      ai_generated_notes:
        description: 'Generate AI-enhanced release notes? [yes]'
        required: true
        type: choice
        options:
          - 'yes'
          - 'no'
        default: 'yes'
      commit_status_timeout:
        description: 'Number of status check attempts [180 = 3 hours at 60s intervals]'
        required: false
        default: '180'
      commit_status_interval:
        description: 'Seconds between status checks [60]'
        required: false
        default: '60'
      previous_version:
        description: 'Previous version to increment from [auto-detect from latest git tag]'
        required: false
        default: ''
      testing_mode:
        description: 'Enable testing mode (allows parallel runs, skips actual deployment) [no]'
        required: false
        type: choice
        options:
          - 'no'
          - 'yes'
        default: 'no'

permissions:
  contents: write
  actions: read
  packages: read

jobs:
  debug-log:
    name: 'üìã Debug & Audit Log'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: always()
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üìã Log Workflow Inputs & Context
        run: |
          echo "## üìã Workflow Debug & Audit Log" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow Attempt:** ${{ github.run_attempt }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "=== üìã WORKFLOW DEBUG & AUDIT LOG ==="
          echo "üïê Workflow started at: $(date -u)"
          echo "üîÑ Run ID: ${{ github.run_id }}"
          echo "üîÑ Run Attempt: ${{ github.run_attempt }}"
          echo "üë§ Triggered by: ${{ github.actor }}"
          echo "üåê Repository: ${{ github.repository }}"
          echo ""
          
          echo "=== üìù USER INPUTS ==="
          echo "Description: '${{ github.event.inputs.description }}'"
          echo "Release Type: '${{ github.event.inputs.release_type }}'"
          echo "Dev Commit: '${{ github.event.inputs.dev_commit }}'"
          echo "Confirmation: '${{ github.event.inputs.confirm }}'"
          echo "AI Generated Notes: '${{ github.event.inputs.ai_generated_notes }}'"
          echo "Status Check Timeout: '${{ github.event.inputs.commit_status_timeout }}' attempts"
          echo "Status Check Interval: '${{ github.event.inputs.commit_status_interval }}' seconds"
          echo ""
          
          echo "### üìù User Inputs:" >> $GITHUB_STEP_SUMMARY
          echo "- **Description:** ${{ github.event.inputs.description }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release Type:** ${{ github.event.inputs.release_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Dev Commit:** ${{ github.event.inputs.dev_commit }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Confirmation:** ${{ github.event.inputs.confirm }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AI Generated Notes:** ${{ github.event.inputs.ai_generated_notes }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status Check Timeout:** ${{ github.event.inputs.commit_status_timeout }} attempts" >> $GITHUB_STEP_SUMMARY
          echo "- **Status Check Interval:** ${{ github.event.inputs.commit_status_interval }} seconds" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: üîç Log Git & Environment Context
        run: |
          echo "=== üîç GIT CONTEXT ==="
          echo "Branch: ${{ github.ref_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "SHA: ${{ github.sha }}"
          echo "Event: ${{ github.event_name }}"
          echo ""
          
          echo "Git Status:"
          git status --porcelain || echo "No git status available"
          echo ""
          
          echo "Recent Commits (last 5):"
          git log --oneline -5 || echo "No git log available"
          echo ""
          
          echo "Remote branches:"
          git branch -r | head -10 || echo "No remote branches info"
          echo ""
          
          echo "Latest tags:"
          git tag --sort=-version:refname | head -10 || echo "No tags found"
          echo ""
          
          echo "### üîç Git Context:" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **SHA:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Event:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: üõ†Ô∏è Log Environment & AI Configuration
        run: |
          echo "=== üõ†Ô∏è ENVIRONMENT ==="
          echo "Runner OS: ${{ runner.os }}"
          echo "Default AI Model: ${{ env.DEFAULT_AI_MODEL }}"
          echo "Fallback AI Model: ${{ env.FALLBACK_AI_MODEL }}"
          echo "Ollama Timeout: ${{ env.OLLAMA_TIMEOUT }}"
          echo "Ollama Retries: ${{ env.OLLAMA_RETRIES }}"
          echo "Build Timeout: ${{ env.BUILD_TIMEOUT }}"
          echo ""
          
          echo "=== üß™ VALIDATION CHECKS ==="
          echo "Confirmation Valid: ${{ github.event.inputs.confirm == 'PUBLISH' }}"
          echo "Branch Valid: ${{ github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev' }}"
          echo "Will Proceed: ${{ github.event.inputs.confirm == 'PUBLISH' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev') }}"
          echo ""
          
          echo "### üõ†Ô∏è Environment:" >> $GITHUB_STEP_SUMMARY
          echo "- **Runner OS:** ${{ runner.os }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AI Model:** ${{ env.DEFAULT_AI_MODEL }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Valid Confirmation:** ${{ github.event.inputs.confirm == 'PUBLISH' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Valid Branch:** ${{ github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Will Proceed:** ${{ github.event.inputs.confirm == 'PUBLISH' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev') }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: üìä Log Previous Releases
        run: |
          echo "=== üìä RELEASE HISTORY ==="
          echo "Checking existing releases..."
          
          # Get latest releases
          RELEASES=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases?per_page=5" \
            | jq -r '.[] | "\(.tag_name) - \(.published_at // "draft") - \(.draft)"' 2>/dev/null || echo "Unable to fetch releases")
          
          echo "Recent releases:"
          echo "$RELEASES"
          echo ""
          
          # Get latest tags  
          echo "Latest tags:"
          git tag --sort=-version:refname | head -5 || echo "No tags found"
          echo ""
          
          echo "### üìä Release History:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "$RELEASES" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

  validate-inputs:
    name: 'üîç Validate Inputs'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: github.event.inputs.confirm == 'PUBLISH' && github.event.inputs.testing_mode != 'yes' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev')
    outputs:
      new_version: ${{ steps.version.outputs.new_version }}
      previous_version: ${{ steps.version.outputs.previous_version }}
      release_type: ${{ steps.version.outputs.release_type }}
    
    steps:
      - name: üîí Check Branch Restriction
        run: |
          echo "üîí Checking branch restrictions..."
          echo "Current branch: ${{ github.ref_name }}"
          echo "Current ref: ${{ github.ref }}"
          
          if [[ "${{ github.ref }}" != "refs/heads/main" && "${{ github.ref }}" != "refs/heads/dev" ]]; then
            echo "‚ùå ERROR: This workflow can only be triggered from 'main' or 'dev' branches"
            echo "‚ùå Current branch: ${{ github.ref_name }}"
            echo "‚ùå Please switch to 'main' or 'dev' branch before running this workflow"
            exit 1
          fi
          
          echo "‚úÖ Branch check passed - running from ${{ github.ref_name }}"

      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üîç Validate dev commit
        run: |
          echo "üîç Validating dev commit..."
          
          # Get the commit to validate and trim whitespace
          COMMIT_SHA=$(echo "${{ github.event.inputs.dev_commit }}" | xargs)
          
          if [ -n "$COMMIT_SHA" ]; then
            echo "üìå Using specified commit: $COMMIT_SHA"
            
            # Verify commit exists and is from dev branch
            if ! git cat-file -e "$COMMIT_SHA" 2>/dev/null; then
              echo "‚ùå Commit $COMMIT_SHA does not exist!"
              exit 1
            fi
            
            if ! git merge-base --is-ancestor "$COMMIT_SHA" origin/dev; then
              echo "‚ùå Commit $COMMIT_SHA is not in dev branch!"
              exit 1
            fi
            
            echo "‚úÖ Commit $COMMIT_SHA is valid and from dev branch"
          else
            echo "üìå Using latest dev commit (no specific commit specified)"
          fi
          
          echo "‚úÖ Ready to publish"

      - name: üè∑Ô∏è Calculate Next Version
        id: version
        run: |
          echo "üîÑ Getting latest release version..."
          
          # Use provided previous version or auto-detect
          if [ -n "${{ github.event.inputs.previous_version }}" ]; then
            LATEST_VERSION="${{ github.event.inputs.previous_version }}"
            echo "üìå Using provided previous version: $LATEST_VERSION"
          else
            # Get latest git tag version, default to v0.0.0 if no tags exist
            LATEST_VERSION=$(git tag -l "v*" | sort -V | tail -n1)
            if [ -z "$LATEST_VERSION" ]; then
              LATEST_VERSION="v0.0.0"
              echo "üìä No git tags found, using default: $LATEST_VERSION"
            else
              echo "üìä Auto-detected latest git tag: $LATEST_VERSION"
            fi
          fi
          
          # Remove 'v' prefix for calculation
          VERSION_NUM=${LATEST_VERSION#v}
          
          # Split version into components
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_NUM"
          
          # Handle empty or invalid versions
          MAJOR=${MAJOR:-0}
          MINOR=${MINOR:-0}
          PATCH=${PATCH:-0}
          
          echo "üìä Previous version components: $MAJOR.$MINOR.$PATCH"
          
          # Calculate new version based on release type
          case "${{ github.event.inputs.release_type }}" in
            "major")
              NEW_MAJOR=$((MAJOR + 1))
              NEW_MINOR=0
              NEW_PATCH=0
              ;;
            "minor")
              NEW_MAJOR=$MAJOR
              NEW_MINOR=$((MINOR + 1))
              NEW_PATCH=0
              ;;
            "patch")
              NEW_MAJOR=$MAJOR
              NEW_MINOR=$MINOR
              NEW_PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="v$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
          echo "üéØ New version: $NEW_VERSION (${{ github.event.inputs.release_type }} release)"
          echo "üìã Description: ${{ github.event.inputs.description }}"
          
          # Export for other steps
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "release_type=${{ github.event.inputs.release_type }}" >> $GITHUB_OUTPUT
          echo "previous_version=$LATEST_VERSION" >> $GITHUB_OUTPUT

  pre-flight-checks:
    name: 'üõ´ Pre-Flight Validation'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: validate-inputs
    if: github.event.inputs.confirm == 'PUBLISH' && github.event.inputs.testing_mode != 'yes'
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üîç Validate Dev Branch Content
        run: |
          echo "üîç Validating dev branch content before merge..."
          
          # Switch to dev branch and pull latest
          git checkout dev
          git pull origin dev
          
          # Check if dev commit exists and is valid
          if [ -n "${{ github.event.inputs.dev_commit }}" ]; then
            DEV_COMMIT=$(echo "${{ github.event.inputs.dev_commit }}" | xargs)
            echo "üìå Validating specific commit: $DEV_COMMIT"
            
            if ! git cat-file -e "$DEV_COMMIT" 2>/dev/null; then
              echo "‚ùå Commit $DEV_COMMIT does not exist!"
              exit 1
            fi
            
            if ! git merge-base --is-ancestor "$DEV_COMMIT" HEAD; then
              echo "‚ùå Commit $DEV_COMMIT is not in current dev branch!"
              exit 1
            fi
            
            # Checkout the specific commit for validation
            git checkout "$DEV_COMMIT"
          fi
          
          echo "‚úÖ Dev branch content validated"

      - name: üìö Validate Quarto Project Structure
        run: |
          echo "üìö Validating Quarto project structure..."
          
          cd quarto
          
          # Check critical files exist using environment variables
          REQUIRED_FILES=("${{ env.QUARTO_MAIN_CONFIG }}" "config/${{ env.QUARTO_HTML_CONFIG }}" "config/${{ env.QUARTO_PDF_CONFIG }}")
          for file in "${REQUIRED_FILES[@]}"; do
            if [ ! -f "$file" ]; then
              echo "‚ùå Required file missing: $file"
              exit 1
            fi
            echo "‚úÖ Found: $file"
          done
          
          # Validate Quarto configuration
          if command -v quarto >/dev/null 2>&1; then
            echo "üîç Checking Quarto configuration..."
            if ! quarto check; then
              echo "‚ö†Ô∏è Quarto check reported issues, but continuing..."
            fi
          else
            echo "‚ÑπÔ∏è Quarto not available for validation in this environment"
          fi
          
          echo "‚úÖ Quarto project structure validated"

      - name: üß™ Test Build Prerequisites
        run: |
          echo "üß™ Testing build prerequisites..."
          
          # Check disk space (PDF builds need significant space)
          echo "üíæ Checking disk space..."
          df -h
          
          AVAILABLE_GB=$(df / | awk 'NR==2 {print int($4/1024/1024)}')
          echo "üìä Available disk space: ${AVAILABLE_GB}GB"
          
          if [ "$AVAILABLE_GB" -lt 5 ]; then
            echo "‚ùå Insufficient disk space! Need at least 5GB, have ${AVAILABLE_GB}GB"
            exit 1
          fi
          
          echo "‚úÖ Sufficient disk space available"
          
          # Test GitHub API access
          echo "üîç Testing GitHub API access..."
          if ! curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
               "https://api.github.com/repos/${{ github.repository }}" >/dev/null; then
            echo "‚ùå GitHub API access failed!"
            exit 1
          fi
          echo "‚úÖ GitHub API access confirmed"
          
          echo "‚úÖ All prerequisites validated"

      - name: ü§ñ Test AI System Availability
        if: github.event.inputs.ai_generated_notes == 'yes'
        run: |
          echo "ü§ñ Testing if AI system can be installed for release notes..."
          
          # Quick test: Can we download Ollama installer?
          echo "üîç Checking Ollama availability..."
          if curl -fsSL --max-time 30 https://ollama.ai/install.sh > /dev/null; then
            echo "‚úÖ Ollama installer is accessible"
            echo "ü§ñ AI-enhanced release notes will be available"
          else
            echo "‚ö†Ô∏è Ollama installer not accessible"
            echo "üìã Will use git-log-only release notes instead"
            echo "üí° This is not a failure - release notes will still be generated"
          fi
          
          echo "‚úÖ AI system availability check complete"

      - name: üìã Pre-Flight Summary
        run: |
          echo "## üõ´ Pre-Flight Validation Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** All checks passed ‚úÖ" >> $GITHUB_STEP_SUMMARY
          echo "**Dev Commit:** ${{ github.event.inputs.dev_commit || 'latest' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Target Version:** ${{ needs.validate-inputs.outputs.new_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Validation Time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚úÖ Validated:" >> $GITHUB_STEP_SUMMARY
          echo "- Dev branch content and commit validity" >> $GITHUB_STEP_SUMMARY
          echo "- Quarto project structure and configuration" >> $GITHUB_STEP_SUMMARY
          echo "- Build prerequisites (disk space, API access)" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event.inputs.ai_generated_notes }}" = "yes" ]; then
            echo "- AI system (Ollama) installation and testing" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üöÄ **Ready to proceed with merge and publication!**" >> $GITHUB_STEP_SUMMARY

  merge-to-main:
    name: 'üîÑ Merge to Main'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [validate-inputs, pre-flight-checks]
    if: github.event.inputs.confirm == 'PUBLISH' && github.event.inputs.testing_mode != 'yes'
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üîç Check for workflow file changes
        run: |
          echo "üîç Checking if workflow files will be modified in merge..."
          
          # Check if workflow files are in the dev branch changes
          if git diff --name-only origin/main..origin/dev | grep -q "\.github/workflows/"; then
            echo "‚ö†Ô∏è  Workflow files detected in dev branch!"
            echo "üìã This will cause permission issues with publish-live workflow."
            echo "üí° Please manually merge workflow changes first:"
            echo "   1. Create PR for workflow changes"
            echo "   2. Review and merge to main"
            echo "   3. Then run publish-live for content only"
            echo ""
            echo "üîç Workflow files in dev branch:"
            git diff --name-only origin/main..origin/dev | grep "\.github/workflows/"
            echo ""
            echo "‚ùå Stopping to prevent permission issues"
            exit 1
          else
            echo "‚úÖ No workflow files detected - safe to proceed"
          fi

      - name: üîÑ Merge dev to main
        run: |
          echo "üîÑ Configuring git..."
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          echo "üîÑ Switching to main branch..."
          git checkout main
          git pull origin main
          
          # Safety check: Ensure main isn't ahead of specified dev commit
          if [ -n "${{ github.event.inputs.dev_commit }}" ]; then
            DEV_COMMIT=$(echo "${{ github.event.inputs.dev_commit }}" | xargs)
            echo "üîç Checking if main is ahead of specified commit $DEV_COMMIT..."
            
            # Check if dev_commit is an ancestor of current main
            if git merge-base --is-ancestor "$DEV_COMMIT" HEAD; then
              echo "‚ö†Ô∏è MAIN IS AHEAD OF SPECIFIED COMMIT!"
              echo "üìä Current main includes changes newer than $DEV_COMMIT"
              echo ""
              echo "üõë This would create a mixed state (old dev + new main changes)"
              echo "üìã Options to resolve:"
              echo "   A) Use latest dev instead (leave dev_commit empty)"
              echo "   B) Reset main to match dev commit (destructive):"
              echo "      git checkout main && git reset --hard $DEV_COMMIT && git push --force-with-lease"
              echo "   C) Merge dev branch normally first, then publish"
              echo ""
              echo "‚ùå Stopping to prevent untested mixed state"
              exit 1
            else
              echo "‚úÖ Safe to merge: $DEV_COMMIT is newer than current main"
            fi
          fi
          
          echo "üîç Checking for potential merge conflicts..."
          # Test merge without committing
          if ! git merge --no-commit --no-ff origin/dev 2>/dev/null; then
            echo "‚ùå MERGE CONFLICTS DETECTED!"
            echo "üõë Automated merge cannot proceed due to conflicts."
            echo "üìã Please resolve conflicts manually:"
            echo "   1. git checkout main"
            echo "   2. git pull origin main" 
            echo "   3. git merge dev"
            echo "   4. Resolve conflicts and commit"
            echo "   5. git push origin main"
            git merge --abort
            exit 1
          fi
          git reset --hard HEAD  # Clean up test merge
          
          echo "‚úÖ No conflicts detected. Proceeding with merge..."
          echo "üîÑ Merging dev into main..."
          
          # Debug: Show what dev_commit input was received
          DEV_COMMIT_INPUT="${{ github.event.inputs.dev_commit }}"
          echo "üîç DEBUG: dev_commit input = '$DEV_COMMIT_INPUT'"
          echo "üîç DEBUG: Input length = ${#DEV_COMMIT_INPUT}"
          
          # Determine which commit to merge
          if [ -n "${{ github.event.inputs.dev_commit }}" ]; then
            MERGE_COMMIT=$(echo "${{ github.event.inputs.dev_commit }}" | xargs)
            echo "üìå SPECIFIC COMMIT MODE: Merging exact commit: $MERGE_COMMIT"
            echo "‚ö†Ô∏è  This includes content + workflow files from that point in time"
          else
            MERGE_COMMIT="origin/dev"
            echo "üìä LATEST DEV MODE: Merging latest dev commit"
            echo "‚úÖ This includes newest content + newest workflow files"
          fi
          
          echo "üéØ Final merge target: $MERGE_COMMIT"
          
          git merge "$MERGE_COMMIT" --no-ff -m "üöÄ Release ${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}

          Merged dev branch to main for publication.
          
          Release Type: ${{ github.event.inputs.release_type }}
          Published by: ${{ github.actor }}
          Dev Commit: ${MERGE_COMMIT}
          Specific Commit: ${{ github.event.inputs.dev_commit || 'latest dev' }}
          Description: ${{ github.event.inputs.description }}"
          
          echo "‚úÖ Merge completed successfully!"

      - name: üöÄ Push merge to main
        run: |
          echo "üöÄ Pushing merge to main branch..."
          git push origin main
          
          echo "‚úÖ Main branch updated successfully!"
          echo "üìã Next step: Monitor production build, then create release tag"

  trigger-production-build:
    name: 'üöÄ Trigger Production Build'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: merge-to-main
    if: github.event.inputs.confirm == 'PUBLISH' && github.event.inputs.testing_mode != 'yes'
    outputs:
      commit_sha: ${{ steps.commit.outputs.commit_sha }}
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üöÄ Get Current Commit SHA
        id: commit
        run: |
          # Get the latest commit SHA from main branch
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "üìå Current commit SHA: $COMMIT_SHA"

  # Matrix-driven production build (clean and simple!)
  call-production-build:
    name: 'üöÄ Call Production Build Matrix'
    needs: [merge-to-main, trigger-production-build]
    uses: ./.github/workflows/quarto-build-container.yml
    with:
      build_linux: true    # Production builds Linux only for now
      build_windows: false
      build_html: true     # HTML + PDF + EPUB for production
      build_pdf: true
      build_epub: true
      target: main
      container_registry: 'ghcr.io'
      container_tag: 'latest'


  create-tag:
    name: 'üè∑Ô∏è Create Release Tag (Final Step)'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [validate-inputs, download-and-deploy-artifacts]
    if: github.event.inputs.confirm == 'PUBLISH' && github.event.inputs.testing_mode != 'yes'
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üîÑ Sync with latest main
        run: |
          echo "üîÑ Configuring git..."
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          echo "üîÑ Switching to main and pulling latest changes..."
          git checkout main
          git pull origin main
          
          echo "‚úÖ Synced with latest main branch"

      - name: üè∑Ô∏è Create Release Tag
        run: |
          echo "üè∑Ô∏è Creating release tag ${{ needs.validate-inputs.outputs.new_version }}..."
          echo "‚úÖ Build AND deployment completed successfully - safe to create release tag"
          
          # Check if tag already exists locally
          if git tag -l "${{ needs.validate-inputs.outputs.new_version }}" | grep -q "${{ needs.validate-inputs.outputs.new_version }}"; then
            echo "‚ö†Ô∏è Tag ${{ needs.validate-inputs.outputs.new_version }} already exists locally"
            echo "üîÑ Removing existing tag to recreate it..."
            git tag -d ${{ needs.validate-inputs.outputs.new_version }}
          fi
          
          # Check if tag exists on remote
          if git ls-remote --tags origin | grep -q "refs/tags/${{ needs.validate-inputs.outputs.new_version }}$"; then
            echo "‚ö†Ô∏è Tag ${{ needs.validate-inputs.outputs.new_version }} already exists on remote"
            echo "üîÑ Removing remote tag to recreate it..."
            git push origin --delete ${{ needs.validate-inputs.outputs.new_version }}
          fi
          
          # Create the tag on the latest main commit
          git tag -a ${{ needs.validate-inputs.outputs.new_version }} -m "Release ${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}"
          echo "‚úÖ Tag created successfully!"

      - name: üöÄ Push tag for release tracking
        run: |
          echo "üöÄ Pushing release tag for version tracking..."
          git push origin ${{ needs.validate-inputs.outputs.new_version }}
          
          echo "‚úÖ Release tag pushed successfully!"
          echo "üè∑Ô∏è Tag: ${{ needs.validate-inputs.outputs.new_version }}"
          echo "üìã Description: ${{ github.event.inputs.description }}"
          echo "üìä This tag marks a successful build and tested release"

  download-and-deploy-artifacts:
    name: 'üì¶ Download Artifacts & Deploy to GitHub Pages'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: call-production-build
    if: github.event.inputs.confirm == 'PUBLISH' && github.event.inputs.testing_mode != 'yes'
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üîç Validate API Contract
        run: |
          echo "üîç Validating artifact names from API..."
          
          HTML_ARTIFACT="${{ needs.call-production-build.outputs.linux_html_artifact }}"
          PDF_ARTIFACT="${{ needs.call-production-build.outputs.linux_pdf_artifact }}"
          EPUB_ARTIFACT="${{ needs.call-production-build.outputs.linux_epub_artifact }}"
          
          echo "üìÑ HTML artifact name: '$HTML_ARTIFACT'"
          echo "üìë PDF artifact name: '$PDF_ARTIFACT'"
          echo "üìö EPUB artifact name: '$EPUB_ARTIFACT'"
          
          # Fail explicitly if API didn't provide artifact names
          if [ -z "$HTML_ARTIFACT" ]; then
            echo "‚ùå CRITICAL: HTML artifact name not provided by build workflow API!"
            echo "üîß This indicates the workflow output contract is broken."
            exit 1
          fi
          
          if [ -z "$PDF_ARTIFACT" ]; then
            echo "‚ùå CRITICAL: PDF artifact name not provided by build workflow API!"
            echo "üîß This indicates the workflow output contract is broken."
            exit 1
          fi
          
          if [ -z "$EPUB_ARTIFACT" ]; then
            echo "‚ùå CRITICAL: EPUB artifact name not provided by build workflow API!"
            echo "üîß This indicates the workflow output contract is broken."
            exit 1
          fi
          
          echo "‚úÖ API contract validated - all artifact names provided"

      - name: üì¶ Download HTML Artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.call-production-build.outputs.linux_html_artifact }}
          path: ./html-temp

      - name: üì¶ Download PDF Artifacts  
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.call-production-build.outputs.linux_pdf_artifact }}
          path: ./pdf-temp

      - name: üì¶ Download EPUB Artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.call-production-build.outputs.linux_epub_artifact }}
          path: ./epub-temp
        continue-on-error: true

      - name: üìã Verify Downloaded Artifacts
        run: |
          echo "üì¶ Verifying downloaded artifacts..."
          
          # Find HTML build directory - check if html-temp has content
          if [ ! -d "html-temp" ] || [ -z "$(ls -A html-temp 2>/dev/null)" ]; then
            echo "‚ùå HTML build directory not found or empty!"
            echo "üìä HTML artifact contents:"
            find html-temp -type f -o -type d | head -20
            exit 1
          fi
          
          # Look for the actual HTML build structure
          HTML_BUILD_DIR="html-temp"
          if [ -d "html-temp/html" ]; then
            HTML_BUILD_DIR="html-temp/html"
            echo "‚úÖ HTML build found in subdirectory: $HTML_BUILD_DIR"
          else
            echo "‚úÖ HTML build found at root level: $HTML_BUILD_DIR"
          fi
          
          echo "üìä HTML structure preview:"
          ls -la "$HTML_BUILD_DIR" | head -5
          
          # Find PDF file
          PDF_FILE=$(find pdf-temp -name "Machine-Learning-Systems.pdf" -type f | head -1)
          if [ -z "$PDF_FILE" ] || [ ! -f "$PDF_FILE" ]; then
            echo "‚ùå PDF file not found in extracted artifacts!"
            echo "üìä PDF artifact contents:"
            find pdf-temp -type f -o -type d | head -20
            exit 1
          fi
          
          echo "‚úÖ PDF found: $PDF_FILE"
          echo "üìä PDF size: $(du -h "$PDF_FILE" | cut -f1)"
          
          # Find EPUB file if available
          EPUB_FILE=""
          if [ -d "epub-temp" ]; then
            EPUB_FILE=$(find epub-temp -name "Machine-Learning-Systems.epub" -type f | head -1)
            if [ -z "$EPUB_FILE" ] || [ ! -f "$EPUB_FILE" ]; then
              # Try alternative EPUB filenames
              EPUB_FILE=$(find epub-temp -name "*.epub" -type f | head -1)
              if [ -n "$EPUB_FILE" ] && [ -f "$EPUB_FILE" ]; then
                echo "‚úÖ EPUB found (alternative name): $EPUB_FILE"
                echo "üìä EPUB size: $(du -h "$EPUB_FILE" | cut -f1)"
              else
                echo "‚ö†Ô∏è EPUB file not found in extracted artifacts - will skip EPUB deployment"
                EPUB_FILE=""
              fi
            else
              echo "‚úÖ EPUB found: $EPUB_FILE"
              echo "üìä EPUB size: $(du -h "$EPUB_FILE" | cut -f1)"
            fi
          else
            echo "‚ö†Ô∏è No EPUB artifact extracted - will skip EPUB deployment"
          fi
          
          # Prepare combined site
          echo "üîÑ Preparing combined HTML site with PDF and EPUB..."
          mkdir -p combined-site
          
          # Copy HTML content
          cp -r "$HTML_BUILD_DIR"/* combined-site/
          
          # Create assets directory
          mkdir -p combined-site/assets
          
          # Copy PDF if available
          if [ -n "$PDF_FILE" ] && [ -f "$PDF_FILE" ]; then
            PDF_SIZE_MB=$(du -m "$PDF_FILE" | cut -f1)
            echo "üìä PDF size: ${PDF_SIZE_MB}MB"
            
            # Deploy PDF to both GitHub Pages and GitHub Release
            cp "$PDF_FILE" combined-site/assets/Machine-Learning-Systems.pdf
            echo "‚úÖ PDF deployed to GitHub Pages (${PDF_SIZE_MB}MB)"
            
            # Also copy PDF for GitHub release
            cp "$PDF_FILE" "Machine-Learning-Systems.pdf"
            echo "‚úÖ PDF prepared for release"
          else
            echo "‚ùå PDF file not found - skipping PDF deployment"
          fi
          
          # Copy EPUB if available
          if [ -n "$EPUB_FILE" ] && [ -f "$EPUB_FILE" ]; then
            EPUB_SIZE_MB=$(du -m "$EPUB_FILE" | cut -f1)
            echo "üìä EPUB size: ${EPUB_SIZE_MB}MB"
            
            # Deploy EPUB to both GitHub Pages and GitHub Release
            cp "$EPUB_FILE" combined-site/assets/Machine-Learning-Systems.epub
            echo "‚úÖ EPUB deployed to GitHub Pages (${EPUB_SIZE_MB}MB)"
            
            # Also copy EPUB for GitHub release
            cp "$EPUB_FILE" "Machine-Learning-Systems.epub"
            echo "‚úÖ EPUB prepared for release"
          else
            echo "‚ùå EPUB file not found - skipping EPUB deployment"
          fi
          
          echo "üìä Combined site structure:"
          ls -la combined-site/ | head -10
          echo "üìä Assets directory:"
          ls -la combined-site/assets/
          
          # Summary of what was prepared
          echo "üìã Asset preparation complete:"
          if [ -f "Machine-Learning-Systems.pdf" ]; then
            echo "  ‚úÖ PDF: Ready for deployment"
          else
            echo "  ‚ùå PDF: Not available"
          fi
          if [ -f "Machine-Learning-Systems.epub" ]; then
            echo "  ‚úÖ EPUB: Ready for deployment"
          else
            echo "  ‚ùå EPUB: Not available"
          fi

      - name: üöÄ Deploy Combined Site to GitHub Pages (Production)
        run: |
          echo "üöÄ Deploying combined HTML + PDF + EPUB site to GitHub Pages..."
          echo "üåê Production URL: https://harvard-edge.github.io/cs249r_book/"
          
          # Configure git
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          
          # Clone gh-pages branch
          git clone --depth=1 --branch=gh-pages https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git gh-pages-repo
          
          # Clear existing content
          cd gh-pages-repo
          rm -rf *
          
          # Copy new combined content
          cp -r ../combined-site/* .
          
          echo "üìä Deployed content structure:"
          ls -la | head -10
          echo "üìä Assets available:"
          ls -la assets/ 2>/dev/null || echo "No assets directory"
          
          # Add all files to git
          git add .
          
          # Commit and push
          git commit -m "üöÄ Deploy release ${{ needs.validate-inputs.outputs.new_version }} from commit ${{ github.sha }}

          Combined HTML site with PDF and EPUB assets for download.
          
          - HTML: Interactive web textbook  
          - PDF: assets/Machine-Learning-Systems.pdf
          - EPUB: assets/Machine-Learning-Systems.epub (if available)
          - Release: ${{ needs.validate-inputs.outputs.new_version }}
          " || echo "No changes to commit"
          
          git push origin gh-pages
          
          echo "‚úÖ GitHub Pages deployment complete!"
          echo "üåê Site: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}"
          echo "üìÑ PDF: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/assets/Machine-Learning-Systems.pdf"
          echo "üìö EPUB: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/assets/Machine-Learning-Systems.epub"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: üì§ Upload PDF Artifact for GitHub Release
        uses: actions/upload-artifact@v4
        with:
          name: pdf-artifact
          path: Machine-Learning-Systems.pdf

      - name: üì§ Upload EPUB Artifact for GitHub Release
        if: success()
        run: |
          if [ -f "Machine-Learning-Systems.epub" ]; then
            echo "‚úÖ EPUB file found for upload"
          else
            echo "‚ö†Ô∏è No EPUB file found - creating empty artifact to prevent workflow failure"
            touch Machine-Learning-Systems.epub
          fi

      - name: üì§ Upload EPUB Artifact
        uses: actions/upload-artifact@v4
        with:
          name: epub-artifact
          path: Machine-Learning-Systems.epub
          if-no-files-found: warn

  generate-release-notes:
    name: 'üìù Generate Release Notes'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [validate-inputs, download-and-deploy-artifacts]
    if: github.event.inputs.confirm == 'PUBLISH' && github.event.inputs.testing_mode != 'yes'
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üìÑ Download PDF from previous job
        uses: actions/download-artifact@v4
        with:
          name: pdf-artifact
          path: ./

      - name: üìù Generate Release Notes
        run: |
          echo "üìù Generating release notes..."
          echo "ü§ñ AI Enhancement Mode: ${{ github.event.inputs.ai_generated_notes }}"
          if [ "${{ github.event.inputs.ai_generated_notes }}" = "yes" ]; then
            echo "   ‚úÖ Will use AI to enhance git log (if AI system is available)"
          else
            echo "   üìã Will use git log only (clean, reliable format)"
          fi
          echo ""
          
          # Generate git log between versions
          PREVIOUS_VERSION="${{ needs.validate-inputs.outputs.previous_version }}"
          CURRENT_VERSION="${{ needs.validate-inputs.outputs.new_version }}"
          
          echo "üìä Generating git log from $PREVIOUS_VERSION to current commit..."
          
          # Create detailed git log
          echo "# Release Notes for $CURRENT_VERSION" > git_changes.md
          echo "" >> git_changes.md
          echo "## Changes since $PREVIOUS_VERSION" >> git_changes.md
          echo "" >> git_changes.md
          
          # Get commit log with details
          if git rev-parse "$PREVIOUS_VERSION" >/dev/null 2>&1; then
            echo "‚úÖ Previous version tag $PREVIOUS_VERSION found"
            
            # Summary format for AI processing
            git log --oneline ${PREVIOUS_VERSION}..HEAD > git_log_summary.txt
            
            # Detailed format for inclusion in release
            echo "### Commit Summary:" >> git_changes.md
            git log --oneline ${PREVIOUS_VERSION}..HEAD >> git_changes.md
            echo "" >> git_changes.md
            
            echo "### Detailed Changes:" >> git_changes.md
            git log --pretty=format:"- **%s** (%h) by %an%n  %b" ${PREVIOUS_VERSION}..HEAD >> git_changes.md
            
            echo "üìä Found $(git rev-list --count ${PREVIOUS_VERSION}..HEAD) commits since $PREVIOUS_VERSION"
          else
            echo "‚ö†Ô∏è Previous version tag $PREVIOUS_VERSION not found, using all commits"
            git log --oneline -20 > git_log_summary.txt
            echo "### Recent Commits:" >> git_changes.md
            git log --oneline -20 >> git_changes.md
          fi
          
          echo "‚úÖ Git log generated and saved to files"
          
          if [ "${{ github.event.inputs.ai_generated_notes }}" = "yes" ]; then
            echo ""
            echo "ü§ñ AI Enhancement Mode Selected - installing Ollama for release notes..."
            
            # Install Ollama for this job (each job runs in isolation)
            echo "ü§ñ Installing Ollama..."
            if curl -fsSL https://ollama.ai/install.sh | sh; then
              echo "‚úÖ Ollama installed successfully"
              
              # Start Ollama service
              echo "üöÄ Starting Ollama service..."
              ollama serve &
              
              # Wait for service to be ready
              echo "‚è≥ Waiting for Ollama service..."
              OLLAMA_READY=false
              for i in {1..30}; do
                if ollama list >/dev/null 2>&1; then
                  echo "‚úÖ Ollama service ready after ${i}0 seconds"
                  OLLAMA_READY=true
                  break
                fi
                echo "‚è≥ Waiting... (${i}/30)"
                sleep 10
              done
              
              if [ "$OLLAMA_READY" = "true" ]; then
                # Pull the model
                MODEL="${{ env.DEFAULT_AI_MODEL }}"
                echo "üì¶ Pulling AI model: $MODEL"
                if timeout ${{ env.OLLAMA_TIMEOUT }} ollama pull $MODEL; then
                  echo "‚úÖ Model $MODEL ready for release notes generation"
                  AI_GENERATION_FAILED=false
                else
                  echo "‚ö†Ô∏è Model pull failed, using git log only"
                  AI_GENERATION_FAILED=true
                fi
              else
                echo "‚ö†Ô∏è Ollama service failed to start, using git log only"
                AI_GENERATION_FAILED=true
              fi
            else
              echo "‚ö†Ô∏è Ollama installation failed, using git log only"
              AI_GENERATION_FAILED=true
            fi
            
            # Generate AI-enhanced release notes using git log
            if [ "$AI_GENERATION_FAILED" != "true" ]; then
              echo "üìù Generating AI-enhanced release notes from git log..."
              
              # Create AI prompt with git log content
              {
                echo "Generate release notes for MLSysBook ${{ needs.validate-inputs.outputs.new_version }} - an open-source Machine Learning Systems textbook."
                echo ""
                echo "AUDIENCE: Students, researchers, practitioners, contributors, and educators using the textbook"
                echo "PURPOSE: Professional announcement of improvements and enhancements in this release"
                echo ""
                echo "RELEASE DESCRIPTION: ${{ github.event.inputs.description }}"
                echo "RELEASE TYPE: ${{ github.event.inputs.release_type }}"
                echo ""
                echo "COMMITS:"
                cat git_log_summary.txt
                echo ""
                echo "STYLE REQUIREMENTS:"
                echo "- Academic, professional tone (like the original v0.1.0 release notes)"
                echo "- Clear structure with appropriate emojis for readability"
                echo "- Focus on educational value and user benefits"
                echo "- Include both content and infrastructure improvements"
                echo ""
                echo "REQUIRED STRUCTURE:"
                echo "# Release ${{ needs.validate-inputs.outputs.new_version }}: [Professional Title]"
                echo "IMPORTANT: Use the EXACT version number ${{ needs.validate-inputs.outputs.new_version }} in the title"
                echo ""
                echo "[Professional intro paragraph about this release's focus]"
                echo ""
                echo "## ‚ú® Key Features"
                echo ""
                echo "### üìñ Content Updates"
                echo "[List 3-5 most significant content improvements, ordered by user impact]"
                echo ""
                echo "### üõ†Ô∏è Infrastructure"  
                echo "[List 3-5 most significant infrastructure/reliability improvements, ordered by user impact]"
                echo ""
                echo "## üéØ [Academic Impact Section]"
                echo "[What this means for students, researchers, and educators]"
                echo ""
                echo "## üåê Access the Book"
                echo "- üìñ **Online Version**: [mlsysbook.ai](https://mlsysbook.ai)"
                echo "- üìÑ **PDF Download**: Available from this release's assets"
                echo "- üìö **EPUB Version**: Available from this release's assets"
                echo ""
                echo "## üìû Feedback & Contributions"
                echo "We welcome feedback, suggestions, and contributions! Please visit our [GitHub repository](https://github.com/harvard-edge/cs249r_book) or website to get involved."
                echo ""
                echo "---"
                echo ""
                echo "For detailed changes, see: [Changelog](https://mlsysbook.ai/changelog)"
                echo ""
                echo "RELEASE ENGINEERING GUIDELINES:"
                echo "- SCOPE: 3-5 items per category (comprehensive but focused)"
                echo "- PRIORITIZE BY USER IMPACT: What affects the most users goes first"
                echo "- Content: 3-5 most significant improvements that change user experience"
                echo "- Infrastructure: 3-5 most significant reliability/performance improvements users notice"
                echo "- Use straightforward, academic language (no marketing terms)"
                echo "- Be factual and direct - state what improved, not how amazing it is"
                echo "- AVOID: ANY chapter/section references (no 'chapter', 'section', 'primer', specific topic names)"
                echo "- GOOD: 'Enhanced visualizations', 'Improved mathematical notation', 'Updated code examples'"
                echo "- BAD: 'Deep Learning Primer', 'Embedded Systems Chapter', 'Workflow Section', 'across various chapters'"
                echo "- Write like a scholarly publication announcement, not marketing material"
              } > ai_prompt.txt
              
              # Generate AI release notes
              if ollama run $MODEL < ai_prompt.txt > ai_release_notes.md 2>/dev/null; then
                echo "‚úÖ AI release notes generated successfully"
                
                # Combine AI notes with detailed git log
                {
                  echo "# Release ${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}"
                  echo ""
                  cat ai_release_notes.md
                  echo ""
                  echo "---"
                  echo ""
                  echo "## Full Change Log"
                  echo ""
                  cat git_changes.md
                } > "release_notes_${{ needs.validate-inputs.outputs.new_version }}.md"
              else
                echo "‚ö†Ô∏è AI generation failed, using git log only"
                AI_GENERATION_FAILED=true
              fi
            fi
            
            # If AI generation failed, fall back to git log only
            if [ "$AI_GENERATION_FAILED" = "true" ]; then
              echo "üìã Falling back to git log only release notes"
              {
                echo "# Release ${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}"
                echo ""
                echo "## Overview"
                echo "This ${{ github.event.inputs.release_type }} release includes the following changes:"
                echo ""
                cat git_changes.md
              } > "release_notes_${{ needs.validate-inputs.outputs.new_version }}.md"
            fi
          else
            echo ""
            echo "üìã Git Log Only Mode - creating clean release notes from git history"
            
            # Create release notes from git log only
            {
              echo "# Release ${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}"
              echo ""
              echo "## Overview"
              echo "This ${{ github.event.inputs.release_type }} release includes the following changes:"
              echo ""
              cat git_changes.md
            } > "release_notes_${{ needs.validate-inputs.outputs.new_version }}.md"
          fi
          
          # Show final release notes
          if [ -f "release_notes_${{ needs.validate-inputs.outputs.new_version }}.md" ]; then
            echo "‚úÖ Release notes generated successfully"
            echo "üìÑ Release notes file details:"
            ls -la "release_notes_${{ needs.validate-inputs.outputs.new_version }}.md"
            echo "üìù Release notes content (first 50 lines):"
            head -50 "release_notes_${{ needs.validate-inputs.outputs.new_version }}.md"
          else
            echo "‚ùå Failed to generate release notes - creating basic fallback"
            # Create a basic fallback release notes file
            {
              echo "# Release ${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}"
              echo ""
              echo "## Release Information"
              echo "- **Version**: ${{ needs.validate-inputs.outputs.new_version }}"
              echo "- **Type**: ${{ github.event.inputs.release_type }} release"
              echo "- **Description**: ${{ github.event.inputs.description }}"
              echo ""
              echo "## Changes"
              echo "Please see the git commit history for detailed changes."
            } > "release_notes_${{ needs.validate-inputs.outputs.new_version }}.md"
            echo "‚úÖ Basic release notes created as fallback"
          fi

      - name: üì§ Upload Release Notes Artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-notes
          path: release_notes_${{ needs.validate-inputs.outputs.new_version }}.md

      - name: üì§ Upload Git Log Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: git-changes
          path: |
            git_changes.md
            git_log_summary.txt
            ai_release_notes.md

  create-release:
    name: 'üì¶ Create GitHub Release'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [validate-inputs, generate-release-notes, create-tag]
    if: github.event.inputs.confirm == 'PUBLISH' && github.event.inputs.testing_mode != 'yes'
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üìÑ Download PDF from previous job
        uses: actions/download-artifact@v4
        with:
          name: pdf-artifact
          path: ./

      - name: üìö Download EPUB from previous job
        uses: actions/download-artifact@v4
        with:
          name: epub-artifact
          path: ./

      - name: üìù Download release notes
        uses: actions/download-artifact@v4
        with:
          name: release-notes
          path: ./

      - name: üì¶ Create GitHub Release with PDF
        run: |
          echo "üì¶ Creating GitHub Release ${{ needs.validate-inputs.outputs.new_version }}..."
          echo "üìã Release details:"
          echo "  - Tag: ${{ needs.validate-inputs.outputs.new_version }}"
          echo "  - Name: ${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}"
          echo "  - Repository: ${{ github.repository }}"
          
          # Use the AI-generated release notes
          RELEASE_NOTES_FILE="release_notes_${{ needs.validate-inputs.outputs.new_version }}.md"
          
          if [ -f "$RELEASE_NOTES_FILE" ]; then
            echo "üìÑ Using AI-generated release notes:"
            cat "$RELEASE_NOTES_FILE"
          else
            echo "‚ùå Release notes file not found!"
            exit 1
          fi
          
          # Create the release as a DRAFT for manual editing
          echo "üöÄ Creating GitHub release as DRAFT..."
          
          # Properly escape the release notes for JSON
          ESCAPED_BODY=$(cat "$RELEASE_NOTES_FILE" | jq -Rs .)
          
          # Create JSON payload using jq to ensure proper escaping
          JSON_PAYLOAD=$(jq -n \
            --arg tag "${{ needs.validate-inputs.outputs.new_version }}" \
            --arg name "${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}" \
            --argjson body "$ESCAPED_BODY" \
            '{
              tag_name: $tag,
              name: $name,
              body: $body,
              draft: true,
              prerelease: false
            }')
          
          RELEASE_RESPONSE=$(curl -s \
            -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Content-Type: application/json" \
            "https://api.github.com/repos/${{ github.repository }}/releases" \
            -d "$JSON_PAYLOAD")
          
          echo "üìä API Response:"
          echo "$RELEASE_RESPONSE" | jq '.'
          
          RELEASE_ID=$(echo "$RELEASE_RESPONSE" | jq -r '.id')
          RELEASE_URL=$(echo "$RELEASE_RESPONSE" | jq -r '.html_url')
          
          if [ "$RELEASE_ID" != "null" ] && [ -n "$RELEASE_ID" ]; then
            echo "‚úÖ Draft release created successfully!"
            echo "üìä Release ID: $RELEASE_ID"
            echo "üîó Release URL: $RELEASE_URL"
            echo "üìù Next step: Edit release notes manually and publish"
            echo "release_id=$RELEASE_ID" >> $GITHUB_ENV
            echo "release_url=$RELEASE_URL" >> $GITHUB_ENV
          else
            echo "‚ùå Failed to create release!"
            echo "üìä Error details:"
            echo "$RELEASE_RESPONSE" | jq -r '.message // "Unknown error"'
            echo "$RELEASE_RESPONSE" | jq -r '.errors[]?.message // empty'
            exit 1
          fi

      - name: üìÑ Upload PDF to Release Assets
        run: |
          echo "üìÑ Uploading PDF to release assets..."
          
          if [ ! -f "Machine-Learning-Systems.pdf" ]; then
            echo "‚ùå PDF file not found!"
            exit 1
          fi
          
          echo "üìä PDF size: $(du -h Machine-Learning-Systems.pdf | cut -f1)"
          
          # Upload the PDF to the release
          UPLOAD_RESPONSE=$(curl -s \
            -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Content-Type: application/pdf" \
            --data-binary @Machine-Learning-Systems.pdf \
            "https://uploads.github.com/repos/${{ github.repository }}/releases/${{ env.release_id }}/assets?name=Machine-Learning-Systems.pdf")
          
          echo "üìä Upload Response:"
          echo "$UPLOAD_RESPONSE" | jq '.'
          
          UPLOAD_ID=$(echo "$UPLOAD_RESPONSE" | jq -r '.id')
          
          if [ "$UPLOAD_ID" != "null" ] && [ -n "$UPLOAD_ID" ]; then
            echo "‚úÖ PDF uploaded successfully to release!"
            echo "üìä Asset ID: $UPLOAD_ID"
            echo "üîó Download URL: https://github.com/${{ github.repository }}/releases/download/${{ needs.validate-inputs.outputs.new_version }}/Machine-Learning-Systems.pdf"
          else
            echo "‚ùå Failed to upload PDF to release!"
            echo "üìä Error details:"
            echo "$UPLOAD_RESPONSE" | jq -r '.message // "Unknown error"'
            exit 1
          fi

      - name: üìö Upload EPUB to Release Assets
        run: |
          echo "üìö Checking for EPUB file to upload..."
          
          if [ ! -f "Machine-Learning-Systems.epub" ]; then
            echo "‚ö†Ô∏è EPUB file not found - skipping EPUB upload"
            exit 0
          fi
          
          # Check if it's an empty file (created as placeholder)
          if [ ! -s "Machine-Learning-Systems.epub" ]; then
            echo "‚ö†Ô∏è EPUB file is empty (placeholder) - skipping EPUB upload"
            exit 0
          fi
          
          echo "üìö Uploading EPUB to release assets..."
          echo "üìä EPUB size: $(du -h Machine-Learning-Systems.epub | cut -f1)"
          
          # Upload the EPUB to the release
          UPLOAD_RESPONSE=$(curl -s \
            -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Content-Type: application/epub+zip" \
            --data-binary @Machine-Learning-Systems.epub \
            "https://uploads.github.com/repos/${{ github.repository }}/releases/${{ env.release_id }}/assets?name=Machine-Learning-Systems.epub")
          
          echo "üìä Upload Response:"
          echo "$UPLOAD_RESPONSE" | jq '.'
          
          UPLOAD_ID=$(echo "$UPLOAD_RESPONSE" | jq -r '.id')
          
          if [ "$UPLOAD_ID" != "null" ] && [ -n "$UPLOAD_ID" ]; then
            echo "‚úÖ EPUB uploaded successfully to release!"
            echo "üìä Asset ID: $UPLOAD_ID"
            echo "üîó Download URL: https://github.com/${{ github.repository }}/releases/download/${{ needs.validate-inputs.outputs.new_version }}/Machine-Learning-Systems.epub"
          else
            echo "‚ö†Ô∏è Failed to upload EPUB to release (continuing anyway)!"
            echo "üìä Error details:"
            echo "$UPLOAD_RESPONSE" | jq -r '.message // "Unknown error"'
          fi

  summary:
    name: 'üìã Publication Summary'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [validate-inputs, create-release]
    if: github.event.inputs.confirm == 'PUBLISH' && github.event.inputs.testing_mode != 'yes'
    
    steps:
      - name: üìã Publication Summary
        run: |
          echo "## üìö Textbook Publication Complete! üéâ" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version Released:** ${{ needs.validate-inputs.outputs.new_version }} (${{ needs.validate-inputs.outputs.release_type }})" >> $GITHUB_STEP_SUMMARY
          echo "**Previous Version:** ${{ needs.validate-inputs.outputs.previous_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Content Published:** ${{ github.event.inputs.description }}" >> $GITHUB_STEP_SUMMARY
          echo "**Published by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Source Commit:** ${{ github.event.inputs.dev_commit || 'latest' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Publication Time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "**Release ID:** ${{ env.release_id || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Release URL:** ${{ env.release_url || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîç Debug Information:" >> $GITHUB_STEP_SUMMARY
          echo "- **Workflow Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Run Attempt:** ${{ github.run_attempt }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit SHA:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AI Generated Notes:** ${{ github.event.inputs.ai_generated_notes }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìù Changes:" >> $GITHUB_STEP_SUMMARY
          echo "${{ github.event.inputs.description }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîÑ What happened:" >> $GITHUB_STEP_SUMMARY
          echo "1. ‚úÖ Verified dev branch tests passed" >> $GITHUB_STEP_SUMMARY
          echo "2. ‚úÖ Calculated new version number" >> $GITHUB_STEP_SUMMARY
          echo "3. ‚úÖ Merged dev ‚Üí main branch" >> $GITHUB_STEP_SUMMARY
          echo "4. ‚úÖ Pushed to main (triggered production build)" >> $GITHUB_STEP_SUMMARY
          echo "5. ‚úÖ Waited for build completion (up to 3 hours)" >> $GITHUB_STEP_SUMMARY
          echo "6. ‚úÖ Created release tag ${{ needs.validate-inputs.outputs.new_version }} (after successful build)" >> $GITHUB_STEP_SUMMARY
          echo "7. ‚úÖ Created GitHub Release (DRAFT - edit manually)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üèóÔ∏è Build Process:" >> $GITHUB_STEP_SUMMARY
          echo "- üìã **Quarto Build Container Workflow**: Triggered by main branch push" >> $GITHUB_STEP_SUMMARY
          echo "- üî® **Build Jobs**: HTML + PDF + EPUB generation on Linux (parallel builds)" >> $GITHUB_STEP_SUMMARY
          echo "- üìÑ **PDF Processing**: Generated, compressed with Ghostscript, stored in build/pdf/" >> $GITHUB_STEP_SUMMARY
          echo "- üì¶ **Artifacts**: main-html-linux (web content) + main-pdf-linux (PDF file) + main-epub-linux (EPUB file)" >> $GITHUB_STEP_SUMMARY
          echo "- üîÑ **Integration**: Downloaded all artifacts and combined into unified deployment" >> $GITHUB_STEP_SUMMARY
          echo "- üåê **Deployment**: Combined HTML + PDF + EPUB deployed to GitHub Pages (gh-pages branch)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üåê Access Your Published Textbook:" >> $GITHUB_STEP_SUMMARY
          echo "- üìñ [Interactive Web Textbook](https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }})" >> $GITHUB_STEP_SUMMARY
          echo "- üì¶ [Version Release Notes](https://github.com/${{ github.repository }}/releases/tag/${{ needs.validate-inputs.outputs.new_version }})" >> $GITHUB_STEP_SUMMARY
          echo "- üìÑ [Download Complete PDF](https://github.com/${{ github.repository }}/releases/download/${{ needs.validate-inputs.outputs.new_version }}/Machine-Learning-Systems.pdf)" >> $GITHUB_STEP_SUMMARY
          echo "- üìö [Download EPUB eBook](https://github.com/${{ github.repository }}/releases/download/${{ needs.validate-inputs.outputs.new_version }}/Machine-Learning-Systems.epub)" >> $GITHUB_STEP_SUMMARY
          echo "- üìÑ [Direct PDF Access](https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/assets/Machine-Learning-Systems.pdf)" >> $GITHUB_STEP_SUMMARY
          echo "- üìö [Direct EPUB Access](https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/assets/Machine-Learning-Systems.epub)" >> $GITHUB_STEP_SUMMARY
          echo "- üéì [Share with Students](https://mlsysbook.ai)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìä Build Status:" >> $GITHUB_STEP_SUMMARY
          echo "- üìã **Quarto Build Container Workflow**: Should be running/completed" >> $GITHUB_STEP_SUMMARY
          echo "- üèóÔ∏è **Quarto Build**: HTML + PDF + EPUB generation" >> $GITHUB_STEP_SUMMARY
          echo "- üìÑ **PDF Assets**: Available at `/assets/Machine-Learning-Systems.pdf`" >> $GITHUB_STEP_SUMMARY
          echo "- üìö **EPUB Assets**: Available at `/assets/Machine-Learning-Systems.epub`" >> $GITHUB_STEP_SUMMARY

  cleanup-on-failure:
    name: 'üßπ Cleanup Failed Release'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [validate-inputs]
    if: always() && github.event.inputs.confirm == 'PUBLISH' && (failure() || cancelled())
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üßπ Clean up failed release artifacts
        run: |
          echo "üßπ Cleaning up artifacts from failed release..."
          
          # Get the version that was being released
          if [ -n "${{ needs.validate-inputs.outputs.new_version }}" ]; then
            VERSION_TAG="${{ needs.validate-inputs.outputs.new_version }}"
            echo "üéØ Cleaning up version: $VERSION_TAG"
          else
            echo "‚ö†Ô∏è No version information available, skipping cleanup"
            exit 0
          fi
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Check and remove local tag
          if git tag -l "$VERSION_TAG" | grep -q "$VERSION_TAG"; then
            echo "üóëÔ∏è Removing local tag: $VERSION_TAG"
            git tag -d "$VERSION_TAG"
          else
            echo "‚ÑπÔ∏è Local tag $VERSION_TAG does not exist"
          fi
          
          # Check and remove remote tag if it exists
          if git ls-remote --tags origin | grep -q "refs/tags/$VERSION_TAG$"; then
            echo "üóëÔ∏è Removing remote tag: $VERSION_TAG"
            git push origin --delete "$VERSION_TAG" || echo "‚ö†Ô∏è Failed to delete remote tag (may not exist)"
          else
            echo "‚ÑπÔ∏è Remote tag $VERSION_TAG does not exist"
          fi
          
          # Check for any draft releases and delete them
          echo "üîç Checking for draft releases..."
          DRAFT_RELEASE=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases" \
            | jq -r ".[] | select(.tag_name == \"$VERSION_TAG\" and .draft == true) | .id")
          
          if [ "$DRAFT_RELEASE" != "null" ] && [ -n "$DRAFT_RELEASE" ]; then
            echo "üóëÔ∏è Deleting draft release: $DRAFT_RELEASE"
            curl -s \
              -X DELETE \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/releases/$DRAFT_RELEASE"
            echo "‚úÖ Draft release deleted"
          else
            echo "‚ÑπÔ∏è No draft release found for $VERSION_TAG"
          fi
          
          echo "‚úÖ Cleanup completed! Repository is ready for retry."

      - name: üìä Cleanup Summary
        run: |
          echo "## üßπ Failed Release Cleanup Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.validate-inputs.outputs.new_version || 'Unknown' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Cleanup Time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîç Original Inputs (for debugging):" >> $GITHUB_STEP_SUMMARY
          echo "- **Description:** ${{ github.event.inputs.description }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release Type:** ${{ github.event.inputs.release_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Dev Commit:** ${{ github.event.inputs.dev_commit }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Confirmation:** ${{ github.event.inputs.confirm }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AI Generated Notes:** ${{ github.event.inputs.ai_generated_notes }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status Check Timeout:** ${{ github.event.inputs.commit_status_timeout }} attempts" >> $GITHUB_STEP_SUMMARY
          echo "- **Status Check Interval:** ${{ github.event.inputs.commit_status_interval }} seconds" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Run Attempt:** ${{ github.run_attempt }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üóëÔ∏è Cleaned Up:" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Local git tags removed" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Remote git tags removed (if they existed)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Draft GitHub releases removed (if they existed)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîÑ Ready for Retry:" >> $GITHUB_STEP_SUMMARY
          echo "You can now safely re-run the publish workflow with the same version number." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üêõ Troubleshooting:" >> $GITHUB_STEP_SUMMARY
          echo "If you continue to have issues, check the workflow logs for the failed step." >> $GITHUB_STEP_SUMMARY

  cleanup-on-timeout:
    name: '‚è∞ Cleanup Timed Out Release'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [validate-inputs, trigger-production-build]
    if: always() && github.event.inputs.confirm == 'PUBLISH' && (needs.trigger-production-build.result == 'failure' || needs.trigger-production-build.result == 'timeout')
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üßπ Clean up timed out release artifacts
        run: |
          echo "‚è∞ Cleaning up artifacts from timed out release..."
          
          # Get the version that was being released
          if [ -n "${{ needs.validate-inputs.outputs.new_version }}" ]; then
            VERSION_TAG="${{ needs.validate-inputs.outputs.new_version }}"
            echo "üéØ Cleaning up version: $VERSION_TAG"
          else
            echo "‚ö†Ô∏è No version information available, skipping cleanup"
            exit 0
          fi
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Check and remove local tag
          if git tag -l "$VERSION_TAG" | grep -q "$VERSION_TAG"; then
            echo "üóëÔ∏è Removing local tag: $VERSION_TAG"
            git tag -d "$VERSION_TAG"
          else
            echo "‚ÑπÔ∏è Local tag $VERSION_TAG does not exist"
          fi
          
          # Check and remove remote tag if it exists
          if git ls-remote --tags origin | grep -q "refs/tags/$VERSION_TAG$"; then
            echo "üóëÔ∏è Removing remote tag: $VERSION_TAG"
            git push origin --delete "$VERSION_TAG" || echo "‚ö†Ô∏è Failed to delete remote tag (may not exist)"
          else
            echo "‚ÑπÔ∏è Remote tag $VERSION_TAG does not exist"
          fi
          
          # Check for any draft releases and delete them
          echo "üîç Checking for draft releases..."
          DRAFT_RELEASE=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases" \
            | jq -r ".[] | select(.tag_name == \"$VERSION_TAG\" and .draft == true) | .id")
          
          if [ "$DRAFT_RELEASE" != "null" ] && [ -n "$DRAFT_RELEASE" ]; then
            echo "üóëÔ∏è Deleting draft release: $DRAFT_RELEASE"
            curl -s \
              -X DELETE \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/releases/$DRAFT_RELEASE"
            echo "‚úÖ Draft release deleted"
          else
            echo "‚ÑπÔ∏è No draft release found for $VERSION_TAG"
          fi
          
          echo "‚úÖ Cleanup completed! Repository is ready for retry."

      - name: üîÑ Rollback Main Branch (if needed)
        run: |
          echo "üîÑ Checking if main branch rollback is needed..."
          
          # Only rollback if merge succeeded but later steps failed
          if [ "${{ needs.merge-to-main.result }}" = "success" ] && [ "${{ needs.create-tag.result }}" != "success" ]; then
            echo "‚ö†Ô∏è Merge succeeded but tag creation failed - considering rollback"
            echo "üîç Checking if main branch needs to be rolled back..."
            
            # Get the commit before the merge
            MERGE_COMMIT=$(git log --oneline -1 --grep="Release $VERSION_TAG" --format="%H" || echo "")
            
            if [ -n "$MERGE_COMMIT" ]; then
              PARENT_COMMIT=$(git log --format="%P" -n 1 "$MERGE_COMMIT" | cut -d' ' -f1)
              echo "üîç Found merge commit: $MERGE_COMMIT"
              echo "üîç Parent commit: $PARENT_COMMIT"
              
              echo "‚ö†Ô∏è To manually rollback main branch, run:"
              echo "   git checkout main"
              echo "   git reset --hard $PARENT_COMMIT"
              echo "   git push origin main --force-with-lease"
              echo ""
              echo "‚ö†Ô∏è AUTOMATED ROLLBACK DISABLED - Manual intervention required"
              echo "üõ°Ô∏è This prevents accidental data loss"
            else
              echo "‚ÑπÔ∏è No merge commit found - no rollback needed"
            fi
          else
            echo "‚ÑπÔ∏è No rollback needed - merge did not complete successfully"
          fi

      - name: üìä Cleanup Summary
        run: |
          echo "## üßπ Failed Release Cleanup Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.validate-inputs.outputs.new_version || 'Unknown' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Cleanup Time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîç Original Inputs (for debugging):" >> $GITHUB_STEP_SUMMARY
          echo "- **Description:** ${{ github.event.inputs.description }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release Type:** ${{ github.event.inputs.release_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Dev Commit:** ${{ github.event.inputs.dev_commit }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Confirmation:** ${{ github.event.inputs.confirm }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AI Generated Notes:** ${{ github.event.inputs.ai_generated_notes }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status Check Timeout:** ${{ github.event.inputs.commit_status_timeout }} attempts" >> $GITHUB_STEP_SUMMARY
          echo "- **Status Check Interval:** ${{ github.event.inputs.commit_status_interval }} seconds" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Run Attempt:** ${{ github.run_attempt }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üóëÔ∏è Cleaned Up:" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Local git tags removed" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Remote git tags removed (if they existed)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Draft GitHub releases removed (if they existed)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîÑ Ready for Retry:" >> $GITHUB_STEP_SUMMARY
          echo "You can now safely re-run the publish workflow with the same version number." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üêõ Troubleshooting:" >> $GITHUB_STEP_SUMMARY
          echo "If you continue to have issues, check the workflow logs for the failed step." >> $GITHUB_STEP_SUMMARY

  testing-mode-summary:
    name: 'üß™ Testing Mode Summary'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event.inputs.confirm == 'PUBLISH' && github.event.inputs.testing_mode == 'yes'
    needs: [validate-inputs, call-production-build]
    
    steps:
      - name: üß™ Testing Mode Complete
        run: |
          echo "## üß™ Testing Mode Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ‚úÖ Testing workflow completed successfully" >> $GITHUB_STEP_SUMMARY
          echo "**Mode:** Testing (no actual deployment)" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìã What was tested:" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Input validation" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Build workflow triggering" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Build completion detection" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Artifact availability" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üöÄ To run actual deployment:" >> $GITHUB_STEP_SUMMARY
          echo "- Set **testing_mode** to **no**" >> $GITHUB_STEP_SUMMARY
          echo "- Re-run with same parameters" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîç Debug Information:" >> $GITHUB_STEP_SUMMARY
          echo "- **Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Description:** ${{ github.event.inputs.description }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release Type:** ${{ github.event.inputs.release_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Dev Commit:** ${{ github.event.inputs.dev_commit }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Concurrency Group:** publish-live-test-${{ github.run_number }}-${{ github.event.inputs.dev_commit }}" >> $GITHUB_STEP_SUMMARY
          
          echo "‚úÖ Testing mode completed successfully!"
          echo "üß™ This run tested the workflow without actual deployment"
          echo "üîÑ Run ID: ${{ github.run_id }}"
          echo "üë§ Triggered by: ${{ github.actor }}"
          echo "üåê Branch: ${{ github.ref_name }}"

  fail-validation:
    name: '‚ùå Validation Failed'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event.inputs.confirm != 'PUBLISH'
    
    steps:
      - name: ‚ùå Invalid confirmation
        run: |
          echo "## ‚ùå Publication Validation Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Reason:** Invalid confirmation" >> $GITHUB_STEP_SUMMARY
          echo "**Expected:** PUBLISH" >> $GITHUB_STEP_SUMMARY
          echo "**Received:** ${{ github.event.inputs.confirm }}" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîç Debug Information:" >> $GITHUB_STEP_SUMMARY
          echo "- **Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Description:** ${{ github.event.inputs.description }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release Type:** ${{ github.event.inputs.release_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Dev Commit:** ${{ github.event.inputs.dev_commit }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AI Generated Notes:** ${{ github.event.inputs.ai_generated_notes }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "‚ùå Publication cancelled - invalid confirmation"
          echo "üîí You must type exactly 'PUBLISH' to confirm"
          echo "üìù You entered: '${{ github.event.inputs.confirm }}'"
          echo "üë§ Triggered by: ${{ github.actor }}"
          echo "üåê Branch: ${{ github.ref_name }}"
          echo "üîÑ Run ID: ${{ github.run_id }}"
          exit 1 