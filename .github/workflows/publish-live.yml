name: 'ğŸš€ Publish Live'

# =============================================================================
# CONFIGURABLE VARIABLES - Edit these to customize the workflow
# =============================================================================

# AI Model Configuration
env:
  DEFAULT_AI_MODEL: "gemma2:9b"           # Default Ollama model
  FALLBACK_AI_MODEL: "gemma2:27b"         # Fallback if default fails
  OLLAMA_TIMEOUT: "300"                    # Timeout for Ollama operations (seconds)
  OLLAMA_RETRIES: "3"                      # Number of retries for Ollama calls
  BUILD_TIMEOUT: "3600"                    # Timeout for build operations (1 hour)
  
  # Quarto Configuration Files
  QUARTO_HTML_CONFIG: "_quarto-html.yml"  # HTML build configuration file
  QUARTO_PDF_CONFIG: "_quarto-pdf.yml"    # PDF build configuration file
  QUARTO_MAIN_CONFIG: "_quarto.yml"       # Main Quarto configuration file

# =============================================================================
# ARTIFACT STRUCTURE DOCUMENTATION
# =============================================================================
# The ğŸ® Controller workflow creates the following artifacts:
# 
# build-ubuntu-latest-html: Contains build/html/ (web version)
# build-ubuntu-latest-pdf:  Contains build/pdf/Machine-Learning-Systems.pdf
# build-windows-latest-html: Contains build/html/ (web version)  
# build-windows-latest-pdf: Contains build/pdf/Machine-Learning-Systems.pdf
#
# This workflow specifically looks for build-ubuntu-latest-pdf to get the Linux-built PDF
# for consistency and reliability. The PDF is compressed with Ghostscript for optimal size.
#
# Expected file structure in build-ubuntu-latest-pdf artifact:
# build/pdf/Machine-Learning-Systems.pdf
# =============================================================================

# Available AI Models (uncomment to use different models):
# - gemma2:9b      (fast, good quality - recommended)
# - gemma2:27b     (better quality, slower)
# - llama3.1:8b    (good balance)
# - llama3.1:70b   (best quality, slowest)
# - mistral:7b     (fast, good for analysis)
# - codellama:7b   (good for code-related changes)

# Manual trigger only - big red button!
# Only allow manual triggers from main and dev branches
#
# ğŸ¯ PUBLISHING BEHAVIOR:
# â”œâ”€â”€ With dev_commit specified (e.g., "b5b452e"):
# â”‚   â”œâ”€â”€ Merges EXACTLY that commit into main
# â”‚   â”œâ”€â”€ Includes content + workflow files from that point in time
# â”‚   â””â”€â”€ Warning: You get the old workflow version too!
# â”‚
# â””â”€â”€ Without dev_commit (empty):
#     â”œâ”€â”€ Merges latest dev branch into main  
#     â”œâ”€â”€ Includes newest content + newest workflow files
#     â””â”€â”€ Recommended for most releases
on:
  workflow_dispatch:
    inputs:
      description:
        description: 'What are you publishing? (brief description)'
        required: false
        default: 'Content updates and improvements'
      release_type:
        description: 'Release type'
        required: true
        type: choice
        options:
          - 'patch'
          - 'minor' 
          - 'major'
        default: 'patch'
      dev_commit:
        description: 'Specific dev commit to publish (WARNING: includes old workflow files!) Leave empty for latest dev'
        required: false
        default: ''
      confirm:
        description: 'Type "PUBLISH" to confirm (safety check)'
        required: true
        default: ''
      ai_generated_notes:
        description: 'Generate AI-enhanced release notes? (yes = AI + git log, no = git log only)'
        required: true
        type: choice
        options:
          - 'yes'
          - 'no'
        default: 'yes'
      commit_status_timeout:
        description: 'Number of status check attempts (180 = 3 hours at 60s intervals)'
        required: false
        default: '180'
      commit_status_interval:
        description: 'Seconds between status checks (heartbeat interval)'
        required: false
        default: '60'

permissions:
  contents: write
  actions: read

jobs:
  debug-log:
    name: 'ğŸ“‹ Debug & Audit Log'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: always()
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ“‹ Log Workflow Inputs & Context
        run: |
          echo "## ğŸ“‹ Workflow Debug & Audit Log" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow Attempt:** ${{ github.run_attempt }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "=== ğŸ“‹ WORKFLOW DEBUG & AUDIT LOG ==="
          echo "ğŸ• Workflow started at: $(date -u)"
          echo "ğŸ”„ Run ID: ${{ github.run_id }}"
          echo "ğŸ”„ Run Attempt: ${{ github.run_attempt }}"
          echo "ğŸ‘¤ Triggered by: ${{ github.actor }}"
          echo "ğŸŒ Repository: ${{ github.repository }}"
          echo ""
          
          echo "=== ğŸ“ USER INPUTS ==="
          echo "Description: '${{ github.event.inputs.description }}'"
          echo "Release Type: '${{ github.event.inputs.release_type }}'"
          echo "Dev Commit: '${{ github.event.inputs.dev_commit }}'"
          echo "Confirmation: '${{ github.event.inputs.confirm }}'"
          echo "AI Generated Notes: '${{ github.event.inputs.ai_generated_notes }}'"
          echo "Status Check Timeout: '${{ github.event.inputs.commit_status_timeout }}' attempts"
          echo "Status Check Interval: '${{ github.event.inputs.commit_status_interval }}' seconds"
          echo ""
          
          echo "### ğŸ“ User Inputs:" >> $GITHUB_STEP_SUMMARY
          echo "- **Description:** ${{ github.event.inputs.description }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release Type:** ${{ github.event.inputs.release_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Dev Commit:** ${{ github.event.inputs.dev_commit }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Confirmation:** ${{ github.event.inputs.confirm }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AI Generated Notes:** ${{ github.event.inputs.ai_generated_notes }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status Check Timeout:** ${{ github.event.inputs.commit_status_timeout }} attempts" >> $GITHUB_STEP_SUMMARY
          echo "- **Status Check Interval:** ${{ github.event.inputs.commit_status_interval }} seconds" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: ğŸ” Log Git & Environment Context
        run: |
          echo "=== ğŸ” GIT CONTEXT ==="
          echo "Branch: ${{ github.ref_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "SHA: ${{ github.sha }}"
          echo "Event: ${{ github.event_name }}"
          echo ""
          
          echo "Git Status:"
          git status --porcelain || echo "No git status available"
          echo ""
          
          echo "Recent Commits (last 5):"
          git log --oneline -5 || echo "No git log available"
          echo ""
          
          echo "Remote branches:"
          git branch -r | head -10 || echo "No remote branches info"
          echo ""
          
          echo "Latest tags:"
          git tag --sort=-version:refname | head -10 || echo "No tags found"
          echo ""
          
          echo "### ğŸ” Git Context:" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **SHA:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Event:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: ğŸ› ï¸ Log Environment & AI Configuration
        run: |
          echo "=== ğŸ› ï¸ ENVIRONMENT ==="
          echo "Runner OS: ${{ runner.os }}"
          echo "Default AI Model: ${{ env.DEFAULT_AI_MODEL }}"
          echo "Fallback AI Model: ${{ env.FALLBACK_AI_MODEL }}"
          echo "Ollama Timeout: ${{ env.OLLAMA_TIMEOUT }}"
          echo "Ollama Retries: ${{ env.OLLAMA_RETRIES }}"
          echo "Build Timeout: ${{ env.BUILD_TIMEOUT }}"
          echo ""
          
          echo "=== ğŸ§ª VALIDATION CHECKS ==="
          echo "Confirmation Valid: ${{ github.event.inputs.confirm == 'PUBLISH' }}"
          echo "Branch Valid: ${{ github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev' }}"
          echo "Will Proceed: ${{ github.event.inputs.confirm == 'PUBLISH' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev') }}"
          echo ""
          
          echo "### ğŸ› ï¸ Environment:" >> $GITHUB_STEP_SUMMARY
          echo "- **Runner OS:** ${{ runner.os }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AI Model:** ${{ env.DEFAULT_AI_MODEL }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Valid Confirmation:** ${{ github.event.inputs.confirm == 'PUBLISH' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Valid Branch:** ${{ github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Will Proceed:** ${{ github.event.inputs.confirm == 'PUBLISH' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev') }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: ğŸ“Š Log Previous Releases
        run: |
          echo "=== ğŸ“Š RELEASE HISTORY ==="
          echo "Checking existing releases..."
          
          # Get latest releases
          RELEASES=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases?per_page=5" \
            | jq -r '.[] | "\(.tag_name) - \(.published_at // "draft") - \(.draft)"' 2>/dev/null || echo "Unable to fetch releases")
          
          echo "Recent releases:"
          echo "$RELEASES"
          echo ""
          
          # Get latest tags  
          echo "Latest tags:"
          git tag --sort=-version:refname | head -5 || echo "No tags found"
          echo ""
          
          echo "### ğŸ“Š Release History:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "$RELEASES" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

  validate-inputs:
    name: 'ğŸ” Validate Inputs'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: github.event.inputs.confirm == 'PUBLISH' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev')
    outputs:
      new_version: ${{ steps.version.outputs.new_version }}
      previous_version: ${{ steps.version.outputs.previous_version }}
      release_type: ${{ steps.version.outputs.release_type }}
    
    steps:
      - name: ğŸ”’ Check Branch Restriction
        run: |
          echo "ğŸ”’ Checking branch restrictions..."
          echo "Current branch: ${{ github.ref_name }}"
          echo "Current ref: ${{ github.ref }}"
          
          if [[ "${{ github.ref }}" != "refs/heads/main" && "${{ github.ref }}" != "refs/heads/dev" ]]; then
            echo "âŒ ERROR: This workflow can only be triggered from 'main' or 'dev' branches"
            echo "âŒ Current branch: ${{ github.ref_name }}"
            echo "âŒ Please switch to 'main' or 'dev' branch before running this workflow"
            exit 1
          fi
          
          echo "âœ… Branch check passed - running from ${{ github.ref_name }}"

      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ” Validate dev commit
        run: |
          echo "ğŸ” Validating dev commit..."
          
          # Get the commit to validate and trim whitespace
          COMMIT_SHA=$(echo "${{ github.event.inputs.dev_commit }}" | xargs)
          
          if [ -n "$COMMIT_SHA" ]; then
            echo "ğŸ“Œ Using specified commit: $COMMIT_SHA"
            
            # Verify commit exists and is from dev branch
            if ! git cat-file -e "$COMMIT_SHA" 2>/dev/null; then
              echo "âŒ Commit $COMMIT_SHA does not exist!"
              exit 1
            fi
            
            if ! git merge-base --is-ancestor "$COMMIT_SHA" origin/dev; then
              echo "âŒ Commit $COMMIT_SHA is not in dev branch!"
              exit 1
            fi
            
            echo "âœ… Commit $COMMIT_SHA is valid and from dev branch"
          else
            echo "ğŸ“Œ Using latest dev commit (no specific commit specified)"
          fi
          
          echo "âœ… Ready to publish"

      - name: ğŸ·ï¸ Calculate Next Version
        id: version
        run: |
          echo "ğŸ”„ Getting latest release version..."
          
          # Use provided previous version or auto-detect
          if [ -n "${{ github.event.inputs.previous_version }}" ]; then
            LATEST_VERSION="${{ github.event.inputs.previous_version }}"
            echo "ğŸ“Œ Using provided previous version: $LATEST_VERSION"
          else
            # Get latest release version, default to v0.0.0 if no releases exist
            LATEST_VERSION=$(curl -s \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/releases/latest" \
              | jq -r '.tag_name // "v0.0.0"')
            echo "ğŸ“Š Auto-detected latest version: $LATEST_VERSION"
          fi
          
          # Remove 'v' prefix for calculation
          VERSION_NUM=${LATEST_VERSION#v}
          
          # Split version into components
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_NUM"
          
          # Handle empty or invalid versions
          MAJOR=${MAJOR:-0}
          MINOR=${MINOR:-0}
          PATCH=${PATCH:-0}
          
          echo "ğŸ“Š Previous version components: $MAJOR.$MINOR.$PATCH"
          
          # Calculate new version based on release type
          case "${{ github.event.inputs.release_type }}" in
            "major")
              NEW_MAJOR=$((MAJOR + 1))
              NEW_MINOR=0
              NEW_PATCH=0
              ;;
            "minor")
              NEW_MAJOR=$MAJOR
              NEW_MINOR=$((MINOR + 1))
              NEW_PATCH=0
              ;;
            "patch")
              NEW_MAJOR=$MAJOR
              NEW_MINOR=$MINOR
              NEW_PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="v$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
          echo "ğŸ¯ New version: $NEW_VERSION (${{ github.event.inputs.release_type }} release)"
          echo "ğŸ“‹ Description: ${{ github.event.inputs.description }}"
          
          # Export for other steps
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "release_type=${{ github.event.inputs.release_type }}" >> $GITHUB_OUTPUT
          echo "previous_version=$LATEST_VERSION" >> $GITHUB_OUTPUT

  pre-flight-checks:
    name: 'ğŸ›« Pre-Flight Validation'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: validate-inputs
    if: github.event.inputs.confirm == 'PUBLISH'
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ” Validate Dev Branch Content
        run: |
          echo "ğŸ” Validating dev branch content before merge..."
          
          # Switch to dev branch and pull latest
          git checkout dev
          git pull origin dev
          
          # Check if dev commit exists and is valid
          if [ -n "${{ github.event.inputs.dev_commit }}" ]; then
            DEV_COMMIT=$(echo "${{ github.event.inputs.dev_commit }}" | xargs)
            echo "ğŸ“Œ Validating specific commit: $DEV_COMMIT"
            
            if ! git cat-file -e "$DEV_COMMIT" 2>/dev/null; then
              echo "âŒ Commit $DEV_COMMIT does not exist!"
              exit 1
            fi
            
            if ! git merge-base --is-ancestor "$DEV_COMMIT" HEAD; then
              echo "âŒ Commit $DEV_COMMIT is not in current dev branch!"
              exit 1
            fi
            
            # Checkout the specific commit for validation
            git checkout "$DEV_COMMIT"
          fi
          
          echo "âœ… Dev branch content validated"

      - name: ğŸ“š Validate Quarto Project Structure
        run: |
          echo "ğŸ“š Validating Quarto project structure..."
          
          cd book
          
          # Check critical files exist using environment variables
          REQUIRED_FILES=("${{ env.QUARTO_MAIN_CONFIG }}" "config/${{ env.QUARTO_HTML_CONFIG }}" "config/${{ env.QUARTO_PDF_CONFIG }}")
          for file in "${REQUIRED_FILES[@]}"; do
            if [ ! -f "$file" ]; then
              echo "âŒ Required file missing: $file"
              exit 1
            fi
            echo "âœ… Found: $file"
          done
          
          # Validate Quarto configuration
          if command -v quarto >/dev/null 2>&1; then
            echo "ğŸ” Checking Quarto configuration..."
            if ! quarto check; then
              echo "âš ï¸ Quarto check reported issues, but continuing..."
            fi
          else
            echo "â„¹ï¸ Quarto not available for validation in this environment"
          fi
          
          echo "âœ… Quarto project structure validated"

      - name: ğŸ§ª Test Build Prerequisites
        run: |
          echo "ğŸ§ª Testing build prerequisites..."
          
          # Check disk space (PDF builds need significant space)
          echo "ğŸ’¾ Checking disk space..."
          df -h
          
          AVAILABLE_GB=$(df / | awk 'NR==2 {print int($4/1024/1024)}')
          echo "ğŸ“Š Available disk space: ${AVAILABLE_GB}GB"
          
          if [ "$AVAILABLE_GB" -lt 5 ]; then
            echo "âŒ Insufficient disk space! Need at least 5GB, have ${AVAILABLE_GB}GB"
            exit 1
          fi
          
          echo "âœ… Sufficient disk space available"
          
          # Test GitHub API access
          echo "ğŸ” Testing GitHub API access..."
          if ! curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
               "https://api.github.com/repos/${{ github.repository }}" >/dev/null; then
            echo "âŒ GitHub API access failed!"
            exit 1
          fi
          echo "âœ… GitHub API access confirmed"
          
          echo "âœ… All prerequisites validated"

      - name: ğŸ¤– Test AI System (Ollama)
        if: github.event.inputs.ai_generated_notes == 'yes'
        run: |
          echo "ğŸ¤– Testing AI system for release notes generation..."
          
          # Install Python dependencies first
          echo "ğŸ Installing Python dependencies..."
          python -m pip install --upgrade pip
          python -m pip install requests
          
          # Install Ollama with retry
          echo "ğŸ¤– Installing Ollama..."
          for i in {1..3}; do
            if curl -fsSL https://ollama.ai/install.sh | sh; then
              echo "âœ… Ollama installed successfully on attempt $i"
              break
            else
              echo "âš ï¸ Ollama install attempt $i failed, retrying..."
              sleep 5
              if [ $i -eq 3 ]; then
                echo "âŒ Ollama installation failed after 3 attempts"
                echo "ğŸ”„ Will use manual release notes instead"
                exit 0  # Don't fail the whole workflow
              fi
            fi
          done
          
          # Start Ollama service with health check
          echo "ğŸš€ Starting Ollama service..."
          ollama serve &
          
          # Wait for service with timeout
          echo "â³ Waiting for Ollama service to be ready..."
          OLLAMA_READY=false
          for i in {1..30}; do
            if ollama list >/dev/null 2>&1; then
              echo "âœ… Ollama service ready after ${i}0 seconds"
              OLLAMA_READY=true
              break
            fi
            echo "â³ Waiting for Ollama service... (${i}/30)"
            sleep 10
          done
          
          if [ "$OLLAMA_READY" != "true" ]; then
            echo "âŒ Ollama service failed to start within 5 minutes"
            echo "ğŸ”„ Will use manual release notes instead"
            exit 0  # Don't fail the whole workflow
          fi
          
          # Pull the default model with retry
          MODEL="${{ env.DEFAULT_AI_MODEL }}"
          echo "ğŸ“¦ Pulling AI model: $MODEL"
          MODEL_READY=false
          for i in {1..3}; do
            if timeout ${{ env.OLLAMA_TIMEOUT }} ollama pull $MODEL; then
              echo "âœ… Model $MODEL pulled successfully on attempt $i"
              MODEL_READY=true
              break
            else
              echo "âš ï¸ Model pull attempt $i failed, retrying..."
              sleep 10
            fi
          done
          
          # Try fallback model if default failed
          if [ "$MODEL_READY" != "true" ]; then
            echo "âš ï¸ Default model failed, trying fallback..."
            MODEL="${{ env.FALLBACK_AI_MODEL }}"
            echo "ğŸ“¦ Pulling fallback AI model: $MODEL"
            if timeout ${{ env.OLLAMA_TIMEOUT }} ollama pull $MODEL; then
              echo "âœ… Fallback model $MODEL pulled successfully"
              MODEL_READY=true
            else
              echo "âŒ Fallback model also failed"
              echo "ğŸ”„ Will use manual release notes instead"
              exit 0  # Don't fail the whole workflow
            fi
          fi
          
          # Test Ollama with a simple query
          echo "ğŸ§ª Testing Ollama with simple query..."
          if echo "Test" | ollama run $MODEL >/dev/null 2>&1; then
            echo "âœ… Ollama AI system is working correctly!"
            echo "ğŸ¤– Model: $MODEL"
            echo "ğŸš€ Ready for AI-powered release notes generation"
            
            # Save the working model for later use
            echo "$MODEL" > /tmp/ollama_model.txt
          else
            echo "âŒ Ollama test query failed"
            echo "ğŸ”„ Will use manual release notes instead"
            exit 0  # Don't fail the whole workflow
          fi

      - name: ğŸ“‹ Pre-Flight Summary
        run: |
          echo "## ğŸ›« Pre-Flight Validation Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** All checks passed âœ…" >> $GITHUB_STEP_SUMMARY
          echo "**Dev Commit:** ${{ github.event.inputs.dev_commit || 'latest' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Target Version:** ${{ needs.validate-inputs.outputs.new_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Validation Time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âœ… Validated:" >> $GITHUB_STEP_SUMMARY
          echo "- Dev branch content and commit validity" >> $GITHUB_STEP_SUMMARY
          echo "- Quarto project structure and configuration" >> $GITHUB_STEP_SUMMARY
          echo "- Build prerequisites (disk space, API access)" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event.inputs.ai_generated_notes }}" = "yes" ]; then
            echo "- AI system (Ollama) installation and testing" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ğŸš€ **Ready to proceed with merge and publication!**" >> $GITHUB_STEP_SUMMARY

  merge-to-main:
    name: 'ğŸ”„ Merge to Main'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [validate-inputs, pre-flight-checks]
    if: github.event.inputs.confirm == 'PUBLISH'
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ” Check for workflow file changes
        run: |
          echo "ğŸ” Checking if workflow files will be modified in merge..."
          
          # Check if workflow files are in the dev branch changes
          if git diff --name-only origin/main..origin/dev | grep -q "\.github/workflows/"; then
            echo "âš ï¸  Workflow files detected in dev branch!"
            echo "ğŸ“‹ This will cause permission issues with publish-live workflow."
            echo "ğŸ’¡ Please manually merge workflow changes first:"
            echo "   1. Create PR for workflow changes"
            echo "   2. Review and merge to main"
            echo "   3. Then run publish-live for content only"
            echo ""
            echo "ğŸ” Workflow files in dev branch:"
            git diff --name-only origin/main..origin/dev | grep "\.github/workflows/"
            echo ""
            echo "âŒ Stopping to prevent permission issues"
            exit 1
          else
            echo "âœ… No workflow files detected - safe to proceed"
          fi

      - name: ğŸ”„ Merge dev to main
        run: |
          echo "ğŸ”„ Configuring git..."
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          echo "ğŸ”„ Switching to main branch..."
          git checkout main
          git pull origin main
          
          # Safety check: Ensure main isn't ahead of specified dev commit
          if [ -n "${{ github.event.inputs.dev_commit }}" ]; then
            DEV_COMMIT=$(echo "${{ github.event.inputs.dev_commit }}" | xargs)
            echo "ğŸ” Checking if main is ahead of specified commit $DEV_COMMIT..."
            
            # Check if dev_commit is an ancestor of current main
            if git merge-base --is-ancestor "$DEV_COMMIT" HEAD; then
              echo "âš ï¸ MAIN IS AHEAD OF SPECIFIED COMMIT!"
              echo "ğŸ“Š Current main includes changes newer than $DEV_COMMIT"
              echo ""
              echo "ğŸ›‘ This would create a mixed state (old dev + new main changes)"
              echo "ğŸ“‹ Options to resolve:"
              echo "   A) Use latest dev instead (leave dev_commit empty)"
              echo "   B) Reset main to match dev commit (destructive):"
              echo "      git checkout main && git reset --hard $DEV_COMMIT && git push --force-with-lease"
              echo "   C) Merge dev branch normally first, then publish"
              echo ""
              echo "âŒ Stopping to prevent untested mixed state"
              exit 1
            else
              echo "âœ… Safe to merge: $DEV_COMMIT is newer than current main"
            fi
          fi
          
          echo "ğŸ” Checking for potential merge conflicts..."
          # Test merge without committing
          if ! git merge --no-commit --no-ff origin/dev 2>/dev/null; then
            echo "âŒ MERGE CONFLICTS DETECTED!"
            echo "ğŸ›‘ Automated merge cannot proceed due to conflicts."
            echo "ğŸ“‹ Please resolve conflicts manually:"
            echo "   1. git checkout main"
            echo "   2. git pull origin main" 
            echo "   3. git merge dev"
            echo "   4. Resolve conflicts and commit"
            echo "   5. git push origin main"
            git merge --abort
            exit 1
          fi
          git reset --hard HEAD  # Clean up test merge
          
          echo "âœ… No conflicts detected. Proceeding with merge..."
          echo "ğŸ”„ Merging dev into main..."
          
          # Debug: Show what dev_commit input was received
          echo "ğŸ” DEBUG: dev_commit input = '${{ github.event.inputs.dev_commit }}'"
          echo "ğŸ” DEBUG: Input length = ${#'${{ github.event.inputs.dev_commit }}'}"
          
          # Determine which commit to merge
          if [ -n "${{ github.event.inputs.dev_commit }}" ]; then
            MERGE_COMMIT=$(echo "${{ github.event.inputs.dev_commit }}" | xargs)
            echo "ğŸ“Œ SPECIFIC COMMIT MODE: Merging exact commit: $MERGE_COMMIT"
            echo "âš ï¸  This includes content + workflow files from that point in time"
          else
            MERGE_COMMIT="origin/dev"
            echo "ğŸ“Š LATEST DEV MODE: Merging latest dev commit"
            echo "âœ… This includes newest content + newest workflow files"
          fi
          
          echo "ğŸ¯ Final merge target: $MERGE_COMMIT"
          
          git merge "$MERGE_COMMIT" --no-ff -m "ğŸš€ Release ${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}

          Merged dev branch to main for publication.
          
          Release Type: ${{ github.event.inputs.release_type }}
          Published by: ${{ github.actor }}
          Dev Commit: ${MERGE_COMMIT}
          Specific Commit: ${{ github.event.inputs.dev_commit || 'latest dev' }}
          Description: ${{ github.event.inputs.description }}"
          
          echo "âœ… Merge completed successfully!"

      - name: ğŸš€ Push merge to main
        run: |
          echo "ğŸš€ Pushing merge to main branch..."
          git push origin main
          
          echo "âœ… Main branch updated successfully!"
          echo "ğŸ“‹ Next step: Monitor production build, then create release tag"

  monitor-build:
    name: 'â³ Monitor Production Build'
    runs-on: ubuntu-latest
    timeout-minutes: 180
    needs: merge-to-main
    if: github.event.inputs.confirm == 'PUBLISH'
    
    steps:
      - name: â³ Wait for Production Build (Commit Status Monitoring)
        run: |
          echo "â³ Waiting for production build to complete (max 3 hours)..."
          echo "ğŸ” Monitoring commit status checks in real-time..."
          
          # Get the latest commit SHA from main branch
          COMMIT_SHA=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/commits/main" \
            | jq -r '.sha')
          
          echo "ğŸ“Œ Monitoring commit: $COMMIT_SHA"
          echo "ğŸ¯ Required status checks: ci/quarto-build-ubuntu-latest-html, ci/quarto-build-ubuntu-latest-pdf"
          
          # Check if quarto-build workflow is running
          echo "ğŸ” Checking for quarto-build workflow runs..."
          WORKFLOW_RUNS=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs?head_sha=$COMMIT_SHA&per_page=10")
          
          echo "ğŸ“Š Workflow runs for this commit:"
          echo "$WORKFLOW_RUNS" | jq -r '.workflow_runs[] | "  - \(.name): \(.status) (\(.conclusion)) - \(.created_at)"' | head -5
          
          # Find quarto-build workflow runs
          QUARTO_BUILD_RUNS=$(echo "$WORKFLOW_RUNS" | jq -r '.workflow_runs[] | select(.name == "ğŸ“š Quarto Build") | .id' | head -2)
          
          if [ -n "$QUARTO_BUILD_RUNS" ]; then
            echo "ğŸ” Found quarto-build workflow runs: $QUARTO_BUILD_RUNS"
            
            # Get the latest quarto-build run
            LATEST_QUARTO_RUN=$(echo "$QUARTO_BUILD_RUNS" | head -1)
            echo "ğŸ“Š Latest quarto-build run ID: $LATEST_QUARTO_RUN"
            
            # Get workflow run details
            RUN_DETAILS=$(curl -s \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runs/$LATEST_QUARTO_RUN")
            
            RUN_STATUS=$(echo "$RUN_DETAILS" | jq -r '.status')
            RUN_CONCLUSION=$(echo "$RUN_DETAILS" | jq -r '.conclusion')
            RUN_CREATED=$(echo "$RUN_DETAILS" | jq -r '.created_at')
            
            echo "ğŸ“‹ Quarto-build status: $RUN_STATUS ($RUN_CONCLUSION) - Started: $RUN_CREATED"
            
            # Get jobs from the workflow run
            JOBS_RESPONSE=$(curl -s \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runs/$LATEST_QUARTO_RUN/jobs")
            
            echo "ğŸ“‹ Quarto-build jobs:"
            echo "$JOBS_RESPONSE" | jq -r '.jobs[] | "  - \(.name): \(.status) (\(.conclusion)) - \(.started_at)"' | head -5
          else
            echo "âš ï¸ No quarto-build workflow runs found for this commit"
            
            # Check if Controller workflow was cancelled (which would prevent quarto-build from running)
            echo "ğŸ” Checking if Controller workflow was cancelled..."
            CONTROLLER_RUNS=$(curl -s \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/actions/workflows/controller.yml/runs?head_sha=$COMMIT_SHA&per_page=5")
            
            CONTROLLER_STATUS=$(echo "$CONTROLLER_RUNS" | jq -r '.workflow_runs[0].conclusion // "null"')
            CONTROLLER_NAME=$(echo "$CONTROLLER_RUNS" | jq -r '.workflow_runs[0].name // "unknown"')
            
            if [ "$CONTROLLER_STATUS" = "cancelled" ]; then
              echo "ğŸš« Controller workflow was cancelled - quarto-build never triggered"
              echo "ğŸ“Š Controller status: $CONTROLLER_NAME ($CONTROLLER_STATUS)"
              echo "âŒ Cannot proceed with release - build was cancelled"
              echo "ğŸ”— Check workflow: https://github.com/${{ github.repository }}/commit/$COMMIT_SHA"
              exit 1
            elif [ "$CONTROLLER_STATUS" = "failure" ]; then
              echo "âŒ Controller workflow failed - quarto-build never triggered"
              echo "ğŸ“Š Controller status: $CONTROLLER_NAME ($CONTROLLER_STATUS)"
              echo "âŒ Cannot proceed with release - controller failed"
              echo "ğŸ”— Check workflow: https://github.com/${{ github.repository }}/commit/$COMMIT_SHA"
              exit 1
            else
              echo "ğŸ“Š Controller status: $CONTROLLER_NAME ($CONTROLLER_STATUS)"
              echo "â³ Will continue monitoring for quarto-build to start..."
            fi
          fi
          
          sleep 30  # Give the build a moment to start
          
          # Wait for all required status checks to complete
          for i in $(seq 1 ${{ github.event.inputs.commit_status_timeout }}); do  # ${{ github.event.inputs.commit_status_timeout }} attempts Ã— 60 seconds = 3 hours max
            echo "ğŸ” Checking commit status (attempt $i/${{ github.event.inputs.commit_status_timeout }})..."
            
            # Get commit status
            STATUS_RESPONSE=$(curl -s \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/commits/$COMMIT_SHA/status")
            
            # Check overall status
            OVERALL_STATE=$(echo "$STATUS_RESPONSE" | jq -r '.state')
            TOTAL_COUNT=$(echo "$STATUS_RESPONSE" | jq -r '.total_count')
            
            echo "ğŸ“Š Overall status: $OVERALL_STATE ($TOTAL_COUNT checks)"
            
            # Get individual status checks
            STATUSES=$(echo "$STATUS_RESPONSE" | jq -r '.statuses')
            
            # Show ALL available status checks for debugging
            echo "ğŸ” All available status checks:"
            echo "$STATUSES" | jq -r '.[] | "  - \(.context): \(.state) - \(.description)"' | head -10
            
            # Early exit if no status checks exist after reasonable time
            if [ "$TOTAL_COUNT" -eq 0 ] && [ $i -gt 10 ]; then
              echo "âš ï¸ No status checks found after $((i * ${{ github.event.inputs.commit_status_interval }} / 60)) minutes"
              echo "ğŸ” Re-checking if quarto-build workflow was triggered..."
              
              # Re-check for quarto-build workflow
              QUARTO_CHECK=$(curl -s \
                -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/${{ github.repository }}/actions/workflows/quarto-build.yml/runs?head_sha=$COMMIT_SHA&per_page=1")
              
              QUARTO_COUNT=$(echo "$QUARTO_CHECK" | jq -r '.total_count')
              
              if [ "$QUARTO_COUNT" -eq 0 ]; then
                echo "âŒ Quarto-build workflow still not triggered after $((i * ${{ github.event.inputs.commit_status_interval }} / 60)) minutes"
                echo "ğŸ” This suggests a workflow configuration issue"
                echo "ğŸ”— Check workflows: https://github.com/${{ github.repository }}/actions"
                exit 1
              fi
            fi
            
            # Check for our specific quarto-build status checks
            HTML_STATUS=$(echo "$STATUSES" | jq -r '.[] | select(.context == "ci/quarto-build-ubuntu-latest-html") | .state' | head -1)
            PDF_STATUS=$(echo "$STATUSES" | jq -r '.[] | select(.context == "ci/quarto-build-ubuntu-latest-pdf") | .state' | head -1)
            
            echo "ğŸ“‹ Expected build status checks:"
            echo "  - HTML Build (Linux): ${HTML_STATUS:-pending}"
            echo "  - PDF Build (Linux): ${PDF_STATUS:-pending}"
            
            # Show detailed status for quarto-build checks specifically
            echo "ğŸ“‹ Quarto build status checks:"
            echo "$STATUSES" | jq -r '.[] | select(.context | startswith("ci/quarto-build")) | "  - \(.context): \(.state) - \(.description)"' | head -4
            
            # Check if all required builds are successful
            if [ "$HTML_STATUS" = "success" ] && [ "$PDF_STATUS" = "success" ]; then
              echo "âœ… All production builds completed successfully!"
              echo "ğŸ“Š HTML Build: âœ… Success"
              echo "ğŸ“Š PDF Build: âœ… Success"
              echo "ğŸ”— View commit status: https://github.com/${{ github.repository }}/commit/$COMMIT_SHA"
              break
            fi
            
            # Check for any failures, cancellations, or errors
            if [ "$HTML_STATUS" = "failure" ] || [ "$PDF_STATUS" = "failure" ]; then
              echo "âŒ Production build failed!"
              echo "ğŸ“Š HTML Build: ${HTML_STATUS:-pending}"
              echo "ğŸ“Š PDF Build: ${PDF_STATUS:-pending}"
              echo "ğŸ”— View commit status: https://github.com/${{ github.repository }}/commit/$COMMIT_SHA"
              exit 1
            elif [ "$HTML_STATUS" = "cancelled" ] || [ "$PDF_STATUS" = "cancelled" ]; then
              echo "ğŸš« Production build was cancelled!"
              echo "ğŸ“Š HTML Build: ${HTML_STATUS:-pending}"
              echo "ğŸ“Š PDF Build: ${PDF_STATUS:-pending}"
              echo "ğŸ”— View commit status: https://github.com/${{ github.repository }}/commit/$COMMIT_SHA"
              exit 1
            elif [ "$HTML_STATUS" = "error" ] || [ "$PDF_STATUS" = "error" ]; then
              echo "âš ï¸ Production build encountered an error!"
              echo "ğŸ“Š HTML Build: ${HTML_STATUS:-pending}"
              echo "ğŸ“Š PDF Build: ${PDF_STATUS:-pending}"
              echo "ğŸ”— View commit status: https://github.com/${{ github.repository }}/commit/$COMMIT_SHA"
              exit 1
            fi
            
            # Show current status with time elapsed
            ELAPSED_MINUTES=$((i * ${{ github.event.inputs.commit_status_interval }} / 60))
            ELAPSED_HOURS=$((ELAPSED_MINUTES / 60))
            REMAINING_MINUTES=$((ELAPSED_MINUTES % 60))
            
            if [ $ELAPSED_HOURS -gt 0 ]; then
              TIME_DISPLAY="${ELAPSED_HOURS}h ${REMAINING_MINUTES}m"
            else
              TIME_DISPLAY="${ELAPSED_MINUTES}m"
            fi
            
            echo "â³ Build still in progress... (attempt $i/${{ github.event.inputs.commit_status_timeout }}, ~${TIME_DISPLAY} elapsed)"
            
            # Show build progress indicators with heartbeat-style updates
            if [ $i -eq 1 ]; then
              echo "ğŸ“‹ Expected build timeline (Linux only):"
              echo "  0-10m: Initial setup and quality checks"
              echo "  10-25m: Quarto build (HTML + PDF generation)"
              echo "  25-35m: PDF compression and processing"
              echo "  35-45m: GitHub Pages deployment"
              echo "  45-60m: Asset copying and finalization"
            fi
            
            # Show heartbeat-style progress every 4th attempt (every 2 minutes)
            if [ $((i % 4)) -eq 0 ]; then
              echo "ğŸ’“ Build heartbeat: $(date)"
              echo "ğŸ“Š Current build status: Monitoring commit checks"
              echo "â° Time elapsed: ${TIME_DISPLAY}"
              echo "ğŸ“ˆ HTML: ${HTML_STATUS:-pending} | PDF: ${PDF_STATUS:-pending}"
              echo "ğŸ”— Monitor: https://github.com/${{ github.repository }}/commit/$COMMIT_SHA"
              
              # Show quarto-build logs if available
              if [ -n "$LATEST_QUARTO_RUN" ]; then
                echo "ğŸ“‹ Latest quarto-build logs:"
                
                # Get the latest job from the workflow run
                LATEST_JOB=$(curl -s \
                  -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  -H "Accept: application/vnd.github.v3+json" \
                  "https://api.github.com/repos/${{ github.repository }}/actions/runs/$LATEST_QUARTO_RUN/jobs" \
                  | jq -r '.jobs[0].id')
                
                if [ "$LATEST_JOB" != "null" ] && [ -n "$LATEST_JOB" ]; then
                  echo "ğŸ” Fetching logs from job: $LATEST_JOB"
                  
                  # Get the latest step from the job
                  LATEST_STEP=$(curl -s \
                    -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                    -H "Accept: application/vnd.github.v3+json" \
                    "https://api.github.com/repos/${{ github.repository }}/actions/runs/$LATEST_QUARTO_RUN/jobs/$LATEST_JOB/logs" \
                    | grep -o 'step_[0-9]*' | tail -1)
                  
                  if [ -n "$LATEST_STEP" ]; then
                    echo "ğŸ“ Latest step logs ($LATEST_STEP):"
                    curl -s \
                      -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                      -H "Accept: application/vnd.github.v3+json" \
                      "https://api.github.com/repos/${{ github.repository }}/actions/runs/$LATEST_QUARTO_RUN/jobs/$LATEST_JOB/logs" \
                      | grep -A 10 "$LATEST_STEP" | tail -5
                  fi
                fi
              fi
              
              # Update GitHub status with progress
              curl -s -X POST \
                -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/${{ github.repository }}/statuses/$COMMIT_SHA" \
                -d "{
                  \"state\": \"pending\",
                  \"description\": \"Publishing: Build ${TIME_DISPLAY} (HTML: ${HTML_STATUS:-pending}, PDF: ${PDF_STATUS:-pending})\",
                  \"context\": \"ci/publish-live-monitor\"
                }" >/dev/null
              echo "---"
            fi
            
            sleep ${{ github.event.inputs.commit_status_interval }}
          done
          
          # If we get here, check final status after timeout
          if [ "$HTML_STATUS" != "success" ] || [ "$PDF_STATUS" != "success" ]; then
            echo "â° Build monitoring timed out after 3 hours"
            echo "ğŸ“Š Final status: HTML=$HTML_STATUS, PDF=$PDF_STATUS"
            
            # Provide specific guidance based on final state
            if [ "$HTML_STATUS" = "cancelled" ] || [ "$PDF_STATUS" = "cancelled" ]; then
              echo "ğŸš« Build was cancelled - no release will be created"
            elif [ "$HTML_STATUS" = "failure" ] || [ "$PDF_STATUS" = "failure" ]; then
              echo "âŒ Build failed - check logs for errors"
            elif [ "$HTML_STATUS" = "error" ] || [ "$PDF_STATUS" = "error" ]; then
              echo "âš ï¸ Build encountered an error - check GitHub Actions logs"
            else
              echo "â³ Build may still be running - check manually"
            fi
            
            echo "ğŸ”— Check status: https://github.com/${{ github.repository }}/commit/$COMMIT_SHA"
            exit 1
          fi

  create-tag:
    name: 'ğŸ·ï¸ Create Release Tag'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [validate-inputs, monitor-build]
    if: github.event.inputs.confirm == 'PUBLISH'
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ”„ Sync with latest main
        run: |
          echo "ğŸ”„ Configuring git..."
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          echo "ğŸ”„ Switching to main and pulling latest changes..."
          git checkout main
          git pull origin main
          
          echo "âœ… Synced with latest main branch"

      - name: ğŸ·ï¸ Create Release Tag
        run: |
          echo "ğŸ·ï¸ Creating release tag ${{ needs.validate-inputs.outputs.new_version }}..."
          echo "âœ… Build completed successfully - safe to create release tag"
          
          # Check if tag already exists locally
          if git tag -l "${{ needs.validate-inputs.outputs.new_version }}" | grep -q "${{ needs.validate-inputs.outputs.new_version }}"; then
            echo "âš ï¸ Tag ${{ needs.validate-inputs.outputs.new_version }} already exists locally"
            echo "ğŸ”„ Removing existing tag to recreate it..."
            git tag -d ${{ needs.validate-inputs.outputs.new_version }}
          fi
          
          # Check if tag exists on remote
          if git ls-remote --tags origin | grep -q "refs/tags/${{ needs.validate-inputs.outputs.new_version }}$"; then
            echo "âš ï¸ Tag ${{ needs.validate-inputs.outputs.new_version }} already exists on remote"
            echo "ğŸ”„ Removing remote tag to recreate it..."
            git push origin --delete ${{ needs.validate-inputs.outputs.new_version }}
          fi
          
          # Create the tag on the latest main commit
          git tag -a ${{ needs.validate-inputs.outputs.new_version }} -m "Release ${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}"
          echo "âœ… Tag created successfully!"

      - name: ğŸš€ Push tag for release tracking
        run: |
          echo "ğŸš€ Pushing release tag for version tracking..."
          git push origin ${{ needs.validate-inputs.outputs.new_version }}
          
          echo "âœ… Release tag pushed successfully!"
          echo "ğŸ·ï¸ Tag: ${{ needs.validate-inputs.outputs.new_version }}"
          echo "ğŸ“‹ Description: ${{ github.event.inputs.description }}"
          echo "ğŸ“Š This tag marks a successful build and tested release"

  download-pdf:
    name: 'ğŸ“„ Download PDF'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: create-tag
    if: github.event.inputs.confirm == 'PUBLISH'
    
    steps:
      - name: ğŸ“„ Download Built PDF from Artifacts
        run: |
          echo "ğŸ“„ Downloading built PDF from artifacts..."
          echo "ğŸ” Looking for Linux PDF build artifacts..."
          echo "ğŸ“‹ Expected artifact: build-ubuntu-latest-pdf"
          echo "ğŸ“‹ Expected file: build/pdf/Machine-Learning-Systems.pdf"
          
          # Download the latest successful build artifacts
          LATEST_BUILD=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs?branch=main&status=success&per_page=1" \
            | jq -r '.workflow_runs[0].id')
          
          if [ "$LATEST_BUILD" = "null" ] || [ -z "$LATEST_BUILD" ]; then
            echo "âŒ No successful builds found!"
            exit 1
          fi
          
          echo "ğŸ“Š Found latest successful build: $LATEST_BUILD"
          
          # Download artifacts from the latest build
          ARTIFACTS_RESPONSE=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/$LATEST_BUILD/artifacts")
          
          echo "ğŸ“Š Available artifacts:"
          echo "$ARTIFACTS_RESPONSE" | jq -r '.artifacts[] | "  - \(.name) (ID: \(.id))"'
          
          # Find the Linux PDF artifact specifically
          LINUX_PDF_ARTIFACT=$(echo "$ARTIFACTS_RESPONSE" | jq -r '.artifacts[] | select(.name == "build-ubuntu-latest-pdf") | .id' | head -1)
          
          if [ "$LINUX_PDF_ARTIFACT" = "null" ] || [ -z "$LINUX_PDF_ARTIFACT" ]; then
            echo "âŒ Linux PDF artifact 'build-ubuntu-latest-pdf' not found!"
            echo "ğŸ” Looking for any PDF artifact as fallback..."
            
            # Fallback: look for any PDF artifact
            PDF_ARTIFACT=$(echo "$ARTIFACTS_RESPONSE" | jq -r '.artifacts[] | select(.name | contains("pdf")) | .id' | head -1)
            
            if [ "$PDF_ARTIFACT" = "null" ] || [ -z "$PDF_ARTIFACT" ]; then
              echo "âŒ No PDF artifact found in build $LATEST_BUILD"
              exit 1
            fi
            
            echo "âš ï¸ Using fallback PDF artifact: $PDF_ARTIFACT"
            LINUX_PDF_ARTIFACT=$PDF_ARTIFACT
          else
            echo "âœ… Found Linux PDF artifact: build-ubuntu-latest-pdf (ID: $LINUX_PDF_ARTIFACT)"
          fi
          
          # Download the artifact
          echo "ğŸ“¥ Downloading PDF artifact..."
          curl -L \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/$LATEST_BUILD/artifacts/$LINUX_PDF_ARTIFACT/zip" \
            -o pdf-artifact.zip
          
          # Extract the PDF
          echo "ğŸ“¦ Extracting PDF artifact..."
          unzip -q pdf-artifact.zip
          
          # Find the PDF file in the expected location
          PDF_FILE=$(find . -name "Machine-Learning-Systems.pdf" -type f | head -1)
          
          if [ -z "$PDF_FILE" ] || [ ! -f "$PDF_FILE" ]; then
            echo "âŒ PDF file not found in extracted artifacts!"
            echo "ğŸ“Š Extracted files and directories:"
            find . -type f -o -type d | head -20
            echo "ğŸ“Š Looking in build/pdf directory..."
            if [ -d "build/pdf" ]; then
              ls -la build/pdf/
            fi
            exit 1
          fi
          
          echo "âœ… PDF found: $PDF_FILE"
          echo "ğŸ“Š PDF size: $(du -h "$PDF_FILE" | cut -f1)"
          
          # Copy to a standard location
          cp "$PDF_FILE" "Machine-Learning-Systems.pdf"
          echo "âœ… PDF ready for release: Machine-Learning-Systems.pdf"
          
          # Upload PDF as artifact for next jobs
          echo "ğŸ“¤ Uploading PDF as artifact..."
          echo "Machine-Learning-Systems.pdf" > pdf-files.txt

      - name: ğŸ“¤ Upload PDF Artifact
        uses: actions/upload-artifact@v4
        with:
          name: pdf-artifact
          path: Machine-Learning-Systems.pdf
          retention-days: 1

  generate-release-notes:
    name: 'ğŸ“ Generate Release Notes'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [validate-inputs, download-pdf]
    if: github.event.inputs.confirm == 'PUBLISH'
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ“„ Download PDF from previous job
        uses: actions/download-artifact@v4
        with:
          name: pdf-artifact
          path: ./

      - name: ğŸ“ Generate Release Notes
        run: |
          echo "ğŸ“ Generating release notes..."
          echo "ğŸ¤– AI Enhancement Mode: ${{ github.event.inputs.ai_generated_notes }}"
          if [ "${{ github.event.inputs.ai_generated_notes }}" = "yes" ]; then
            echo "   âœ… Will use AI to enhance git log (if AI system is available)"
          else
            echo "   ğŸ“‹ Will use git log only (clean, reliable format)"
          fi
          echo ""
          
          # Generate git log between versions
          PREVIOUS_VERSION="${{ needs.validate-inputs.outputs.previous_version }}"
          CURRENT_VERSION="${{ needs.validate-inputs.outputs.new_version }}"
          
          echo "ğŸ“Š Generating git log from $PREVIOUS_VERSION to current commit..."
          
          # Create detailed git log
          echo "# Release Notes for $CURRENT_VERSION" > git_changes.md
          echo "" >> git_changes.md
          echo "## Changes since $PREVIOUS_VERSION" >> git_changes.md
          echo "" >> git_changes.md
          
          # Get commit log with details
          if git rev-parse "$PREVIOUS_VERSION" >/dev/null 2>&1; then
            echo "âœ… Previous version tag $PREVIOUS_VERSION found"
            
            # Summary format for AI processing
            git log --oneline ${PREVIOUS_VERSION}..HEAD > git_log_summary.txt
            
            # Detailed format for inclusion in release
            echo "### Commit Summary:" >> git_changes.md
            git log --oneline ${PREVIOUS_VERSION}..HEAD >> git_changes.md
            echo "" >> git_changes.md
            
            echo "### Detailed Changes:" >> git_changes.md
            git log --pretty=format:"- **%s** (%h) by %an%n  %b" ${PREVIOUS_VERSION}..HEAD >> git_changes.md
            
            echo "ğŸ“Š Found $(git rev-list --count ${PREVIOUS_VERSION}..HEAD) commits since $PREVIOUS_VERSION"
          else
            echo "âš ï¸ Previous version tag $PREVIOUS_VERSION not found, using all commits"
            git log --oneline -20 > git_log_summary.txt
            echo "### Recent Commits:" >> git_changes.md
            git log --oneline -20 >> git_changes.md
          fi
          
          echo "âœ… Git log generated and saved to files"
          
          if [ "${{ github.event.inputs.ai_generated_notes }}" = "yes" ]; then
            echo ""
            echo "ğŸ¤– AI Enhancement Mode Selected - using pre-tested Ollama system..."
            
            # Check if Ollama is already running from pre-flight
            if ollama list >/dev/null 2>&1; then
              echo "âœ… Ollama service is already running from pre-flight checks"
              
              # Get the working model from pre-flight
              if [ -f "/tmp/ollama_model.txt" ]; then
                MODEL=$(cat /tmp/ollama_model.txt)
                echo "ğŸ¤– Using pre-tested model: $MODEL"
              else
                echo "âš ï¸ Model info not found, using default"
                MODEL="${{ env.DEFAULT_AI_MODEL }}"
              fi
            else
              echo "âš ï¸ Ollama not running, AI generation was likely skipped in pre-flight"
              AI_GENERATION_FAILED=true
            fi
            
            # Generate AI-enhanced release notes using git log
            if [ "$AI_GENERATION_FAILED" != "true" ]; then
              echo "ğŸ“ Generating AI-enhanced release notes from git log..."
              
              # Create AI prompt with git log content
              {
                echo "Please create professional release notes for version ${{ needs.validate-inputs.outputs.new_version }} based on the following git commits."
                echo ""
                echo "Release Description: ${{ github.event.inputs.description }}"
                echo "Release Type: ${{ github.event.inputs.release_type }}"
                echo ""
                echo "Git Commits:"
                cat git_log_summary.txt
                echo ""
                echo "Please format as:"
                echo "- Brief overview of this release"
                echo "- Key changes organized by category (Features, Bug Fixes, Improvements, etc.)"
                echo "- Keep it professional but accessible"
                echo "- Include any breaking changes if evident"
              } > ai_prompt.txt
              
              # Generate AI release notes
              if ollama run $MODEL < ai_prompt.txt > ai_release_notes.md 2>/dev/null; then
                echo "âœ… AI release notes generated successfully"
                
                # Combine AI notes with detailed git log
                {
                  echo "# Release ${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}"
                  echo ""
                  cat ai_release_notes.md
                  echo ""
                  echo "---"
                  echo ""
                  echo "## Full Change Log"
                  echo ""
                  cat git_changes.md
                } > "release_notes_${{ needs.validate-inputs.outputs.new_version }}.md"
              else
                echo "âš ï¸ AI generation failed, using git log only"
                cp git_changes.md "release_notes_${{ needs.validate-inputs.outputs.new_version }}.md"
              fi
              
            fi
          else
            echo ""
            echo "ğŸ“‹ Git Log Only Mode - creating clean release notes from git history"
            
            # Create release notes from git log only
            {
              echo "# Release ${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}"
              echo ""
              echo "## Overview"
              echo "This ${{ github.event.inputs.release_type }} release includes the following changes:"
              echo ""
              cat git_changes.md
            } > "release_notes_${{ needs.validate-inputs.outputs.new_version }}.md"
          fi
          
          # Show final release notes
          if [ -f "release_notes_${{ needs.validate-inputs.outputs.new_version }}.md" ]; then
            echo "âœ… Release notes generated successfully"
            echo "ğŸ“„ Release notes file details:"
            ls -la "release_notes_${{ needs.validate-inputs.outputs.new_version }}.md"
            echo "ğŸ“ Release notes content (first 50 lines):"
            head -50 "release_notes_${{ needs.validate-inputs.outputs.new_version }}.md"
          else
            echo "âŒ Failed to generate release notes"
            exit 1
          fi

      - name: ğŸ“¤ Upload Release Notes Artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-notes
          path: release_notes_${{ needs.validate-inputs.outputs.new_version }}.md
          retention-days: 1

      - name: ğŸ“¤ Upload Git Log Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: git-changes
          path: |
            git_changes.md
            git_log_summary.txt
            ai_release_notes.md
          retention-days: 7

  create-release:
    name: 'ğŸ“¦ Create GitHub Release'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [validate-inputs, generate-release-notes]
    if: github.event.inputs.confirm == 'PUBLISH'
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ“„ Download PDF from previous job
        uses: actions/download-artifact@v4
        with:
          name: pdf-artifact
          path: ./

      - name: ğŸ“ Download release notes
        uses: actions/download-artifact@v4
        with:
          name: release-notes
          path: ./

      - name: ğŸ“¦ Create GitHub Release with PDF
        run: |
          echo "ğŸ“¦ Creating GitHub Release ${{ needs.validate-inputs.outputs.new_version }}..."
          echo "ğŸ“‹ Release details:"
          echo "  - Tag: ${{ needs.validate-inputs.outputs.new_version }}"
          echo "  - Name: ${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}"
          echo "  - Repository: ${{ github.repository }}"
          
          # Use the AI-generated release notes
          RELEASE_NOTES_FILE="release_notes_${{ needs.validate-inputs.outputs.new_version }}.md"
          
          if [ -f "$RELEASE_NOTES_FILE" ]; then
            echo "ğŸ“„ Using AI-generated release notes:"
            cat "$RELEASE_NOTES_FILE"
          else
            echo "âŒ Release notes file not found!"
            exit 1
          fi
          
          # Create the release as a DRAFT for manual editing
          echo "ğŸš€ Creating GitHub release as DRAFT..."
          RELEASE_RESPONSE=$(curl -s \
            -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases" \
            -d "{
              \"tag_name\": \"${{ needs.validate-inputs.outputs.new_version }}\",
              \"name\": \"${{ needs.validate-inputs.outputs.new_version }}: ${{ github.event.inputs.description }}\",
              \"body\": \"$(cat $RELEASE_NOTES_FILE | sed 's/"/\\"/g' | tr '\n' '\\n')\",
              \"draft\": true,
              \"prerelease\": false
            }")
          
          echo "ğŸ“Š API Response:"
          echo "$RELEASE_RESPONSE" | jq '.'
          
          RELEASE_ID=$(echo "$RELEASE_RESPONSE" | jq -r '.id')
          RELEASE_URL=$(echo "$RELEASE_RESPONSE" | jq -r '.html_url')
          
          if [ "$RELEASE_ID" != "null" ] && [ -n "$RELEASE_ID" ]; then
            echo "âœ… Draft release created successfully!"
            echo "ğŸ“Š Release ID: $RELEASE_ID"
            echo "ğŸ”— Release URL: $RELEASE_URL"
            echo "ğŸ“ Next step: Edit release notes manually and publish"
            echo "release_id=$RELEASE_ID" >> $GITHUB_ENV
            echo "release_url=$RELEASE_URL" >> $GITHUB_ENV
          else
            echo "âŒ Failed to create release!"
            echo "ğŸ“Š Error details:"
            echo "$RELEASE_RESPONSE" | jq -r '.message // "Unknown error"'
            echo "$RELEASE_RESPONSE" | jq -r '.errors[]?.message // empty'
            exit 1
          fi

      - name: ğŸ“„ Upload PDF to Release Assets
        run: |
          echo "ğŸ“„ Uploading PDF to release assets..."
          
          if [ ! -f "Machine-Learning-Systems.pdf" ]; then
            echo "âŒ PDF file not found!"
            exit 1
          fi
          
          echo "ğŸ“Š PDF size: $(du -h Machine-Learning-Systems.pdf | cut -f1)"
          
          # Upload the PDF to the release
          UPLOAD_RESPONSE=$(curl -s \
            -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Content-Type: application/pdf" \
            --data-binary @Machine-Learning-Systems.pdf \
            "https://uploads.github.com/repos/${{ github.repository }}/releases/${{ env.release_id }}/assets?name=Machine-Learning-Systems.pdf")
          
          echo "ğŸ“Š Upload Response:"
          echo "$UPLOAD_RESPONSE" | jq '.'
          
          UPLOAD_ID=$(echo "$UPLOAD_RESPONSE" | jq -r '.id')
          
          if [ "$UPLOAD_ID" != "null" ] && [ -n "$UPLOAD_ID" ]; then
            echo "âœ… PDF uploaded successfully to release!"
            echo "ğŸ“Š Asset ID: $UPLOAD_ID"
            echo "ğŸ”— Download URL: https://github.com/${{ github.repository }}/releases/download/${{ needs.validate-inputs.outputs.new_version }}/Machine-Learning-Systems.pdf"
          else
            echo "âŒ Failed to upload PDF to release!"
            echo "ğŸ“Š Error details:"
            echo "$UPLOAD_RESPONSE" | jq -r '.message // "Unknown error"'
            exit 1
          fi

  summary:
    name: 'ğŸ“‹ Publication Summary'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [validate-inputs, create-release]
    if: github.event.inputs.confirm == 'PUBLISH'
    
    steps:
      - name: ğŸ“‹ Publication Summary
        run: |
          echo "## ğŸ“š Textbook Publication Complete! ğŸ‰" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version Released:** ${{ needs.validate-inputs.outputs.new_version }} (${{ needs.validate-inputs.outputs.release_type }})" >> $GITHUB_STEP_SUMMARY
          echo "**Previous Version:** ${{ needs.validate-inputs.outputs.previous_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Content Published:** ${{ github.event.inputs.description }}" >> $GITHUB_STEP_SUMMARY
          echo "**Published by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Source Commit:** ${{ github.event.inputs.dev_commit || 'latest' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Publication Time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "**Release ID:** ${{ env.release_id || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Release URL:** ${{ env.release_url || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ” Debug Information:" >> $GITHUB_STEP_SUMMARY
          echo "- **Workflow Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Run Attempt:** ${{ github.run_attempt }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit SHA:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AI Generated Notes:** ${{ github.event.inputs.ai_generated_notes }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“ Changes:" >> $GITHUB_STEP_SUMMARY
          echo "${{ github.event.inputs.description }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ”„ What happened:" >> $GITHUB_STEP_SUMMARY
          echo "1. âœ… Verified dev branch tests passed" >> $GITHUB_STEP_SUMMARY
          echo "2. âœ… Calculated new version number" >> $GITHUB_STEP_SUMMARY
          echo "3. âœ… Merged dev â†’ main branch" >> $GITHUB_STEP_SUMMARY
          echo "4. âœ… Pushed to main (triggered production build)" >> $GITHUB_STEP_SUMMARY
          echo "5. âœ… Waited for build completion (up to 3 hours)" >> $GITHUB_STEP_SUMMARY
          echo "6. âœ… Created release tag ${{ needs.validate-inputs.outputs.new_version }} (after successful build)" >> $GITHUB_STEP_SUMMARY
          echo "7. âœ… Created GitHub Release (DRAFT - edit manually)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ—ï¸ Build Process:" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“š **Controller Workflow**: Triggered by main branch push" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ”¨ **Build Jobs**: HTML + PDF generation on Linux only" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“„ **PDF Processing**: Generated, compressed with Ghostscript, stored in build/pdf/" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“¦ **Artifacts**: build-ubuntu-latest-pdf contains Machine-Learning-Systems.pdf" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸŒ **Deployment**: GitHub Pages with PDF download available" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸŒ Access Your Published Textbook:" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“– [Interactive Web Textbook](https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }})" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“¦ [Version Release Notes](https://github.com/${{ github.repository }}/releases/tag/${{ needs.validate-inputs.outputs.new_version }})" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“„ [Download Complete PDF](https://github.com/${{ github.repository }}/releases/download/${{ needs.validate-inputs.outputs.new_version }}/Machine-Learning-Systems.pdf)" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“„ [Direct PDF Access](https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/assets/Machine-Learning-Systems.pdf)" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“ [Share with Students](https://mlsysbook.ai)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“Š Build Status:" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ® **Controller Workflow**: Should be running/completed" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“š **Quarto Build**: HTML + PDF generation" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“„ **PDF Assets**: Available at `/assets/Machine-Learning-Systems.pdf`" >> $GITHUB_STEP_SUMMARY

  cleanup-on-failure:
    name: 'ğŸ§¹ Cleanup Failed Release'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [validate-inputs]
    if: always() && github.event.inputs.confirm == 'PUBLISH' && (failure() || cancelled())
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ§¹ Clean up failed release artifacts
        run: |
          echo "ğŸ§¹ Cleaning up artifacts from failed release..."
          
          # Get the version that was being released
          if [ -n "${{ needs.validate-inputs.outputs.new_version }}" ]; then
            VERSION_TAG="${{ needs.validate-inputs.outputs.new_version }}"
            echo "ğŸ¯ Cleaning up version: $VERSION_TAG"
          else
            echo "âš ï¸ No version information available, skipping cleanup"
            exit 0
          fi
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Check and remove local tag
          if git tag -l "$VERSION_TAG" | grep -q "$VERSION_TAG"; then
            echo "ğŸ—‘ï¸ Removing local tag: $VERSION_TAG"
            git tag -d "$VERSION_TAG"
          else
            echo "â„¹ï¸ Local tag $VERSION_TAG does not exist"
          fi
          
          # Check and remove remote tag if it exists
          if git ls-remote --tags origin | grep -q "refs/tags/$VERSION_TAG$"; then
            echo "ğŸ—‘ï¸ Removing remote tag: $VERSION_TAG"
            git push origin --delete "$VERSION_TAG" || echo "âš ï¸ Failed to delete remote tag (may not exist)"
          else
            echo "â„¹ï¸ Remote tag $VERSION_TAG does not exist"
          fi
          
          # Check for any draft releases and delete them
          echo "ğŸ” Checking for draft releases..."
          DRAFT_RELEASE=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases" \
            | jq -r ".[] | select(.tag_name == \"$VERSION_TAG\" and .draft == true) | .id")
          
          if [ "$DRAFT_RELEASE" != "null" ] && [ -n "$DRAFT_RELEASE" ]; then
            echo "ğŸ—‘ï¸ Deleting draft release: $DRAFT_RELEASE"
            curl -s \
              -X DELETE \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/releases/$DRAFT_RELEASE"
            echo "âœ… Draft release deleted"
          else
            echo "â„¹ï¸ No draft release found for $VERSION_TAG"
          fi
          
          echo "âœ… Cleanup completed! Repository is ready for retry."

      - name: ğŸ“Š Cleanup Summary
        run: |
          echo "## ğŸ§¹ Failed Release Cleanup Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.validate-inputs.outputs.new_version || 'Unknown' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Cleanup Time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ” Original Inputs (for debugging):" >> $GITHUB_STEP_SUMMARY
          echo "- **Description:** ${{ github.event.inputs.description }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release Type:** ${{ github.event.inputs.release_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Dev Commit:** ${{ github.event.inputs.dev_commit }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Confirmation:** ${{ github.event.inputs.confirm }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AI Generated Notes:** ${{ github.event.inputs.ai_generated_notes }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status Check Timeout:** ${{ github.event.inputs.commit_status_timeout }} attempts" >> $GITHUB_STEP_SUMMARY
          echo "- **Status Check Interval:** ${{ github.event.inputs.commit_status_interval }} seconds" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Run Attempt:** ${{ github.run_attempt }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ—‘ï¸ Cleaned Up:" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Local git tags removed" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Remote git tags removed (if they existed)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Draft GitHub releases removed (if they existed)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ”„ Ready for Retry:" >> $GITHUB_STEP_SUMMARY
          echo "You can now safely re-run the publish workflow with the same version number." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ› Troubleshooting:" >> $GITHUB_STEP_SUMMARY
          echo "If you continue to have issues, check the workflow logs for the failed step." >> $GITHUB_STEP_SUMMARY

  cleanup-on-timeout:
    name: 'â° Cleanup Timed Out Release'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [validate-inputs, monitor-build]
    if: always() && github.event.inputs.confirm == 'PUBLISH' && (needs.monitor-build.result == 'failure' || needs.monitor-build.result == 'timeout')
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ§¹ Clean up timed out release artifacts
        run: |
          echo "â° Cleaning up artifacts from timed out release..."
          
          # Get the version that was being released
          if [ -n "${{ needs.validate-inputs.outputs.new_version }}" ]; then
            VERSION_TAG="${{ needs.validate-inputs.outputs.new_version }}"
            echo "ğŸ¯ Cleaning up version: $VERSION_TAG"
          else
            echo "âš ï¸ No version information available, skipping cleanup"
            exit 0
          fi
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Check and remove local tag
          if git tag -l "$VERSION_TAG" | grep -q "$VERSION_TAG"; then
            echo "ğŸ—‘ï¸ Removing local tag: $VERSION_TAG"
            git tag -d "$VERSION_TAG"
          else
            echo "â„¹ï¸ Local tag $VERSION_TAG does not exist"
          fi
          
          # Check and remove remote tag if it exists
          if git ls-remote --tags origin | grep -q "refs/tags/$VERSION_TAG$"; then
            echo "ğŸ—‘ï¸ Removing remote tag: $VERSION_TAG"
            git push origin --delete "$VERSION_TAG" || echo "âš ï¸ Failed to delete remote tag (may not exist)"
          else
            echo "â„¹ï¸ Remote tag $VERSION_TAG does not exist"
          fi
          
          # Check for any draft releases and delete them
          echo "ğŸ” Checking for draft releases..."
          DRAFT_RELEASE=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases" \
            | jq -r ".[] | select(.tag_name == \"$VERSION_TAG\" and .draft == true) | .id")
          
          if [ "$DRAFT_RELEASE" != "null" ] && [ -n "$DRAFT_RELEASE" ]; then
            echo "ğŸ—‘ï¸ Deleting draft release: $DRAFT_RELEASE"
            curl -s \
              -X DELETE \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/releases/$DRAFT_RELEASE"
            echo "âœ… Draft release deleted"
          else
            echo "â„¹ï¸ No draft release found for $VERSION_TAG"
          fi
          
          echo "âœ… Cleanup completed! Repository is ready for retry."

      - name: ğŸ”„ Rollback Main Branch (if needed)
        run: |
          echo "ğŸ”„ Checking if main branch rollback is needed..."
          
          # Only rollback if merge succeeded but later steps failed
          if [ "${{ needs.merge-to-main.result }}" = "success" ] && [ "${{ needs.create-tag.result }}" != "success" ]; then
            echo "âš ï¸ Merge succeeded but tag creation failed - considering rollback"
            echo "ğŸ” Checking if main branch needs to be rolled back..."
            
            # Get the commit before the merge
            MERGE_COMMIT=$(git log --oneline -1 --grep="Release $VERSION_TAG" --format="%H" || echo "")
            
            if [ -n "$MERGE_COMMIT" ]; then
              PARENT_COMMIT=$(git log --format="%P" -n 1 "$MERGE_COMMIT" | cut -d' ' -f1)
              echo "ğŸ” Found merge commit: $MERGE_COMMIT"
              echo "ğŸ” Parent commit: $PARENT_COMMIT"
              
              echo "âš ï¸ To manually rollback main branch, run:"
              echo "   git checkout main"
              echo "   git reset --hard $PARENT_COMMIT"
              echo "   git push origin main --force-with-lease"
              echo ""
              echo "âš ï¸ AUTOMATED ROLLBACK DISABLED - Manual intervention required"
              echo "ğŸ›¡ï¸ This prevents accidental data loss"
            else
              echo "â„¹ï¸ No merge commit found - no rollback needed"
            fi
          else
            echo "â„¹ï¸ No rollback needed - merge did not complete successfully"
          fi

      - name: ğŸ“Š Cleanup Summary
        run: |
          echo "## ğŸ§¹ Failed Release Cleanup Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.validate-inputs.outputs.new_version || 'Unknown' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Cleanup Time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ” Original Inputs (for debugging):" >> $GITHUB_STEP_SUMMARY
          echo "- **Description:** ${{ github.event.inputs.description }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release Type:** ${{ github.event.inputs.release_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Dev Commit:** ${{ github.event.inputs.dev_commit }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Confirmation:** ${{ github.event.inputs.confirm }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AI Generated Notes:** ${{ github.event.inputs.ai_generated_notes }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status Check Timeout:** ${{ github.event.inputs.commit_status_timeout }} attempts" >> $GITHUB_STEP_SUMMARY
          echo "- **Status Check Interval:** ${{ github.event.inputs.commit_status_interval }} seconds" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Run Attempt:** ${{ github.run_attempt }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ—‘ï¸ Cleaned Up:" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Local git tags removed" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Remote git tags removed (if they existed)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Draft GitHub releases removed (if they existed)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ”„ Ready for Retry:" >> $GITHUB_STEP_SUMMARY
          echo "You can now safely re-run the publish workflow with the same version number." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ› Troubleshooting:" >> $GITHUB_STEP_SUMMARY
          echo "If you continue to have issues, check the workflow logs for the failed step." >> $GITHUB_STEP_SUMMARY

  fail-validation:
    name: 'âŒ Validation Failed'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event.inputs.confirm != 'PUBLISH'
    
    steps:
      - name: âŒ Invalid confirmation
        run: |
          echo "## âŒ Publication Validation Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Reason:** Invalid confirmation" >> $GITHUB_STEP_SUMMARY
          echo "**Expected:** PUBLISH" >> $GITHUB_STEP_SUMMARY
          echo "**Received:** ${{ github.event.inputs.confirm }}" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ” Debug Information:" >> $GITHUB_STEP_SUMMARY
          echo "- **Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Description:** ${{ github.event.inputs.description }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release Type:** ${{ github.event.inputs.release_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Dev Commit:** ${{ github.event.inputs.dev_commit }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AI Generated Notes:** ${{ github.event.inputs.ai_generated_notes }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "âŒ Publication cancelled - invalid confirmation"
          echo "ğŸ”’ You must type exactly 'PUBLISH' to confirm"
          echo "ğŸ“ You entered: '${{ github.event.inputs.confirm }}'"
          echo "ğŸ‘¤ Triggered by: ${{ github.actor }}"
          echo "ğŸŒ Branch: ${{ github.ref_name }}"
          echo "ğŸ”„ Run ID: ${{ github.run_id }}"
          exit 1 