name: 'ğŸ“š Quarto Build (Baremetal)'

# Set retention period to 7 days
env:
  GITHUB_ACTIONS_RETENTION_DAYS: 7

# Cancel duplicate builds for same target+ref combination
concurrency:
  group: quarto-build-baremetal-${{ inputs.target }}-${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: true

# This workflow builds a Quarto project and uploads artifacts
# It handles both Windows and Linux environments with extensive caching for better performance
# Note: This workflow does NOT deploy - all deployment is handled by publish-live workflow
on:
  workflow_dispatch:
    inputs:
      environment:
        required: false
        type: string
        default: 'development'
        description: 'Build environment'
      os:
        required: false
        type: choice
        default: 'ubuntu-latest'
        description: 'Operating system to run on'
        options:
          - ubuntu-latest
          - windows-latest
      quarto-version:
        required: false
        type: string
        default: '1.7.31'
        description: 'Version of Quarto to use'
      r-version:
        required: false
        type: string
        default: '4.3.2'
        description: 'Version of R to use'
      target:
        required: false
        type: choice
        default: 'dev'
        description: 'Target branch (dev/main) - determines build behavior'
        options:
          - dev
          - main
      format:
        required: false
        type: choice
        default: 'html'
        description: 'Format to build'
        options:
          - html
          - pdf
          - epub
          - all
      quarto-log-level:
        required: false
        type: choice
        default: 'INFO'
        description: 'Quarto log level'
        options:
          - INFO
          - DEBUG
      artifact_name:
        required: false
        type: string
        default: ''
        description: 'Explicit artifact name (if empty, uses build-{os}-{format} pattern)'
  workflow_call:
    inputs:
      # Matrix configuration inputs - determines what gets built
      build_linux:
        required: false
        type: boolean
        default: true
        description: 'Build on Linux'
      build_windows:
        required: false
        type: boolean
        default: false
        description: 'Build on Windows'
      build_html:
        required: false
        type: boolean
        default: true
        description: 'Build HTML format'
      build_pdf:
        required: false
        type: boolean
        default: false
        description: 'Build PDF format'
      
      # Build configuration
      target:
        required: false
        type: string
        default: 'dev'
        description: 'Target branch (dev/main) - determines build behavior'
      environment:
        required: false
        type: string
        default: 'development'
        description: 'Build environment'
      quarto-version:
        required: false
        type: string
        default: '1.7.31'
        description: 'Version of Quarto to use'
      r-version:
        required: false
        type: string
        default: '4.3.2'
        description: 'Version of R to use'
      
      # Legacy inputs for backward compatibility
      os:
        required: false
        type: string
        default: ''
        description: 'LEGACY: Operating system (use build_linux/build_windows instead)'
      format:
        required: false
        type: string
        default: ''
        description: 'LEGACY: Format to build (use build_html/build_pdf instead)'
      artifact_name:
        required: false
        type: string
        default: ''
        description: 'LEGACY: Explicit artifact name'
      deploy:
        required: false
        type: boolean
        default: false
        description: 'LEGACY: Whether to deploy artifacts'
    outputs:
      build_success:
        description: "Whether all builds completed successfully"
        value: ${{ jobs.collect-results.outputs.build_success }}
      linux_html_artifact:
        description: "Linux HTML artifact name"
        value: ${{ jobs.collect-results.outputs.linux_html_artifact }}
      linux_pdf_artifact:
        description: "Linux PDF artifact name"
        value: ${{ jobs.collect-results.outputs.linux_pdf_artifact }}
      windows_html_artifact:
        description: "Windows HTML artifact name"
        value: ${{ jobs.collect-results.outputs.windows_html_artifact }}
      windows_pdf_artifact:
        description: "Windows PDF artifact name"
        value: ${{ jobs.collect-results.outputs.windows_pdf_artifact }}
      target:
        description: "Build target (dev/main)"
        value: ${{ inputs.target }}
      formats_built:
        description: "Comma-separated list of formats built"
        value: ${{ jobs.collect-results.outputs.formats_built }}

permissions:
  contents: write
  pages: write

jobs:
  # Generate dynamic matrix based on inputs
  generate-matrix:
    name: 'ğŸ¯ Generate Build Matrix'
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.generate.outputs.matrix }}
      
    steps:
      - name: ğŸ¯ Generate Build Matrix
        id: generate
        run: |
          echo "ğŸ¯ Generating build matrix from inputs..."
          
          # Handle legacy inputs for backward compatibility
          BUILD_LINUX="${{ inputs.build_linux }}"
          BUILD_WINDOWS="${{ inputs.build_windows }}"
          BUILD_HTML="${{ inputs.build_html }}"
          BUILD_PDF="${{ inputs.build_pdf }}"
          
          # Legacy format input conversion
          if [ -n "${{ inputs.format }}" ] && [ "${{ inputs.format }}" != "" ]; then
            echo "ğŸ”„ Converting legacy format input: ${{ inputs.format }}"
            case "${{ inputs.format }}" in
              "html") BUILD_HTML="true"; BUILD_PDF="false" ;;
              "pdf") BUILD_HTML="false"; BUILD_PDF="true" ;;
              "all") BUILD_HTML="true"; BUILD_PDF="true" ;;
              "epub") echo "âš ï¸ EPUB format not supported in matrix mode"; ;;
            esac
          fi
          
          # Legacy OS input conversion
          if [ -n "${{ inputs.os }}" ] && [ "${{ inputs.os }}" != "" ]; then
            echo "ğŸ”„ Converting legacy OS input: ${{ inputs.os }}"
            case "${{ inputs.os }}" in
              "ubuntu-latest") BUILD_LINUX="true"; BUILD_WINDOWS="false" ;;
              "windows-latest") BUILD_LINUX="false"; BUILD_WINDOWS="true" ;;
            esac
          fi
          
          # Start with empty matrix
          MATRIX='{"include":[]}'
          
          # Linux builds
          if [ "$BUILD_LINUX" = "true" ]; then
            if [ "$BUILD_HTML" = "true" ]; then
              MATRIX=$(echo "$MATRIX" | jq '.include += [{"os": "ubuntu-latest", "os_name": "linux", "format": "html", "artifact": "${{ inputs.target }}-html-linux"}]')
            fi
            if [ "$BUILD_PDF" = "true" ]; then
              MATRIX=$(echo "$MATRIX" | jq '.include += [{"os": "ubuntu-latest", "os_name": "linux", "format": "pdf", "artifact": "${{ inputs.target }}-pdf-linux"}]')
            fi
          fi
          
          # Windows builds  
          if [ "$BUILD_WINDOWS" = "true" ]; then
            if [ "$BUILD_HTML" = "true" ]; then
              MATRIX=$(echo "$MATRIX" | jq '.include += [{"os": "windows-latest", "os_name": "windows", "format": "html", "artifact": "${{ inputs.target }}-html-windows"}]')
            fi
            if [ "$BUILD_PDF" = "true" ]; then
              MATRIX=$(echo "$MATRIX" | jq '.include += [{"os": "windows-latest", "os_name": "windows", "format": "pdf", "artifact": "${{ inputs.target }}-pdf-windows"}]')
            fi
          fi
          
          echo "ğŸ“Š Generated matrix:"
          echo "$MATRIX" | jq '.'
          
          # Check if matrix is empty
          BUILD_COUNT=$(echo "$MATRIX" | jq '.include | length')
          if [ "$BUILD_COUNT" -eq 0 ]; then
            echo "âŒ No builds selected! At least one OS and format must be enabled."
            exit 1
          fi
          
          echo "âœ… Matrix generated with $BUILD_COUNT build jobs"
          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT

  # Dynamic matrix build job
  build:
    name: 'ğŸš€ ${{ matrix.os_name }} ${{ matrix.format }} (Baremetal)'
    needs: generate-matrix
    runs-on: ${{ matrix.os }}
    if: needs.generate-matrix.outputs.matrix != ''
    
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.generate-matrix.outputs.matrix) }}
    outputs:
      build_success: ${{ steps.outputs.outputs.build_success }}
      html_artifact: ${{ steps.outputs.outputs.html_artifact }}
      pdf_artifact: ${{ steps.outputs.outputs.pdf_artifact }}
      os_name: ${{ steps.outputs.outputs.os_name }}
      target: ${{ steps.outputs.outputs.target }}
      formats_built: ${{ steps.outputs.outputs.formats_built }}
    timeout-minutes: 60   # â° Set job timeout to 1 hour (3600 seconds)
    environment:
      name: ${{ inputs.environment }}
    env:
      R_LIBS_USER: ${{ github.workspace }}/.r-lib
      QUARTO_LOG_LEVEL: ${{ inputs.quarto-log-level || 'INFO' }}
      # UTF-8 encoding for proper emoji display
      PYTHONIOENCODING: utf-8
      LANG: en_US.UTF-8
      LC_ALL: en_US.UTF-8

    steps:
      - name: ğŸš¦ Set Initial Build Status
        shell: bash
        run: |
          echo "ğŸš¦ Setting initial build status to pending..."
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/statuses/${{ github.sha }}" \
            -d "{
              \"state\": \"pending\",
              \"description\": \"Quarto build started (${{ inputs.os }}, ${{ inputs.format }})\",
              \"context\": \"ci/quarto-build-${{ inputs.os }}-${{ inputs.format }}\"
            }"

      - name: ğŸ” Validate inputs
        shell: pwsh
        run: |
          # Set UTF-8 encoding for proper emoji display
          [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
          $OutputEncoding = [System.Text.Encoding]::UTF8
          [Console]::InputEncoding = [System.Text.Encoding]::UTF8
          
          Write-Output "ğŸ”„ Validating workflow inputs..."
          Write-Output "ğŸ‘‰ Target: ${{ inputs.target }}"
          Write-Output "ğŸ‘‰ OS: ${{ inputs.os }}"
          Write-Output "ğŸ‘‰ Environment: ${{ inputs.environment }}"
          Write-Output "ğŸ‘‰ Format: ${{ inputs.format }}"
          Write-Output "ğŸ‘‰ Deploy: Artifacts only - no deployment"
          Write-Output "ğŸ‘‰ TeX Live: Always installed for all formats (consistent environment)"
          
          $valid_formats = @("html", "pdf", "epub", "all")
          if ("${{ inputs.format }}" -notin $valid_formats) {
            Write-Error "âŒ Format must be one of: $($valid_formats -join ', ')"
            exit 1
          }
          
          Write-Output "âœ… Input validation passed"

      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ“¦ Setup Quarto
        uses: quarto-dev/quarto-actions/setup@v2
        with:
          version: ${{ inputs.quarto-version }}
        # Outputs quarto version information after installation
        id: quarto-setup

      - name: ğŸ“‹ Quarto Setup Info
        shell: bash
        run: |
          echo "ğŸ”„ Checking Quarto installation..."
          quarto check
          echo "ğŸ“Š Quarto version info:"
          quarto --version
          echo "ğŸ“ Quarto installation location:"
          which quarto || where.exe quarto

      - name: ğŸ Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: ğŸ’¾ Cache Python packages
        uses: actions/cache@v4
        id: cache-python-packages
        with:
          path: |
            ~/.cache/pip
            ~\AppData\Local\pip\Cache
          key: python-pkgs-${{ runner.os }}-${{ hashFiles('tools/dependencies/requirements.txt') }}
          restore-keys: |
            python-pkgs-${{ runner.os }}-

      # Install Ghostscript before Python package verification
      - name: ğŸ“¦ Install Ghostscript (Linux)
        if: runner.os == 'Linux'
        run: sudo apt-get install -y ghostscript

      - name: ğŸ“¦ Install Ghostscript (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # Use winget if available, otherwise fallback to chocolatey
          try {
            winget install ArtifexSoftware.GhostScript --accept-source-agreements --accept-package-agreements
            Write-Output "âœ… Ghostscript installed via winget"
          } catch {
            Write-Output "ğŸ”„ winget not available, using chocolatey..."
            choco install ghostscript -y
          }
          
          # Add Ghostscript to PATH (both installation methods use the same path)
          $gsPath = Get-ChildItem "C:\Program Files\gs" | Sort-Object Name -Descending | Select-Object -First 1
          $binPath = Join-Path $gsPath.FullName "bin"
          echo "Adding Ghostscript path: $binPath"
          echo "$binPath" | Out-File -Append -FilePath $env:GITHUB_PATH -Encoding UTF8

      - name: ğŸ“¦ Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install -r tools/dependencies/requirements.txt

      # Cache Linux system packages without hardcoded paths
      - name: ğŸ’¾ Cache APT packages
        if: runner.os == 'Linux'
        uses: actions/cache@v4
        id: cache-apt
        with:
          path: ~/.apt-cache
          key: apt-${{ runner.os }}-${{ hashFiles('.github/workflows/*.yml') }}
          restore-keys: |
            apt-${{ runner.os }}-

      - name: ğŸ› ï¸ Install Linux Dependencies
        if: runner.os == 'Linux' && steps.cache-apt.outputs.cache-hit != 'true'
        shell: bash
        run: |
          echo "ğŸ”„ Installing Linux dependencies..."
          echo "ğŸ“¦ Creating APT cache directory"
          mkdir -p ~/.apt-cache

          echo "ğŸ“¦ Updating package lists"
          sudo apt-get update

          echo "ğŸ“¦ Installing required system libraries"
          sudo apt-get -o dir::cache::archives="$HOME/.apt-cache" install -y \
            fonts-dejavu \
            fonts-freefont-ttf \
            gdk-pixbuf2.0-bin \
            libcairo2 \
            libfontconfig1 \
            libfontconfig1-dev \
            libfreetype6 \
            libfreetype6-dev \
            libpango-1.0-0 \
            libpangocairo-1.0-0 \
            libpangoft2-1.0-0 \
            libxml2-dev \
            libcurl4-openssl-dev \
            libjpeg-dev \
            libtiff5-dev \
            libpng-dev \
            libharfbuzz-dev \
            libfribidi-dev \
            librsvg2-dev \
            libgdal-dev \
            libudunits2-dev

          echo "âœ… Linux dependencies installed"
                
      - name: ğŸ¨ Install Inkscape and font dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          # First remove any existing Inkscape
          sudo apt-get remove -y inkscape || true
          # Install Inkscape from PPA for more reliable version
          echo "ğŸ“¦ Installing Inkscape from PPA..."
          sudo add-apt-repository ppa:inkscape.dev/stable -y
          sudo apt-get update
          sudo apt-get install -y inkscape
          
          # Install font dependencies
          echo "ğŸ“¦ Installing font dependencies..."
          sudo apt-get install -y \
            fonts-freefont-ttf \
            fonts-liberation \
            fontconfig
          
          # Update font cache after installing Inkscape and fonts
          echo "ğŸ§¹ Updating font cache..."
          sudo fc-cache -fv
          
          # Verify Inkscape installation
          echo "ğŸ“Š Inkscape version:"
          inkscape --version
          
          # Test SVG to PDF conversion with the new Inkscape
          echo "ğŸ§ª Testing Inkscape SVG to PDF conversion..."
          echo '<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><circle cx="50" cy="50" r="40" fill="red"/></svg>' > test.svg
          inkscape --export-type=pdf --export-filename=test.pdf test.svg
          
          # Verify if the PDF was created
          if [ -f test.pdf ]; then
            echo "âœ… Inkscape SVG to PDF conversion successful!"
            ls -lh test.pdf
          else
            echo "âŒ Inkscape SVG to PDF conversion failed."
            echo "ğŸ” Checking Inkscape installation..."
            dpkg -l | grep inkscape
            which inkscape
            ldd $(which inkscape) | grep "not found" || echo "All dependencies resolved"
          fi
          
      - name: ğŸ¨ Install Inkscape (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # Set UTF-8 encoding for proper emoji display
          [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
          $OutputEncoding = [System.Text.Encoding]::UTF8
          [Console]::InputEncoding = [System.Text.Encoding]::UTF8
          
          # Use winget (Windows default package manager) if available, otherwise fallback to chocolatey
          try {
            winget install Inkscape.Inkscape --accept-source-agreements --accept-package-agreements
            Write-Output "âœ… Inkscape installed via winget"
          } catch {
            Write-Output "ğŸ”„ winget not available, using chocolatey..."
            choco install inkscape -y
          }
          
          # Add Inkscape to PATH (both installation methods use the same path)
          echo "C:\Program Files\Inkscape\bin" | Out-File -Append -Encoding UTF8 $env:GITHUB_PATH
          
          # Verify Inkscape installation
          inkscape --version

      # Install TeX Live packages (Cross-platform) - ALWAYS install for consistency
      # Required for TikZ diagrams in HTML (PDF->SVG), PDF output, and potential future needs
      - name: ğŸ“¦ Install TeX Live packages
        uses: zauguin/install-texlive@v4
        with:
          package_file: tools/dependencies/tl_packages
          texlive_version: 2025
          cache_version: 1
          
      - name: ğŸ” Verify TeX Live Installation
        shell: bash
        run: |
          echo "ğŸ”„ Verifying TeX Live installation (installed for all builds)..."
          echo "ğŸ“Š Current format: ${{ inputs.format }}"
          echo "ğŸ“Š Philosophy: All builds get same environment, only build targets differ"
          
          # Check LaTeX engines
          echo "ğŸ“Š Checking LaTeX engines:"
          which lualatex || echo "âŒ lualatex not found"
          which pdflatex || echo "âŒ pdflatex not found"
          lualatex --version | head -2 || echo "âŒ lualatex version failed"
          
          # Check if required packages are available
          echo "ğŸ“Š Checking core LaTeX and TikZ packages:"
          kpsewhich pgf.sty && echo "âœ… PGF package found" || echo "âŒ PGF package missing"
          kpsewhich pgfplots.sty && echo "âœ… PGFPlots package found" || echo "âŒ PGFPlots package missing"
          kpsewhich xcolor.sty && echo "âœ… XColor package found" || echo "âŒ XColor package missing"
          kpsewhich amsmath.sty && echo "âœ… AMSMath package found" || echo "âŒ AMSMath package missing"
          kpsewhich standalone.cls && echo "âœ… Standalone class found" || echo "âŒ Standalone class missing"
          
          echo "ğŸ“Š Checking font packages:"
          kpsewhich phvr7t.tfm && echo "âœ… Helvetica font found" || echo "âŒ Helvetica font missing"
          kpsewhich t1phv.fd && echo "âœ… Helvetica font descriptor found" || echo "âŒ Helvetica font descriptor missing"
          
          # Test TikZ compilation
          echo "ğŸ§ª Testing TikZ compilation..."
          cat > test_tikz.tex << 'EOF'
          \documentclass{standalone}
          \usepackage{tikz}
          \usepackage{pgfplots}
          \usepackage{amsmath}
          \usepackage{amssymb}
          \usepackage{xcolor}
          \usepackage[T1]{fontenc}
          \usetikzlibrary{positioning}
          \usetikzlibrary{calc}
          \begin{document}
          \begin{tikzpicture}[font=\small\usefont{T1}{phv}{m}{n}]
          \node[draw, fill=blue!20] at (0,0) {TikZ Test};
          \node[draw, fill=red!20] at (2,0) {Success};
          \draw[->] (0.8,0) -- (1.2,0);
          \end{tikzpicture}
          \end{document}
          EOF
          
          if lualatex -interaction=nonstopmode test_tikz.tex; then
            echo "âœ… TikZ compilation successful"
            ls -la test_tikz.pdf
          else
            echo "âŒ TikZ compilation failed"
            cat test_tikz.log | tail -20 || echo "No log file found"
          fi
          
          rm -f test_tikz.*
         
      - name: ğŸ“Š Setup R
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: ${{ inputs.r-version }}
          use-public-rspm: true

      - name: ğŸ“‹ R Setup Info
        shell: Rscript {0}
        run: |
          cat("ğŸ”„ R Version Information:\n")
          cat(paste("R version:", R.version$version.string, "\n"))
          cat(paste("R home:", R.home(), "\n"))
          cat(paste("R library paths:", paste(.libPaths(), collapse=", "), "\n"))

      # Cache R packages using standard paths
      - name: ğŸ’¾ Cache R packages
        uses: actions/cache@v4
        id: cache-r-packages
        with:
          path: |
            ${{ env.R_LIBS_USER }}
          key: r-pkgs-${{ runner.os }}-${{ inputs.r-version }}-${{ hashFiles('tools/dependencies/install_packages.R', '**/*.qmd') }}
          restore-keys: |
            r-pkgs-${{ runner.os }}-${{ inputs.r-version }}-

      - name: ğŸ“¦ Install R packages
        if: steps.cache-r-packages.outputs.cache-hit != 'true'
        shell: Rscript {0}
        run: |
          # Set options for better package installation
          options(repos = c(CRAN = "https://cran.rstudio.com"))
          
          cat("ğŸ”„ Installing R packages...\n")
          cat(paste("R library path:", Sys.getenv("R_LIBS_USER"), "\n"))
          
          # Create and set library path
          lib_path <- Sys.getenv("R_LIBS_USER")
          dir.create(lib_path, showWarnings = FALSE, recursive = TRUE)
          .libPaths(lib_path)
          
          # Install packages
          cat("ğŸ“¦ Installing remotes package...\n")
          install.packages("remotes")
          
          if (file.exists("tools/dependencies/install_packages.R")) {
            cat("ğŸ“¦ Installing packages from tools/dependencies/install_packages.R...\n")
            source("tools/dependencies/install_packages.R")
          } else {
            cat("âš ï¸ No tools/dependencies/install_packages.R found, installing common packages\n")
            pkgs <- c("rmarkdown", "knitr", "tidyverse", "ggplot2", "bookdown")
            cat(paste("ğŸ“¦ Installing packages:", paste(pkgs, collapse=", "), "\n"))
            install.packages(pkgs)
          }
          
          cat("âœ… R package installation complete\n")
          cat("ğŸ“Š Installed packages:\n")
          ip <- installed.packages()[, "Package"]
          print(head(ip, 10))
          cat(paste("Total packages installed:", nrow(ip), "\n"))
          
          # Verify critical R packages are installed
          cat("ğŸ” Verifying R package installation...\n")
          required_r_packages <- c("ggplot2", "ggrepel", "knitr", "rmarkdown", "tidyverse", 
                                 "reshape2", "reticulate", "rsvg", "viridis", "xml2", "dplyr", "grid")
          missing_r_packages <- c()
          for (pkg in required_r_packages) {
            if (!requireNamespace(pkg, quietly = TRUE)) {
              missing_r_packages <- c(missing_r_packages, pkg)
            }
          }
          
          if (length(missing_r_packages) > 0) {
            cat(paste("âŒ Missing R packages:", paste(missing_r_packages, collapse = ", "), "\n"))
            quit(status = 1)
          } else {
            cat("âœ… All required R packages installed successfully\n")
          }

      - name: ğŸ’“ Start Build Heartbeat
        shell: bash
        run: |
          echo "ğŸ’“ Starting build heartbeat system..."
          echo "â° Build started at: $(date)"
          echo "ğŸ“Š Build configuration:"
          echo "   - Format: ${{ inputs.format }}"
          echo "   - OS: ${{ inputs.os }}"
          echo "   - Environment: ${{ inputs.environment }}"
          echo "   - Timeout: 60 minutes"
          echo "ğŸ’“ Heartbeat will show progress every 5 minutes"
          
          # Start background heartbeat process
          (
            while true; do
              sleep 300  # 5 minutes
              echo "ğŸ’“ Build heartbeat: $(date) - Still building..."
              echo "ğŸ“Š Current memory usage:"
              free -h || echo "Memory info not available"
              echo "ğŸ“Š Current disk usage:"
              df -h . || echo "Disk info not available"
              echo "ğŸ“Š Active processes:"
              ps aux | grep -E "(quarto|R|python)" | head -5 || echo "Process info not available"
              echo "---"
            done
          ) &
          HEARTBEAT_PID=$!
          echo $HEARTBEAT_PID > /tmp/heartbeat.pid
          echo "âœ… Heartbeat started (PID: $HEARTBEAT_PID)"

      - name: ğŸ”¨ Build HTML (copy config and render)
        if: matrix.format == 'html'
        shell: bash
        run: |
          echo "ğŸš€ Setting up HTML configuration..."
          cd quarto
          rm -f _quarto.yml
          cp config/_quarto-html.yml _quarto.yml
          echo "âœ… Configuration set to HTML"
          
          echo "ğŸ”¨ Building HTML..."
          echo "â° HTML build started at: $(date)"
          
          # Update status to building
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/statuses/${{ github.sha }}" \
            -d "{
              \"state\": \"pending\",
              \"description\": \"Building HTML content (${{ inputs.os }})\",
              \"context\": \"ci/quarto-build-${{ inputs.os }}-${{ inputs.format }}\"
            }"
          
          # Enable verbose logging for debugging
          quarto render --to html
          echo "âœ… HTML build completed at: $(date)"
        
      - name: ğŸ”¨ Build PDF (copy config and render)
        if: matrix.format == 'pdf'
        shell: bash
        run: |
          echo "ğŸš€ Setting up PDF configuration..."
          cd quarto
          rm -f _quarto.yml
          cp config/_quarto-pdf.yml _quarto.yml
          echo "âœ… Configuration set to PDF"
          
          echo "ğŸ”¨ Building PDF..."
          echo "â° PDF build started at: $(date)"
          echo "ğŸ“Š This is typically the longest step (can take 30-45 minutes)"
          echo "ğŸ’“ Heartbeat will continue showing progress..."
          
          # Update status to building PDF
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/statuses/${{ github.sha }}" \
            -d "{
              \"state\": \"pending\",
              \"description\": \"Building PDF content (${{ inputs.os }}) - this takes 30-45min\",
              \"context\": \"ci/quarto-build-${{ inputs.os }}-${{ inputs.format }}\"
            }"
          
          # Enable verbose logging for debugging
          quarto render --to titlepage-pdf
          echo "âœ… PDF build completed at: $(date)"
      
      - name: ğŸ’“ Stop Build Heartbeat
        shell: bash
        run: |
          echo "ğŸ’“ Stopping build heartbeat..."
          if [ -f /tmp/heartbeat.pid ]; then
            HEARTBEAT_PID=$(cat /tmp/heartbeat.pid)
            if kill -0 $HEARTBEAT_PID 2>/dev/null; then
              kill $HEARTBEAT_PID
              echo "âœ… Heartbeat stopped (PID: $HEARTBEAT_PID)"
            else
              echo "âš ï¸ Heartbeat process already stopped"
            fi
            rm -f /tmp/heartbeat.pid
          else
            echo "âš ï¸ No heartbeat PID file found"
          fi
          echo "â° Total build time: $(date)"

      - name: ğŸ“‹ Check Quarto Build Output
        shell: bash
        run: |
          echo "ğŸ”„ Checking Quarto build output..."

          # HTML check
          if [[ "${{ inputs.format }}" == "html" || "${{ inputs.format }}" == "all" ]]; then
            if [ -d "build/html" ]; then
              echo "âœ… build/html directory exists"
              echo "ğŸ“Š Files in build/html directory:"
              ls -la build/html | head -n 20
              echo "ğŸ“Š Total files in build/html:"
              find build/html -type f | wc -l
            else
              echo "âŒ build/html directory not found!"
            fi
          fi

          # PDF check
          if [[ "${{ inputs.format }}" == "pdf" || "${{ inputs.format }}" == "all" ]]; then
            if [ -d "build/pdf" ]; then
              echo "âœ… build/pdf directory exists"
              echo "ğŸ“Š Files in build/pdf directory:"
              ls -la build/pdf | head -n 20
              echo "ğŸ“Š Total files in build/pdf:"
              find build/pdf -type f | wc -l
              
              if [ -f "build/pdf/Machine-Learning-Systems.pdf" ]; then
                echo "âœ… PDF file exists"
                echo "ğŸ“Š PDF file size:"
                du -h "build/pdf/Machine-Learning-Systems.pdf"
              else
                echo "âš ï¸ PDF file not found!"
              fi
            else
              echo "âŒ build/pdf directory not found!"
            fi
          fi

      - name: ğŸ“‰ Compress PDF with Ghostscript (Linux)
        if: runner.os == 'Linux' && matrix.format == 'pdf'
        run: |
          if [ -f "build/pdf/Machine-Learning-Systems.pdf" ]; then
            gs \
              -sDEVICE=pdfwrite \
              -dCompatibilityLevel=1.4 \
              -dPDFSETTINGS=/ebook \
              -dNOPAUSE \
              -dQUIET \
              -dBATCH \
              -sOutputFile="./build/pdf/ebook.pdf" \
              "./build/pdf/Machine-Learning-Systems.pdf"

            # Replace original with compressed
            mv ./build/pdf/ebook.pdf ./build/pdf/Machine-Learning-Systems.pdf
          else
            echo "âš ï¸ PDF file not found for compression"
          fi

      - name: ğŸ“‰ Compress PDF with Ghostscript (Windows)
        if: runner.os == 'Windows' && matrix.format == 'pdf'
        shell: pwsh
        run: |
          # Set UTF-8 encoding for proper emoji display
          [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
          $OutputEncoding = [System.Text.Encoding]::UTF8
          [Console]::InputEncoding = [System.Text.Encoding]::UTF8
          
          $input = "./build/pdf/Machine-Learning-Systems.pdf"
          $output = "./build/pdf/ebook.pdf"

          if (!(Test-Path $input)) {
            Write-Warning "âš ï¸ Input PDF not found! Skipping compression..."
            exit 0  # Non-zero exit would fail the workflow
          }

          Write-Output "ğŸ“‰ Compressing PDF using Ghostscript..."

          # Unless you are a sucker for pain, don't try to line-break this command (it was a nightmare)
          # Note that compatability should be written as -dCompatibilityLevel:1.4, not -dCompatibilityLevel=1.4!!!
          & gswin64c -sDEVICE=pdfwrite -dCompatibilityLevel:1.4 -dPDFSETTINGS=/ebook -dNOPAUSE -dBATCH -sOutputFile="$output" "$input"

          if (Test-Path $output) {
            $afterSize = (Get-Item $output).Length / 1MB
            Write-Output ("ğŸ“ Compressed PDF size: {0:N2} MB" -f $afterSize)
            Write-Output "âœ… Compression successful"
            Move-Item -Force $output $input
          } else {
            Write-Warning "âš ï¸ Compression failed but continuing"
          }
          
      - name: ğŸ“¤ Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact }}
          path: build/${{ matrix.format }}

      - name: ğŸ“‹ Build Declaration
        id: outputs
        shell: bash
        run: |
          # Determine OS name from runner.os
          if [ "${{ runner.os }}" = "Linux" ]; then
            OS_NAME="linux"
          elif [ "${{ runner.os }}" = "Windows" ]; then
            OS_NAME="windows"
          else
            OS_NAME="unknown"
          fi
          
          # Determine artifact names based on formats built
          HTML_ARTIFACT=""
          PDF_ARTIFACT=""
          FORMATS_BUILT=""
          
          if [[ "${{ inputs.format }}" == "html" || "${{ inputs.format }}" == "all" ]]; then
            HTML_ARTIFACT="${{ inputs.target }}-html-${OS_NAME}"
            FORMATS_BUILT="html"
          fi
          
          if [[ "${{ inputs.format }}" == "pdf" || "${{ inputs.format }}" == "all" ]]; then
            PDF_ARTIFACT="${{ inputs.target }}-pdf-${OS_NAME}"
            if [ -n "$FORMATS_BUILT" ]; then
              FORMATS_BUILT="$FORMATS_BUILT,pdf"
            else
              FORMATS_BUILT="pdf"
            fi
          fi
          
          # Legacy artifact name for backward compatibility
          ARTIFACT_NAME="${{ inputs.artifact_name != '' && inputs.artifact_name || format('build-{0}-{1}', inputs.os, inputs.format) }}"
          
          echo "ğŸ“¦ Build Declaration: Successfully created artifacts"
          echo "ğŸ“Š HTML Artifact: '$HTML_ARTIFACT'"
          echo "ğŸ“Š PDF Artifact: '$PDF_ARTIFACT'"
          echo "ğŸ“Š Format: ${{ inputs.format }}"
          echo "ğŸ“Š OS: ${{ inputs.os }}"
          echo "ğŸ“Š Target: ${{ inputs.target }}"
          echo "ğŸ“Š Method: Baremetal Build ($OS_NAME)"
          echo "ğŸ“Š Formats Built: $FORMATS_BUILT"
          echo "ğŸ“ Note: This workflow only builds artifacts - deployment handled by publish-live workflow"
          
          # Standardized outputs
          echo "build_success=true" >> $GITHUB_OUTPUT
          echo "html_artifact=$HTML_ARTIFACT" >> $GITHUB_OUTPUT
          echo "pdf_artifact=$PDF_ARTIFACT" >> $GITHUB_OUTPUT
          echo "os_name=$OS_NAME" >> $GITHUB_OUTPUT
          echo "target=${{ inputs.target }}" >> $GITHUB_OUTPUT
          echo "formats_built=$FORMATS_BUILT" >> $GITHUB_OUTPUT
          
          # Legacy output for backward compatibility
          echo "artifact_created=$ARTIFACT_NAME" >> $GITHUB_OUTPUT



      - name: ğŸ“ Collect Build Logs and System Info (Universal)
        if: always()  # Always run, even if previous steps failed
        shell: pwsh
        run: |
          # Set UTF-8 encoding for proper emoji display
          [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
          $OutputEncoding = [System.Text.Encoding]::UTF8
          [Console]::InputEncoding = [System.Text.Encoding]::UTF8
          
          Write-Output "ğŸ”„ Collecting comprehensive build logs and system information..."
          
          # Create logs directory structure
          New-Item -Type Directory -Path "logs", "logs/system-info", "logs/build-output" -Force | Out-Null
          
          # === COLLECT ALL BUILD LOGS ===
          Write-Output "ğŸ“„ Searching for build logs in all directories..."
          
          # Find and copy all .log files from common locations
          $logPaths = @("quarto", "build", "_book", ".", "_site")
          foreach ($path in $logPaths) {
            if (Test-Path $path) {
              Write-Output "ğŸ” Searching in: $path"
              Get-ChildItem -Path $path -Recurse -Include "*.log" -ErrorAction SilentlyContinue | ForEach-Object {
                $relativePath = $_.FullName.Replace($PWD.Path, "").TrimStart("/\")
                $sanitizedName = $relativePath -replace "[/\\:]", "_"
                Write-Output "ğŸ“„ Found log: $relativePath â†’ logs/$sanitizedName"
                Copy-Item $_.FullName "logs/$sanitizedName" -ErrorAction SilentlyContinue
              }
            }
          }
          
          # Look for any output files that might contain build info
          Get-ChildItem -Recurse -Include "*.out", "*.aux", "*.fls", "*.fdb_latexmk" -ErrorAction SilentlyContinue | ForEach-Object {
            $relativePath = $_.FullName.Replace($PWD.Path, "").TrimStart("/\")
            $sanitizedName = $relativePath -replace "[/\\:]", "_"
            Copy-Item $_.FullName "logs/build-output/$sanitizedName" -ErrorAction SilentlyContinue
          }
          
          # === SYSTEM ENVIRONMENT ===
          Write-Output "ğŸ–¥ï¸ Collecting system environment..."
          @"
          === Build Environment Information ===
          Date: $(Get-Date)
          GitHub Workflow: ${{ github.workflow }}
          GitHub Run ID: ${{ github.run_id }}
          Runner OS: ${{ runner.os }}
          Build Format: ${{ inputs.format }}
          PowerShell Version: $($PSVersionTable.PSVersion)
          Working Directory: $PWD
          
          "@ | Out-File "logs/system-info/environment.log" -Encoding UTF8
          
          # === SYSTEM RESOURCES ===
          Write-Output "ğŸ“Š Collecting system resources..."
          if ($IsWindows -or $env:OS -eq "Windows_NT") {
            @"
          === System Resources (Windows) ===
          "@ | Out-File "logs/system-info/resources.log" -Encoding UTF8
            
            # Windows system info
            Get-ComputerInfo | Select-Object TotalPhysicalMemory, CsProcessors, WindowsVersion | Out-File "logs/system-info/resources.log" -Append -Encoding UTF8
            Get-WmiObject -Class Win32_LogicalDisk | Select-Object DeviceID, Size, FreeSpace | Out-File "logs/system-info/resources.log" -Append -Encoding UTF8
          } else {
            @"
          === System Resources (Linux) ===
          "@ | Out-File "logs/system-info/resources.log" -Encoding UTF8
            
            # Linux system info
            if (Get-Command free -ErrorAction SilentlyContinue) {
              & free -h 2>&1 | Out-File "logs/system-info/resources.log" -Append -Encoding UTF8
            }
            if (Get-Command df -ErrorAction SilentlyContinue) {
              & df -h 2>&1 | Out-File "logs/system-info/resources.log" -Append -Encoding UTF8
            }
          }
          
          # === GRAPHICS/PNG LIBRARIES ===
          Write-Output "ğŸ–¼ï¸ Collecting graphics library information..."
          @"
          === Graphics Libraries Information ===
          "@ | Out-File "logs/system-info/libraries.log" -Encoding UTF8
          
          if ($IsWindows -or $env:OS -eq "Windows_NT") {
            # Windows DLL information
            Get-ChildItem -Path $env:SystemRoot\System32 -Include "*png*", "*cairo*", "*freetype*" -ErrorAction SilentlyContinue | 
              Select-Object Name, Length, LastWriteTime | Out-File "logs/system-info/libraries.log" -Append -Encoding UTF8
          } else {
            # Linux library information
            if (Get-Command ldconfig -ErrorAction SilentlyContinue) {
              & ldconfig -p 2>&1 | Select-String -Pattern "(png|cairo|freetype|graphite)" | Out-File "logs/system-info/libraries.log" -Append -Encoding UTF8
            }
            if (Get-Command pkg-config -ErrorAction SilentlyContinue) {
              @("libpng", "cairo", "freetype2") | ForEach-Object {
                "--- $_ ---" | Out-File "logs/system-info/libraries.log" -Append -Encoding UTF8
                $result = if (& pkg-config --exists $_ 2>$null) { & pkg-config --modversion $_ 2>&1 } else { "Not found" }
                $result | Out-File "logs/system-info/libraries.log" -Append -Encoding UTF8
              }
            }
          }
          
          # === TEX DISTRIBUTION ===
          Write-Output "ğŸ“– Collecting TeX distribution info..."
          @"
          === TeX Distribution Information ===
          "@ | Out-File "logs/system-info/tex-info.log" -Encoding UTF8
          
          # Check for TeX executables
          @("pdflatex", "lualatex", "xelatex", "tlmgr") | ForEach-Object {
            "--- $_ ---" | Out-File "logs/system-info/tex-info.log" -Append -Encoding UTF8
            if (Get-Command $_ -ErrorAction SilentlyContinue) {
              & $_ --version 2>&1 | Select-Object -First 5 | Out-File "logs/system-info/tex-info.log" -Append -Encoding UTF8
            } else {
              "$_ not found" | Out-File "logs/system-info/tex-info.log" -Append -Encoding UTF8
            }
          }
          
          # === QUARTO INFORMATION ===
          Write-Output "ğŸ“š Collecting Quarto information..."
          @"
          === Quarto Information ===
          "@ | Out-File "logs/system-info/quarto-info.log" -Encoding UTF8
          
          if (Get-Command quarto -ErrorAction SilentlyContinue) {
            & quarto --version 2>&1 | Out-File "logs/system-info/quarto-info.log" -Append -Encoding UTF8
            "--- Quarto Check ---" | Out-File "logs/system-info/quarto-info.log" -Append -Encoding UTF8
            & quarto check 2>&1 | Out-File "logs/system-info/quarto-info.log" -Append -Encoding UTF8
          } else {
            "Quarto not found" | Out-File "logs/system-info/quarto-info.log" -Append -Encoding UTF8
          }
          
          # === SUMMARY ===
          Write-Output "ğŸ“Š Build log collection summary:"
          Write-Output "ğŸ“ Log files collected:"
          Get-ChildItem -Path "logs" -Recurse -File | ForEach-Object {
            $size = if ($_.Length -gt 1MB) { "{0:N2} MB" -f ($_.Length / 1MB) } 
                    elseif ($_.Length -gt 1KB) { "{0:N2} KB" -f ($_.Length / 1KB) } 
                    else { "$($_.Length) bytes" }
            Write-Output "  ğŸ“„ $($_.FullName.Replace($PWD.Path, '.')) ($size)"
          }

      - name: ğŸ“¤ Upload Build Logs (Always)
        if: always()  # Upload logs even if build fails
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ inputs.os }}-${{ inputs.format }}-${{ github.run_id }}
          path: logs/
          retention-days: 30  # Keep logs for 30 days for debugging
          if-no-files-found: warn

      - name: ğŸ“‹ Build Summary
        shell: pwsh
        run: |
          # Set UTF-8 encoding for proper emoji display
          [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
          $OutputEncoding = [System.Text.Encoding]::UTF8
          [Console]::InputEncoding = [System.Text.Encoding]::UTF8
          
          # TeX Live is now always installed for consistent environment across all builds
          $texLiveStatus = "âœ… Always installed (zauguin/install-texlive@v4)"
          
          @"
          ## ğŸ“Š Build Status Summary
          ğŸ¯ Target: ${{ inputs.target }}
          ğŸ’» OS: ${{ inputs.os }}
          ğŸ”§ Environment: ${{ inputs.environment }}
          ğŸ“š Quarto Version: ${{ inputs.quarto-version }}
          ğŸ”¬ R Version: ${{ inputs.r-version }}
          ğŸ“„ Format: ${{ inputs.format }}
          ğŸš€ Deploy: Artifacts only (no deployment in this workflow)
          ğŸ§© Cache Status:
            - TeX Live: $texLiveStatus
            - R Packages: ${{ steps.cache-r-packages.outputs.cache-hit == 'true' && 'âœ… Hit' || 'âŒ Miss' }}
            - Python Packages: ${{ steps.cache-python-packages.outputs.cache-hit == 'true' && 'âœ… Hit' || 'âŒ Miss' }}
          ğŸ“ Debug Artifacts:
            - Build logs available as artifact: build-logs-${{ inputs.os }}-${{ inputs.format }}-${{ github.run_id }}
            - Includes: TeX logs, system info, library details, and comprehensive build output
            - Retention: 30 days for debugging
          â° Completed at: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")
          "@ | Add-Content $env:GITHUB_STEP_SUMMARY

      - name: ğŸ¯ Set Final Build Status
        if: always()
        shell: bash
        run: |
          echo "ğŸ¯ Setting final build status..."
          
          # Determine the final status based on job status
          if [ "${{ job.status }}" = "success" ]; then
            STATE="success"
            DESCRIPTION="Build completed successfully (${{ inputs.os }}, ${{ inputs.format }})"
          else
            STATE="failure"
            DESCRIPTION="Build failed (${{ inputs.os }}, ${{ inputs.format }})"
          fi
          
          echo "ğŸ“Š Final status: $STATE"
          echo "ğŸ“ Description: $DESCRIPTION"
          
          # Set the final commit status
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/statuses/${{ github.sha }}" \
            -d "{
              \"state\": \"$STATE\",
              \"description\": \"$DESCRIPTION\",
              \"context\": \"ci/quarto-build-${{ inputs.os }}-${{ inputs.format }}\"
            }"
          
          echo "âœ… Commit status updated successfully"

  # Collect results from all matrix builds
  collect-results:
    name: 'ğŸ“Š Collect Results'
    needs: [generate-matrix, build]
    runs-on: ubuntu-latest
    if: always()
    outputs:
      build_success: ${{ steps.collect.outputs.build_success }}
      linux_html_artifact: ${{ steps.collect.outputs.linux_html_artifact }}
      linux_pdf_artifact: ${{ steps.collect.outputs.linux_pdf_artifact }}
      windows_html_artifact: ${{ steps.collect.outputs.windows_html_artifact }}
      windows_pdf_artifact: ${{ steps.collect.outputs.windows_pdf_artifact }}
      formats_built: ${{ steps.collect.outputs.formats_built }}
      
    steps:
      - name: ğŸ“Š Collect Matrix Results
        id: collect
        run: |
          echo "ğŸ“Š Collecting results from baremetal matrix builds..."
          
          # Parse the matrix to determine what was built
          MATRIX='${{ needs.generate-matrix.outputs.matrix }}'
          echo "ğŸ“‹ Matrix: $MATRIX"
          
          # Initialize outputs
          LINUX_HTML=""
          LINUX_PDF=""
          WINDOWS_HTML=""
          WINDOWS_PDF=""
          FORMATS_BUILT=()
          
          # Collect artifact names based on successful builds
          echo "$MATRIX" | jq -r '.include[] | "\(.os_name) \(.format) \(.artifact)"' | while IFS=' ' read -r OS_NAME FORMAT ARTIFACT; do
            if [ "${{ needs.build.result }}" = "success" ]; then
              case "${OS_NAME}_${FORMAT}" in
                "linux_html")
                  echo "linux_html_artifact=$ARTIFACT" >> $GITHUB_OUTPUT
                  ;;
                "linux_pdf")
                  echo "linux_pdf_artifact=$ARTIFACT" >> $GITHUB_OUTPUT
                  ;;
                "windows_html")
                  echo "windows_html_artifact=$ARTIFACT" >> $GITHUB_OUTPUT
                  ;;
                "windows_pdf")
                  echo "windows_pdf_artifact=$ARTIFACT" >> $GITHUB_OUTPUT
                  ;;
              esac
              FORMATS_BUILT+=("$FORMAT")
            fi
          done
          
          # Determine overall success
          if [ "${{ needs.build.result }}" = "success" ]; then
            BUILD_SUCCESS="true"
          else
            BUILD_SUCCESS="false"
          fi
          
          # Join formats built (remove duplicates)
          FORMATS_LIST=$(printf '%s\n' "${FORMATS_BUILT[@]}" | sort -u | tr '\n' ',' | sed 's/,$//')
          
          echo "build_success=$BUILD_SUCCESS" >> $GITHUB_OUTPUT
          echo "formats_built=$FORMATS_LIST" >> $GITHUB_OUTPUT
          
          echo "âœ… Baremetal build results collected:"
          echo "  Success: $BUILD_SUCCESS"
          echo "  Formats: $FORMATS_LIST"