{"title":"Vision-Language Models (VLM)","markdown":{"headingText":"Vision-Language Models (VLM)","headingAttr":{"id":"","classes":["unnumbered"],"keyvalue":[]},"containsRefs":false,"markdown":"\n![*DALL·E prompt - A Raspberry Pi setup featuring vision tasks. The image shows a Raspberry Pi connected to a camera, with various computer vision tasks displayed visually around it, including object detection, image captioning, segmentation, and visual grounding. The Raspberry Pi is placed on a desk, with a display showing bounding boxes and annotations related to these tasks. The background should be a home workspace, with tools and devices typically used by developers and hobbyists.*](images/jpeg/cover.jpg)\n\n## Introduction {#sec-visionlanguage-models-vlm-introduction-4272}\n\nIn this hands-on lab, we will continuously explore AI applications at the Edge, from the basic setup of the Florence-2, Microsoft's state-of-the-art vision foundation model, to advanced implementations on devices like the Raspberry Pi. We will learn to use Vision Language Models (VLMs) for tasks such as captioning, object detection, grounding, segmentation, and OCR on a Raspberry Pi.\n\n### Why Florence-2 at the Edge? {#sec-visionlanguage-models-vlm-florence2-edge-0534}\n\n[Florence-2](https://arxiv.org/abs/2311.06242) is a vision-language model open-sourced by Microsoft under the MIT license, which significantly advances vision-language models by combining a lightweight architecture with robust capabilities. Thanks to its training on the massive FLD-5B dataset, which contains 126 million images and 5.4 billion visual annotations, it achieves performance comparable to larger models. This makes Florence-2 ideal for deployment at the edge, where power and computational resources are limited.\n\nIn this tutorial, we will explore how to use Florence-2 for real-time computer vision applications, such as:\n\n- Image captioning\n- Object detection\n- Segmentation\n- Visual grounding\n\n> **Visual grounding** involves linking textual descriptions to specific regions within an image. This enables the model to understand where particular objects or entities described in a prompt are in the image. For example, if the prompt is \"a red car,\" the model will identify and highlight the region where the red car is found in the image. Visual grounding is helpful for applications where precise alignment between text and visual content is needed, such as human-computer interaction, image annotation, and interactive AI systems.\n\nIn the tutorial, we will walk through:\n\n- Setting up Florence-2 on the Raspberry Pi\n- Running inference tasks such as object detection and captioning\n- Optimizing the model to get the best performance from the edge device\n- Exploring practical, real-world applications with fine-tuning.\n\n### Florence-2 Model Architecture {#sec-visionlanguage-models-vlm-florence2-model-architecture-b695}\n\nFlorence-2 utilizes a unified, prompt-based representation to handle various vision-language tasks. The model architecture consists of two main components: an **image encoder** and a **multi-modal transformer encoder-decoder**.\n\n```{.tikz}\n\\noindent\n\\begin{minipage}{\\linewidth}\n\\centering\n\\scalebox{0.8}{%\n\\begin{tikzpicture}[font=\\small\\usefont{T1}{phv}{m}{n}]\n\\tikzset{Line/.style={line width=1.0pt,black!50},\n  Box/.style={inner xsep=2pt,\n    draw=BlueLine,\n    node distance=0.6,\n    line width=0.75pt,\n    fill=BlueL,\n    anchor=west,\n    text width=36mm,\n    align=flush center,\n    minimum width=36mm,\n    minimum height=8mm\n  },\n}\n\n\\node[Box,draw=RedLine, fill=RedL](B1){Input};\n\\node[Box,below left=of B1](B2){Image};\n\\node[Box,below right =of B1](B3){Text Prompt};\n\\node[Box,below=of B2](B4){Image Encoder (DaVIT)};\n\\node[Box,below=of B3](B5){Text Tokenize};\n\\node[Box,below=of $(B4)!0.5!(B5)$](B6){Multimodality Encoder (Transformer)};\n\\node[Box,below=of B6](B7){Multimodality Decoder (Transformer)};\n\\node[Box,below=of B7,draw=RedLine, fill=RedL](B8){Output (Text/Coordinates)};\n%\n\\draw[Line,-latex](B1)-|(B2);\n\\draw[Line,-latex](B1)-|(B3);\n\\draw[Line,-latex](B2)--(B4);\n\\draw[Line,-latex](B3)--(B5);\n\\draw[Line,-latex](B4)|-(B6);\n\\draw[Line,-latex](B5)|-(B6);\n\\draw[Line,-latex](B6)--(B7);\n\\draw[Line,-latex](B7)--(B8);\n\\end{tikzpicture}}\n\\end{minipage}\n```\n\n- **Image Encoder**: The image encoder is based on the [DaViT (Dual Attention Vision Transformers) architecture](https://arxiv.org/abs/2204.03645). It converts input images into a series of visual token embeddings. These embeddings serve as the foundational representations of the visual content, capturing both spatial and contextual information about the image.\n\n- **Multi-Modal Transformer Encoder-Decoder**: Florence-2's core is the multi-modal transformer encoder-decoder, which combines visual token embeddings from the image encoder with textual embeddings generated by a BERT-like model. This combination allows the model to simultaneously process visual and textual inputs, enabling a unified approach to tasks such as image captioning, object detection, and segmentation.\n\nThe model's training on the extensive FLD-5B dataset ensures it can effectively handle diverse vision tasks without requiring task-specific modifications. Florence-2 uses textual prompts to activate specific tasks, making it highly flexible and capable of zero-shot generalization. For tasks like object detection or visual grounding, the model incorporates additional location tokens to represent regions within the image, ensuring a precise understanding of spatial relationships.\n\n> Florence-2's compact architecture and innovative training approach allow it to perform computer vision tasks accurately, even on resource-constrained devices like the Raspberry Pi.\n\n## Technical Overview {#sec-visionlanguage-models-vlm-technical-overview-faee}\n\nFlorence-2 introduces several innovative features that set it apart:\n\n### Architecture {#sec-visionlanguage-models-vlm-architecture-9992}\n\n\\noindent\n![](images/png/arch.png){width=85% fig-align=\"center\"}\n\n- **Lightweight Design**: Two variants available\n  - Florence-2-Base: 232 million parameters\n  - Florence-2-Large: 771 million parameters\n- **Unified Representation**: Handles multiple vision tasks through a single architecture\n- **DaViT Vision Encoder**: Converts images into visual token embeddings\n- **Transformer-based Multi-modal Encoder-Decoder**: Processes combined visual and text embeddings\n\n### Training Dataset (FLD-5B) {#sec-visionlanguage-models-vlm-training-dataset-fld5b-2779}\n\n\\noindent\n![](images/png/dataset_fld-5b.png){width=85% fig-align=\"center\"}\n\n- 126 million unique images\n- 5.4 billion comprehensive annotations, including:\n  - 500M text annotations\n  - 1.3B region-text annotations\n  - 3.6B text-phrase-region annotations\n- Automated annotation pipeline using specialist models\n- Iterative refinement process for high-quality labels\n\n### Key Capabilities {#sec-visionlanguage-models-vlm-key-capabilities-2707}\n\nFlorence-2 excels in multiple vision tasks:\n\n#### Zero-shot Performance {#sec-visionlanguage-models-vlm-zeroshot-performance-e3c6}\n\n- Image Captioning: Achieves 135.6 CIDEr score on COCO\n- Visual Grounding: 84.4% recall@1 on Flickr30k\n- Object Detection: 37.5 mAP on COCO val2017\n- Referring Expression: 67.0% accuracy on RefCOCO\n\n#### Fine-tuned Performance {#sec-visionlanguage-models-vlm-finetuned-performance-119c}\n\n- Competitive with specialist models despite the smaller size\n- Outperforms larger models in specific benchmarks\n- Efficient adaptation to new tasks\n\n### Practical Applications {#sec-visionlanguage-models-vlm-practical-applications-4b8f}\n\nFlorence-2 can be applied across various domains:\n\n1. **Content Understanding**\n   - Automated image captioning for accessibility\n   - Visual content moderation\n   - Media asset management\n\n2. **E-commerce**\n   - Product image analysis\n   - Visual search\n   - Automated product tagging\n\n3. **Healthcare**\n   - Medical image analysis\n   - Diagnostic assistance\n   - Research data processing\n\n4. **Security & Surveillance**\n   - Object detection and tracking\n   - Anomaly detection\n   - Scene understanding\n\n### Comparing Florence-2 with other VLMs {#sec-visionlanguage-models-vlm-comparing-florence2-vlms-b507}\n\nFlorence-2 stands out from other visual language models due to its impressive zero-shot capabilities. Unlike models like [Google PaliGemma](https://huggingface.co/blog/paligemma), which rely on extensive fine-tuning to adapt to various tasks, Florence-2 works right out of the box, as we will see in this lab. It can also compete with larger models like GPT-4V and Flamingo, which often have many more parameters but only sometimes match Florence-2's performance. For example, Florence-2 achieves better zero-shot results than Kosmos-2 despite having over twice the parameters.\n\nIn benchmark tests, Florence-2 has shown remarkable performance in tasks like COCO captioning and referring expression comprehension. It outperformed models like PolyFormer and UNINEXT in object detection and segmentation tasks on the [COCO dataset](https://docs.ultralytics.com/datasets/detect/coco/). It is a highly competitive choice for real-world applications where both performance and resource efficiency are crucial.\n\n## Setup and Installation {#sec-visionlanguage-models-vlm-setup-installation-78de}\n\nOur choice of edge device is the Raspberry Pi 5 (Raspi-5). Its robust platform is equipped with the Broadcom BCM2712, a 2.4 GHz quad-core 64-bit Arm Cortex-A76 CPU featuring Cryptographic Extension and enhanced caching capabilities. It boasts a VideoCore VII GPU, dual 4Kp60 HDMI® outputs with HDR, and a 4Kp60 HEVC decoder. Memory options include 4 GB and 8 GB of high-speed LPDDR4X SDRAM, with 8 GB being our choice to run Florence-2. It also features expandable storage via a microSD card slot and a PCIe 2.0 interface for fast peripherals such as M.2 SSDs (Solid State Drives).\n\n> For real applications, SSDs are a better option than SD cards.\n\nWe suggest installing an Active Cooler, a dedicated clip-on cooling solution for Raspberry Pi 5 (Raspi-5), for this lab. It combines an aluminum heat sink with a temperature-controlled blower fan to keep the Raspi-5 operating comfortably under heavy loads, such as running Florense-2.\n\n\\noindent\n![](images/jpeg/raspi5-active-cooler.jpg){width=80% fig-align=\"center\"}\n\n### Environment configuration {#sec-visionlanguage-models-vlm-environment-configuration-0062}\n\nTo run [Microsoft Florense-2](https://huggingface.co/microsoft/Florence-2-base) on the Raspberry Pi 5, we'll need a few libraries:\n\n1. **[Transformers](https://huggingface.co/docs/transformers/en/index)**:\n   - Florence-2 uses the `transformers` library from Hugging Face for model loading and inference. This library provides the architecture for working with pre-trained vision-language models, making it easy to perform tasks like image captioning, object detection, and more. Essentially, `transformers` helps in interacting with the model, processing input prompts, and obtaining outputs.\n\n2. **PyTorch**:\n   - PyTorch is a deep learning framework that provides the infrastructure needed to run the Florence-2 model, which includes tensor operations, GPU acceleration (if a GPU is available), and model training/inference functionalities. The Florence-2 model is trained in PyTorch, and we need it to leverage its functions, layers, and computation capabilities to perform inferences on the Raspberry Pi.\n\n3. **Timm** (PyTorch Image Models):\n   - Florence-2 uses `timm` to access efficient implementations of vision models and pre-trained weights. Specifically, the `timm` library is utilized for the **image encoder** part of Florence-2, particularly for managing the DaViT architecture. It provides model definitions and optimized code for common vision tasks and allows the easy integration of different backbones that are lightweight and suitable for edge devices.\n\n4. **Einops**:\n   - `Einops` is a library for flexible and powerful tensor operations. It makes it easy to reshape and manipulate tensor dimensions, which is especially important for the multi-modal processing done in Florence-2. Vision-language models like Florence-2 often need to rearrange image data, text embeddings, and visual embeddings to align correctly for the transformer blocks, and `einops` simplifies these complex operations, making the code more readable and concise.\n\nIn short, these libraries enable different essential components of Florence-2:\n\n- **Transformers** and **PyTorch** are needed to load the model and run the inference.\n- **Timm** is used to access and efficiently implement the vision encoder.\n- **Einops** helps reshape data, facilitating the integration of visual and text features.\n\nAll these components work together to help Florence-2 run seamlessly on our Raspberry Pi, allowing it to perform complex vision-language tasks relatively quickly.\n\nConsidering that the Raspberry Pi already has its OS installed, let's use `SSH` to reach it from another computer:\n\n```bash\nssh mjrovai@raspi-5.local\n```\n\nAnd check the IP allocated to it:\n\n```bash\nhostname -I\n```\n\n`192.168.4.209 `\n\n\\noindent\n![](images/png/ssh.png)\n\n**Updating the Raspberry Pi**\n\nFirst, ensure your Raspberry Pi is up to date:\n\n```bash\nsudo apt update\nsudo apt upgrade -y\n```\n\n**Initial setup for using PIP**:\n\n```bash\nsudo apt install python3-pip\nsudo rm /usr/lib/python3.11/EXTERNALLY-MANAGED\npip3 install --upgrade pip\n```\n\n**Install Dependencies**\n\n```bash\nsudo apt-get install libjpeg-dev libopenblas-dev libopenmpi-dev \\\n    libomp-dev\n```\n\nLet’s set up and activate a **Virtual Environment** for working with Florence-2:\n\n```bash\npython3 -m venv ~/florence\nsource ~/florence/bin/activate\n```\n\n**Install PyTorch**\n\n```bash\npip3 install setuptools numpy Cython\npip3 install requests\npip3 install torch torchvision \\\n    --index-url https://download.pytorch.org/whl/cpu\npip3 install torchaudio \\\n    --index-url https://download.pytorch.org/whl/cpu\n```\n\nLet's verify that PyTorch is correctly installed:\n\n\\noindent\n![](images/png/test-pytorch.png)\n\n**Install Transformers, Timm and Einops**:\n\n```bash\npip3 install transformers\npip3 install timm einops\n```\n\n**Install the model**:\n\n```bash\npip3 install autodistill-florence-2\n```\n\n**Jupyter Notebook and Python libraries**\n\nInstalling a Jupyter Notebook to run and test our Python scripts is possible.\n\n```bash\npip3 install jupyter\npip3 install numpy Pillow matplotlib\njupyter notebook --generate-config\n```\n\n### Testing the installation {#sec-visionlanguage-models-vlm-testing-installation-4988}\n\nRunning the Jupyter Notebook on the remote computer\n\n```bash\njupyter notebook --ip=192.168.4.209 --no-browser\n```\n\nRunning the above command on the SSH terminal, we can see the local URL address to open the notebook:\n\n\\noindent\n![](images/png/jupyter.png)\n\nThe notebook with the code used on this initial test can be found on the Lab GitHub:\n\n- [10-florence2_test.ipynb](https://github.com/Mjrovai/EdgeML-with-Raspberry-Pi/blob/main/FLORENCE-2/notebooks/10-florence2_test.ipynb)\n\nWe can access it on the remote computer by entering the Raspberry Pi’s IP address and the provided token in a web browser (copy the entire URL from the terminal).\n\nFrom the Home page, create a new notebook [`Python 3 (ipykernel)` ] and copy and paste the [example code](https://huggingface.co/microsoft/Florence-2-base#how-to-get-started-with-the-model) from Hugging Face Hub.\n\nThe code is designed to run Florence-2 on a given image to perform **object detection**. It loads the model, processes an image and a prompt, and then generates a response to identify and describe the objects in the image.\n\n- The **processor** helps prepare text and image inputs.\n- The **model** takes the processed inputs to generate a meaningful response.\n- The **post-processing** step refines the generated output into a more interpretable form, like bounding boxes for detected objects.\n\n> This workflow leverages the versatility of Florence-2 to handle **vision-language tasks** and is implemented efficiently using PyTorch, Transformers, and related image-processing tools.\n\n```python\nimport requests\nfrom PIL import Image\nimport torch\nfrom transformers import AutoProcessor, AutoModelForCausalLM\n\ndevice = \"cuda:0\" if torch.cuda.is_available() else \"cpu\"\ntorch_dtype = (\n    torch.float16 if torch.cuda.is_available() else torch.float32\n)\n\nmodel = AutoModelForCausalLM.from_pretrained(\n    \"microsoft/Florence-2-base\",\n    torch_dtype=torch_dtype,\n    trust_remote_code=True,\n).to(device)\nprocessor = AutoProcessor.from_pretrained(\n    \"microsoft/Florence-2-base\", trust_remote_code=True\n)\n\nprompt = \"<OD>\"\n\nurl = (\n    \"https://huggingface.co/datasets/huggingface/\"\n    \"documentation-images/resolve/main/transformers/\"\n    \"tasks/car.jpg?download=true\"\n)\nimage = Image.open(requests.get(url, stream=True).raw)\n\ninputs = processor(text=prompt, images=image, return_tensors=\"pt\").to(\n    device, torch_dtype\n)\n\ngenerated_ids = model.generate(\n    input_ids=inputs[\"input_ids\"],\n    pixel_values=inputs[\"pixel_values\"],\n    max_new_tokens=1024,\n    do_sample=False,\n    num_beams=3,\n)\ngenerated_text = processor.batch_decode(\n    generated_ids, skip_special_tokens=False\n)[0]\n\nparsed_answer = processor.post_process_generation(\n    generated_text,\n    task=\"<OD>\",\n    image_size=(image.width, image.height),\n)\n\nprint(parsed_answer)\n```\n\nLet's break down the provided code step by step:\n\n#### Importing Required Libraries {#sec-visionlanguage-models-vlm-importing-required-libraries-1ee5}\n\n```python\nimport requests\nfrom PIL import Image\nimport torch\nfrom transformers import AutoProcessor, AutoModelForCausalLM\n```\n- **requests**: Used to make HTTP requests. In this case, it downloads an image from a URL.\n- **PIL (Pillow)**: Provides tools for manipulating images. Here, it's used to open the downloaded image.\n- **torch**: PyTorch is imported to handle tensor operations and determine the hardware availability (CPU or GPU).\n- **transformers**: This module provides easy access to Florence-2 by using `AutoProcessor` and `AutoModelForCausalLM` to load pre-trained models and process inputs.\n\n#### Determining the Device and Data Type {#sec-visionlanguage-models-vlm-determining-device-data-type-4011}\n\n```python\ndevice = \"cuda:0\" if torch.cuda.is_available() else \"cpu\"\n\ntorch_dtype = (\n    torch.float16 if torch.cuda.is_available() else torch.float32\n)\n```\n- **Device Setup**: The code checks if a CUDA-enabled GPU is available (`torch.cuda.is_available()`). The device is set to \"cuda:0\" if a GPU is available. Otherwise, it defaults to `\"cpu\"` (our case here).\n- **Data Type Setup**: If a GPU is available, `torch.float16` is chosen, which uses half-precision floats to speed up processing and reduce memory usage. On the CPU, it defaults to `torch.float32` to maintain compatibility.\n\n#### Loading the Model and Processor {#sec-visionlanguage-models-vlm-loading-model-processor-fb73}\n\n```python\nmodel = AutoModelForCausalLM.from_pretrained(\n    \"microsoft/Florence-2-base\",\n    torch_dtype=torch_dtype,\n    trust_remote_code=True,\n).to(device)\n\nprocessor = AutoProcessor.from_pretrained(\n    \"microsoft/Florence-2-base\", trust_remote_code=True\n)\n```\n- **Model Initialization**:\n  - **`AutoModelForCausalLM.from_pretrained()`** loads the pre-trained Florence-2 model from Microsoft's repository on Hugging Face. The `torch_dtype` is set according to the available hardware (GPU/CPU), and `trust_remote_code=True` allows the use of any custom code that might be provided with the model.\n  - **`.to(device)`** moves the model to the appropriate device (either CPU or GPU). In our case, it will be set to `CPU`.\n\n- **Processor Initialization**:\n  - **`AutoProcessor.from_pretrained()`** loads the processor for Florence-2. The processor is responsible for transforming text and image inputs into a format the model can work with (e.g., encoding text, normalizing images, etc.).\n\n### Defining the Prompt {#sec-visionlanguage-models-vlm-defining-prompt-2cd2}\n\n```python\nprompt = \"<OD>\"\n```\n- **Prompt Definition**: The string `\"<OD>\"` is used as a prompt. This refers to \"Object Detection\", instructing the model to detect objects on the image.\n\n#### Downloading and Loading the Image {#sec-visionlanguage-models-vlm-downloading-loading-image-e518}\n\n```python\nurl = \"https://huggingface.co/datasets/huggingface/\"\n      \"documentation-images/resolve/main/transformers/\"\n      \"tasks/car.jpg?download=true\"\nimage = Image.open(requests.get(url, stream=True).raw)\n```\n- **Downloading the Image**: The **`requests.get()`** function fetches the image from the specified URL. The `stream=True` parameter ensures the image is streamed rather than downloaded completely at once.\n- **Opening the Image**: **`Image.open()`** opens the image so the model can process it.\n\n#### Processing Inputs {#sec-visionlanguage-models-vlm-processing-inputs-14e0}\n\n```python\ninputs = processor(text=prompt, images=image, return_tensors=\"pt\").to(\n    device, torch_dtype\n)\n```\n- **Processing Input Data**: The **`processor()`** function processes the text (`prompt`) and the image (`image`). The `return_tensors=\"pt\"` argument converts the processed data into PyTorch tensors, which are necessary for inputting data into the model.\n- **Moving Inputs to Device**: **`.to(device, torch_dtype)`** moves the inputs to the correct device (CPU or GPU) and assigns the appropriate data type.\n\n### Generating the Output {#sec-visionlanguage-models-vlm-generating-output-6e10}\n\n```python\ngenerated_ids = model.generate(\n    input_ids=inputs[\"input_ids\"],\n    pixel_values=inputs[\"pixel_values\"],\n    max_new_tokens=1024,\n    do_sample=False,\n    num_beams=3,\n)\n```\n- **Model Generation**: **`model.generate()`** is used to generate the output based on the input data.\n  - **`input_ids`**: Represents the tokenized form of the prompt.\n  - **`pixel_values`**: Contains the processed image data.\n  - **`max_new_tokens=1024`**: Specifies the maximum number of new tokens to be generated in the response. This limits the response length.\n  - **`do_sample=False`**: Disables sampling; instead, the generation uses deterministic methods (beam search).\n  - **`num_beams=3`**: Enables beam search with three beams, which improves output quality by considering multiple possibilities during generation.\n\n#### Decoding the Generated Text {#sec-visionlanguage-models-vlm-decoding-generated-text-70e0}\n\n```python\ngenerated_text = processor.batch_decode(\n    generated_ids, skip_special_tokens=False\n)[0]\n```\n- **Batch Decode**: **`processor.batch_decode()`** decodes the generated IDs (tokens) into readable text. The `skip_special_tokens=False` parameter means that the output will include any special tokens that may be part of the response.\n\n#### Post-processing the Generation {#sec-visionlanguage-models-vlm-postprocessing-generation-6592}\n\n```python\nparsed_answer = processor.post_process_generation(\n    generated_text,\n    task=\"<OD>\",\n    image_size=(image.width, image.height),\n)\n```\n- **Post-Processing**: **`processor.post_process_generation()`** is called to process the generated text further, interpreting it based on the task (`\"<OD>\"` for object detection) and the size of the image.\n- This function extracts specific information from the generated text, such as bounding boxes for detected objects, making the output more useful for visual tasks.\n\n#### Printing the Output {#sec-visionlanguage-models-vlm-printing-output-8a57}\n\n```python\nprint(parsed_answer)\n```\n- Finally, **`print(parsed_answer)`** displays the output, which could include object detection results, such as bounding box coordinates and labels for the detected objects in the image.\n\n#### Result {#sec-visionlanguage-models-vlm-result-0a91}\n\nRunning the code, we get as the Parsed Answer:\n\n```bash\n[{'<OD>': {\n   'bboxes': [\n     [34.23999786376953, 160.0800018310547, 597.4400024414062],\n     [371.7599792480469, 272.32000732421875, 241.67999267578125],\n     [303.67999267578125, 247.4399871826172, 454.0799865722656],\n     [276.7200012207031, 553.9199829101562, 370.79998779296875],\n     [96.31999969482422, 280.55999755859375, 198.0800018310547],\n     [371.2799987792969]\n    ],\n    'labels': ['car', 'door handle', 'wheel', 'wheel']\n}}]\n\n```\n\nFirst, let's inspect the image:\n\n```python\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(8, 8))\nplt.imshow(image)\nplt.axis(\"off\")\nplt.show()\n```\n\n\\noindent\n![](images/png/fusca.png){width=80% fig-align=\"center\"}\n\nBy the Object Detection result, we can see that:\n\n```bash\n'labels': ['car', 'door handle', 'wheel', 'wheel']\n```\n\nIt seems that at least a few objects were detected. We can also implement a code to draw the bounding boxes in the find objects:\n\n```python\ndef plot_bbox(image, data):\n    # Create a figure and axes\n    fig, ax = plt.subplots()\n\n    # Display the image\n    ax.imshow(image)\n\n    # Plot each bounding box\n    for bbox, label in zip(data[\"bboxes\"], data[\"labels\"]):\n        # Unpack the bounding box coordinates\n        x1, y1, x2, y2 = bbox\n        # Create a Rectangle patch\n        rect = patches.Rectangle(\n            (x1, y1),\n            x2 - x1,\n            y2 - y1,\n            linewidth=1,\n            edgecolor=\"r\",\n            facecolor=\"none\",\n        )\n        # Add the rectangle to the Axes\n        ax.add_patch(rect)\n        # Annotate the label\n        plt.text(\n            x1,\n            y1,\n            label,\n            color=\"white\",\n            fontsize=8,\n            bbox=dict(facecolor=\"red\", alpha=0.5),\n        )\n\n    # Remove the axis ticks and labels\n    ax.axis(\"off\")\n\n    # Show the plot\n    plt.show()\n```\n\n> **Box (x0, y0, x1, y1)**: Location tokens correspond to the top-left and bottom-right corners of a box.\n\nAnd running\n\n```\nplot_bbox(image, parsed_answer['<OD>'])\n```\n\nWe get:\n\n\\noindent\n![](images/png/result_test.png){width=80% fig-align=\"center\"}\n\n## Florence-2 Tasks {#sec-visionlanguage-models-vlm-florence2-tasks-bcbb}\n\nFlorence-2 is designed to perform a variety of computer vision and vision-language tasks through `prompts`. These tasks can be activated by providing a specific textual prompt to the model, as we saw with `<OD>` (Object Detection).\n\nFlorence-2's versatility comes from combining these prompts, allowing us to guide the model's behavior to perform specific vision tasks. Changing the prompt allows us to adapt Florence-2 to different tasks without needing task-specific modifications in the architecture. This capability directly results from Florence-2's unified model architecture and large-scale multi-task training on the FLD-5B dataset.\n\nHere are some of the key tasks that Florence-2 can perform, along with example prompts:\n\n### Object Detection (OD) {#sec-visionlanguage-models-vlm-object-detection-od-ef58}\n\n   - **Prompt**: `\"<OD>\"`\n   - **Description**: Identifies objects in an image and provides bounding boxes for each detected object. This task is helpful for applications like visual inspection, surveillance, and general object recognition.\n\n### Image Captioning {#sec-visionlanguage-models-vlm-image-captioning-c35d}\n\n   - **Prompt**: `\"<CAPTION>\"`\n   - **Description**: Generates a textual description for an input image. This task helps the model describe what is happening in the image, providing a human-readable caption for content understanding.\n\n### Detailed Captioning {#sec-visionlanguage-models-vlm-detailed-captioning-7819}\n\n   - **Prompt**: `\"<DETAILED_CAPTION>\"`\n   - **Description**: Generates a more detailed caption with more nuanced information about the scene, such as the objects present and their relationships.\n\n### Visual Grounding {#sec-visionlanguage-models-vlm-visual-grounding-7e4d}\n\n   - **Prompt**: `\"<CAPTION_TO_PHRASE_GROUNDING>\"`\n   - **Description**: Links a textual description to specific regions in an image. For example, given a prompt like \"a green car,\" the model highlights where the green car is in the image. This is useful for human-computer interaction, where you must find specific objects based on text.\n\n### Segmentation {#sec-visionlanguage-models-vlm-segmentation-e618}\n\n   - **Prompt**: `\"<REFERRING_EXPRESSION_SEGMENTATION>\"`\n   - **Description**: Performs segmentation based on a referring expression, such as \"the blue cup.\" The model identifies and segments the specific region containing the object mentioned in the prompt (all related pixels).\n\n### Dense Region Captioning {#sec-visionlanguage-models-vlm-dense-region-captioning-ed94}\n\n   - **Prompt**: `\"<DENSE_REGION_CAPTION>\"`\n   - **Description**: Provides captions for multiple regions within an image, offering a detailed breakdown of all visible areas, including different objects and their relationships.\n\n### OCR with Region {#sec-visionlanguage-models-vlm-ocr-region-75f2}\n\n   - **Prompt**: `\"<OCR_WITH_REGION>\"`\n   - **Description**: Performs Optical Character Recognition (OCR) on an image and provides bounding boxes for the detected text. This is useful for extracting and locating textual information in images, such as reading signs, labels, or other forms of text in images.\n\n### Phrase Grounding for Specific Expressions {#sec-visionlanguage-models-vlm-phrase-grounding-specific-expressions-0d0c}\n\n   - **Prompt**: `\"<CAPTION_TO_PHRASE_GROUNDING>\"` along with a specific expression, such as `\"a wine glass\"`.\n   - **Description**: Locates the area in the image that corresponds to a specific textual phrase. This task allows for identifying particular objects or elements when prompted with a word or keyword.\n\n### Open Vocabulary Object Detection {#sec-visionlanguage-models-vlm-open-vocabulary-object-detection-3811}\n\n   - **Prompt**: `\"<OPEN_VOCABULARY_OD>\"`\n   - **Description**: The model can detect objects without being restricted to a predefined list of classes, making it helpful in recognizing a broader range of items based on general visual understanding.\n\n## Exploring  computer vision and vision-language tasks {#sec-visionlanguage-models-vlm-exploring-computer-vision-visionlanguage-tasks-5c1d}\n\nFor exploration, all codes can be found on the GitHub:\n\n- [20-florence_2.ipynb](https://github.com/Mjrovai/EdgeML-with-Raspberry-Pi/blob/main/FLORENCE-2/notebooks/20-florence_2.ipynb)\n\nLet's use a couple of images created by Dall-E and upload them to the Rasp-5 (FileZilla can be used for that). The images will be saved on a sub-folder named `images` :\n\n```python\ndogs_cats = Image.open(\"./images/dogs-cats.jpg\")\ntable = Image.open(\"./images/table.jpg\")\n```\n\n\\noindent\n![](images/png/img_test.png)\n\nLet's create a function to facilitate our exploration and to keep track of the latency of the model for different tasks:\n\n```python\ndef run_example(task_prompt, text_input=None, image=None):\n    start_time = time.perf_counter()  # Start timing\n    if text_input is None:\n        prompt = task_prompt\n    else:\n        prompt = task_prompt + text_input\n    inputs = processor(\n        text=prompt, images=image, return_tensors=\"pt\"\n    ).to(device)\n    generated_ids = model.generate(\n        input_ids=inputs[\"input_ids\"],\n        pixel_values=inputs[\"pixel_values\"],\n        max_new_tokens=1024,\n        early_stopping=False,\n        do_sample=False,\n        num_beams=3,\n    )\n    generated_text = processor.batch_decode(\n        generated_ids, skip_special_tokens=False\n    )[0]\n    parsed_answer = processor.post_process_generation(\n        generated_text,\n        task=task_prompt,\n        image_size=(image.width, image.height),\n    )\n\n    end_time = time.perf_counter()  # End timing\n    elapsed_time = end_time - start_time  # Calculate elapsed time\n    print(\n        f\" \\n[INFO] ==> Florence-2-base ({task_prompt}), \\\n          took {elapsed_time:.1f} seconds to execute.\\n\"\n    )\n\n    return parsed_answer\n```\n\n### Caption {#sec-visionlanguage-models-vlm-caption-a1d1}\n\n**1. Dogs and Cats**\n\n```python\nrun_example(task_prompt=\"<CAPTION>\", image=dogs_cats)\n```\n\n```bash\n[INFO] ==> Florence-2-base (<CAPTION>), \\\ntook 16.1 seconds to execute.\n\n{'<CAPTION>': 'A group of dogs and cats sitting in a garden.'}\n```\n\n**2. Table**\n\n```python\nrun_example(task_prompt=\"<CAPTION>\", image=table)\n```\n\n```bash\n[INFO] ==> Florence-2-base (<CAPTION>), \\\ntook 16.5 seconds to execute.\n\n{'<CAPTION>': 'A wooden table topped with a plate of fruit \\\nand a glass of wine.'}\n```\n\n### Detailed Caption {#sec-visionlanguage-models-vlm-detailed-caption-4b44}\n\n**1. Dogs and Cats**\n\n```python\nrun_example(task_prompt=\"<DETAILED_CAPTION>\", image=dogs_cats)\n```\n\n```bash\n[INFO] ==> Florence-2-base (<DETAILED_CAPTION>), \\\ntook 25.5 seconds to execute.\n\n{'<DETAILED_CAPTION>': 'The image shows a group of cats and \\\ndogs sitting on top of a lush green field, surrounded by plants \\\nwith flowers, trees, and a house in the background. The sky is \\\nvisible above them, creating a peaceful atmosphere.'}\n```\n\n**2. Table**\n\n```python\nrun_example(task_prompt=\"<DETAILED_CAPTION>\", image=table)\n```\n\n```bash\n[INFO] ==> Florence-2-base (<DETAILED_CAPTION>), \\\ntook 26.8 seconds to execute.\n\n{'<DETAILED_CAPTION>': 'The image shows a wooden table with \\\na bottle of wine and a glass of wine on it, surrounded by \\\na variety of fruits such as apples, oranges, and grapes. \\\nIn the background, there are chairs, plants, trees, and \\\na house, all slightly blurred.'}\n```\n\n### More Detailed Caption {#sec-visionlanguage-models-vlm-detailed-caption-f936}\n\n**1. Dogs and Cats**\n\n```python\nrun_example(task_prompt=\"<MORE_DETAILED_CAPTION>\", image=dogs_cats)\n```\n\n```bash\n[INFO] ==> Florence-2-base (<MORE_DETAILED_CAPTION>), \\\ntook 49.8 seconds to execute.\n\n{'<MORE_DETAILED_CAPTION>': 'The image shows a group of four \\\ncats and a dog in a garden. The garden is filled with colorful \\\nflowers and plants, and there is a pathway leading up to \\\na house in the background. The main focus of the image is \\\na large German Shepherd dog standing on the left side of \\\nthe garden, with its tongue hanging out and its mouth open, \\\nas if it is panting. On the right side, there are \\\ntwo smaller cats, one orange and one gray, sitting on the \\\ngrass. In the background, there is another golden retriever \\\ndog sitting and looking at the camera. The sky is blue and \\\nthe sun is shining, creating a warm and inviting atmosphere.'}\n```\n\n**2. Table**\n\n```python\nrun_example(task_prompt=\"< MORE_DETAILED_CAPTION>\", image=table)\n```\n\n```bash\nINFO] ==> Florence-2-base (<MORE_DETAILED_CAPTION>), \\\ntook 32.4 seconds to execute.\n\n{'<MORE_DETAILED_CAPTION>': 'The image shows a wooden table \\\nwith a wooden tray on it. On the tray, there are various \\\nfruits such as grapes, oranges, apples, and grapes. There \\\nis also a bottle of red wine on the table. The background \\\nshows a garden with trees and a house. The overall mood \\\nof the image is peaceful and serene.'}\n```\n\n> We can note that the more detailed the caption task, the longer the latency and the possibility of mistakes (like \"The image shows a group of four cats and a dog in a garden\", instead of two dogs and three cats).\n\n### Object Detection {#sec-visionlanguage-models-vlm-object-detection-dd2b}\n\nWe can run the same previous function for object detection using the prompt `<OD>`.\n\n```python\ntask_prompt = \"<OD>\"\nresults = run_example(task_prompt, image=dogs_cats)\nprint(results)\n```\n\nLet's see the result:\n\n```bash\n[INFO] ==> Florence-2-base (<OD>), took 20.9 seconds to execute.\n\n{'<OD>': {'bboxes': [\n  [737.79, 571.90, 1022.46, 980.48],\n  [0.51, 593.40, 211.45, 991.74],\n  [445.95, 721.40, 680.44, 850.43],\n  [39.42, 91.64, 491.00, 933.37],\n  [570.88, 184.83, 974.33, 782.84]\n  ],\n  'labels': ['cat', 'cat', 'cat', 'dog', 'dog']\n}}\n```\n\nOnly by the labels `['cat,' 'cat,' 'cat,' 'dog,' 'dog']` is it possible to see that the main objects in the image were captured. Let's apply the function used before to draw the bounding boxes:\n\n```python\nplot_bbox(dogs_cats, results[\"<OD>\"])\n```\n\n\\noindent\n![](images/png/od_cat_dogs.png){width=65% fig-align=\"center\"}\n\nLet's also do it with the Table image:\n\n```python\ntask_prompt = \"<OD>\"\nresults = run_example(task_prompt, image=table)\nplot_bbox(table, results[\"<OD>\"])\n```\n\n```ba\n[INFO] ==> Florence-2-base (<OD>), took 40.8 seconds to execute.\n```\n\n\\noindent\n![](images/png/od_table.png){width=75% fig-align=\"center\"}\n\n### Dense Region Caption {#sec-visionlanguage-models-vlm-dense-region-caption-fd99}\n\nIt is possible to mix the classic Object Detection with the Caption task in specific sub-regions of the image:\n\n```python\ntask_prompt = \"<DENSE_REGION_CAPTION>\"\n\nresults = run_example(task_prompt, image=dogs_cats)\nplot_bbox(dogs_cats, results[\"<DENSE_REGION_CAPTION>\"])\n\nresults = run_example(task_prompt, image=table)\nplot_bbox(table, results[\"<DENSE_REGION_CAPTION>\"])\n```\n\n\\noindent\n![](images/png/od_caption_cat_dog_table.png)\n\n### Caption to Phrase Grounding {#sec-visionlanguage-models-vlm-caption-phrase-grounding-a092}\n\nWith this task, we can enter with a caption, such as \"a wine glass\", \"a wine bottle,\" or \"a half orange,\" and Florence-2 will localize the object in the image:\n\n```python\ntask_prompt = \"<CAPTION_TO_PHRASE_GROUNDING>\"\n\nresults = run_example(\n    task_prompt, text_input=\"a wine bottle\", image=table\n)\nplot_bbox(table, results[\"<CAPTION_TO_PHRASE_GROUNDING>\"])\n\nresults = run_example(\n    task_prompt, text_input=\"a wine glass\", image=table\n)\nplot_bbox(table, results[\"<CAPTION_TO_PHRASE_GROUNDING>\"])\n\nresults = run_example(\n    task_prompt, text_input=\"a half orange\", image=table\n)\nplot_bbox(table, results[\"<CAPTION_TO_PHRASE_GROUNDING>\"])\n```\n\n\\noindent\n![](images/png/caption_ground.png)\n\n```bash\n[INFO] ==> Florence-2-base (<CAPTION_TO_PHRASE_GROUNDING>), \\\ntook 15.7 seconds to execute\neach task.\n```\n\n### Cascade Tasks {#sec-visionlanguage-models-vlm-cascade-tasks-8b5e}\n\nWe can also enter the image caption as the input text to push Florence-2 to find more objects:\n\n```python\ntask_prompt = \"<CAPTION>\"\nresults = run_example(task_prompt, image=dogs_cats)\ntext_input = results[task_prompt]\ntask_prompt = \"<CAPTION_TO_PHRASE_GROUNDING>\"\nresults = run_example(task_prompt, text_input, image=dogs_cats)\nplot_bbox(dogs_cats, results[\"<CAPTION_TO_PHRASE_GROUNDING>\"])\n```\n\nChanging the task_prompt among `<CAPTION,>` `<DETAILED_CAPTION>` and `<MORE_DETAILED_CAPTION>`, we will get more objects in the image.\n\n\\noindent\n![](images/png/cascade.png)\n\n### Open Vocabulary Detection {#sec-visionlanguage-models-vlm-open-vocabulary-detection-be66}\n\n`<OPEN_VOCABULARY_DETECTION>` allows Florence-2 to detect recognizable objects in an image without relying on a predefined list of categories, making it a versatile tool for identifying various items that may not have been explicitly labeled during training. Unlike `<CAPTION_TO_PHRASE_GROUNDING>`, which requires a specific text phrase to locate and highlight a particular object in an image, `<OPEN_VOCABULARY_DETECTION>` performs a broad scan to find and classify all objects present.\n\nThis makes `<OPEN_VOCABULARY_DETECTION>` particularly useful for applications where you need a comprehensive overview of everything in an image without prior knowledge of what to expect. Enter with a text describing specific objects not previously detected, resulting in their detection. For example:\n\n```python\ntask_prompt = \"<OPEN_VOCABULARY_DETECTION>\"\n\ntext = [\n    \"a house\",\n    \"a tree\",\n    \"a standing cat at the left\",\n    \"a sleeping cat on the ground\",\n    \"a standing cat at the right\",\n    \"a yellow cat\",\n]\n\nfor txt in text:\n    results = run_example(\n        task_prompt, text_input=txt, image=dogs_cats\n    )\n\n    bbox_results = convert_to_od_format(\n        results[\"<OPEN_VOCABULARY_DETECTION>\"]\n    )\n\n    plot_bbox(dogs_cats, bbox_results)\n```\n\n\\noindent\n![](images/png/open_vacab_exemples.png){width=85% fig-align=\"center\"}\n\n```bash\n[INFO] ==> Florence-2-base (<OPEN_VOCABULARY_DETECTION>), \\\ntook 15.1 seconds to execute\neach task.\n```\n\n> Note: Trying to use Florence-2 to find objects that were not found can leads to mistakes (see examples on the Notebook).\n\n### Referring expression segmentation {#sec-visionlanguage-models-vlm-referring-expression-segmentation-de08}\n\nWe can also segment a specific object in the image and give its description (caption), such as “a wine bottle\" on the table image or “a German Sheppard\" on the dogs_cats.\n\nReferring expression segmentation results format: `{'<REFERRING_EXPRESSION_SEGMENTATION>': {'Polygons': [[[polygon]], ...], 'labels': ['', '', ...]}}`, one object is represented by a list of polygons. each polygon is `[x1, y1, x2, y2, ..., xn, yn]`.\n\n> **Polygon (x1, y1, …, xn, yn)**: Location tokens represent the vertices of a polygon in clockwise order.\n\nSo, let's first create a function to plot the segmentation:\n\n```python\nfrom PIL import Image, ImageDraw, ImageFont\nimport copy\nimport random\nimport numpy as np\n\ncolormap = [\n    \"blue\",\n    \"orange\",\n    \"green\",\n    \"purple\",\n    \"brown\",\n    \"pink\",\n    \"gray\",\n    \"olive\",\n    \"cyan\",\n    \"red\",\n    \"lime\",\n    \"indigo\",\n    \"violet\",\n    \"aqua\",\n    \"magenta\",\n    \"coral\",\n    \"gold\",\n    \"tan\",\n    \"skyblue\",\n]\n\n\ndef draw_polygons(image, prediction, fill_mask=False):\n    \"\"\"\n        Draws segmentation masks with polygons on an image.\n\n        Parameters:\n          - image_path: Path to the image file.\n          - prediction: Dictionary containing 'polygons' and 'labels'\n                  keys. 'polygons' is a list of lists, each\n                  containing vertices of a polygon. 'labels' is\n                  a list of labels corresponding to each polygon.\n    - fill_mask: Boolean indicating whether to fill the polygons\n                 with color.\n    \"\"\"\n    # Load the image\n\n    draw = ImageDraw.Draw(image)\n\n    # Set up scale factor if needed (use 1 if not scaling)\n    scale = 1\n\n    # Iterate over polygons and labels\n    for polygons, label in zip(\n        prediction[\"polygons\"], prediction[\"labels\"]\n    ):\n        color = random.choice(colormap)\n        fill_color = random.choice(colormap) if fill_mask else None\n\n        for _polygon in polygons:\n            _polygon = np.array(_polygon).reshape(-1, 2)\n            if len(_polygon) < 3:\n                print(\"Invalid polygon:\", _polygon)\n                continue\n\n            _polygon = (_polygon * scale).reshape(-1).tolist()\n\n            # Draw the polygon\n            if fill_mask:\n                draw.polygon(_polygon, outline=color, fill=fill_color)\n            else:\n                draw.polygon(_polygon, outline=color)\n\n            # Draw the label text\n            draw.text(\n                (_polygon[0] + 8, _polygon[1] + 2), label, fill=color\n            )\n\n    # Save or display the image\n    # image.show()  # Display the image\n    display(image)\n```\n\nNow we can run the functions:\n\n```python\ntask_prompt = \"<REFERRING_EXPRESSION_SEGMENTATION>\"\n\nresults = run_example(\n    task_prompt, text_input=\"a wine bottle\", image=table\n)\noutput_image = copy.deepcopy(table)\ndraw_polygons(\n    output_image,\n    results[\"<REFERRING_EXPRESSION_SEGMENTATION>\"],\n    fill_mask=True,\n)\n\nresults = run_example(\n    task_prompt, text_input=\"a german sheppard\", image=dogs_cats\n)\noutput_image = copy.deepcopy(dogs_cats)\ndraw_polygons(\n    output_image,\n    results[\"<REFERRING_EXPRESSION_SEGMENTATION>\"],\n    fill_mask=True,\n)\n```\n\n\\noindent\n![](images/png/dog_bottle_seg.png){width=75% fig-align=\"center\"}\n\n```bash\n[INFO] ==> Florence-2-base\n(<REFERRING_EXPRESSION_SEGMENTATION>), took 207.0 seconds\nto execute each task.\n```\n\n### Region to Segmentation {#sec-visionlanguage-models-vlm-region-segmentation-1899}\n\nWith this task, it is also possible to give the object coordinates in the image to segment it. The input format is `'<loc_x1><loc_y1><loc_x2><loc_y2>', [x1, y1, x2, y2]` , which is the quantized coordinates in [0, 999].\n\nFor example, when running the code:\n\n```python\ntask_prompt = \"<CAPTION_TO_PHRASE_GROUNDING>\"\nresults = run_example(\n    task_prompt, text_input=\"a half orange\", image=table\n)\nresults\n```\n\nThe results were:\n\n```\n{'<CAPTION_TO_PHRASE_GROUNDING>': {'bboxes': [[343.552001953125,\n    689.6640625,\n    530.9440307617188,\n    873.9840698242188]],\n  'labels': ['a half']}}\n```\n\nUsing the bboxes rounded coordinates:\n\n```python\ntask_prompt = \"<REGION_TO_SEGMENTATION>\"\nresults = run_example(\n    task_prompt,\n    text_input=(\"<loc_343><loc_690>\" \"<loc_531><loc_874>\"),\n    image=table,\n)\noutput_image = copy.deepcopy(table)\ndraw_polygons(\n    output_image, results[\"<REGION_TO_SEGMENTATION>\"], fill_mask=True\n)\n```\n\nWe got the segmentation of the object on those coordinates (Latency: 83 seconds):\n\n\\noindent\n![](images/png/orange_seg.png){width=65% fig-align=\"center\"}\n\n### Region to Texts {#sec-visionlanguage-models-vlm-region-texts-d085}\n\nWe can also give the region (coordinates and ask for a caption):\n\n```python\ntask_prompt = \"<REGION_TO_CATEGORY>\"\nresults = run_example(\n    task_prompt,\n    text_input=(\"<loc_343><loc_690>\" \"<loc_531><loc_874>\"),\n    image=table,\n)\nresults\n```\n\n```python\n[INFO] ==> Florence-2-base (<REGION_TO_CATEGORY>), \\\ntook 14.3 seconds to execute.\n\n{{\n  '<REGION_TO_CATEGORY>':\n    'orange<loc_343><loc_690>'\n    '<loc_531><loc_874>'\n}\n```\n\nThe model identified an orange in that region. Let's ask for a description:\n\n```python\ntask_prompt = \"<REGION_TO_DESCRIPTION>\"\nresults = run_example(\n    task_prompt,\n    text_input=(\"<loc_343><loc_690>\" \"<loc_531><loc_874>\"),\n    image=table,\n)\nresults\n```\n\n```python\n[INFO] ==> Florence-2-base (<REGION_TO_CATEGORY>), \\\ntook 14.6 seconds to execute.\n\n{\n  '<REGION_TO_CATEGORY>':\n    'orange<loc_343><loc_690>'\n    '<loc_531><loc_874>'\n}\n```\n\nIn this case, the description did not provide more details, but it could. Try another example.\n\n### OCR {#sec-visionlanguage-models-vlm-ocr-708e}\n\nWith Florence-2, we can perform Optical Character Recognition (OCR) on an image, getting what is written on it (`task_prompt = '<OCR>'` and also get the bounding boxes (location) for the detected text (`ask_prompt = '<OCR_WITH_REGION>'`). Those tasks can help extract and locate textual information in images, such as reading signs, labels, or other forms of text in images.\n\nLet’s upload a flyer from a talk in Brazil to Raspi. Let’s test works in another language, here Portuguese):\n\n```python\nflayer = Image.open(\"./images/embarcados.jpg\")\n# Display the image\nplt.figure(figsize=(8, 8))\nplt.imshow(flayer)\nplt.axis(\"off\")\n# plt.title(\"Image\")\nplt.show()\n```\n\n\\noindent\n![](images/png/flyer.png){width=80% fig-align=\"center\"}\n\nLet's examine the image with `'<MORE_DETAILED_CAPTION>'` :\n\n```bash\n[INFO] ==> Florence-2-base (<MORE_DETAILED_CAPTION>), \\\ntook 85.2 seconds to execute.\n\n{'<MORE_DETAILED_CAPTION>': 'The image is a promotional poster \\\nfor an event called \"Machine Learning Embarcados\" hosted by \\\nMarcelo Roval. The poster has a black background with white \\\ntext. On the left side of the poster, there is a logo of a \\\ncoffee cup with the text \"Café Com Embarcados\" above it. \\\nBelow the logo, it says \"25 de Setembro as 17th\" which \\\ntranslates to \"25th of September as 17\" in English. \\n\\nOn \\\nthe right side, there are two smaller text boxes with the names \\\nof the participants and their names. The first text box reads \\\n\"Democratizando a Inteligência Artificial para Paises em \\\nDesenvolvimento\" and the second text box says \"Toda \\\nquarta-feira\" which is Portuguese for \"Transmissão via in \\\nPortuguese\".\\n\\nIn the center of the image, there has a photo \\\nof Marcelo, a man with a beard and glasses, smiling at the \\\ncamera. He is wearing a white hard hat and a white shirt. \\\nThe text boxes are in orange and yellow colors.'}\n```\n\nThe description is very accurate. Let's get to the more important words with the task OCR:\n\n```python\ntask_prompt = \"<OCR>\"\nrun_example(task_prompt, image=flayer)\n```\n\n```bash\n[INFO] ==> Florence-2-base (<OCR>), took 37.7 seconds to execute.\n\n{'<OCR>':\n 'Machine Learning Café com Embarcado Embarcados '\n 'Democratizando a Inteligência Artificial para Paises em '\n '25 de Setembro às 17h Desenvolvimento Toda quarta-feira '\n 'Marcelo Roval Professor na UNIFIEI e Transmissão via in '\n 'Co-Director do TinyML4D'}\n```\n\nLet's locate the words in the flyer:\n\n```python\ntask_prompt = \"<OCR_WITH_REGION>\"\nresults = run_example(task_prompt, image=flayer)\n```\n\nLet's also create a function to draw bounding boxes around the detected words:\n\n```python\ndef draw_ocr_bboxes(image, prediction):\n    scale = 1\n    draw = ImageDraw.Draw(image)\n    bboxes = prediction[\"quad_boxes\"]\n    labels = prediction[\"labels\"]\n    for box, label in zip(bboxes, labels):\n        color = random.choice(colormap)\n        new_box = (np.array(box) * scale).tolist()\n        draw.polygon(new_box, width=3, outline=color)\n        draw.text(\n            (new_box[0] + 8, new_box[1] + 2),\n            \"{}\".format(label),\n            align=\"right\",\n            fill=color,\n        )\n    display(image)\n```\n\n```python\noutput_image = copy.deepcopy(flayer)\ndraw_ocr_bboxes(output_image, results[\"<OCR_WITH_REGION>\"])\n```\n\n\\noindent\n![](images/png/output_ocr.png){width=80% fig-align=\"center\"}\n\nWe can inspect the detected words:\n\n```python\nresults[\"<OCR_WITH_REGION>\"][\"labels\"]\n```\n\n```bash\n'</s>Machine Learning',\n 'Café',\n 'com',\n 'Embarcado',\n 'Embarcados',\n 'Democratizando a Inteligência',\n 'Artificial para Paises em',\n '25 de Setembro ás 17h',\n 'Desenvolvimento',\n 'Toda quarta-feira',\n 'Marcelo Roval',\n 'Professor na UNIFIEI e',\n 'Transmissão via',\n 'in',\n 'Co-Director do TinyML4D']\n```\n\n## Latency Summary {#sec-visionlanguage-models-vlm-latency-summary-fec8}\n\nThe latency observed for different tasks using Florence-2 on the Raspberry Pi (Raspi-5) varied depending on the complexity of the task:\n\n- **Image Captioning**: It took approximately 16-17 seconds to generate a caption for an image.\n- **Detailed Captioning**: Increased latency to around 25-27 seconds, requiring generating more nuanced scene descriptions.\n- **More Detailed Captioning**: It took about 32-50 seconds, and the latency increased as the description grew more complex.\n- **Object Detection**: It took approximately 20-41 seconds, depending on the image’s complexity and the number of detected objects.\n- **Visual Grounding**: Approximately 15-16 seconds to localize specific objects based on textual prompts.\n- **OCR (Optical Character Recognition)**: Extracting text from an image took around 37-38 seconds.\n- **Segmentation and Region to Segmentation**: Segmentation tasks took considerably longer, with a latency of around 83-207 seconds, depending on the complexity and the number of regions to be segmented.\n\nThese latency times highlight the resource constraints of edge devices like the Raspberry Pi and emphasize the need to optimize the model and the environment to achieve real-time performance.\n\n\\noindent\n![](images/png/htop.png)\n\n> Running complex tasks can use all 8 GB of the Raspi-5's memory. For example, the above screenshot during the Florence OD task shows 4 CPUs at full speed and over 5 GB of memory in use. Consider increasing the SWAP memory to 2 GB.\n\nChecking the CPU temperature with `vcgencmd measure_temp` , showed that temperature can go up to +80oC.\n\n## Fine-Tuning {#sec-visionlanguage-models-vlm-finetunning-80d7}\n\nAs explored in this lab, Florence supports many tasks out of the box, including captioning, object detection, OCR, and more. However, like other pre-trained foundational models, Florence-2 may need domain-specific knowledge. For example, it may need to improve with medical or satellite imagery. In such cases, **fine-tuning** with a custom dataset is necessary. The Roboflow tutorial, [How to Fine-tune Florence-2 for Object Detection Tasks](https://blog.roboflow.com/fine-tune-florence-2-object-detection/), shows how to fine-tune Florence-2 on object detection datasets to improve model performance for our specific use case.\n\nBased on the above tutorial, it is possible to fine-tune the Florence-2 model to detect boxes and wheels used in previous labs:\n\n\\noindent\n![](images/png/fine-tuning.png)\n\nIt is important to note that after fine-tuning, the model can still detect classes that don't belong to our custom dataset, like cats, dogs, grapes, etc, as seen before).\n\nThe complete fine-tuning project using a previously annotated dataset in Roboflow and executed on CoLab can be found in the notebook:\n\n- [30-Finetune_florence_2_on_detection_dataset_box_vs_wheel.ipynb](https://github.com/Mjrovai/EdgeML-with-Raspberry-Pi/blob/main/FLORENCE-2/notebooks/30-Finetune_florence_2_on_detection_dataset_box_vs_wheel.ipynb)\n\nIn another example, in the post, [Fine-tuning Florence-2 - Microsoft's Cutting-edge Vision Language Models](https://huggingface.co/blog/finetune-florence2),  the authors show an example of fine-tuning Florence on `DocVQA`. The authors report that Florence 2 can perform visual question answering (VQA), but the released models don't include VQA capability.\n\n## Summary {#sec-visionlanguage-models-vlm-summary-012c}\n\nFlorence-2 offers a versatile and powerful approach to vision-language tasks at the edge, providing performance that rivals larger, task-specific models, such as YOLO for object detection, BERT/RoBERTa for text analysis, and specialized OCR models.\n\nThanks to its multi-modal transformer architecture, Florence-2 is more flexible than YOLO in terms of the tasks it can handle. These include object detection, image captioning, and visual grounding.\n\nUnlike **BERT**, which focuses purely on language, Florence-2 integrates vision and language, allowing it to excel in applications that require both modalities, such as image captioning and visual grounding.\n\nMoreover, while traditional **OCR models** such as Tesseract and EasyOCR are designed solely for recognizing and extracting text from images, Florence-2’s OCR capabilities are part of a broader framework that includes contextual understanding and visual-text alignment. This makes it particularly useful for scenarios that require both reading text and interpreting its context within images.\n\nOverall, Florence-2 stands out for its ability to seamlessly integrate various vision-language tasks into a unified model that is efficient enough to run on edge devices like the Raspberry Pi. This makes it a compelling choice for developers and researchers exploring AI applications at the edge.\n\n### Key Advantages of Florence-2 {#sec-visionlanguage-models-vlm-key-advantages-florence2-0a83}\n\n1. **Unified Architecture**\n   - Single model handles multiple vision tasks vs. specialized models (YOLO, BERT, Tesseract)\n   - Eliminates the need for multiple model deployments and integrations\n   - Consistent API and interface across tasks\n\n2. **Performance Comparison**\n   - Object Detection: Comparable to YOLOv8 (~37.5 mAP on COCO vs. YOLOv8's ~39.7 mAP) despite being general-purpose\n   - Text Recognition: Handles multiple languages effectively like specialized OCR models (Tesseract, EasyOCR)\n   - Language Understanding: Integrates BERT-like capabilities for text processing while adding visual context\n\n3. **Resource Efficiency**\n   - The Base model (232M parameters) achieves strong results despite smaller size\n   - Runs effectively on edge devices (Raspberry Pi)\n   - Single model deployment vs. multiple specialized models\n\n### Trade-offs {#sec-visionlanguage-models-vlm-tradeoffs-8964}\n\n1. **Performance vs. Specialized Models**\n   - YOLO series may offer faster inference for pure object detection\n   - Specialized OCR models might handle complex document layouts better\n   - BERT/RoBERTa provide deeper language understanding for text-only tasks\n\n2. **Resource Requirements**\n   - Higher latency on edge devices (15-200s depending on task)\n   - Requires careful memory management on Raspberry Pi\n   - It may need optimization for real-time applications\n\n3. **Deployment Considerations**\n   - Initial setup is more complex than single-purpose models\n   - Requires understanding of multiple task types and prompts\n   - The learning curve for optimal prompt engineering\n\n### Best Use Cases {#sec-visionlanguage-models-vlm-best-use-cases-e73b}\n\n1. **Resource-Constrained Environments**\n   - Edge devices requiring multiple vision capabilities\n   - Systems with limited storage/deployment capacity\n   - Applications needing flexible vision processing\n\n2. **Multi-modal Applications**\n   - Content moderation systems\n   - Accessibility tools\n   - Document analysis workflows\n\n3. **Rapid Prototyping**\n   - Quick deployment of vision capabilities\n   - Testing multiple vision tasks without separate models\n   - Proof-of-concept development\n\n## Future Implications {#sec-visionlanguage-models-vlm-future-implications-2fe6}\n\nFlorence-2 represents a shift toward unified vision models that could eventually replace task-specific architectures in many applications. While specialized models maintain advantages in specific scenarios, the convenience and efficiency of unified models like Florence-2 make them increasingly attractive for real-world deployments.\n\nThe lab demonstrates Florence-2's viability on edge devices, suggesting future IoT, mobile computing, and embedded systems applications where deploying multiple specialized models would be impractical.\n\n## Resources {#sec-visionlanguage-models-vlm-resources-fb6a}\n\n- [10-florence2_test.ipynb](https://github.com/Mjrovai/EdgeML-with-Raspberry-Pi/blob/main/FLORENCE-2/notebooks/10-florence2_test.ipynb)\n- [20-florence_2.ipynb](https://github.com/Mjrovai/EdgeML-with-Raspberry-Pi/blob/main/FLORENCE-2/notebooks/20-florence_2.ipynb)\n\n- [30-Finetune_florence_2_on_detection_dataset_box_vs_wheel.ipynb](https://github.com/Mjrovai/EdgeML-with-Raspberry-Pi/blob/main/FLORENCE-2/notebooks/30-Finetune_florence_2_on_detection_dataset_box_vs_wheel.ipynb)\n\n```{=latex}\n\\part{key:shared}\n```\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":3,"number-sections":false,"highlight-style":"github","include-after-body":[{"text":"<script src=\"assets/scripts/subscribe-modal.js\" defer></script>\n"}],"output-file":"vlm.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.25","theme":{"light":["default","../../../assets/styles/style.scss"],"dark":["default","../../../assets/styles/style.scss","../../../assets/styles/dark-mode.scss"]},"respect-user-color-scheme":true,"code-copy":true,"anchor-sections":true},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}