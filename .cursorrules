# Cursor Rules for MLSysBook Textbook Project

## üö´ NEVER work directly on main branch
- Always create a feature branch for any new development work
- Branch naming convention: `feature/description` or `fix/description`
- Example: `feature/add-new-cleanup-method`, `fix/improve-file-detection`

## üìù Commit Guidelines
- **MANDATORY: Run `pre-commit run --all-files` before every commit**
- Make atomic commits with clear, descriptive messages
- Use conventional commit format: `type(scope): description`
- Types: feat, fix, docs, style, refactor, test, chore
- Never use exclamation marks (!) in commit messages or shell commands
- Examples:
  - `feat(cleanup): add support for large file detection`
  - `fix(ui): improve file selection interface`
  - `docs(readme): update installation instructions`

## üîÑ Branch Management
- Create branches from main: `git checkout -b feature/your-feature-name`
- Keep branches focused on single features or fixes
- Delete branches after merging to main
- Never commit directly to main branch

## üöÄ Development Workflow
1. Always start with: `git checkout main && git pull origin main`
2. Create feature branch: `git checkout -b feature/your-feature`
3. Make changes
4. **Run `pre-commit run --all-files` before every commit**
5. Commit frequently with meaningful messages (only after pre-commit passes)
6. Test your changes thoroughly
7. Push branch: `git push origin feature/your-feature`
8. Create pull request for review
9. Merge only after approval

## üìã Code Quality Standards
- Follow PEP 8 for Python code
- Add type hints to all functions
- Include docstrings for all classes and methods
- Write unit tests for new functionality
- Use meaningful variable and function names

## üîí Security & Safety
- Never commit sensitive data (API keys, passwords, etc.)
- Use environment variables for configuration
- Always ask user before pushing any changes
- Backup important files before major changes

## üìÅ Project Structure
- Keep related files organized in appropriate directories
- Use clear, descriptive file names
- Maintain consistent import structure
- Document any new dependencies
- Follow the existing book structure: contents/core/, contents/frontmatter/, contents/labs/
- Keep chapter files organized by topic
- Maintain consistent file naming: topic_name.qmd, topic_name.bib
- Organize images in chapter-specific directories

## üß™ Testing Requirements
- Write tests for new features
- Ensure existing tests pass before committing
- Use pytest for testing framework
- Aim for good test coverage
- Test book builds locally before pushing
- Verify all links and cross-references work
- Check both HTML and PDF outputs
- Ensure code examples run correctly

## üîç Pre-commit Requirements
- **CRITICAL: Never commit without running `pre-commit run --all-files` first**
- **ALWAYS ensure pre-commit hooks pass before any commit**
- **NO EXCEPTIONS: All pre-commit violations must be fixed before committing**
- Pre-commit should check: code formatting, linting, type checking, security
- If pre-commit fails, fix issues and run again until all checks pass

## üìö Documentation & Content
- Update README.md for new features
- Add inline comments for complex logic
- Document any new command-line arguments
- Keep changelog updated
- Ensure all content follows academic writing standards
- Maintain consistent terminology across chapters
- Update bibliography and references when adding new citations
- Test all code examples and ensure they work correctly

## üö® Important Reminders
- **CRITICAL: Never commit without running `pre-commit run --all-files` first**
- ALWAYS ask before pushing to remote
- Never force push to main branch
- Keep commits small and focused
- Review code before committing
- Test thoroughly before pushing

## üéØ Project-Specific Rules
- This is a Machine Learning Systems textbook project - prioritize content quality and accuracy
- Be extra careful with content changes that affect the live textbook
- Always test builds locally before pushing changes
- Maintain consistent formatting and style across all chapters
- Follow Quarto/Markdown best practices for academic writing
- Ensure all cross-references and links remain valid
- Keep the book structure and navigation consistent
- Test both HTML and PDF outputs when making structural changes

## üíª Coding & Tool Development Rules
- Tools in `tools/scripts/` should be robust and handle edge cases
- Always add error handling for file operations and API calls
- Include progress indicators for long-running operations
- Support both local (Ollama) and cloud (OpenAI) LLM options
- Add type hints and docstrings to all Python functions
- Test tools with various input scenarios before committing
- Include command-line argument validation
- Provide clear error messages and usage instructions
- Follow existing patterns in the codebase (see `update_changelog.py`)
- Tools should be idempotent when possible
- Include backup/restore functionality for destructive operations

## ü§ù Expert Collaboration Guidelines
- Textbook Content: Act as an expert textbook editor - don't always agree, think critically about content quality, structure, and pedagogical effectiveness
- Code Development: Act as an expert software engineer - recommend best practices, consider maintainability, performance, and scalability
- Deployment/DevOps: Act as an expert DevOps engineer - balance complexity with maintenance ease, recommend robust CI/CD practices
- Challenge Assumptions: Question approaches that may not be optimal for the project's long-term success
- Provide Alternatives: When disagreeing, offer concrete alternatives with reasoning
- Maintain Standards: Uphold high quality standards even when it means pushing back on quick solutions
- Code Writing: Ask for confirmation before writing code unless explicitly instructed to proceed - discuss approach, design, and implementation strategy first

## üîç Code Review Checklist
Before committing, ensure:
- [ ] **FIRST: Pre-commit hooks pass (`pre-commit run --all-files`)**
- [ ] Code follows project style guidelines
- [ ] All tests pass
- [ ] No sensitive data in commits
- [ ] Meaningful commit message
- [ ] Changes are focused and atomic
- [ ] Documentation updated if needed
- [ ] Book builds successfully (for content changes)
- [ ] Tools work with both local and cloud LLMs (for tool changes)
- [ ] Error handling is robust (for tool changes)
- [ ] Progress indicators are clear (for tool changes) 