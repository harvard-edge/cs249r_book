"use strict";(self.webpackChunkinjectchat=self.webpackChunkinjectchat||[]).push([[384],{384:(t,e,r)=>{r.r(e),r.d(e,{delete_row:()=>j,initiate:()=>l,quickStart:()=>b,quickStart_single:()=>m,search:()=>w,update:()=>p});let o={dbName:"vectorDB_new",objectStore:"vectors",hyperplanes:10,dimensions:384,numPlanes:5};class s{constructor(t,e,r=5){this.numTables=r,this.tables=Array.from({length:r},(()=>Array.from({length:e},(()=>function(t){return Array.from({length:t},(()=>Math.random()-.5))}(t)))))}hashVector(t){return this.tables.map((e=>e.map((e=>t.reduce(((t,r,o)=>t+r*e[o]),0)>=0?"1":"0")).join("")))}}function n(t,e){1===t.length&&(t=t[0]);return t.reduce(((t,r,o)=>t+r*e[o]),0)/(Math.sqrt(t.reduce(((t,e)=>t+e*e),0))*Math.sqrt(e.reduce(((t,e)=>t+e*e),0)))}class c{#t;#e;#r;#o;constructor(t={}){const{dbName:e,objectStore:r,vectorPath:n,dimensions:c,numPlanes:a}={...o,...t};this.#t=r,this.#e=n,this.#o=new s(c,a),this.#r=function(t){const{dbName:e,objectStore:r,vectorPath:s}={...o,...t};return new Promise(((t,o)=>{const s=indexedDB.open(e,2);s.onupgradeneeded=t=>{const e=t.target.result;e.objectStoreNames.contains(r)||e.createObjectStore(r,{autoIncrement:!0});const o=`${r}_hashIndex`;e.objectStoreNames.contains(o)||e.createObjectStore(o,{autoIncrement:!0})},s.onsuccess=e=>{t(e.target.result)},s.onerror=t=>{o(t.target.error)}}))}({dbName:e,objectStore:r,vectorPath:n})}async insert(t){const e=t[this.#e];if(!(Array.isArray(e)||e instanceof Int8Array))throw new Error(`${this.#e} on 'object' is expected to be an Array or Int8Array`);const r=(await this.#r).transaction([this.#t,`${this.#t}_hashIndex`],"readwrite"),o=r.objectStore(this.#t),s=r.objectStore(`${this.#t}_hashIndex`);try{const r=o.add(t),n=await new Promise(((t,e)=>{r.onsuccess=()=>t(r.result),r.onerror=()=>e(r.error)})),c=this.#o.hashVector(e);for(let t of c){const e=await new Promise(((e,r)=>{const o=s.get(t);o.onsuccess=()=>e(o.result||[]),o.onerror=()=>r(o.error)}));e.push(n),await new Promise(((r,o)=>{const n=s.put(e,t);n.onsuccess=()=>r(),n.onerror=()=>o(n.error)}))}return n}catch(t){throw t}}async delete(t){if(null==t)throw new Error("Unable to delete object without a key");const e=(await this.#r).transaction([this.#t,`${this.#t}_hashIndex`],"readwrite"),r=e.objectStore(this.#t),o=e.objectStore(`${this.#t}_hashIndex`),s=await new Promise(((e,o)=>{const s=r.get(t);s.onsuccess=()=>e(s.result),s.onerror=()=>o(s.error)}));if(!s)throw new Error("Object not found with the provided key");const n=s[this.#e],c=this.#o.hashVector(n);return await Promise.all(c.map((e=>this.removeFromBucket(o,t,e)))),new Promise(((e,o)=>{const s=r.delete(t);s.onsuccess=()=>e(),s.onerror=()=>o(s.error)}))}async removeFromBucket(t,e,r){const o=await new Promise(((e,o)=>{const s=t.get(r);s.onsuccess=()=>e(s.result||[]),s.onerror=()=>o(s.error)})),s=o.indexOf(e);-1!==s&&(o.splice(s,1),await new Promise(((e,s)=>{const n=t.put(o,r);n.onsuccess=()=>e(),n.onerror=()=>s(n.error)})))}async update(t,e){if(null==t)throw new Error("Unable to update object without a key");if(!(this.#e in e))throw new Error(`${this.#e} expected to be present in the object being updated`);if(!(Array.isArray(e[this.#e])||e[this.#e]instanceof Int8Array))throw new Error(`${this.#e} on 'object' is expected to be an Array or Int8Array`);const r=(await this.#r).transaction([this.#t,`${this.#t}_hashIndex`],"readwrite"),o=r.objectStore(this.#t),s=r.objectStore(`${this.#t}_hashIndex`),n=o.get(t);return new Promise(((r,c)=>{n.onsuccess=async()=>{const a=n.result;if(!a)return void c(new Error("Object not found with the provided key"));const i=this.#o.hashVector(a[this.#e]),h=this.#o.hashVector(e[this.#e]),u=o.put(e,t);u.onsuccess=async()=>{try{for(let e=0;e<this.#o.numTables;e++)i[e]!==h[e]&&await this.updateHashIndex(s,t,i[e],h[e]);r(u.result)}catch(t){c(t)}},u.onerror=()=>c(u.error)},n.onerror=()=>c(n.error)}))}async updateHashIndex(t,e,r,o){const s=t.get(r),n=await new Promise(((t,e)=>{s.onsuccess=()=>t(s.result||[]),s.onerror=()=>e(s.error)})),c=n.indexOf(e);-1!==c&&(n.splice(c,1),await t.put(n,r));const a=t.get(o),i=await new Promise(((t,e)=>{a.onsuccess=()=>t(a.result||[]),a.onerror=()=>e(a.error)}));i.push(e),await t.put(i,o)}async query(t,e={limit:10}){const{limit:r}=e;let o=new Set,s=[];try{const e=(await this.#r).transaction([this.#t,`${this.#t}_hashIndex`],"readonly"),c=e.objectStore(this.#t),a=e.objectStore(`${this.#t}_hashIndex`),i=this.#o.hashVector(t);for(let e of i){const r=await new Promise(((t,r)=>{const o=a.get(e);o.onsuccess=()=>t(o.result||[]),o.onerror=()=>r(o.error)}));for(let e of r)if(!o.has(e)){o.add(e);const r=await new Promise(((t,r)=>{const o=c.get(e);o.onsuccess=()=>t(o.result),o.onerror=()=>r(o.error)})),a=n(t,r[this.#e]);s.push({object:r,key:e,similarity:a})}}return s.sort(((t,e)=>e.similarity-t.similarity)),s.slice(0,r)}catch(t){throw t}}get objectStore(){return this.#t}}const a="https://tinymlbackend3.azurewebsites.net/api/embeddings-binary";function i(t,e){return fetch(a,{method:"POST",headers:{Authorization:`Bearer ${e}`,"Content-Type":"application/json"},body:JSON.stringify({text:t})}).then((t=>{if(!t.ok)throw new Error(`HTTP error! status: ${t.status}`);return t.json()})).catch((t=>{}))}const h=new class{constructor(t,e,r="\n\n"){this.interval=t,this.overlap=e,this.charToSplit=r}split(t){const e=[],r=t.split(this.charToSplit);let o=[],s=0;return r.forEach((t=>{(t.match(/\w+|[^\w\s]+/g)||[]).forEach((t=>{s+t.length+1>this.interval&&(e.push(o.join(" ")),o=o.slice(-this.overlap),s=o.join(" ").length+1),o.push(t),s+=t.length+1}))})),o.length>0&&e.push(o.join(" ")),e}}(200,20,"\n\n");let u;const d=[];async function l(t){var e;return e={dbName:t},o={...o,...e},u=new c({vectorPath:"embedding"}),o}async function b(t,e,r=!0){const{text:o,...s}=t,n=h.split(o);let c;c=await i(n,e);for(let e=0;e<n.length;e++){const{text:r,...o}=t;o.text=n[e];const s=await u.insert({embedding:c[e],...o});d.push({key:s,...o})}return d}async function w(t,e={limit:5},r,o=!0){let s;s=await i(t,r);return await u.query(s,e)}async function m(t,e,r=!0){const{text:o,...s}=t,n=i([o],e),c=await u.insert({embedding:n,text:o,...s});return d.push({key:c,...s}),d}async function j(t){return await u.delete(t)}async function p(t,e,r){const o=e.text;if(!e.embedding){const t=await i([o],r);e.embedding=t}return await u.update(t,{embedding:text_embeddings,metaData:e})}}}]);