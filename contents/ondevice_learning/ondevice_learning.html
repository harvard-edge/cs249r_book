<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Machine Learning Systems - 13&nbsp; On-Device Learning</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../contents/ops/ops.html" rel="next">
<link href="../../contents/benchmarking/benchmarking.html" rel="prev">
<link href="../../favicon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-M21L0CBCVN"></script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Machine Learning Systems</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-wide">
    <a href="https://github.com/harvard-edge/cs249r_book" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <div class="dropdown">
      <a href="" title="Download" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download"><i class="bi bi-download"></i></a>
      <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item quarto-navbar-tools-item" href="../../Machine-Learning-Systems.pdf">
              <i class="bi bi-bi-file-pdf pe-1"></i>
            Download PDF
            </a>
          </li>
          <li>
            <a class="dropdown-item quarto-navbar-tools-item" href="../../Machine-Learning-Systems.epub">
              <i class="bi bi-bi-journal pe-1"></i>
            Download ePub
            </a>
          </li>
      </ul>
    </div>
    <div class="dropdown">
      <a href="" title="Share" id="quarto-navigation-tool-dropdown-1" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Share"><i class="bi bi-share"></i></a>
      <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="quarto-navigation-tool-dropdown-1">
          <li>
            <a class="dropdown-item quarto-navbar-tools-item" href="https://twitter.com/intent/tweet?url=|url|">
              <i class="bi bi-bi-twitter pe-1"></i>
            Twitter
            </a>
          </li>
          <li>
            <a class="dropdown-item quarto-navbar-tools-item" href="https://www.facebook.com/sharer/sharer.php?u=|url|">
              <i class="bi bi-bi-facebook pe-1"></i>
            Facebook
            </a>
          </li>
      </ul>
    </div>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../contents/introduction.html">MAIN</a></li><li class="breadcrumb-item"><a href="../../contents/ondevice_learning/ondevice_learning.html"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">On-Device Learning</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">FRONT MATTER</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/dedication.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Dedication</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/acknowledgements.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Acknowledgements</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/contributors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Contributors</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/copyright.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Copyright</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/about.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About the Book</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">MAIN</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/embedded_sys/embedded_sys.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Embedded Systems</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/dl_primer/dl_primer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Deep Learning Primer</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/embedded_ml/embedded_ml.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Embedded AI</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/workflow/workflow.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">AI Workflow</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/data_engineering/data_engineering.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Data Engineering</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/frameworks/frameworks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">AI Frameworks</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/training/training.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">AI Training</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/efficient_ai/efficient_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Efficient AI</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/optimizations/optimizations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Model Optimizations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/hw_acceleration/hw_acceleration.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">AI Acceleration</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/benchmarking/benchmarking.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Benchmarking AI</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/ondevice_learning/ondevice_learning.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">On-Device Learning</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/ops/ops.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Embedded AIOps</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/privacy_security/privacy_security.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Security &amp; Privacy</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/responsible_ai/responsible_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Responsible AI</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/sustainable_ai/sustainable_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Sustainable AI</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/ai_for_good/ai_for_good.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">AI for Good</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/robust_ai/robust_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Robust AI</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/generative_ai/generative_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Generative AI</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">REFERENCES</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true">
 <span class="menu-text">EXERCISES</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/niclav_sys/niclav_sys.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Setup Nicla Vision</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/image_classification/image_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">CV on Nicla Vision</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/object_detection_fomo/object_detection_fomo.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Object Detection</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/kws_feature_eng/kws_feature_eng.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Audio Feature Engineering</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/kws_nicla/kws_nicla.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Keyword Spotting (KWS)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/dsp_spectral_features_block/dsp_spectral_features_block.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">DSP - Spectral Features</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/motion_classify_ad/motion_classify_ad.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Motion Classification and Anomaly Detection</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/tools.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Tools</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/zoo_datasets.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Datasets</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/zoo_models.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Model Zoo</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/learning_resources.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">Resources</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/community.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">E</span>&nbsp; <span class="chapter-title">Communities</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../contents/case_studies.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">F</span>&nbsp; <span class="chapter-title">Case Studies</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">13.1</span> Introduction</a></li>
  <li><a href="#advantages-and-limitations" id="toc-advantages-and-limitations" class="nav-link" data-scroll-target="#advantages-and-limitations"><span class="header-section-number">13.2</span> Advantages and Limitations</a>
  <ul>
  <li><a href="#benefits" id="toc-benefits" class="nav-link" data-scroll-target="#benefits"><span class="header-section-number">13.2.1</span> Benefits</a>
  <ul class="collapse">
  <li><a href="#privacy-and-data-security" id="toc-privacy-and-data-security" class="nav-link" data-scroll-target="#privacy-and-data-security">Privacy and Data Security</a></li>
  <li><a href="#regulatory-compliance" id="toc-regulatory-compliance" class="nav-link" data-scroll-target="#regulatory-compliance">Regulatory Compliance</a></li>
  <li><a href="#reduced-bandwidth-costs-and-increased-efficiency" id="toc-reduced-bandwidth-costs-and-increased-efficiency" class="nav-link" data-scroll-target="#reduced-bandwidth-costs-and-increased-efficiency">Reduced Bandwidth, Costs, and Increased Efficiency</a></li>
  </ul></li>
  <li><a href="#limitations" id="toc-limitations" class="nav-link" data-scroll-target="#limitations"><span class="header-section-number">13.2.2</span> Limitations</a>
  <ul class="collapse">
  <li><a href="#compute-resources" id="toc-compute-resources" class="nav-link" data-scroll-target="#compute-resources">Compute resources</a></li>
  <li><a href="#dataset-size-accuracy-and-generalization" id="toc-dataset-size-accuracy-and-generalization" class="nav-link" data-scroll-target="#dataset-size-accuracy-and-generalization">Dataset Size, Accuracy, and Generalization</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#on-device-adaptation" id="toc-on-device-adaptation" class="nav-link" data-scroll-target="#on-device-adaptation"><span class="header-section-number">13.3</span> On-device Adaptation</a>
  <ul>
  <li><a href="#reducing-model-complexity" id="toc-reducing-model-complexity" class="nav-link" data-scroll-target="#reducing-model-complexity"><span class="header-section-number">13.3.1</span> Reducing Model Complexity</a>
  <ul class="collapse">
  <li><a href="#traditional-ml-algorithms" id="toc-traditional-ml-algorithms" class="nav-link" data-scroll-target="#traditional-ml-algorithms">Traditional ML Algorithms</a></li>
  <li><a href="#pruning" id="toc-pruning" class="nav-link" data-scroll-target="#pruning">Pruning</a></li>
  <li><a href="#reducing-complexity-of-deep-learning-models" id="toc-reducing-complexity-of-deep-learning-models" class="nav-link" data-scroll-target="#reducing-complexity-of-deep-learning-models">Reducing Complexity of Deep Learning Models</a></li>
  </ul></li>
  <li><a href="#modifying-optimization-processes" id="toc-modifying-optimization-processes" class="nav-link" data-scroll-target="#modifying-optimization-processes"><span class="header-section-number">13.3.2</span> Modifying Optimization Processes</a>
  <ul class="collapse">
  <li><a href="#quantization-aware-scaling" id="toc-quantization-aware-scaling" class="nav-link" data-scroll-target="#quantization-aware-scaling">Quantization-Aware Scaling</a></li>
  <li><a href="#sparse-updates" id="toc-sparse-updates" class="nav-link" data-scroll-target="#sparse-updates">Sparse Updates</a></li>
  <li><a href="#layer-wise-training" id="toc-layer-wise-training" class="nav-link" data-scroll-target="#layer-wise-training">Layer-Wise Training</a></li>
  <li><a href="#trading-computation-for-memory" id="toc-trading-computation-for-memory" class="nav-link" data-scroll-target="#trading-computation-for-memory">Trading Computation for Memory</a></li>
  </ul></li>
  <li><a href="#developing-new-data-representations" id="toc-developing-new-data-representations" class="nav-link" data-scroll-target="#developing-new-data-representations"><span class="header-section-number">13.3.3</span> Developing New Data Representations</a>
  <ul class="collapse">
  <li><a href="#data-compression" id="toc-data-compression" class="nav-link" data-scroll-target="#data-compression">Data Compression</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#transfer-learning" id="toc-transfer-learning" class="nav-link" data-scroll-target="#transfer-learning"><span class="header-section-number">13.4</span> Transfer Learning</a>
  <ul>
  <li><a href="#pre-deployment-specialization" id="toc-pre-deployment-specialization" class="nav-link" data-scroll-target="#pre-deployment-specialization"><span class="header-section-number">13.4.1</span> Pre-Deployment Specialization</a></li>
  <li><a href="#post-deployment-adaptation" id="toc-post-deployment-adaptation" class="nav-link" data-scroll-target="#post-deployment-adaptation"><span class="header-section-number">13.4.2</span> Post-Deployment Adaptation</a></li>
  <li><a href="#benefits-1" id="toc-benefits-1" class="nav-link" data-scroll-target="#benefits-1"><span class="header-section-number">13.4.3</span> Benefits</a></li>
  <li><a href="#core-concepts" id="toc-core-concepts" class="nav-link" data-scroll-target="#core-concepts"><span class="header-section-number">13.4.4</span> Core Concepts</a>
  <ul class="collapse">
  <li><a href="#source-and-target-tasks" id="toc-source-and-target-tasks" class="nav-link" data-scroll-target="#source-and-target-tasks">Source and Target Tasks</a></li>
  <li><a href="#representation-transfer" id="toc-representation-transfer" class="nav-link" data-scroll-target="#representation-transfer">Representation Transfer</a></li>
  <li><a href="#fine-tuning" id="toc-fine-tuning" class="nav-link" data-scroll-target="#fine-tuning">Fine-Tuning</a></li>
  <li><a href="#feature-extractions" id="toc-feature-extractions" class="nav-link" data-scroll-target="#feature-extractions">Feature Extractions</a></li>
  </ul></li>
  <li><a href="#types-of-transfer-learning" id="toc-types-of-transfer-learning" class="nav-link" data-scroll-target="#types-of-transfer-learning"><span class="header-section-number">13.4.5</span> Types of Transfer Learning</a>
  <ul class="collapse">
  <li><a href="#inductive-transfer-learning" id="toc-inductive-transfer-learning" class="nav-link" data-scroll-target="#inductive-transfer-learning">Inductive Transfer Learning</a></li>
  <li><a href="#transductive-transfer-learning" id="toc-transductive-transfer-learning" class="nav-link" data-scroll-target="#transductive-transfer-learning">Transductive Transfer Learning</a></li>
  <li><a href="#unsupervised-transfer-learning" id="toc-unsupervised-transfer-learning" class="nav-link" data-scroll-target="#unsupervised-transfer-learning">Unsupervised Transfer Learning</a></li>
  <li><a href="#comparison-and-trade-offs" id="toc-comparison-and-trade-offs" class="nav-link" data-scroll-target="#comparison-and-trade-offs">Comparison and Trade-offs</a></li>
  </ul></li>
  <li><a href="#constraints-and-considerations" id="toc-constraints-and-considerations" class="nav-link" data-scroll-target="#constraints-and-considerations"><span class="header-section-number">13.4.6</span> Constraints and Considerations</a>
  <ul class="collapse">
  <li><a href="#domain-similarity" id="toc-domain-similarity" class="nav-link" data-scroll-target="#domain-similarity">Domain Similarity</a></li>
  <li><a href="#task-similarity" id="toc-task-similarity" class="nav-link" data-scroll-target="#task-similarity">Task Similarity</a></li>
  <li><a href="#data-quality-and-quantity" id="toc-data-quality-and-quantity" class="nav-link" data-scroll-target="#data-quality-and-quantity">Data Quality and Quantity</a></li>
  <li><a href="#feature-space-overlap" id="toc-feature-space-overlap" class="nav-link" data-scroll-target="#feature-space-overlap">Feature Space Overlap</a></li>
  <li><a href="#model-complexity" id="toc-model-complexity" class="nav-link" data-scroll-target="#model-complexity">Model Complexity</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec-fl" id="toc-sec-fl" class="nav-link" data-scroll-target="#sec-fl"><span class="header-section-number">13.5</span> Federated Machine Learning</a>
  <ul>
  <li><a href="#communication-efficiency" id="toc-communication-efficiency" class="nav-link" data-scroll-target="#communication-efficiency"><span class="header-section-number">13.5.1</span> Communication Efficiency</a></li>
  <li><a href="#model-compression" id="toc-model-compression" class="nav-link" data-scroll-target="#model-compression"><span class="header-section-number">13.5.2</span> Model Compression</a></li>
  <li><a href="#selective-update-sharing" id="toc-selective-update-sharing" class="nav-link" data-scroll-target="#selective-update-sharing"><span class="header-section-number">13.5.3</span> Selective Update Sharing</a></li>
  <li><a href="#optimized-aggregation" id="toc-optimized-aggregation" class="nav-link" data-scroll-target="#optimized-aggregation"><span class="header-section-number">13.5.4</span> Optimized Aggregation</a></li>
  <li><a href="#handling-non-iid-data" id="toc-handling-non-iid-data" class="nav-link" data-scroll-target="#handling-non-iid-data"><span class="header-section-number">13.5.5</span> Handling non-IID Data</a></li>
  <li><a href="#client-selection" id="toc-client-selection" class="nav-link" data-scroll-target="#client-selection"><span class="header-section-number">13.5.6</span> Client Selection</a></li>
  <li><a href="#an-example-of-deployed-federated-learning-g-board" id="toc-an-example-of-deployed-federated-learning-g-board" class="nav-link" data-scroll-target="#an-example-of-deployed-federated-learning-g-board"><span class="header-section-number">13.5.7</span> An Example of Deployed Federated Learning: G board</a></li>
  <li><a href="#benchmarking-for-federated-learning-medperf" id="toc-benchmarking-for-federated-learning-medperf" class="nav-link" data-scroll-target="#benchmarking-for-federated-learning-medperf"><span class="header-section-number">13.5.8</span> Benchmarking for Federated Learning: MedPerf</a></li>
  </ul></li>
  <li><a href="#security-concerns" id="toc-security-concerns" class="nav-link" data-scroll-target="#security-concerns"><span class="header-section-number">13.6</span> Security Concerns</a>
  <ul>
  <li><a href="#data-poisoning" id="toc-data-poisoning" class="nav-link" data-scroll-target="#data-poisoning"><span class="header-section-number">13.6.1</span> Data Poisoning</a></li>
  <li><a href="#adversarial-attacks" id="toc-adversarial-attacks" class="nav-link" data-scroll-target="#adversarial-attacks"><span class="header-section-number">13.6.2</span> Adversarial Attacks</a></li>
  <li><a href="#model-inversion" id="toc-model-inversion" class="nav-link" data-scroll-target="#model-inversion"><span class="header-section-number">13.6.3</span> Model Inversion</a></li>
  <li><a href="#on-device-learning-security-concerns" id="toc-on-device-learning-security-concerns" class="nav-link" data-scroll-target="#on-device-learning-security-concerns"><span class="header-section-number">13.6.4</span> On-Device Learning Security Concerns</a></li>
  <li><a href="#mitigation-of-on-device-learning-risks" id="toc-mitigation-of-on-device-learning-risks" class="nav-link" data-scroll-target="#mitigation-of-on-device-learning-risks"><span class="header-section-number">13.6.5</span> Mitigation of On-Device Learning Risks</a></li>
  <li><a href="#securing-training-data" id="toc-securing-training-data" class="nav-link" data-scroll-target="#securing-training-data"><span class="header-section-number">13.6.6</span> Securing Training Data</a>
  <ul class="collapse">
  <li><a href="#encryption" id="toc-encryption" class="nav-link" data-scroll-target="#encryption">Encryption</a></li>
  <li><a href="#differential-privacy" id="toc-differential-privacy" class="nav-link" data-scroll-target="#differential-privacy">Differential Privacy</a></li>
  <li><a href="#anomaly-detection" id="toc-anomaly-detection" class="nav-link" data-scroll-target="#anomaly-detection">Anomaly Detection</a></li>
  <li><a href="#input-data-validation" id="toc-input-data-validation" class="nav-link" data-scroll-target="#input-data-validation">Input Data Validation</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#on-device-training-frameworks" id="toc-on-device-training-frameworks" class="nav-link" data-scroll-target="#on-device-training-frameworks"><span class="header-section-number">13.7</span> On-Device Training Frameworks</a>
  <ul>
  <li><a href="#tiny-training-engine" id="toc-tiny-training-engine" class="nav-link" data-scroll-target="#tiny-training-engine"><span class="header-section-number">13.7.1</span> Tiny Training Engine</a></li>
  <li><a href="#tiny-transfer-learning" id="toc-tiny-transfer-learning" class="nav-link" data-scroll-target="#tiny-transfer-learning"><span class="header-section-number">13.7.2</span> Tiny Transfer Learning</a></li>
  <li><a href="#tiny-train" id="toc-tiny-train" class="nav-link" data-scroll-target="#tiny-train"><span class="header-section-number">13.7.3</span> Tiny Train</a></li>
  <li><a href="#comparison" id="toc-comparison" class="nav-link" data-scroll-target="#comparison"><span class="header-section-number">13.7.4</span> Comparison</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">13.8</span> Conclusion</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/harvard-edge/cs249r_book/edit/main/contents/ondevice_learning/ondevice_learning.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/harvard-edge/cs249r_book/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li><li><a href="https://github.com/harvard-edge/cs249r_book/blob/main/contents/ondevice_learning/ondevice_learning.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../contents/introduction.html">MAIN</a></li><li class="breadcrumb-item"><a href="../../contents/ondevice_learning/ondevice_learning.html"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">On-Device Learning</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">On-Device Learning</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/png/cover_ondevice_learning.png" class="img-fluid figure-img"></p>
<figcaption><em>DALL·E 3 Prompt: Drawing of a smartphone with its internal components exposed, revealing diverse miniature engineers of different genders and skin tones actively working on the ML model. The engineers, including men, women, and non-binary individuals, are tuning parameters, repairing connections, and enhancing the network on the fly. Data flows into the ML model, being processed in real-time, and generating output inferences.</em></figcaption>
</figure>
</div>
<p>On-device Learning represents a significant innovation for embedded and edge IoT devices, enabling models to train and update directly on small local devices. This contrasts with traditional methods where models are trained on expansive cloud computing resources before deployment. With On-Device Learning, devices like smart speakers, wearables, and industrial sensors can refine models in real-time based on local data, without needing to transmit data externally. For example, a voice-enabled smart speaker could learn and adapt to its owner’s speech patterns and vocabulary right on the device. But there is no such thing as free lunch, therefore in this chapter, we will discuss both the benefits and the limitations of on-device learning.</p>
<div class="callout callout-style-simple callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Learning Objectives
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><p>Understand on-device learning and how it differs from cloud-based training</p></li>
<li><p>Recognize the benefits and limitations of on-device learning</p></li>
<li><p>Examine strategies to adapt models through complexity reduction, optimization, and data compression</p></li>
<li><p>Understand related concepts like federated learning and transfer learning</p></li>
<li><p>Analyze the security implications of on-device learning and mitigation strategies</p></li>
</ul>
</div>
</div>
<section id="introduction" class="level2" data-number="13.1">
<h2 data-number="13.1" class="anchored" data-anchor-id="introduction"><span class="header-section-number">13.1</span> Introduction</h2>
<p>On-device Learning refers to the process of training ML models directly on the device where they are deployed, as opposed to traditional methods where models are trained on powerful servers and then deployed to devices. This method is particularly relevant to TinyML, where ML systems are integrated into tiny, resource-constrained devices.</p>
<p>An example of On-Device Learning can be seen in a smart thermostat that adapts to user behavior over time. Initially, the thermostat may have a generic model that understands basic patterns of usage. However, as it is exposed to more data, such as the times the user is home or away, preferred temperatures, and external weather conditions, the thermostat can refine its model directly on the device to provide a personalized experience for the user. This is all done without the need to send data back to a central server for processing.</p>
<p>Another example is in predictive text on smartphones. As users type, the phone learns from the user’s language patterns and suggests words or phrases that are likely to be used next. This learning happens directly on the device, and the model updates in real-time as more data is collected. A widely used real-world example of on-device learning is Gboard. On an Android phone, Gboard learns from typing and dictation patterns to enhance the experience for all users. On-device learning is also called federated learning. <a href="#fig-federated-cycle" class="quarto-xref">Figure&nbsp;<span>13.1</span></a> shows the cycle of federated learning on mobile devices: A. the device learns from user patterns; B. local model updates are communicated to the cloud; C. the cloud server updates the global model and sends the new model to all the devices.</p>
<div id="fig-federated-cycle" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-federated-cycle-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/png/ondevice_intro.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-federated-cycle-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;13.1: Federated learning cycle. Credit: <a href="https://ai.googleblog.com/2017/04/federated-learning-collaborative.html">Google Research.</a>
</figcaption>
</figure>
</div>
</section>
<section id="advantages-and-limitations" class="level2" data-number="13.2">
<h2 data-number="13.2" class="anchored" data-anchor-id="advantages-and-limitations"><span class="header-section-number">13.2</span> Advantages and Limitations</h2>
<p>On-Device Learning provides a number of advantages over traditional cloud-based ML. By keeping data and models on the device, it eliminates the need for costly data transmission and addresses privacy concerns. This allows for more personalized, responsive experiences as the model can adapt in real-time to user behavior.</p>
<p>However, On-Device Learning also comes with tradeoffs. The limited compute resources on consumer devices can make it challenging to run complex models locally. Datasets are also more restricted since they consist only of user-generated data from a single device. Additionally, updating models requires pushing out new versions rather than seamless cloud updates.</p>
<p>On-Device Learning opens up new capabilities by enabling offline AI while maintaining user privacy. But it requires carefully managing model and data complexity within the constraints of consumer devices. Finding the right balance between localization and cloud offloading is key to delivering optimized on-device experiences.</p>
<section id="benefits" class="level3" data-number="13.2.1">
<h3 data-number="13.2.1" class="anchored" data-anchor-id="benefits"><span class="header-section-number">13.2.1</span> Benefits</h3>
<section id="privacy-and-data-security" class="level4">
<h4 class="anchored" data-anchor-id="privacy-and-data-security">Privacy and Data Security</h4>
<p>One of the significant advantages of on-device learning is the enhanced privacy and security of user data. For instance, consider a smartwatch that monitors sensitive health metrics such as heart rate and blood pressure. By processing data and adapting models directly on the device, the biometric data remains localized, circumventing the need to transmit raw data to cloud servers where it could be susceptible to breaches.</p>
<p>Server breaches are far from rare, with millions of records compromised annually. For example, the 2017 Equifax breach exposed the personal data of 147 million people. By keeping data on the device, the risk of such exposures is drastically minimized. On-device learning acts as a safeguard against unauthorized access from various threats, including malicious actors, insider threats, and accidental exposure, by eliminating reliance on centralized cloud storage.</p>
<p>Regulations like the Health Insurance Portability and Accountability Act (<a href="https://www.cdc.gov/phlp/publications/topic/hipaa.html">HIPAA</a>) and the General Data Protection Regulation (<a href="https://gdpr.eu/tag/gdpr/">GDPR</a>) mandate stringent data privacy requirements that on-device learning adeptly addresses. By ensuring data remains localized and is not transferred to other systems, on-device learning facilitates <a href="https://www.researchgate.net/publication/321515854_The_EU_General_Data_Protection_Regulation_GDPR_A_Practical_Guide">compliance with these regulations</a>.</p>
<p>On-device learning is not just beneficial for individual users; it has significant implications for organizations and sectors dealing with highly sensitive data. For instance, within the military, on-device learning empowers frontline systems to adapt models and function independently of connections to central servers that could potentially be compromised. By localizing data processing and learning, critical and sensitive information is staunchly protected. However, this comes with the trade-off that individual devices take on more value and may incentivize theft or destruction, as they become sole carriers of specialized AI models. Care must be taken to secure devices themselves when transitioning to on-device learning.</p>
<p>It is also important in preserving the privacy, security, and regulatory compliance of personal and sensitive data. Training and operating models locally, as opposed to in the cloud, substantially augments privacy measures, ensuring that user data is safeguarded from potential threats.</p>
<p>However, this is not entirely intuitive because on-device learning could instead open systems up to new privacy attacks. With valuable data summaries and model updates permanently stored on individual devices, it may be much harder to physically and digitally protect them compared to a large computing cluster. While on-device learning reduces the amount of data compromised in any one breach, it could also introduce new dangers by dispersing sensitive information across many decentralized endpoints. Careful security practices are still essential for on-device systems.</p>
</section>
<section id="regulatory-compliance" class="level4">
<h4 class="anchored" data-anchor-id="regulatory-compliance">Regulatory Compliance</h4>
<p>On-device learning helps address major privacy regulations like (<a href="https://gdpr.eu/tag/gdpr/">GDPR</a>) and <a href="https://oag.ca.gov/privacy/ccpa">CCPA</a>. These regulations require data localization, restricting cross-border data transfers to approved countries with adequate controls. GDPR also mandates privacy by design and consent requirements for data collection. By keeping data processing and model training localized on-device, sensitive user data is not transferred across borders. This avoids major compliance headaches for organizations.</p>
<p>For example, a healthcare provider monitoring patient vitals with wearables would have to ensure cross-border data transfers comply with HIPAA and GDPR if using the cloud. Determining which country’s laws apply and securing approvals for international data flows introduces legal and engineering burdens. With on-device learning, no data leaves the device, simplifying compliance. The time and resources spent on compliance are reduced significantly.</p>
<p>Industries like healthcare, finance and government with highly regulated data can benefit greatly from on-device learning. By localizing data and learning, regulatory requirements on privacy and data sovereignty are more easily met. On-device solutions provide an efficient way to build compliant AI applications.</p>
<p>Major privacy regulations impose restrictions on cross-border data movement that on-device learning inherently addresses through localized processing. This reduces the compliance burden for organizations working with regulated data.</p>
</section>
<section id="reduced-bandwidth-costs-and-increased-efficiency" class="level4">
<h4 class="anchored" data-anchor-id="reduced-bandwidth-costs-and-increased-efficiency">Reduced Bandwidth, Costs, and Increased Efficiency</h4>
<p>One major advantage of on-device learning is the significant reduction in bandwidth usage and associated cloud infrastructure costs. By keeping data localized for model training, rather than transmitting raw data to the cloud, on-device learning can result in substantial savings in bandwidth. For instance, a network of cameras analyzing video footage can achieve up to significant reductions in data transfer by training models on-device rather than streaming all video footage to the cloud for processing.</p>
<p>This reduction in data transmission not only saves bandwidth but also translates to lower costs for servers, networking, and data storage in the cloud. Large organizations, which might spend millions on cloud infrastructure to train models on device data, can experience dramatic cost reductions through on-device learning. In the era of Generative AI, where <a href="https://epochai.org/blog/trends-in-the-dollar-training-cost-of-machine-learning-systems">costs have been escalating significantly</a>, finding ways to keep expenses down has become increasingly important.</p>
<p>Furthermore, the energy and environmental costs associated with running large server farms are also diminished. Data centers are known to consume vast amounts of energy, contributing to greenhouse gas emissions. By reducing the need for extensive cloud-based infrastructure, on-device learning plays a part in mitigating the environmental impact of data processing <span class="citation" data-cites="wu2022sustainable">(<a href="../../references.html#ref-wu2022sustainable" role="doc-biblioref">Wu et al. 2022</a>)</span>.</p>
<p>Specifically for endpoint applications, on-device learning minimizes the number of network API calls needed to run inference through a cloud provider. For applications with millions of users, the cumulative costs associated with bandwidth and API calls can quickly escalate. In contrast, performing training and inferences locally is considerably more efficient and cost-effective. On-device learning has been shown to reduce training memory requirements, drastically improve memory efficiency, and reduce up to 20% in per-iteration latency under the state-of-the-art optimizations <span class="citation" data-cites="dhar2021survey">(<a href="../../references.html#ref-dhar2021survey" role="doc-biblioref">Dhar et al. 2021</a>)</span>.</p>
<p>Another key benefit of on-device learning is the potential for IoT devices to continuously adapt their ML model to new data for continuous, lifelong learning. On-device models can quickly become outdated as user behavior, data patterns, and preferences change. Continuous learning enables the model to efficiently adapt to new data and improvements and maintain high model performance over time.</p>
</section>
</section>
<section id="limitations" class="level3" data-number="13.2.2">
<h3 data-number="13.2.2" class="anchored" data-anchor-id="limitations"><span class="header-section-number">13.2.2</span> Limitations</h3>
<p>While traditional cloud-based ML systems have access to nearly endless computing resources, on-device learning is often restricted by the limitations in computational and storage power of the edge device that the model is trained on. By definition, an <a href="http://arxiv.org/abs/1911.00623">edge device</a> is a device with restrained computing, memory, and energy resources, that cannot be easily increased or decreased. Thus, the reliance on edge devices can restrict the complexity, efficiency, and size of on-device ML models.</p>
<section id="compute-resources" class="level4">
<h4 class="anchored" data-anchor-id="compute-resources">Compute resources</h4>
<p>Traditional cloud-based ML systems utilize large servers with multiple high-end GPUs or TPUs that provide nearly endless computational power and memory. For example, services like Amazon Web Services (AWS) <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/concepts.html">EC2</a> allow configuring clusters of GPU instances for massively parallel training.</p>
<p>In contrast, on-device learning is restricted by the hardware limitations of the edge device it runs on. Edge devices refer to endpoints like smartphones, embedded electronics, and IoT devices. By definition, these devices have highly restrained computing, memory, and energy resources compared to the cloud.</p>
<p>For example, a typical smartphone or Raspberry Pi may only have a few CPU cores, a few GB of RAM, and a small battery. Even more resource-constrained are TinyML microcontroller devices such as the <a href="https://store-usa.arduino.cc/products/arduino-nano-33-ble-sense">Arduino Nano BLE Sense</a>. The resources are fixed on these devices and can’t easily be increased on demand like scaling cloud infrastructure. This reliance on edge devices directly restricts the complexity, efficiency, and size of models that can be deployed for on-device training:</p>
<ul>
<li><strong>Complexity</strong>: Limits on memory, computing, and power restrict model architecture design, constraining the number of layers and parameters.</li>
<li><strong>Efficiency</strong>: Models must be heavily optimized through methods like quantization and pruning to run faster and consume less energy.</li>
<li><strong>Size</strong>: Actual model files must be compressed as much as possible to fit within the storage limitations of edge devices.</li>
</ul>
<p>Thus, while the cloud offers endless scalability, on-device learning must operate within the tight resource constraints of endpoint hardware. This requires careful co-design of streamlined models, training methods, and optimizations tailored specifically for edge devices.</p>
</section>
<section id="dataset-size-accuracy-and-generalization" class="level4">
<h4 class="anchored" data-anchor-id="dataset-size-accuracy-and-generalization">Dataset Size, Accuracy, and Generalization</h4>
<p>In addition to limited computing resources, on-device learning is also constrained in terms of the dataset available for training models.</p>
<p>In the cloud, models are trained on massive, diverse datasets like ImageNet or Common Crawl. For example, ImageNet contains over 14 million images carefully categorized across thousands of classes.</p>
<p>On-device learning instead relies on smaller, decentralized data silos unique to each device. A smartphone camera roll may contain only thousands of photos centered around a user’s specific interests and environments.</p>
<p>This decentralized data leads to a lack of IID (independent and identically distributed) data. For instance, two friends may take many photos of the same places and objects, meaning their data distributions are highly correlated rather than independent.</p>
<p>Reasons data may be non-IID in on-device settings:</p>
<ul>
<li><strong>User heterogeneity</strong>: different users have different interests and environments.</li>
<li><strong>Device differences:</strong> sensors, regions, and demographics affect data.</li>
<li><strong>Temporal effects:</strong> time of day, seasonal impacts on data.</li>
</ul>
<p>The effectiveness of ML relies heavily on large, diverse training data. With small, localized datasets, on-device models may fail to generalize across different user populations and environments. For example, a disease detection model trained only on images from a single hospital would not generalize well to other patient demographics. Without extensive, diverse medical images, the model’s real-world performance would suffer. Thus, while cloud-based learning leverages massive datasets, on-device learning relies on much smaller, decentralized data silos unique to each user.</p>
<p>The limited data and optimizations required for on-device learning can negatively impact model accuracy and generalization:</p>
<ul>
<li>Small datasets increase overfitting risk. For example, a fruit classifier trained on 100 images risks overfitting compared to one trained on 1 million diverse images.</li>
<li>Noisy user-generated data reduces quality. Sensor noise or improper data labeling by non-experts may degrade training.</li>
<li>Optimizations like pruning and quantization trade off accuracy for efficiency. An 8-bit quantized model runs faster but less accurately than a 32-bit model.</li>
</ul>
<p>So while cloud models achieve high accuracy with massive datasets and no constraints, on-device models can struggle to generalize. Some studies show that on-device training matches cloud accuracy on select tasks. However, performance on real-world workloads requires further study <span class="citation" data-cites="lin2022device">(<a href="../../references.html#ref-lin2022device" role="doc-biblioref">Lin et al. 2022</a>)</span>.</p>
<p>For instance, a cloud model can accurately detect pneumonia in chest X-rays from thousands of hospitals. However, an on-device model trained only on a small local patient population may fail to generalize.</p>
<p>Unreliable accuracy limits the real-world applicability of on-device learning for mission-critical uses like disease diagnosis or self-driving vehicles.</p>
<p>On-device training is also slower than the cloud due to limited resources. Even if each iteration is faster, the overall training process takes longer.</p>
<p>For example, a real-time robotics application may require model updates within milliseconds. On-device training on small embedded hardware may take seconds or minutes per update - too slow for real-time use.</p>
<p>Accuracy, generalization, and speed challenges pose hurdles to adopting on-device learning for real-world production systems, especially when reliability and low latency are critical.</p>
</section>
</section>
</section>
<section id="on-device-adaptation" class="level2" data-number="13.3">
<h2 data-number="13.3" class="anchored" data-anchor-id="on-device-adaptation"><span class="header-section-number">13.3</span> On-device Adaptation</h2>
<p>In an ML task, resource consumption <a href="http://arxiv.org/abs/1911.00623">mainly</a> comes from three sources:</p>
<ul>
<li>The ML model itself;</li>
<li>The optimization process during model learning</li>
<li>Storing and processing the dataset used for learning.</li>
</ul>
<p>Correspondingly, there are three approaches to adapting existing ML algorithms onto resource-constrained devices:</p>
<ul>
<li>Reducing the complexity of the ML model</li>
<li>Modifying optimizations to reduce training resource requirements</li>
<li>Creating new storage-efficient data representations</li>
</ul>
<p>In the following section, we will review these on-device learning adaptation methods. More details on model optimizations can be found in the <a href="../../contents/optimizations/optimizations.html">Model Optimizations</a> chapter.</p>
<section id="reducing-model-complexity" class="level3" data-number="13.3.1">
<h3 data-number="13.3.1" class="anchored" data-anchor-id="reducing-model-complexity"><span class="header-section-number">13.3.1</span> Reducing Model Complexity</h3>
<p>In this section, we will briefly discuss ways to reduce model complexity to adapt ML models on-device. For details of reducing model complexity, please refer to the Model Optimization Chapter.</p>
<section id="traditional-ml-algorithms" class="level4">
<h4 class="anchored" data-anchor-id="traditional-ml-algorithms">Traditional ML Algorithms</h4>
<p>Due to the compute and memory limitations of edge devices, select traditional ML algorithms are great candidates for on-device learning applications due to their lightweight nature. Some example algorithms with low resource footprints include Naive Bayes Classifier, Support Vector Machines (SVMs), Linear Regression, Logistic Regression, and select Decision Tree algorithms.</p>
<p>With some refinements, these classical ML algorithms can be adapted to specific hardware architectures and perform simple tasks, and their low performance requirements make it easy to integrate continuous learning even on edge devices.</p>
</section>
<section id="pruning" class="level4">
<h4 class="anchored" data-anchor-id="pruning">Pruning</h4>
<p>Pruning is a technique used to reduce the size and complexity of an ML model to improve their efficiency and generalization performance. This is beneficial for training models on edge devices, where we want to minimize the resource usage while maintaining competitive accuracy.</p>
<p>The primary goal of pruning is to remove parts of the model that do not contribute significantly to its predictive power while retaining the most informative aspects. In the context of decision trees, pruning involves removing some of the branches (subtrees) from the tree, leading to a smaller and simpler tree. In the context of DNN, pruning is used to reduce the number of neurons (units) or connections in the network, as shown in <a href="#fig-ondevice-pruning" class="quarto-xref">Figure&nbsp;<span>13.2</span></a>.</p>
<div id="fig-ondevice-pruning" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ondevice-pruning-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/jpg/pruning.jpeg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ondevice-pruning-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;13.2: Network pruning.
</figcaption>
</figure>
</div>
</section>
<section id="reducing-complexity-of-deep-learning-models" class="level4">
<h4 class="anchored" data-anchor-id="reducing-complexity-of-deep-learning-models">Reducing Complexity of Deep Learning Models</h4>
<p>Traditional cloud-based DNN frameworks have too much memory overhead to be used on-device. <a href="http://arxiv.org/abs/2206.15472">For example</a>, deep learning systems like PyTorch and TensorFlow require hundreds of megabytes of memory overhead when training models such as <a href="https://openaccess.thecvf.com/content_cvpr_2018/html/Sandler_MobileNetV2_Inverted_Residuals_CVPR_2018_paper.html">MobilenetV2</a>, and the overhead scales as the number of training parameters increases.</p>
<p>Traditional cloud-based DNN frameworks have too much memory overhead to be used on-device. For example, deep learning systems like PyTorch and TensorFlow require hundreds of megabytes of memory overhead when training models such as MobilenetV2-w0.35, and the overhead scales as the number of training parameters increases.</p>
<p>Current research for lightweight DNNs mostly explore CNN architectures. Several bare-metal frameworks designed for running Neural Network on MCUs by keeping computational overhead and memory footprint low also exist. Some examples include MNN, TVM, and TensorFlow Lite. However, they can only perform inference during forward pass and lack support for back-propagation. While these models are designed for edge deployment, their reduction in model weights and architectural connections led to reduced resource requirements for continuous learning.</p>
<p>The tradeoff between performance and model support is clear when adapting the most popular DNN systems. How do we adapt existing DNN models to resource-constrained settings while maintaining support for back-propagation and continuous learning? Latest research suggests algorithm and system codesign techniques that help reduce the resource consumption of ML training on edge devices. Utilizing techniques such as quantization-aware scaling (QAS), sparse updates, and other cutting edge techniques, on-device learning is possible on embedded systems with a few hundred kilobytes of RAM without additional memory while maintaining <a href="http://arxiv.org/abs/2206.15472">high accuracy</a>.</p>
</section>
</section>
<section id="modifying-optimization-processes" class="level3" data-number="13.3.2">
<h3 data-number="13.3.2" class="anchored" data-anchor-id="modifying-optimization-processes"><span class="header-section-number">13.3.2</span> Modifying Optimization Processes</h3>
<p>Choosing the right optimization strategy is important for DNN training on-device, since this allows for the finding of a good local minimum. This optimization strategy must also consider limited memory and power since training occurs on-device.</p>
<section id="quantization-aware-scaling" class="level4">
<h4 class="anchored" data-anchor-id="quantization-aware-scaling">Quantization-Aware Scaling</h4>
<p>Quantization is a common method for reducing the memory footprint of DNN training. Although this could introduce new errors, these errors can be mitigated by designing a model to characterize this statistical error. For example, models could use stochastic rounding or introduce the quantization error into the gradient updates.</p>
<p>A specific algorithmic technique is Quantization-Aware Scaling (QAS), used to improve the performance of neural networks on low-precision hardware, such as edge devices and mobile devices or TinyML systems, by adjusting the scale factors during the quantization process.</p>
<p>As we discussed in the Model Optimizations chapter, quantization is the process of mapping a continuous range of values to a discrete set of values. In the context of neural networks, quantization often involves reducing the precision of the weights and activations from 32-bit floating point to lower-precision formats such as 8-bit integers. This reduction in precision can significantly reduce the computational cost and memory footprint of the model, making it suitable for deployment on low-precision hardware. <a href="#fig-float-int-quantization" class="quarto-xref">Figure&nbsp;<span>13.3</span></a> is an example of float to integer quatization.</p>
<div id="fig-float-int-quantization" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-float-int-quantization-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/png/ondevice_quantization_matrix.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-float-int-quantization-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;13.3: Float to integer qunatization. Credit: <a href="https://developer-blogs.nvidia.com/wp-content/uploads/2021/07/qat-training-precision.png">Nvidia.</a>
</figcaption>
</figure>
</div>
<p>However, the quantization process can also introduce quantization errors that can degrade the performance of the model. Quantization-aware scaling is a technique that aims to minimize these errors by adjusting the scale factors used in the quantization process.</p>
<p>The QAS process involves two main steps:</p>
<ul>
<li><p><strong>Quantization-aware training:</strong> In this step, the neural network is trained with quantization in mind, using simulated quantization to mimic the effects of quantization during the forward and backward passes. This allows the model to learn to compensate for the quantization errors and improve its performance on low-precision hardware. Refer to QAT section in Model Optimizations for details.</p></li>
<li><p><strong>Quantization and scaling:</strong> After training, the model is quantized to low-precision format, and the scale factors are adjusted to minimize the quantization errors. The scale factors are chosen based on the distribution of the weights and activations in the model, and are adjusted to ensure that the quantized values are within the range of the low-precision format.</p></li>
</ul>
<p>QAS is used to overcome the difficulties of optimizing models on tiny devices. Without needing hyperparamter tuning. QAS automatically scales tensor gradients with various bit-precisions. This in turn stabilizes the training process and matches the accuracy of floating-point precision.</p>
</section>
<section id="sparse-updates" class="level4">
<h4 class="anchored" data-anchor-id="sparse-updates">Sparse Updates</h4>
<p>Although QAS enables optimizing a quantized model, it uses a large amount of memory that is unrealistic for on-device training. So spare update is used to reduce the memory footprint of full backward computation. Instead of pruning weights for inference, sparse update prunes the gradient during backwards propagation to update the model sparsely. In other words, sparse update skips computing gradients of less important layers and sub-tensors.</p>
<p>However, determining the optimal sparse update scheme given a constraining memory budget can be challenging due to the large search space. For example, the MCUNet model has 43 convolutional layers and a search space of approximately 1030. One technique to address this issue is contribution analysis. Contribution analysis measures the accuracy improvement from biases (updating the last few biases compared to only updating the classifier) and weights (updating the weight of one extra layer compared to only having a bias update). By trying to maximize these improvements, contribution analysis automatically derives an optimal sparse update scheme for enabling on-device training.</p>
</section>
<section id="layer-wise-training" class="level4">
<h4 class="anchored" data-anchor-id="layer-wise-training">Layer-Wise Training</h4>
<p>Other methods besides quantization can help optimize routines. One such method is layer-wise training. A significant memory consumer of DNN training is the end-to-end back-propagation. This requires all intermediate feature maps to be stored so the model can calculate gradients. An alternative to this approach that reduces the memory footprint of DNN training is sequential layer-by-layer training <span class="citation" data-cites="chen2016training">(<a href="../../references.html#ref-chen2016training" role="doc-biblioref">T. Chen et al. 2016</a>)</span>. Instead of training end-to-end, training a single layer at a time helps avoid having to store intermediate feature maps.</p>
</section>
<section id="trading-computation-for-memory" class="level4">
<h4 class="anchored" data-anchor-id="trading-computation-for-memory">Trading Computation for Memory</h4>
<p>The strategy of trading computation for memory involves releasing some of the memory being used to store intermediate results. Instead, these results can be recomputed as needed. Reducing memory in exchange for more computation is shown to reduce the memory footprint of DNN training to fit into almost any budget while also minimizing computational cost <span class="citation" data-cites="gruslys2016memory">(<a href="../../references.html#ref-gruslys2016memory" role="doc-biblioref">Gruslys et al. 2016</a>)</span>.</p>
</section>
</section>
<section id="developing-new-data-representations" class="level3" data-number="13.3.3">
<h3 data-number="13.3.3" class="anchored" data-anchor-id="developing-new-data-representations"><span class="header-section-number">13.3.3</span> Developing New Data Representations</h3>
<p>The dimensionality and volume of the training data can significantly impact on-device adaptation. So another technique for adapting models onto resource-cosntrained devices is to represent datasets in a more efficient way.</p>
<section id="data-compression" class="level4">
<h4 class="anchored" data-anchor-id="data-compression">Data Compression</h4>
<p>The goal of data compression is to reach high accuracies while limiting the amount of training data. One method to achieve this is prioritizing sample complexity: the amount of training data required for the algorithm to reach a target accuracy <span class="citation" data-cites="dhar2021survey">(<a href="../../references.html#ref-dhar2021survey" role="doc-biblioref">Dhar et al. 2021</a>)</span>.</p>
<p>Other more common methods of data compression focus on reducing the dimensionality and the volume of the training data. For example, an approach could take advantage of matrix sparsity to reduce the memory footprint of storing training data. Training data can be transformed into a lower-dimensional embedding and factorized into a dictionary matrix multiplied by a block-sparse coefficient matrix <span class="citation" data-cites="rouhani2017tinydl">(<a href="../../references.html#ref-rouhani2017tinydl" role="doc-biblioref">Darvish Rouhani, Mirhoseini, and Koushanfar 2017</a>)</span>. Another example could involve representing words from a large language training dataset in a more compressed vector format <span class="citation" data-cites="li2016lightrnn">(<a href="../../references.html#ref-li2016lightrnn" role="doc-biblioref">Li et al. 2016</a>)</span>.</p>
</section>
</section>
</section>
<section id="transfer-learning" class="level2" data-number="13.4">
<h2 data-number="13.4" class="anchored" data-anchor-id="transfer-learning"><span class="header-section-number">13.4</span> Transfer Learning</h2>
<p>Transfer learning is a ML technique where a model developed for a particular task is reused as the starting point for a model on a second task. In the context of on-device AI, transfer learning allows us to leverage pre-trained models that have already learned useful representations from large datasets, and fine-tune them for specific tasks using smaller datasets directly on the device. This can significantly reduce the computational resources and time required for training models from scratch.</p>
<p><a href="#fig-transfer-learning-apps" class="quarto-xref">Figure&nbsp;<span>13.4</span></a> includes some intuitive examples of transfer learning from the real world. For instance, if you can ride a bicycle, then you probably know how to balance yourself on two-wheel vehicles. Then, it would be easier for you to learn how to ride a motorcyle than it would be for someone who cannot ride a bicycle.</p>
<div id="fig-transfer-learning-apps" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-transfer-learning-apps-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/png/ondevice_transfer_learning_apps.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-transfer-learning-apps-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;13.4: Transferring knowledge between tasks. Credit: <span class="citation" data-cites="zhuang2021comprehensive">Zhuang et al. (<a href="../../references.html#ref-zhuang2021comprehensive" role="doc-biblioref">2021</a>)</span>.
</figcaption>
</figure>
</div>
<p>Let’s take the example of a smart sensor application that uses on-device AI to recognize objects in images captured by the device. Traditionally, this would require sending the image data to a server, where a large neural network model processes the data and sends back the results. With on-device AI, the model is stored and runs directly on-device, eliminating the need to send data to a server.</p>
<p>If we want to customize the model for the on-device characteristics, training a neural network model from scratch on the device would however be impractical due to the limited computational resources and battery life. This is where transfer learning comes in. Instead of training a model from scratch, we can take a pre-trained model, such as a convolutional neural network (CNN) or a transformer network that has been trained on a large dataset of images, and fine-tune it for our specific object recognition task. This fine-tuning can be done directly on the device using a smaller dataset of images relevant to the task. By leveraging the pre-trained model, we can reduce the computational resources and time required for training, while still achieving high accuracy for the object recognition task.</p>
<p>Transfer learning plays an important role in making on-device AI practical by allowing us to leverage pre-trained models and fine-tune them for specific tasks, thereby reducing the computational resources and time required for training. The combination of on-device AI and transfer learning opens up new possibilities for AI applications that are more privacy-conscious and responsive to user needs.</p>
<p>Transfer learning has revolutionized the way models are developed and deployed, both in the cloud and at the edge. Transfer learning is being used in the real world. One such example is the use of transfer learning to develop AI models that can detect and diagnose diseases from medical images, such as X-rays, MRI scans, and CT scans. For example, researchers at Stanford University developed a transfer learning model that can detect cancer in skin images with an accuracy of 97% <span class="citation" data-cites="esteva2017dermatologist">(<a href="../../references.html#ref-esteva2017dermatologist" role="doc-biblioref">Esteva et al. 2017</a>)</span>. This model was pre-trained on 1.28 million images to classify a broad range of objects, then specialized for cancer detection by training on a dermatologist-curated dataset of skin images.</p>
<p>Implementation in production scenarios can be broadly categorized into two stages: pre-deployment and post-deployment.</p>
<section id="pre-deployment-specialization" class="level3" data-number="13.4.1">
<h3 data-number="13.4.1" class="anchored" data-anchor-id="pre-deployment-specialization"><span class="header-section-number">13.4.1</span> Pre-Deployment Specialization</h3>
<p>In the pre-deployment stage, transfer learning acts as a catalyst to expedite the development process. Here’s how it typically works: Imagine we are creating a system to recognize different breeds of dogs. Rather than starting from scratch, we can utilize a pre-trained model that has already mastered the broader task of recognizing animals in images.</p>
<p>This pre-trained model serves as a solid foundation and contains a wealth of knowledge acquired from extensive data. We then fine-tune this model using a specialized dataset containing images of various dog breeds. This fine-tuning process tailors the model to our specific need — identifying dog breeds with precision. Once fine-tuned and validated to meet performance criteria, this specialized model is then ready for deployment.</p>
<p>Here’s how it works in practice:</p>
<ul>
<li><strong>Start with a Pre-Trained Model:</strong> Begin by selecting a model that has already been trained on a comprehensive dataset, usually related to a general task. This model serves as the foundation for the task at hand.</li>
<li><strong>Fine-Tuning:</strong> The pre-trained model is then fine-tuned on a smaller, more specialized dataset that is specific to the desired task. This step allows the model to adapt and specialize its knowledge to the specific requirements of the application.</li>
<li><strong>Validation:</strong> After fine-tuning, the model is validated to ensure it meets the performance criteria for the specialized task.</li>
<li><strong>Deployment:</strong> Once validated, the specialized model is then deployed into the production environment.</li>
</ul>
<p>This method significantly reduces the time and computational resources required to train a model from scratch <span class="citation" data-cites="pan2009survey">(<a href="../../references.html#ref-pan2009survey" role="doc-biblioref">Pan and Yang 2010</a>)</span>. By adopting transfer learning, embedded systems can achieve high accuracy on specialized tasks without the need to gather extensive data or expend significant computational resources on training from the ground up.</p>
</section>
<section id="post-deployment-adaptation" class="level3" data-number="13.4.2">
<h3 data-number="13.4.2" class="anchored" data-anchor-id="post-deployment-adaptation"><span class="header-section-number">13.4.2</span> Post-Deployment Adaptation</h3>
<p>Deployment to a device need not mark the culmination of a ML model’s educational trajectory. With the advent of transfer learning, we open the doors to the deployment of adaptive ML models to real-world scenarios, catering to the personalized needs of users.</p>
<p>Consider a real-world application where a parent wishes to identify their child in a collection of images from a school event on their smartphone. In this scenario, the parent is faced with the challenge of locating their child amidst images of many other children. Here, transfer learning can be employed to fine-tune an embedded system’s model to this unique and specialized task. Initially, the system might use a generic model trained to recognize faces in images. However, with transfer learning, the system can adapt this model to recognize the specific features of the user’s child.</p>
<p>Here’s how it works:</p>
<ol type="1">
<li><strong>Data Collection:</strong> The embedded system gathers images that include the child, ideally with the parent’s input to ensure accuracy and relevance. This can be done directly on the device, maintaining the user’s data privacy.</li>
<li><strong>Model Fine-Tuning:</strong> The pre-existing face recognition model, which has been trained on a large and diverse dataset, is then fine-tuned using the newly collected images of the child. This process adapts the model to recognize the child’s specific facial features, distinguishing them from other children in the images.</li>
<li><strong>Validation:</strong> The refined model is then validated to ensure it accurately recognizes the child in various images. This can involve the parent verifying the model’s performance and providing feedback for further improvements.</li>
<li><strong>Deployment:</strong> Once validated, the adapted model is deployed on the device, enabling the parent to easily identify their child in images without having to sift through them manually.</li>
</ol>
<p>This on-the-fly customization enhances the model’s efficacy for the individual user, ensuring that they benefit from ML personalization. This is in part how iPhotos or Google photos works when they ask us to recognize a face and then based on that information they index all the photos by that face. Because the learning and adaptation occur on the device itself, there are no risks to personal privacy. The parent’s images are not uploaded to a cloud server or shared with third parties, protecting the family’s privacy while still reaping the benefits of a personalized ML model. This approach represents a significant step forward in the quest to provide users with tailored ML solutions that respect and uphold their privacy.</p>
</section>
<section id="benefits-1" class="level3" data-number="13.4.3">
<h3 data-number="13.4.3" class="anchored" data-anchor-id="benefits-1"><span class="header-section-number">13.4.3</span> Benefits</h3>
<p>Transfer learning has become an important technique in the field of ML and artificial intelligence, and it is particularly valuable for several reasons.</p>
<ol type="1">
<li><strong>Data Scarcity:</strong> In many real-world scenarios, acquiring a sufficiently large labeled dataset for training a ML model from scratch is challenging. Transfer learning mitigates this issue by allowing the use of pre-trained models that have already learned valuable features from a vast dataset.</li>
<li><strong>Computational Expense:</strong> Training a model from scratch requires significant computational resources and time, especially for complex models like deep neural networks. By using transfer learning, we can leverage the computation that has already been done during the training of the source model, thereby saving both time and computational power.</li>
<li><strong>Limited Annotated Data:</strong> For some specific tasks, there might be ample raw data available, but the process of labeling that data for supervised learning can be costly and time-consuming. Transfer learning enables us to utilize pre-trained models that have been trained on a related task with labeled data, hence requiring less annotated data for the new task.</li>
</ol>
<p>There are advantages to reusing the features:</p>
<ol type="1">
<li><strong>Hierarchical Feature Learning:</strong> Deep learning models, particularly Convolutional Neural Networks (CNNs), have the ability to learn hierarchical features. Lower layers typically learn generic features like edges and shapes, while higher layers learn more complex and task-specific features. Transfer learning allows us to reuse the generic features learned by a model and fine-tune the higher layers for our specific task.</li>
<li><strong>Boosting Performance:</strong> Transfer learning has been proven to boost the performance of models on tasks with limited data. The knowledge gained from the source task can provide a valuable starting point and lead to faster convergence and improved accuracy on the target task.</li>
</ol>
</section>
<section id="core-concepts" class="level3" data-number="13.4.4">
<h3 data-number="13.4.4" class="anchored" data-anchor-id="core-concepts"><span class="header-section-number">13.4.4</span> Core Concepts</h3>
<p>Understanding the core concepts of transfer learning is essential for effectively utilizing this powerful approach in ML. Here we’ll break down some of the main principles and components that underlie the process of transfer learning.</p>
<section id="source-and-target-tasks" class="level4">
<h4 class="anchored" data-anchor-id="source-and-target-tasks">Source and Target Tasks</h4>
<p>In transfer learning, there are two main tasks involved: the source task and the target task. The source task is the task for which the model has already been trained and has learned valuable information. The target task is the new task we want the model to perform. The goal of transfer learning is to leverage the knowledge gained from the source task to improve performance on the target task.</p>
<p>If we have a model trained to recognize various fruits in images (source task), and we want to create a new model to recognize different vegetables in images (target task), we can use transfer learning to leverage the knowledge gained during the fruit recognition task to improve the performance of the vegetable recognition model.</p>
</section>
<section id="representation-transfer" class="level4">
<h4 class="anchored" data-anchor-id="representation-transfer">Representation Transfer</h4>
<p>Representation transfer is about transferring the learned representations (features) from the source task to the target task. There are three main types of representation transfer:</p>
<ul>
<li><strong>Instance Transfer:</strong> This involves reusing the data instances from the source task in the target task.</li>
<li><strong>Feature-Representation Transfer:</strong> This involves transferring the learned feature representations from the source task to the target task.</li>
<li><strong>Parameter Transfer:</strong> This involves transferring the learned parameters (weights) of the model from the source task to the target task.</li>
</ul>
<p>In natural language processing, a model trained to understand the syntax and grammar of a language (source task) can have its learned representations transferred to a new model designed to perform sentiment analysis (target task).</p>
</section>
<section id="fine-tuning" class="level4">
<h4 class="anchored" data-anchor-id="fine-tuning">Fine-Tuning</h4>
<p>Fine-tuning is the process of adjusting the parameters of a pre-trained model to adapt it to the target task. This typically involves updating the weights of the model’s layers, especially the last few layers, to make the model more relevant for the new task. In image classification, a model pre-trained on a general dataset like ImageNet (source task) can be fine-tuned by adjusting the weights of its layers to perform well on a specific classification task, like recognizing specific animal species (target task).</p>
</section>
<section id="feature-extractions" class="level4">
<h4 class="anchored" data-anchor-id="feature-extractions">Feature Extractions</h4>
<p>Feature extraction involves using a pre-trained model as a fixed feature extractor, where the output of the model’s intermediate layers is used as features for the target task. This approach is particularly useful when the target task has a small dataset, as the pre-trained model’s learned features can significantly enhance performance. In medical image analysis, a model pre-trained on a large dataset of general medical images (source task) can be used as a feature extractor to provide valuable features for a new model designed to recognize specific types of tumors in X-ray images (target task).</p>
</section>
</section>
<section id="types-of-transfer-learning" class="level3" data-number="13.4.5">
<h3 data-number="13.4.5" class="anchored" data-anchor-id="types-of-transfer-learning"><span class="header-section-number">13.4.5</span> Types of Transfer Learning</h3>
<p>Transfer learning can be classified into three main types based on the nature of the source and target tasks and data. Let’s explore each type in detail:</p>
<section id="inductive-transfer-learning" class="level4">
<h4 class="anchored" data-anchor-id="inductive-transfer-learning">Inductive Transfer Learning</h4>
<p>In inductive transfer learning, the goal is to learn the target predictive function with the help of source data. It typically involves fine-tuning a pre-trained model on the target task with available labeled data. A common example of inductive transfer learning is image classification tasks. For instance, a model pre-trained on the ImageNet dataset (source task) can be fine-tuned to classify specific types of birds (target task) using a smaller labeled dataset of bird images.</p>
</section>
<section id="transductive-transfer-learning" class="level4">
<h4 class="anchored" data-anchor-id="transductive-transfer-learning">Transductive Transfer Learning</h4>
<p>Transductive transfer learning involves using source and target data, but only the source task. The main aim is to transfer knowledge from the source domain to the target domain, even though the tasks remain the same. Sentiment analysis for different languages can serve as an example of transductive transfer learning. A model trained to perform sentiment analysis in English (source task) can be adapted to perform sentiment analysis in another language, like French (target task), by leveraging parallel datasets of English and French sentences with the same sentiments.</p>
</section>
<section id="unsupervised-transfer-learning" class="level4">
<h4 class="anchored" data-anchor-id="unsupervised-transfer-learning">Unsupervised Transfer Learning</h4>
<p>Unsupervised transfer learning is used when the source and target tasks are related, but there is no labeled data available for the target task. The goal is to leverage the knowledge gained from the source task to improve performance on the target task, even without labeled data. An example of unsupervised transfer learning is topic modeling in text data. A model trained to extract topics from news articles (source task) can be adapted to extract topics from social media posts (target task) without needing labeled data for the social media posts.</p>
</section>
<section id="comparison-and-trade-offs" class="level4">
<h4 class="anchored" data-anchor-id="comparison-and-trade-offs">Comparison and Trade-offs</h4>
<p>By leveraging these different types of transfer learning, practitioners can choose the approach that best fits the nature of their tasks and available data, ultimately leading to more effective and efficient ML models. So in summary:</p>
<ul>
<li><strong>Inductive:</strong> different source and target tasks, different domains</li>
<li><strong>Transductive:</strong> different source and target tasks, same domain</li>
<li><strong>Unsupervised:</strong> unlabeled source data, transfers feature representations</li>
</ul>
<p>Here’s a matrix that outlines in a bit more detail the similarities and differences between the types of transfer learning:</p>
<table class="table">
<colgroup>
<col style="width: 24%">
<col style="width: 23%">
<col style="width: 25%">
<col style="width: 26%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Inductive Transfer Learning</th>
<th>Transductive Transfer Learning</th>
<th>Unsupervised Transfer Learning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Labeled Data for Target Task</strong></td>
<td>Required</td>
<td>Not Required</td>
<td>Not Required</td>
</tr>
<tr class="even">
<td><strong>Source Task</strong></td>
<td>Can be different</td>
<td>Same</td>
<td>Same or Different</td>
</tr>
<tr class="odd">
<td><strong>Target Task</strong></td>
<td>Can be different</td>
<td>Same</td>
<td>Can be different</td>
</tr>
<tr class="even">
<td><strong>Objective</strong></td>
<td>Improve target task performance with source data</td>
<td>Transfer knowledge from source to target domain</td>
<td>Leverage source task to improve target task performance without labeled data</td>
</tr>
<tr class="odd">
<td><strong>Example</strong></td>
<td>ImageNet to bird classification</td>
<td>Sentiment analysis in different languages</td>
<td>Topic modeling for different text data</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="constraints-and-considerations" class="level3" data-number="13.4.6">
<h3 data-number="13.4.6" class="anchored" data-anchor-id="constraints-and-considerations"><span class="header-section-number">13.4.6</span> Constraints and Considerations</h3>
<p>When engaging in transfer learning, there are several factors that must be considered to ensure successful knowledge transfer and model performance. Here’s a breakdown of some key factors:</p>
<section id="domain-similarity" class="level4">
<h4 class="anchored" data-anchor-id="domain-similarity">Domain Similarity</h4>
<p>Domain similarity refers to how closely related the source and target domains are. The more similar the domains, the more likely the transfer learning will be successful. Transferring knowledge from a model trained on images of outdoor scenes (source domain) to a new task that involves recognizing objects in indoor scenes (target domain) might be more successful than transferring knowledge from outdoor scenes to a task involving text analysis, as the domains (images vs.&nbsp;text) are quite different.</p>
</section>
<section id="task-similarity" class="level4">
<h4 class="anchored" data-anchor-id="task-similarity">Task Similarity</h4>
<p>Task similarity refers to how closely related the source and target tasks are. Similar tasks are likely to benefit more from transfer learning. A model trained to recognize different breeds of dogs (source task) can be more easily adapted to recognize different breeds of cats (target task) than it can be adapted to perform a completely different task like language translation.</p>
</section>
<section id="data-quality-and-quantity" class="level4">
<h4 class="anchored" data-anchor-id="data-quality-and-quantity">Data Quality and Quantity</h4>
<p>The quality and quantity of data available for the target task can significantly impact the success of transfer learning. More and high-quality data can result in better model performance. If we have a large dataset with clear, well-labeled images for our target task of recognizing specific bird species, the transfer learning process is likely to be more successful than if we have a small, noisy dataset.</p>
</section>
<section id="feature-space-overlap" class="level4">
<h4 class="anchored" data-anchor-id="feature-space-overlap">Feature Space Overlap</h4>
<p>Feature space overlap refers to how well the features learned by the source model align with the features needed for the target task. Greater overlap can lead to more successful transfer learning. A model trained on high-resolution images (source task) may not transfer well to a target task that involves low-resolution images, as the feature space (high-res vs.&nbsp;low-res) is different.</p>
</section>
<section id="model-complexity" class="level4">
<h4 class="anchored" data-anchor-id="model-complexity">Model Complexity</h4>
<p>The complexity of the source model can also impact the success of transfer learning. Sometimes, a simpler model might transfer better than a complex one, as it is less likely to overfit the source task. A simple convolutional neural network (CNN) model trained on image data (source task) may transfer more successfully to a new image classification task (target task) than a complex CNN with many layers, as the simpler model is less likely to overfit the source task.</p>
<p>By considering these factors, ML practitioners can make informed decisions about when and how to utilize transfer learning, ultimately leading to more successful model performance on the target task. The success of transfer learning hinges on the degree of similarity between the source and target domains. There is risk of overfitting, especially when fine-tuning occurs on a limited dataset. On the computational front, it is worth noting that certain pre-trained models, owing to their size, might not comfortably fit into the memory constraints of some devices or may run prohibitively slowly. Over time, as data evolves, there is potential for model drift, indicating the need for periodic re-training or ongoing adaptation.</p>
</section>
</section>
</section>
<section id="sec-fl" class="level2" data-number="13.5">
<h2 data-number="13.5" class="anchored" data-anchor-id="sec-fl"><span class="header-section-number">13.5</span> Federated Machine Learning</h2>
<p>Federated Learning Overview</p>
<p>The modern internet is full of large networks of connected devices. Whether it’s cell phones, thermostats, smart speakers or any number of other IOT products, countless edge devices are a goldmine for hyper-personalized, rich data. However, with that rich data comes an assortment of problems with information transfer and privacy. Constructing a training dataset in the cloud from these devices would involve high volumes of bandwidth and cost inefficient data transfer and violate user’s privacy.</p>
<p>Federated learning offers a solution to these problems: train models partially on the edge devices and only communicate model updates to the cloud. In 2016, a team from Google designed architecture for federated learning that attempts to address these problems.</p>
<p>In their initial paper Google outlines a principle federated learning algorithm called FederatedAveraging, shown in <a href="#fig-federated-avg-algo" class="quarto-xref">Figure&nbsp;<span>13.5</span></a>. Specifically, FederatedAveraging performs stochastic gradient descent (SGD) over several different edge devices. In this process, each device calculates a gradient <span class="math inline">\(g_k = \nabla F_k(w_t)\)</span> which is then applied to update the server side weights as (with <span class="math inline">\(\eta\)</span> as learning rate across <span class="math inline">\(k\)</span> clients): <span class="math display">\[
w_{t+1} \rightarrow w_t - \eta \sum_{k=1}^{K} \frac{n_k}{n}g_k
\]</span> This boils down the basic algorithm for federated learning on the right. For each round of training, the server takes a random set of the client devices and calls each client to train on its local batch using the most recent server side weights. Those weights then get returned to the server where they are collected individually then averaged to update the global model weights.</p>
<div id="fig-federated-avg-algo" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-federated-avg-algo-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/png/ondevice_fed_averaging.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-federated-avg-algo-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;13.5: Google’s Proposed FederatedAverage Algorithm. Credit: McMahan et al.&nbsp;(<a href="https://arxiv.org/abs/1602.05629">2017</a>).
</figcaption>
</figure>
</div>
<p>With this proposed structure, there are a few key vectors for optimizing federated learning further. We will outline each in the following subsections.</p>
<section id="communication-efficiency" class="level3" data-number="13.5.1">
<h3 data-number="13.5.1" class="anchored" data-anchor-id="communication-efficiency"><span class="header-section-number">13.5.1</span> Communication Efficiency</h3>
<p>One of the key bottlenecks in federated learning is communication. Every time a client trains the model, they must communicate back to the server their updates. Similarly, once the server has averaged all the updates, it must send them back to the client. On large networks of millions of devices, this incurs huge bandwidth and resource cost. As the field of federated learning advances, a few optimizations have been developed to minimize this communication. To address the footprint of the model, researchers have developed model compression techniques. In the client server protocol, federated learning can also minimize communication through selective sharing of updates on clients. Finally, efficient aggregation techniques can also streamline the communication process.</p>
</section>
<section id="model-compression" class="level3" data-number="13.5.2">
<h3 data-number="13.5.2" class="anchored" data-anchor-id="model-compression"><span class="header-section-number">13.5.2</span> Model Compression</h3>
<p>In standard federated learning, the server must communicate the entire model to each client and then the client must send back all of the updated weights. This means that the easiest way to reduce both the memory and communication footprint on the client is to minimize the size of the model needed to be communicated. To do this, we can employ all of the previously discussed model optimization strategies.</p>
<p>In 2022, another team at Google proposed wherein each client communicates via a compressed format and decompresses the model on the fly for training <span class="citation" data-cites="yang2023online">(<a href="../../references.html#ref-yang2023online" role="doc-biblioref">Yang et al. 2023</a>)</span>, allocating and deallocating the full memory for the model only for a short period while training. The model is compressed through a range of various quantization strategies elaborated upon in their paper. Meanwhile the server can update the uncompressed model, decompressing and applying updates as they come in.</p>
</section>
<section id="selective-update-sharing" class="level3" data-number="13.5.3">
<h3 data-number="13.5.3" class="anchored" data-anchor-id="selective-update-sharing"><span class="header-section-number">13.5.3</span> Selective Update Sharing</h3>
<p>There are a breadth of methods for selectively sharing updates. The general principle is that reducing the portion of the model that the clients are training on the edge reduces the memory necessary for training and the size of communication to the server. In basic federated learning, the client trains the entire model. This means that when a client sends an update to the server it has gradients for every weight in the network.</p>
<p>However, we cannot just reduce communication by sending pieces of those gradients to the server from each client because the gradients are part of an entire update required to improve the model. Instead, you need to architecturally design the model such that the clients each train only a small portion of the broader model, reducing the total communication while still gaining the benefit of training on client data. A paper <span class="citation" data-cites="shi2022data">(<a href="../../references.html#ref-shi2022data" role="doc-biblioref">Shi and Radu 2022</a>)</span> from the University of Sheffield applies this concept to a CNN by splitting the global model into two parts: an upper and lower part as shown in <span class="citation" data-cites="chen2023learning">Z. Chen and Xu (<a href="../../references.html#ref-chen2023learning" role="doc-biblioref">2023</a>)</span>.</p>
<div id="fig-split-model" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-split-model-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/png/ondevice_split_model.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-split-model-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;13.6: Split model architecture for selective sharing. Credit: Shi et al., (<a href="https://doi.org/10.1145/3517207.3526980">2022</a>).
</figcaption>
</figure>
</div>
<p>The lower part is designed to focus on generic features in the dataset while the upper part trained on those generic features is designed to be more sensitive to the activation maps. This means that the lower part of the model is trained through standard federated averaging across all of the clients. Meanwhile, the upper part of the model is trained entirely on the server side from the activation maps generated by the clients. This approach drastically reduces communication for the model while still making the network robust to various types of input found in the data on the client devices.</p>
</section>
<section id="optimized-aggregation" class="level3" data-number="13.5.4">
<h3 data-number="13.5.4" class="anchored" data-anchor-id="optimized-aggregation"><span class="header-section-number">13.5.4</span> Optimized Aggregation</h3>
<p>In addition to reducing the communication overhead, optimizing the aggregation function can improve model training speed and accuracy in certain federated learning use cases. While the standard for aggregation is just averaging, there are various other approaches which can improve model efficiency, accuracy, and security. One alternative is clipped averaging which clips the model updates within a specific range. Another strategy to preserve security is differential privacy average aggregation. This approach integrates differential privacy into the aggregations tep to protect client identities. Each client adds a layer of random noise to their updates before communicating to the server. The server then updates the server with the noisy updates, meaning that the amount of noise needs to be tuned carefully to balance privacy and accuracy.</p>
<p>In addition to security enhancing aggregation methods, there are several modifications to the aggregation methods that can improve training speed and performance by adding client metadata along with the weight updates. Momentum aggregation is a technique which helps address the convergence problem. In federated learning, client data can be extremely heterogeneous depending on the different environments devices are in. That means that many models with heterogeneous data may struggle to converge. Each client stores a momentum term locally which tracks the pace of change over several updates. With clients communicating this momentum, the server can factor in the rate of change of each update when changing the global model to accelerate convergence. Similarly, weighted aggregation can factoro in the client performance or other parameters like device type or network connection strength to adjust the weight with which the server should incorporate the model updates. Further description of specific aggregation algorithms are described by <span class="citation" data-cites="moshawrab2023reviewing">Moshawrab et al. (<a href="../../references.html#ref-moshawrab2023reviewing" role="doc-biblioref">2023</a>)</span>.</p>
</section>
<section id="handling-non-iid-data" class="level3" data-number="13.5.5">
<h3 data-number="13.5.5" class="anchored" data-anchor-id="handling-non-iid-data"><span class="header-section-number">13.5.5</span> Handling non-IID Data</h3>
<p>When using federated learning to train a model across many client devices, it is convenient to consider the data to be independent and identically distributed (IID) across all clients. When data is IID, the model will converge faster and perform better because each local update on any given client is more representative of the broader dataset. This makes aggregation straightforward as you can directly average all clients. However, this is not how data often appears in the real world. Consider a few of the following ways in which data may be non-IID:</p>
<ul>
<li><p>If you are learning on a set of health-monitor devices, different device models could mean different sensor qualities and properties. This means that low quality sensors and devices may produce data, and therefore model updates distinctly different than high quality ones</p></li>
<li><p>A smart keyboard trained to perform autocorrect. If you have a disproportionate amount of devices from a certain region the slang, sentence structure, or even language they were using could skew more model updates towards a certain style of typing</p></li>
<li><p>If you have wildlife sensors in remote areas, connectivity may not be equally distributed causing some clients in certain regions to be able to send more model updates than others. If those regions have different wildlife activity from certain species, that could skew the updates toward those animals</p></li>
</ul>
<p>There are a few approaches to addressing non-IID data in federated learning. One approach would be to change the aggregation algorithm. If you use a weighted aggregation algorithm, you can adjust based on different client properties like region, sensor properties, or connectivity <span class="citation" data-cites="zhao2018federated">(<a href="../../references.html#ref-zhao2018federated" role="doc-biblioref">Zhao et al. 2018</a>)</span>.</p>
</section>
<section id="client-selection" class="level3" data-number="13.5.6">
<h3 data-number="13.5.6" class="anchored" data-anchor-id="client-selection"><span class="header-section-number">13.5.6</span> Client Selection</h3>
<p>Considering all of the factors influencing the efficacy of federated learning like IID data and communication, client selection is key component to ensuring a system trains well. Selecting the wrong clients can skew the dataset, resulting in non-IID data. Similarly, choosing clients randomly with bad network connections can slow down communication. Therefore, when selecting the right subset of clients, several key characteristics must be considered.</p>
<p>When selecting clients, there are three main components to consider: data heterogeneity, resource allocation, and communication cost. To address data heterogeneity, we can select for clients on the previously proposed metrics in the non-IID section. In federated learning, all devices may not have the same amount of compute, resulting in some being more inefficient at training than others. When selecting a subset of clients for training, one must consider a balance of data heterogeneity and available resources. In an ideal scenario, you can always select the subset of clients with the greatest resources. However, this may skew your dataset so a balance must be struck. Communication differences add another layer to this, you do not want to be bottlenecked by waiting for devices with poor connections to transmit their entire updates. Therefore, you must also consider choosing a subset of diverse yet well-connected devices.</p>
</section>
<section id="an-example-of-deployed-federated-learning-g-board" class="level3" data-number="13.5.7">
<h3 data-number="13.5.7" class="anchored" data-anchor-id="an-example-of-deployed-federated-learning-g-board"><span class="header-section-number">13.5.7</span> An Example of Deployed Federated Learning: G board</h3>
<p>A primary example of a deployed federated learning system is Google’s Keyboard, Gboard, for android devices. In their implementation of federated learning for the keyboard, Google focused on employing differential privacy techniques to protect the user’s data and identity. Gboard leverages language models for several key features such as Next Word Prediction (NWP), Smart Compose (SC), and On-The-Fly rescoring (OTF) <span class="citation" data-cites="xu2023federated">(<a href="../../references.html#ref-xu2023federated" role="doc-biblioref">Xu et al. 2023</a>)</span>, as shown in <a href="#fig-gboard-features" class="quarto-xref">Figure&nbsp;<span>13.7</span></a>.</p>
<p>NWP will anticipate the next word the user is trying to type based on the previous one. SC gives inline suggestions to speed up the typing based on each character. OTF will re-rank the proposed next words based on the active typing process. All three of these models need to run quickly on the edge and federated learning can accelerate training on the users’ data. However, uploading every word a user typed to the cloud for training would be a massive privacy violation. Therefore, federated learning with an emphasis on differential privacy protects the user while still enabling a better user experience.</p>
<div id="fig-gboard-features" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-gboard-features-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/png/ondevice_gboard_example.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-gboard-features-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;13.7: Google G Board Features. Credit: Zheng et al., (<a href="https://arxiv.org/abs/2305.18465">2023</a>).
</figcaption>
</figure>
</div>
<p>To accomplish this goal, Google employed their algorithm DP-FTRL which provides a formal guarantee that trained models will not memorize specific user data or identities. The system desgined of the algorithm is shown in <a href="#fig-differential-privacy" class="quarto-xref">Figure&nbsp;<span>13.8</span></a>. DP-FTRL combined with secure aggregation, a strategy of encrypting model updates, provides an optimal balance of privacy and utility. Furthermore, adaptive clipping is applied in the aggregation process to limit the impact of individual users on the global model (step 3 in <a href="#fig-differential-privacy" class="quarto-xref">Figure&nbsp;<span>13.8</span></a>). Through a combination of all of these techniques, Google can continuously refine their keyboard while preserving user privacy in a formally provable way.</p>
<div id="fig-differential-privacy" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-differential-privacy-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/png/ondevice_gboard_approach.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-differential-privacy-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;13.8: Differential Privacy in G Board. Credit: Zheng et al., (<a href="https://arxiv.org/abs/2305.18465">2023</a>).
</figcaption>
</figure>
</div>
</section>
<section id="benchmarking-for-federated-learning-medperf" class="level3" data-number="13.5.8">
<h3 data-number="13.5.8" class="anchored" data-anchor-id="benchmarking-for-federated-learning-medperf"><span class="header-section-number">13.5.8</span> Benchmarking for Federated Learning: MedPerf</h3>
<p>One of the richest examples of data on the edge is medical devices. These devices store some of the most personal data on users but offer huge advances in personalized treatment and better accuracy in medical AI. Given these two factors, medical devices are the perfect use case for federated learning. <a href="https://doi.org/10.1038/s42256-023-00652-2">MedPerf</a> is an open source platform used to benchmark models using federated evaluation <span class="citation" data-cites="karargyris2023federated">(<a href="../../references.html#ref-karargyris2023federated" role="doc-biblioref">Karargyris et al. 2023</a>)</span>. Instead of just training models via federated learning, MedPerf takes the model to edge devices to test it against personalized data while preserving privacy. In this way a benchmark committee can evaluate various models in the real world on edge devices while still preserving patient anonymity.</p>
</section>
</section>
<section id="security-concerns" class="level2" data-number="13.6">
<h2 data-number="13.6" class="anchored" data-anchor-id="security-concerns"><span class="header-section-number">13.6</span> Security Concerns</h2>
<p>Performing ML model training and adaptation on end-user devices also introduces security risks that must be addressed. Some key security concerns include:</p>
<ul>
<li><strong>Exposure of private data</strong>: Training data may be leaked or stolen from devices</li>
<li><strong>Data poisoning</strong>: Adversaries can manipulate training data to degrade model performance</li>
<li><strong>Model extraction</strong>: Attackers may attempt to steal trained model parameters</li>
<li><strong>Membership inference</strong>: Models may reveal participation of specific users’ data</li>
<li><strong>Evasion attacks</strong>: Specially crafted inputs can cause misclassification</li>
</ul>
<p>Any system that performs learning on-device introduces security concerns, as it may expose vulnerabilities in larger scale models. There are numerous security risks associated with any ML model, but these risks have specific consequences for on-device learning. Fortunately, there are methods to mitigate these risks to improve the real-world performance of on-device learning.</p>
<section id="data-poisoning" class="level3" data-number="13.6.1">
<h3 data-number="13.6.1" class="anchored" data-anchor-id="data-poisoning"><span class="header-section-number">13.6.1</span> Data Poisoning</h3>
<p>On-device ML introduces unique data security challenges compared to traditional cloud-based training. In particular, data poisoning attacks pose a serious threat during on-device learning. Adversaries can manipulate training data to degrade model performance when deployed.</p>
<p>Several data poisoning attack techniques exist:</p>
<ul>
<li><strong>Label Flipping:</strong> It involves applying incorrect labels to samples. For instance, in image classification, cat photos may be labeled as dogs to confuse the model. Flipping even <a href="https://proceedings.mlr.press/v139/schwarzschild21a.html">10% of labels</a> can have significant consequences on the model.</li>
<li><strong>Data Insertion:</strong> It introduces fake or distorted inputs into the training set. This could include pixelated images, noisy audio, or garbled text.</li>
<li><strong>Logic Corruption:</strong> This alters the underlying <a href="https://www.worldscientific.com/doi/10.1142/S0218001414600027">patterns</a> in data to mislead the model. In sentiment analysis, highly negative reviews may be marked positive through this technique. For this reason, recent surveys have shown that many companies are more <a href="https://proceedings.mlr.press/v139/schwarzschild21a.html">afraid of data poisoning</a> than other adversarial ML concerns.</li>
</ul>
<p>What makes data poisoning alarming is how it exploits the discrepancy between curated datasets and live training data. Consider a cat photo dataset collected from the internet. In the weeks later when this data trains a model on-device, new cat photos on the web differ significantly.</p>
<p>With data poisoning, attackers purchase domains and upload content that influences a portion of the training data. Even small data changes significantly impact the model’s learned behavior. Consequently, poisoning can instill racist, sexist, or other harmful biases if unchecked.</p>
<p><a href="https://en.wikipedia.org/wiki/Tay_(chatbot)">Microsoft Tay</a> was a chatbot launched by Microsoft in 2016. It was designed to learn from its interactions with users on social media platforms like Twitter. Unfortunately, Microsoft Tay became a prime example of data poisoning in ML models. Within 24 hours of its launch, Microsoft had to take Tay offline because it had started producing offensive and inappropriate messages, including hate speech and racist comments. This occurred because some users on social media intentionally fed Tay with harmful and offensive input, which the chatbot then learned from and incorporated into its responses.</p>
<p>This incident is a clear example of data poisoning because malicious actors intentionally manipulated the data used to train and inform the chatbot’s responses. The data poisoning resulted in the chatbot adopting harmful biases and producing output that was not intended by its developers. It demonstrates how even small amounts of maliciously crafted data can have a significant impact on the behavior of ML models, and highlights the importance of implementing robust data filtering and validation mechanisms to prevent such incidents from occurring.</p>
<p>The real-world impacts of such biases could be dangerous. Rigorous data validation, anomaly detection, and tracking of data provenance are critical defensive measures. Adopting frameworks like Five Safes ensures models are trained on high-quality, representative data <span class="citation" data-cites="desai2016five">(<a href="../../references.html#ref-desai2016five" role="doc-biblioref">Desai et al. 2016</a>)</span>.</p>
<p>Data poisoning is a pressing concern for secure on-device learning, since data at the endpoint cannot be easily monitored in real-time and if models are allowed to adapt on their own then we run the risk of the device acting malicously. But continued research in adversarial ML aims to develop robust solutions to detect and mitigate such data attacks.</p>
</section>
<section id="adversarial-attacks" class="level3" data-number="13.6.2">
<h3 data-number="13.6.2" class="anchored" data-anchor-id="adversarial-attacks"><span class="header-section-number">13.6.2</span> Adversarial Attacks</h3>
<p>During the training phase, attackers might inject malicious data into the training dataset, which can subtly alter the model’s behavior. For example, an attacker could add images of cats that are labeled as dogs into a dataset used to train an image classification model. If done cleverly, the model’s accuracy might not significantly drop, and the attack could go unnoticed. The model would then incorrectly classify some cats as dogs, which could have consequences depending on the application.</p>
<p>In an embedded security camera system, for instance, this could allow an intruder to avoid detection by wearing a specific pattern that the model has been tricked into classifying as non-threatening.</p>
<p>During the inference phase, attackers can use adversarial examples to fool the model. Adversarial examples are inputs that have been slightly altered in a way that causes the model to make incorrect predictions. For instance, an attacker might add a small amount of noise to an image in a way that causes a face recognition system to misidentify a person. These attacks can be particularly concerning in applications where safety is at stake, such as autonomous vehicles. In the example you mentioned, the researchers were able to cause a traffic sign recognition system to misclassify a stop sign as a speed sign. This type of misclassification could potentially lead to accidents if it occurred in a real-world autonomous driving system.</p>
<p>To mitigate these risks, several defenses can be employed:</p>
<ul>
<li><strong>Data Validation and Sanitization:</strong> Before incorporating new data into the training dataset, it should be thoroughly validated and sanitized to ensure it is not malicious.</li>
<li><strong>Adversarial Training:</strong> The model can be trained on adversarial examples to make it more robust to these types of attacks.</li>
<li><strong>Input Validation:</strong> During inference, inputs should be validated to ensure they have not been manipulated to create adversarial examples.</li>
<li><strong>Regular Auditing and Monitoring:</strong> Regularly auditing and monitoring the model’s behavior can help to detect and mitigate adversarial attacks. In the context of tiny ML systems, this is easier said than done, because it is often hard to monitor embedded ML systems at the endpoint due to communication bandwidth limitations and so forth, which we will discuss in the MLOps chapter.</li>
</ul>
<p>By understanding the potential risks and implementing these defenses, we can help to secure on-device training at the endpoint/edge and mitigate the impact of adversarial attacks. Most people easily confuse data poisoning and adversarial attacks. So here is a table comparing data poisoning and adversarial attacks:</p>
<table class="table">
<colgroup>
<col style="width: 19%">
<col style="width: 39%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th>Aspect</th>
<th>Data Poisoning</th>
<th>Adversarial Attacks</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Timing</strong></td>
<td>Training phase</td>
<td>Inference phase</td>
</tr>
<tr class="even">
<td><strong>Target</strong></td>
<td>Training data</td>
<td>Input data</td>
</tr>
<tr class="odd">
<td><strong>Goal</strong></td>
<td>Negatively affect model’s performance</td>
<td>Cause incorrect predictions</td>
</tr>
<tr class="even">
<td><strong>Method</strong></td>
<td>Insert malicious examples into training data, often with incorrect labels</td>
<td>Add carefully crafted noise to input data</td>
</tr>
<tr class="odd">
<td><strong>Example</strong></td>
<td>Adding images of cats labeled as dogs to a dataset used for training an image classification model</td>
<td>Adding a small amount of noise to an image in a way that causes a face recognition system to misidentify a person</td>
</tr>
<tr class="even">
<td><strong>Potential Effects</strong></td>
<td>Model learns incorrect patterns and makes incorrect predictions</td>
<td>Immediate and potentially dangerous incorrect predictions</td>
</tr>
<tr class="odd">
<td><strong>Applications Affected</strong></td>
<td>Any ML model</td>
<td>Autonomous vehicles, security systems, etc</td>
</tr>
</tbody>
</table>
</section>
<section id="model-inversion" class="level3" data-number="13.6.3">
<h3 data-number="13.6.3" class="anchored" data-anchor-id="model-inversion"><span class="header-section-number">13.6.3</span> Model Inversion</h3>
<p>Model inversion attacks are a privacy threat to on-device machine learning models trained on sensitive user data <span class="citation" data-cites="nguyen2023re">(<a href="../../references.html#ref-nguyen2023re" role="doc-biblioref">Nguyen et al. 2023</a>)</span>. Understanding this attack vector and mitigation strategies will be important for building secure and ethical on-device AI. For example, imagine an iPhone app uses on-device learning to categorize photos in your camera roll into groups like “beach”, “food”, or “selfies” for easier searching.</p>
<p>The on-device model may be pretrained by Apple on a dataset of iCloud photos from consenting users. A malicious attacker could attempt to extract parts of those original iCloud training photos using model inversion. Specifically, the attacker feeds crafted synthetic inputs into the on-device photo classifier. By tweaking the synthetic inputs and observing how the model categorizes them, they can refine the inputs until they reconstruct copies of the original training data - like a beach photo from a user’s iCloud. Now the attacker has breached that user’s privacy by obtaining one of their personal photos without consent. This demonstrates why model inversion is dangerous - it can potentially leak highly sensitive training data.</p>
<p>Photos are an especially high-risk data type because they often contain identifiable people, location information, and private moments. But the same attack methodology could apply to other personal data like audio recordings, text messages, or users’ health data.</p>
<p>To defend against model inversion, one would need to take precautions like adding noise to the model outputs or using privacy-preserving machine learning techniques like <a href="@sec-fl">federated learning</a> to train the on-device model. The goal is to prevent attackers from being able to reconstruct the original training data.</p>
</section>
<section id="on-device-learning-security-concerns" class="level3" data-number="13.6.4">
<h3 data-number="13.6.4" class="anchored" data-anchor-id="on-device-learning-security-concerns"><span class="header-section-number">13.6.4</span> On-Device Learning Security Concerns</h3>
<p>While data poisoning and adversarial attacks are common concerns for ML models in general, on-device learning introduces unique security risks. When on-device variants of large-scale models are published, adversaries can exploit these smaller models to attack their larger counterparts. Research has demonstrated that as on-device models and full-scale models become more similar, the vulnerability of the original large-scale models increases significantly. For instance, evaluations across 19 Deep Neural Networks (DNNs) revealed that exploiting on-device models could increase the vulnerability of the original large-scale models by <a href="http://arxiv.org/abs/2212.13700">up to 100 times</a>.</p>
<p>There are three primary types of security risks specific to on-device learning:</p>
<ul>
<li><p><strong>Transfer-Based Attacks</strong>: These attacks exploit the transferability property between a surrogate model (an approximation of the target model, similar to an on-device model) and a remote target model (the original full-scale model). Attackers generate adversarial examples using the surrogate model, which can then be used to deceive the target model. For example, imagine an on-device model designed to identify spam emails. An attacker could use this model to generate a spam email that is not detected by the larger, full-scale email filtering system.</p></li>
<li><p><strong>Optimization-Based Attacks</strong>: These attacks generate adversarial examples for transfer-based attacks using some form of objective function, and iteratively modify inputs to achieve the desired outcome. Gradient estimation attacks, for example, approximate the model’s gradient using query outputs (such as softmax confidence scores), while gradient-free attacks use the model’s final decision (the predicted class) to approximate the gradient, albeit requiring many more queries.</p></li>
<li><p><strong>Query Attacks with Transfer Priors</strong>: These attacks combine elements of transfer-based and optimization-based attacks. They reverse engineer on-device models to serve as surrogates for the target full-scale model. In other words, attackers use the smaller on-device model to understand how the larger model works, and then use this knowledge to attack the full-scale model.</p></li>
</ul>
<p>By understanding these specific risks associated with on-device learning, we can develop more robust security protocols to protect both on-device and full-scale models from potential attacks.</p>
</section>
<section id="mitigation-of-on-device-learning-risks" class="level3" data-number="13.6.5">
<h3 data-number="13.6.5" class="anchored" data-anchor-id="mitigation-of-on-device-learning-risks"><span class="header-section-number">13.6.5</span> Mitigation of On-Device Learning Risks</h3>
<p>To mitigate the numerous security risks associated with on-device learning, a variety of methods can be employed. These methods may be specific to the type of attack or serve as a general tool to bolster security.</p>
<p>One strategy to reduce security risks is to diminish the similarity between on-device models and full-scale models, thereby reducing transferability by up to 90%. This method, known as similarity-unpairing, addresses the problem that arises when adversaries exploit the input-gradient similarity between the two models. By fine-tuning the full-scale model to create a new version with similar accuracy but different input gradients, we can then construct the on-device model by quantizing this updated full-scale model. This unpairing reduces the vulnerability of on-device models by limiting the exposure of the original full-scale model. Importantly, the order of finetuning and quantization can be varied while still achieving risk mitigation <span class="citation" data-cites="hong2023publishing">(<a href="../../references.html#ref-hong2023publishing" role="doc-biblioref">Hong, Carlini, and Kurakin 2023</a>)</span>.</p>
<p>To tackle data poisoning, it is imperative to source datasets from trusted and reliable <a href="https://www.eetimes.com/cybersecurity-threats-loom-over-endpoint-ai-systems/?_gl=1%2A17zgs0d%2A_ga%2AMTY0MzA1MTAyNS4xNjk4MDgyNzc1%2A_ga_ZLV02RYCZ8%2AMTY5ODA4Mjc3NS4xLjAuMTY5ODA4Mjc3NS42MC4wLjA">vendors</a>.</p>
<p>In combating adversarial attacks, several strategies can be employed. A proactive approach involves generating adversarial examples and incorporating them into the model’s training dataset, thereby fortifying the model against such attacks. Tools like <a href="http://github.com/cleverhans-lab/cleverhans">CleverHans</a>, an open-source training library, are instrumental in creating adversarial examples. Defense distillation is another effective strategy, wherein the on-device model outputs probabilities of different classifications rather than definitive decisions <span class="citation" data-cites="hong2023publishing">(<a href="../../references.html#ref-hong2023publishing" role="doc-biblioref">Hong, Carlini, and Kurakin 2023</a>)</span>, making it more challenging for adversarial examples to exploit the model.</p>
<p>The theft of intellectual property is another significant concern when deploying on-device models. Intellectual property theft is a concern when deploying on-device models, as adversaries may attempt to reverse-engineer the model to steal the underlying technology. To safeguard against intellectual property theft, the binary executable of the trained model should be stored on a microcontroller unit with encrypted software and secured physical interfaces of the chip. Furthermore, the final dataset used for training the model should be kept <a href="https://www.eetimes.com/cybersecurity-threats-loom-over-endpoint-ai-systems/?_gl=1%2A17zgs0d%2A_ga%2AMTY0MzA1MTAyNS4xNjk4MDgyNzc1%2A_ga_ZLV02RYCZ8%2AMTY5ODA4Mjc3NS4xLjAuMTY5ODA4Mjc3NS42MC4wLjA">private</a>.</p>
<p>Furthermore, on-device models often utilize well-known or open-source datasets, such as MobileNet’s Visual Wake Words. As such, it is important to maintain the <a href="http://arxiv.org/abs/2212.13700">privacy of the final dataset</a> used for training the model. Additionally, protecting the data augmentation process and incorporating specific use cases can minimize the risk of reverse-engineering an on-device model.</p>
<p>Lastly, the Adversarial Threat Landscape for Artificial-Intelligence Systems (<a href="https://atlas.mitre.org/">ATLAS</a>) serves as a valuable matrix tool that helps assess the risk profile of on-device models, empowering developers to identify and <a href="https://www.eetimes.com/cybersecurity-threats-loom-over-endpoint-ai-systems/?_gl=1%2A17zgs0d%2A_ga%2AMTY0MzA1MTAyNS4xNjk4MDgyNzc1%2A_ga_ZLV02RYCZ8%2AMTY5ODA4Mjc3NS4xLjAuMTY5ODA4Mjc3NS42MC4wLjA">mitigate</a> potential risks proactively.</p>
</section>
<section id="securing-training-data" class="level3" data-number="13.6.6">
<h3 data-number="13.6.6" class="anchored" data-anchor-id="securing-training-data"><span class="header-section-number">13.6.6</span> Securing Training Data</h3>
<p>There are a variety of different ways to secure on-device training data. Each of these concepts in itself is really deep and could be worth a class by itself. So here we’ll briefly allude to those concepts so you’re aware about what to learn further.</p>
<section id="encryption" class="level4">
<h4 class="anchored" data-anchor-id="encryption">Encryption</h4>
<p>Encryption serves as the first line of defense for training data. This involves implementing end-to-end encryption for both local storage on devices and communication channels to prevent unauthorized access to raw training data. Trusted execution environments, such as <a href="https://www.intel.com/content/www/us/en/architecture-and-technology/software-guard-extensions.html">Intel SGX</a> and <a href="https://www.arm.com/technologies/trustzone-for-cortex-a#:~:text=Arm%20TrustZone%20technology%20offers%20an,trust%20based%20on%20PSA%20guidelines.">ARM TrustZone</a>, are essential for facilitating secure training on encrypted data.</p>
<p>Additionally, when aggregating updates from multiple devices, secure multi-party computation protocols can be employed to enhance security <span class="citation" data-cites="kairouz2015secure">(<a href="../../references.html#ref-kairouz2015secure" role="doc-biblioref">Kairouz, Oh, and Viswanath 2015</a>)</span>. A practical application of this is in collaborative on-device learning, where cryptographic privacy-preserving aggregation of user model updates can be implemented. This technique effectively hides individual user data even during the aggregation phase.</p>
</section>
<section id="differential-privacy" class="level4">
<h4 class="anchored" data-anchor-id="differential-privacy">Differential Privacy</h4>
<p>Differential privacy is another crucial strategy for protecting training data. By injecting calibrated statistical noise into the data, we can mask individual records while still extracting valuable population patterns <span class="citation" data-cites="dwork2014algorithmic">(<a href="../../references.html#ref-dwork2014algorithmic" role="doc-biblioref">Dwork and Roth 2013</a>)</span>. Managing the privacy budget across multiple training iterations and reducing noise as the model converges is also vital <span class="citation" data-cites="abadi2016deep">(<a href="../../references.html#ref-abadi2016deep" role="doc-biblioref">Abadi et al. 2016</a>)</span>. Methods such as formally provable differential privacy, which may include adding Laplace or Gaussian noise scaled to the dataset’s sensitivity, can be employed.</p>
</section>
<section id="anomaly-detection" class="level4">
<h4 class="anchored" data-anchor-id="anomaly-detection">Anomaly Detection</h4>
<p>Anomaly detection plays an important role in identifying and mitigating potential data poisoning attacks. This can be achieved through statistical analyses like Principal Component Analysis (PCA) and clustering, which help to detect deviations in aggregated training data. Time-series methods such as <a href="https://en.wikipedia.org/wiki/CUSUM">Cumulative Sum (CUSUM)</a> charts are useful for identifying shifts indicative of potential poisoning. Comparing current data distributions with previously seen clean data distributions can also help to flag anomalies. Moreover, suspected poisoned batches should be removed from the training update aggregation process. For example, spot checks on subsets of training images on devices can be conducted using photoDNA hashes to identify poisoned inputs.</p>
</section>
<section id="input-data-validation" class="level4">
<h4 class="anchored" data-anchor-id="input-data-validation">Input Data Validation</h4>
<p>Lastly, input data validation is essential for ensuring the integrity and validity of input data before it is fed into the training model, thereby protecting against adversarial payloads. Similarity measures, such as cosine distance, can be employed to catch inputs that deviate significantly from the expected distribution. Suspicious inputs that may contain adversarial payloads should be quarantined and sanitized. Furthermore, parser access to training data should be restricted to validated code paths only. Leveraging hardware security features, such as ARM Pointer Authentication, can prevent memory corruption (ARM Limited, 2023). An example of this is implementing input integrity checks on audio training data used by smart speakers before processing by the speech recognition model <span class="citation" data-cites="chen2023learning">(<a href="../../references.html#ref-chen2023learning" role="doc-biblioref">Z. Chen and Xu 2023</a>)</span>.</p>
</section>
</section>
</section>
<section id="on-device-training-frameworks" class="level2" data-number="13.7">
<h2 data-number="13.7" class="anchored" data-anchor-id="on-device-training-frameworks"><span class="header-section-number">13.7</span> On-Device Training Frameworks</h2>
<p>Embedded inference frameworks like TF-Lite Micro <span class="citation" data-cites="david2021tensorflow">(<a href="../../references.html#ref-david2021tensorflow" role="doc-biblioref">David et al. 2021</a>)</span>, TVM <span class="citation" data-cites="chen2018tvm">(<a href="../../references.html#ref-chen2018tvm" role="doc-biblioref">T. Chen et al. 2018</a>)</span>, and MCUNet <span class="citation" data-cites="lin2020mcunet">(<a href="../../references.html#ref-lin2020mcunet" role="doc-biblioref">Lin et al. 2020</a>)</span> provide a slim runtime for running neural network models on microcontrollers and other resource-constrained devices. However, they don’t support on-device training. Training requires its own set of specialized tools due to the impact of quantization on gradient calculation and the memory footprint of backpropagation <span class="citation" data-cites="lin2022device">(<a href="../../references.html#ref-lin2022device" role="doc-biblioref">Lin et al. 2022</a>)</span>.</p>
<p>In recent years, there are a handful of tools and frameworks that have started to emerge that enable on-device training, and these include Tiny Training Engine <span class="citation" data-cites="lin2022device">(<a href="../../references.html#ref-lin2022device" role="doc-biblioref">Lin et al. 2022</a>)</span>, TinyTL <span class="citation" data-cites="cai2020tinytl">(<a href="../../references.html#ref-cai2020tinytl" role="doc-biblioref">Cai et al. 2020</a>)</span>, and TinyTrain <span class="citation" data-cites="kwon2023tinytrain">(<a href="../../references.html#ref-kwon2023tinytrain" role="doc-biblioref">Kwon et al. 2023</a>)</span>.</p>
<section id="tiny-training-engine" class="level3" data-number="13.7.1">
<h3 data-number="13.7.1" class="anchored" data-anchor-id="tiny-training-engine"><span class="header-section-number">13.7.1</span> Tiny Training Engine</h3>
<p>Tiny Training Engine (TTE) uses several techniques to optimize memory usage and speed up the training process. An overview of the TTE workflow is shown in <a href="#fig-tte-workflow" class="quarto-xref">Figure&nbsp;<span>13.9</span></a>. First, TTE offloads the automatic differentiation to compile time instead of runtime. This significantly reduces overhead during training. Second, TTE performs graph optimization like pruning and sparse updates to reduce memory requirements and accelerate computations.</p>
<div id="fig-tte-workflow" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-tte-workflow-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/png/ondevice_training_flow.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-tte-workflow-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;13.9: TTE workflow.
</figcaption>
</figure>
</div>
<p>Specifically, TTE follows four main steps:</p>
<ul>
<li>During compile time, TTE traces the forward propagation graph and derives the corresponding backward graph for backpropagation. This allows <a href="https://harvard-edge.github.io/cs249r_book/frameworks.html#differentiable-programming">differentiation</a> to happen at compile time rather than runtime.</li>
<li>TTE prunes any nodes representing frozen weights from the backward graph. Frozen weights are weights that are not updated during training to reduce certain neurons’ impact. Pruning their nodes saves memory.</li>
<li>TTE reorders the gradient descent operators to interleave them with the backward pass computations. This scheduling minimizes memory footprints.</li>
<li>TTE uses code generation to compile the optimized forward and backward graphs, which are then deployed for on-device training.</li>
</ul>
</section>
<section id="tiny-transfer-learning" class="level3" data-number="13.7.2">
<h3 data-number="13.7.2" class="anchored" data-anchor-id="tiny-transfer-learning"><span class="header-section-number">13.7.2</span> Tiny Transfer Learning</h3>
<p>Tiny Transfer Learning (TinyTL) enables memory-efficient on-device training through a technique called weight freezing. During training, much of the memory bottleneck comes from storing intermediate activations and updating the weights in the neural network.</p>
<p>To reduce this memory overhead, TinyTL freezes the majority of the weights so they do not need to be updated during training. This eliminates the need to store intermediate activations for frozen parts of the network. TinyTL only fine-tunes the bias terms, which are much smaller than the weights. An overview of TinyTL workflow is shown in <a href="#fig-tinytl-workflow" class="quarto-xref">Figure&nbsp;<span>13.10</span></a>.</p>
<div id="fig-tinytl-workflow" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-tinytl-workflow-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/png/ondevice_transfer_tinytl.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-tinytl-workflow-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;13.10: TinyTL workflow. Credit: <span class="citation" data-cites="cai2020tinytl">Cai et al. (<a href="../../references.html#ref-cai2020tinytl" role="doc-biblioref">2020</a>)</span>.)
</figcaption>
</figure>
</div>
<p>Freezing weights is applicable not just to fully-connected layers but also to convolutional and normalization layers. However, only adapting the biases limits the model’s ability to learn and adapt to new data.</p>
<p>To increase adaptability without much additional memory, TinyTL uses a small residual learning model. This refines the intermediate feature maps to produce better outputs, even with fixed weights. The residual model introduces minimal overhead - less than 3.8% on top of the base model.</p>
<p>By freezing most weights TinyTL significantly cuts down memory usage during on-device training. The residual model then allows it to still adapt and learn effectively for the task. The combined approach provides memory-efficient on-device training with minimal impact on model accuracy.</p>
</section>
<section id="tiny-train" class="level3" data-number="13.7.3">
<h3 data-number="13.7.3" class="anchored" data-anchor-id="tiny-train"><span class="header-section-number">13.7.3</span> Tiny Train</h3>
<p>TinyTrain significantly reduces the time required for on-device training by selectively updating only certain parts of the model. It does this using a technique called task-adaptive sparse updating, as shown in <a href="#fig-tiny-train" class="quarto-xref">Figure&nbsp;<span>13.11</span></a>.</p>
<p>Based on the user data, memory, and compute available on the device, TinyTrain dynamically chooses which layers of the neural network to update during training. This layer selection is optimized to reduce computation and memory usage while maintaining high accuracy.</p>
<div id="fig-tiny-train" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-tiny-train-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/png/ondevice_pretraining.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-tiny-train-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;13.11: TinyTrain workflow. Credit: <span class="citation" data-cites="kwon2023tinytrain">Kwon et al. (<a href="../../references.html#ref-kwon2023tinytrain" role="doc-biblioref">2023</a>)</span>.
</figcaption>
</figure>
</div>
<p>More specifically, TinyTrain first does offline pretraining of the model. During pretraining, it not only trains the model on the task data but also meta-trains the model. Meta-training means training the model on metadata about the training process itself. This meta-learning improves the model’s ability to adapt accurately even when limited data is available for the target task.</p>
<p>Then, during the online adaptation stage when the model is being customized on the device, TinyTrain performs task-adaptive sparse updates. Using the criteria around the device’s capabilities, it selects only certain layers to update through backpropagation. The layers are chosen to balance accuracy, memory usage, and computation time.</p>
<p>By sparsely updating layers tailored to the device and task, TinyTrain is able to significantly reduce on-device training time and resource usage. The offline meta-training also improves accuracy when adapting with limited data. Together, these methods enable fast, efficient, and accurate on-device training.</p>
</section>
<section id="comparison" class="level3" data-number="13.7.4">
<h3 data-number="13.7.4" class="anchored" data-anchor-id="comparison"><span class="header-section-number">13.7.4</span> Comparison</h3>
<p>Here is a table summarizing the key similarities and differences between the Tiny Training Engine, TinyTL, and TinyTrain frameworks:</p>
<table class="table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>Framework</th>
<th>Similarities</th>
<th>Differences</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Tiny Training Engine</td>
<td>On-device training <br> Optimize memory &amp; computation <br> Leverage pruning, sparsity, etc</td>
<td>Traces forward &amp; backward graphs <br> Prunes frozen weights <br> Interleaves backprop &amp; gradients <br> Code generation</td>
</tr>
<tr class="even">
<td>TinyTL</td>
<td>On-device training <br> Optimize memory &amp; computation <br> Leverage freezing, sparsity, etc</td>
<td>Freezes most weights <br> Only adapts biases <br> Uses residual model</td>
</tr>
<tr class="odd">
<td>TinyTrain</td>
<td>On-device training <br> Optimize memory &amp; computation <br> Leverage sparsity, etc</td>
<td>Meta-training in pretraining <br> Task-adaptive sparse updating <br> Selective layer updating</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="conclusion" class="level2" data-number="13.8">
<h2 data-number="13.8" class="anchored" data-anchor-id="conclusion"><span class="header-section-number">13.8</span> Conclusion</h2>
<p>The concept of on-device learning is increasingly important for increasing the usability and scalability of TinyML. This chapter explored the intricacies of on-device learning, exploring its advantages and limitations, adaptation strategies, key related algorithms and techniques, security implications, and existing and emerging on-device training frameworks.</p>
<p>On-device learning is, undoubtedly, a groundbreaking paradigm that brings forth numerous advantages for embedded and edge ML deployments. By performing training directly on the endpoint devices, on-device learning obviates the need for continuous cloud connectivity, making it particularly well-suited for IoT and edge computing applications. It comes with benefits such as improved privacy, ease of compliance, and resource efficiency. At the same time, on-device learning faces limitations related to hardware constraints, limited data size, and reduced model accuracy and generalization.</p>
<p>Mechanisms such as reduced model complexity, optimization and data compression techniques, and related learning methods such as transfer learning and federated learning allow models to adapt to learn and evolve under resource constraints, thus serving as the bedrock for effective ML on edge devices.</p>
<p>The critical security concerns in on-device learning highlighted in this chapter, ranging from data poisoning and adversarial attacks to specific risks introduced by on-device learning, must be addressed in real workloads for on-device learning to be a viable paradigm. Effective mitigation strategies, such as data validation, encryption, differential privacy, anomaly detection, and input data validation, are crucial to safeguard on-device learning systems from these threats.</p>
<p>The emergence of specialized on-device training frameworks like Tiny Training Engine, Tiny Transfer Learning, and Tiny Train presents practical tools to enable efficient on-device training. These frameworks employ various techniques to optimize memory usage, reduce computational overhead, and streamline the on-device training process.</p>
<p>In conclusion, on-device learning stands at the forefront of TinyML, promising a future where models can autonomously acquire knowledge and adapt to changing environments on edge devices. The application of on-device learning has the potential to revolutionize various domains, including healthcare, industrial IoT, and smart cities. However, the transformative potential of on-device learning must be balanced with robust security measures to protect against data breaches and adversarial threats. Embracing innovative on-device training frameworks and implementing stringent security protocols are key steps in unlocking the full potential of on-device learning. As this technology continues to evolve, it holds the promise of making our devices smarter, more responsive, and better integrated into our daily lives.</p>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-abadi2016deep" class="csl-entry" role="listitem">
Abadi, Martin, Andy Chu, Ian Goodfellow, H. Brendan McMahan, Ilya Mironov, Kunal Talwar, and Li Zhang. 2016. <span>“Deep Learning with Differential Privacy.”</span> In <em>Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security</em>, 308–18. CCS ’16. New York, NY, USA: ACM. <a href="https://doi.org/10.1145/2976749.2978318">https://doi.org/10.1145/2976749.2978318</a>.
</div>
<div id="ref-cai2020tinytl" class="csl-entry" role="listitem">
Cai, Han, Chuang Gan, Ligeng Zhu, and Song Han. 2020. <span>“TinyTL: Reduce Memory, Not Parameters for Efficient on-Device Learning.”</span> In <em>Advances in Neural Information Processing Systems</em>. Vol. 33.
</div>
<div id="ref-chen2018tvm" class="csl-entry" role="listitem">
Chen, Tianqi, Thierry Moreau, Ziheng Jiang, Lianmin Zheng, Eddie Yan, Haichen Shen, Meghan Cowan, et al. 2018. <span>“<span>TVM:</span> <span>An</span> Automated End-to-End Optimizing Compiler for Deep Learning.”</span> In <em>13th USENIX Symposium on Operating Systems Design and Implementation (OSDI 18)</em>, 578–94.
</div>
<div id="ref-chen2016training" class="csl-entry" role="listitem">
Chen, Tianqi, Bing Xu, Chiyuan Zhang, and Carlos Guestrin. 2016. <span>“Training Deep Nets with Sublinear Memory Cost.”</span> <em>ArXiv Preprint</em> abs/1604.06174. <a href="https://arxiv.org/abs/1604.06174">https://arxiv.org/abs/1604.06174</a>.
</div>
<div id="ref-chen2023learning" class="csl-entry" role="listitem">
Chen, Zhiyong, and Shugong Xu. 2023. <span>“Learning Domain-Heterogeneous Speaker Recognition Systems with Personalized Continual Federated Learning.”</span> <em>EURASIP Journal on Audio, Speech, and Music Processing</em> 2023 (1): 33. <a href="https://doi.org/10.1186/s13636-023-00299-2">https://doi.org/10.1186/s13636-023-00299-2</a>.
</div>
<div id="ref-rouhani2017tinydl" class="csl-entry" role="listitem">
Darvish Rouhani, Bita, Azalia Mirhoseini, and Farinaz Koushanfar. 2017. <span>“<span>TinyDL:</span> <span class="nocase">Just-in-time</span> Deep Learning Solution for Constrained Embedded Systems.”</span> In <em>2017 IEEE International Symposium on Circuits and Systems (ISCAS)</em>, 1–4. IEEE. <a href="https://doi.org/10.1109/iscas.2017.8050343">https://doi.org/10.1109/iscas.2017.8050343</a>.
</div>
<div id="ref-david2021tensorflow" class="csl-entry" role="listitem">
David, Robert, Jared Duke, Advait Jain, Vijay Janapa Reddi, Nat Jeffries, Jian Li, Nick Kreeger, et al. 2021. <span>“Tensorflow Lite Micro: <span>Embedded</span> Machine Learning for Tinyml Systems.”</span> <em>Proceedings of Machine Learning and Systems</em> 3: 800–811.
</div>
<div id="ref-desai2016five" class="csl-entry" role="listitem">
Desai, Tanvi, Felix Ritchie, Richard Welpton, et al. 2016. <span>“Five Safes: <span>Designing</span> Data Access for Research.”</span> <em>Economics Working Paper Series</em> 1601: 28.
</div>
<div id="ref-dhar2021survey" class="csl-entry" role="listitem">
Dhar, Sauptik, Junyao Guo, Jiayi (Jason) Liu, Samarth Tripathi, Unmesh Kurup, and Mohak Shah. 2021. <span>“A Survey of on-Device Machine Learning: An Algorithms and Learning Theory Perspective.”</span> <em>ACM Transactions on Internet of Things</em> 2 (3): 1–49. <a href="https://doi.org/10.1145/3450494">https://doi.org/10.1145/3450494</a>.
</div>
<div id="ref-dwork2014algorithmic" class="csl-entry" role="listitem">
Dwork, Cynthia, and Aaron Roth. 2013. <span>“The Algorithmic Foundations of Differential Privacy.”</span> <em>Foundations and Trends<span></span> in Theoretical Computer Science</em> 9 (3-4): 211–407. <a href="https://doi.org/10.1561/0400000042">https://doi.org/10.1561/0400000042</a>.
</div>
<div id="ref-esteva2017dermatologist" class="csl-entry" role="listitem">
Esteva, Andre, Brett Kuprel, Roberto A. Novoa, Justin Ko, Susan M. Swetter, Helen M. Blau, and Sebastian Thrun. 2017. <span>“Dermatologist-Level Classification of Skin Cancer with Deep Neural Networks.”</span> <em>Nature</em> 542 (7639): 115–18. <a href="https://doi.org/10.1038/nature21056">https://doi.org/10.1038/nature21056</a>.
</div>
<div id="ref-gruslys2016memory" class="csl-entry" role="listitem">
Gruslys, Audrunas, Rémi Munos, Ivo Danihelka, Marc Lanctot, and Alex Graves. 2016. <span>“Memory-Efficient Backpropagation Through Time.”</span> In <em>Advances in Neural Information Processing Systems 29: Annual Conference on Neural Information Processing Systems 2016, December 5-10, 2016, Barcelona, Spain</em>, edited by Daniel D. Lee, Masashi Sugiyama, Ulrike von Luxburg, Isabelle Guyon, and Roman Garnett, 4125–33. <a href="https://proceedings.neurips.cc/paper/2016/hash/a501bebf79d570651ff601788ea9d16d-Abstract.html">https://proceedings.neurips.cc/paper/2016/hash/a501bebf79d570651ff601788ea9d16d-Abstract.html</a>.
</div>
<div id="ref-hong2023publishing" class="csl-entry" role="listitem">
Hong, Sanghyun, Nicholas Carlini, and Alexey Kurakin. 2023. <span>“Publishing Efficient on-Device Models Increases Adversarial Vulnerability.”</span> In <em>2023 IEEE Conference on Secure and Trustworthy Machine Learning (SaTML)</em>, 271–90. IEEE; IEEE. <a href="https://doi.org/10.1109/satml54575.2023.00026">https://doi.org/10.1109/satml54575.2023.00026</a>.
</div>
<div id="ref-kairouz2015secure" class="csl-entry" role="listitem">
Kairouz, Peter, Sewoong Oh, and Pramod Viswanath. 2015. <span>“Secure Multi-Party Differential Privacy.”</span> In <em>Advances in Neural Information Processing Systems 28: Annual Conference on Neural Information Processing Systems 2015, December 7-12, 2015, Montreal, Quebec, Canada</em>, edited by Corinna Cortes, Neil D. Lawrence, Daniel D. Lee, Masashi Sugiyama, and Roman Garnett, 2008–16. <a href="https://proceedings.neurips.cc/paper/2015/hash/a01610228fe998f515a72dd730294d87-Abstract.html">https://proceedings.neurips.cc/paper/2015/hash/a01610228fe998f515a72dd730294d87-Abstract.html</a>.
</div>
<div id="ref-karargyris2023federated" class="csl-entry" role="listitem">
Karargyris, Alexandros, Renato Umeton, Micah J Sheller, Alejandro Aristizabal, Johnu George, Anna Wuest, Sarthak Pati, et al. 2023. <span>“Federated Benchmarking of Medical Artificial Intelligence with <span>MedPerf</span>.”</span> <em>Nature Machine Intelligence</em> 5 (7): 799–810. <a href="https://doi.org/10.1038/s42256-023-00652-2">https://doi.org/10.1038/s42256-023-00652-2</a>.
</div>
<div id="ref-kwon2023tinytrain" class="csl-entry" role="listitem">
Kwon, Young D, Rui Li, Stylianos I Venieris, Jagmohan Chauhan, Nicholas D Lane, and Cecilia Mascolo. 2023. <span>“<span>TinyTrain:</span> <span>Deep</span> Neural Network Training at the Extreme Edge.”</span> <em>ArXiv Preprint</em> abs/2307.09988. <a href="https://arxiv.org/abs/2307.09988">https://arxiv.org/abs/2307.09988</a>.
</div>
<div id="ref-li2016lightrnn" class="csl-entry" role="listitem">
Li, Xiang, Tao Qin, Jian Yang, and Tie-Yan Liu. 2016. <span>“LightRNN: Memory and Computation-Efficient Recurrent Neural Networks.”</span> In <em>Advances in Neural Information Processing Systems 29: Annual Conference on Neural Information Processing Systems 2016, December 5-10, 2016, Barcelona, Spain</em>, edited by Daniel D. Lee, Masashi Sugiyama, Ulrike von Luxburg, Isabelle Guyon, and Roman Garnett, 4385–93. <a href="https://proceedings.neurips.cc/paper/2016/hash/c3e4035af2a1cde9f21e1ae1951ac80b-Abstract.html">https://proceedings.neurips.cc/paper/2016/hash/c3e4035af2a1cde9f21e1ae1951ac80b-Abstract.html</a>.
</div>
<div id="ref-lin2020mcunet" class="csl-entry" role="listitem">
Lin, Ji, Wei-Ming Chen, Yujun Lin, John Cohn, Chuang Gan, and Song Han. 2020. <span>“MCUNet: Tiny Deep Learning on IoT Devices.”</span> In <em>Advances in Neural Information Processing Systems 33: Annual Conference on Neural Information Processing Systems 2020, NeurIPS 2020, December 6-12, 2020, Virtual</em>, edited by Hugo Larochelle, Marc’Aurelio Ranzato, Raia Hadsell, Maria-Florina Balcan, and Hsuan-Tien Lin. <a href="https://proceedings.neurips.cc/paper/2020/hash/86c51678350f656dcc7f490a43946ee5-Abstract.html">https://proceedings.neurips.cc/paper/2020/hash/86c51678350f656dcc7f490a43946ee5-Abstract.html</a>.
</div>
<div id="ref-lin2022device" class="csl-entry" role="listitem">
Lin, Ji, Ligeng Zhu, Wei-Ming Chen, Wei-Chen Wang, Chuang Gan, and Song Han. 2022. <span>“On-Device Training Under 256kb Memory.”</span> <em>Adv. Neur. In.</em> 35: 22941–54.
</div>
<div id="ref-moshawrab2023reviewing" class="csl-entry" role="listitem">
Moshawrab, Mohammad, Mehdi Adda, Abdenour Bouzouane, Hussein Ibrahim, and Ali Raad. 2023. <span>“Reviewing Federated Learning Aggregation Algorithms; Strategies, Contributions, Limitations and Future Perspectives.”</span> <em>Electronics</em> 12 (10): 2287. <a href="https://doi.org/10.3390/electronics12102287">https://doi.org/10.3390/electronics12102287</a>.
</div>
<div id="ref-nguyen2023re" class="csl-entry" role="listitem">
Nguyen, Ngoc-Bao, Keshigeyan Chandrasegaran, Milad Abdollahzadeh, and Ngai-Man Cheung. 2023. <span>“Re-Thinking Model Inversion Attacks Against Deep Neural Networks.”</span> In <em>2023 IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR)</em>, 16384–93. IEEE. <a href="https://doi.org/10.1109/cvpr52729.2023.01572">https://doi.org/10.1109/cvpr52729.2023.01572</a>.
</div>
<div id="ref-pan2009survey" class="csl-entry" role="listitem">
Pan, Sinno Jialin, and Qiang Yang. 2010. <span>“A Survey on Transfer Learning.”</span> <em>IEEE Trans. Knowl. Data Eng.</em> 22 (10): 1345–59. <a href="https://doi.org/10.1109/tkde.2009.191">https://doi.org/10.1109/tkde.2009.191</a>.
</div>
<div id="ref-shi2022data" class="csl-entry" role="listitem">
Shi, Hongrui, and Valentin Radu. 2022. <span>“Data Selection for Efficient Model Update in Federated Learning.”</span> In <em>Proceedings of the 2nd European Workshop on Machine Learning and Systems</em>, 72–78. ACM. <a href="https://doi.org/10.1145/3517207.3526980">https://doi.org/10.1145/3517207.3526980</a>.
</div>
<div id="ref-wu2022sustainable" class="csl-entry" role="listitem">
Wu, Carole-Jean, Ramya Raghavendra, Udit Gupta, Bilge Acun, Newsha Ardalani, Kiwan Maeng, Gloria Chang, et al. 2022. <span>“Sustainable Ai: <span>Environmental</span> Implications, Challenges and Opportunities.”</span> <em>Proceedings of Machine Learning and Systems</em> 4: 795–813.
</div>
<div id="ref-xu2023federated" class="csl-entry" role="listitem">
Xu, Zheng, Yanxiang Zhang, Galen Andrew, Christopher A Choquette-Choo, Peter Kairouz, H Brendan McMahan, Jesse Rosenstock, and Yuanbo Zhang. 2023. <span>“Federated Learning of Gboard Language Models with Differential Privacy.”</span> <em>ArXiv Preprint</em> abs/2305.18465. <a href="https://arxiv.org/abs/2305.18465">https://arxiv.org/abs/2305.18465</a>.
</div>
<div id="ref-yang2023online" class="csl-entry" role="listitem">
Yang, Tien-Ju, Yonghui Xiao, Giovanni Motta, Françoise Beaufays, Rajiv Mathews, and Mingqing Chen. 2023. <span>“Online Model Compression for Federated Learning with Large Models.”</span> In <em>ICASSP 2023 - 2023 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP)</em>, 1–5. IEEE; IEEE. <a href="https://doi.org/10.1109/icassp49357.2023.10097124">https://doi.org/10.1109/icassp49357.2023.10097124</a>.
</div>
<div id="ref-zhao2018federated" class="csl-entry" role="listitem">
Zhao, Yue, Meng Li, Liangzhen Lai, Naveen Suda, Damon Civin, and Vikas Chandra. 2018. <span>“Federated Learning with Non-Iid Data.”</span> <em>ArXiv Preprint</em> abs/1806.00582. <a href="https://arxiv.org/abs/1806.00582">https://arxiv.org/abs/1806.00582</a>.
</div>
<div id="ref-zhuang2021comprehensive" class="csl-entry" role="listitem">
Zhuang, Fuzhen, Zhiyuan Qi, Keyu Duan, Dongbo Xi, Yongchun Zhu, Hengshu Zhu, Hui Xiong, and Qing He. 2021. <span>“A Comprehensive Survey on Transfer Learning.”</span> <em>Proceedings of the IEEE</em> 109 (1): 43–76. <a href="https://doi.org/10.1109/JPROC.2020.3004555">https://doi.org/10.1109/JPROC.2020.3004555</a>.
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../contents/benchmarking/benchmarking.html" class="pagination-link  aria-label=" &lt;span="" ai&lt;="" span&gt;"="">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Benchmarking AI</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../contents/ops/ops.html" class="pagination-link" aria-label="<span class='chapter-number'>14</span>&nbsp; <span class='chapter-title'>Embedded AIOps</span>">
        <span class="nav-page-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Embedded AIOps</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Edited by Prof.&nbsp;Vijay Janapa Reddi (Harvard University)</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/harvard-edge/cs249r_book/edit/main/contents/ondevice_learning/ondevice_learning.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/harvard-edge/cs249r_book/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li><li><a href="https://github.com/harvard-edge/cs249r_book/blob/main/contents/ondevice_learning/ondevice_learning.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>This book was built with <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>




</body></html>