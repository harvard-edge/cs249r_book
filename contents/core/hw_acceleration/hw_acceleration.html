<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.22">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>11&nbsp; AI Acceleration – Machine Learning Systems</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>

<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../contents/core/benchmarking/benchmarking.html" rel="next">
<link href="../../../contents/core/optimizations/optimizations.html" rel="prev">
<link href="../../../favicon.png" rel="icon" type="image/png">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-dark-34508e5e58b8127575b7405b0c3a6b03.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-68bca3a50acd80feb0cb8c3c361c6f22.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-dark-a663e6bfba90bed7713841609c58f0c5.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../../site_libs/bootstrap/bootstrap-9086c98c903691155b39be0cadd49f03.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<script src="../../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet"><script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "~",
    "/"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-M21L0CBCVN"></script><script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-M21L0CBCVN', { 'anonymize_ip': true});
</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-M21L0CBCVN"></script><script type="module" src="../../../scripts/ai_menu/dist/bundle.js" defer=""></script><script type="module" src="../../../scripts/ai_menu/dist/sqlite3-opfs-async-proxy-B_ImRJXp.js"></script><script type="module" src="../../../scripts/ai_menu/dist/sqlite3-worker1-bundler-friendly-CbDNa4by.js"></script><script type="module" src="../../../scripts/ai_menu/dist/worker-voUF5YDa.js"></script><script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script><script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>
</head>
<body class="nav-sidebar floating nav-fixed slimcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><nav class="navbar navbar-expand-lg " data-bs-theme="dark"><div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Machine Learning Systems</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-wide tools-end">
    <a href="https://github.com/harvard-edge/cs249r_book" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="../../../Machine-Learning-Systems.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
    <div class="dropdown">
      <a href="" title="Share" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" role="link" aria-label="Share"><i class="bi bi-share"></i></a>
      <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="quarto-navigation-tool-dropdown-0">
<li>
            <a class="dropdown-item quarto-navbar-tools-item" href="https://twitter.com/intent/tweet?url=%7Curl%7C">
              <i class="bi bi-twitter pe-1"></i>
            Twitter
            </a>
          </li>
          <li>
            <a class="dropdown-item quarto-navbar-tools-item" href="https://www.facebook.com/sharer/sharer.php?u=%7Curl%7C">
              <i class="bi bi-facebook pe-1"></i>
            Facebook
            </a>
          </li>
      </ul>
</div>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav><nav class="quarto-secondary-nav"><div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../contents/core/hw_acceleration/hw_acceleration.html"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">AI Acceleration</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav><div id="quarto-announcement" data-announcement-id="516b1a1219b9ad93e03bf11eebdf0272" class="alert alert-primary hidden">
<i class="bi bi-book quarto-announcement-icon"></i><div class="quarto-announcement-content">
🔔 <b>What’s New in the Book?</b><br> 📘 <b>[May 05]:</b> Revised Ch. 14 (<i>On-Device Learning</i> 📱).<br> 🛠️ <b>[Mar 25]:</b> Major updates to Ch. 13 (<i>ML Operations</i> ⚙️), Ch. 17–19 (<i>Sustainable AI</i> 🌿, <i>Robust AI</i> 🛡️, <i>AI for Good</i> 🌍).<br> 🚀 <b>[Mar 03]:</b> Updated Ch. 10 (<i>AI Acceleration</i>) &amp; Ch. 12 (<i>Benchmarking AI</i> 📊).<br> ⚡ <b>[Feb 02]:</b> Updates to Ch. 8 (<i>AI Training</i> 🏋️) &amp; Ch. 9 (<i>Efficient AI</i>).<br> 📚 <b>[Jan 16]:</b> Expanded Ch. 1–7 + brand-new Ch. 4! 🔢<br> 🗒️ <b>More Updates:</b> <a href="contents/frontmatter/changelog/changelog.html">See the Full Changelog</a>.<br><div style="height: 1px; background-color: #ccc; margin: 5px 0;">

</div>
<p>🌍 <b>Shaping the Future:</b> Every GitHub ⭐ supports global AI education and open learning.<br> 🙏 <b>Support the Mission:</b> Your ⭐ keeps this resource free, high-quality, and evolving.<br> ✍️ <b>Keep It Growing:</b> A ⭐ a day keeps Vijay writing all day! → <a href="https://github.com/harvard-edge/cs249r_book"><b>Star the book on GitHub</b></a></p>
</div>
<i class="bi bi-x-lg quarto-announcement-action"></i>
</div>
</header><!-- content --><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto"><div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
<li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/foreword.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Author’s Note</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/about/about.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About the Book</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/changelog/changelog.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Book Changelog</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/acknowledgements/acknowledgements.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Acknowledgements</span></a>
  </div>
</li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/ai/socratiq.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">SocratiQ AI</span></a>
  </div>
</li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text"><div class="part">AI Essentials</div></span></span>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/introduction/introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ml_systems/ml_systems.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">ML Systems</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/dl_primer/dl_primer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">DL Primer</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/dnn_architectures/dnn_architectures.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">DNN Architectures</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text"><div class="part">AI Engineering Principles</div></span></span>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/workflow/workflow.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">AI Workflow</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/data_engineering/data_engineering.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Data Engineering</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/frameworks/frameworks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">AI Frameworks</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/training/training.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">AI Training</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/efficient_ai/efficient_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Efficient AI</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/optimizations/optimizations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Model Optimizations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/hw_acceleration/hw_acceleration.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">AI Acceleration</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/benchmarking/benchmarking.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Benchmarking AI</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ops/ops.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">ML Operations</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text"><div class="part">AI Best Practices</div></span></span>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ondevice_learning/ondevice_learning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">On-Device Learning</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/privacy_security/privacy_security.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Security &amp; Privacy</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/responsible_ai/responsible_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Responsible AI</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/sustainable_ai/sustainable_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Sustainable AI</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/robust_ai/robust_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Robust AI</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text"><div class="part">AI Perspectives</div></span></span>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ai_for_good/ai_for_good.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">AI for Good</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/conclusion/conclusion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Conclusion</span></span></a>
  </div>
</li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text">LABS</span></span>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/overview.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/getting_started.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Getting Started</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../contents/labs/arduino/nicla_vision/nicla_vision.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Nicla Vision</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/setup/setup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Setup</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/image_classification/image_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Image Classification</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/object_detection/object_detection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Object Detection</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/kws/kws.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Keyword Spotting (KWS)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/motion_classification/motion_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Motion Classification and Anomaly Detection</span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../contents/labs/seeed/xiao_esp32s3/xiao_esp32s3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">XIAO ESP32S3</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/setup/setup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Setup</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/image_classification/image_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Image Classification</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/object_detection/object_detection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Object Detection</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/kws/kws.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Keyword Spotting (KWS)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/motion_classification/motion_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Motion Classification and Anomaly Detection</span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../contents/labs/raspi/raspi.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Raspberry Pi</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-8" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/setup/setup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Setup</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/image_classification/image_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Image Classification</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/object_detection/object_detection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Object Detection</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/llm/llm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Small Language Models (SLM)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/vlm/vlm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Vision-Language Models (VLM)</span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../contents/labs/shared/shared.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Shared Labs</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-9" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/shared/kws_feature_eng/kws_feature_eng.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">KWS Feature Engineering</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/shared/dsp_spectral_features_block/dsp_spectral_features_block.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">DSP Spectral Features</span></a>
  </div>
</li>
      </ul>
</li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-10" role="navigation" aria-expanded="false">
 <span class="menu-text">Appendix</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-10" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-10" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/appendix/phd_survival_guide.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">PhD Survival Guide</span></a>
  </div>
</li>
      </ul>
</li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text">REFERENCES</span></span>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
</div>
</nav><div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active"><h2 id="toc-title">Table of contents</h2>
   
  <ul>
<li><a href="#purpose" id="toc-purpose" class="nav-link active" data-scroll-target="#purpose">Purpose</a></li>
  <li><a href="#overview" id="toc-overview" class="nav-link" data-scroll-target="#overview"><span class="header-section-number">11.1</span> Overview</a></li>
  <li>
<a href="#hardware-evolution" id="toc-hardware-evolution" class="nav-link" data-scroll-target="#hardware-evolution"><span class="header-section-number">11.2</span> Hardware Evolution</a>
  <ul>
<li><a href="#specialized-computing" id="toc-specialized-computing" class="nav-link" data-scroll-target="#specialized-computing"><span class="header-section-number">11.2.1</span> Specialized Computing</a></li>
  <li><a href="#specialized-computing-expansion" id="toc-specialized-computing-expansion" class="nav-link" data-scroll-target="#specialized-computing-expansion"><span class="header-section-number">11.2.2</span> Specialized Computing Expansion</a></li>
  <li><a href="#domain-specific-architectures" id="toc-domain-specific-architectures" class="nav-link" data-scroll-target="#domain-specific-architectures"><span class="header-section-number">11.2.3</span> Domain-Specific Architectures</a></li>
  <li><a href="#ml-in-computational-domains" id="toc-ml-in-computational-domains" class="nav-link" data-scroll-target="#ml-in-computational-domains"><span class="header-section-number">11.2.4</span> ML in Computational Domains</a></li>
  <li><a href="#application-specific-accelerators" id="toc-application-specific-accelerators" class="nav-link" data-scroll-target="#application-specific-accelerators"><span class="header-section-number">11.2.5</span> Application-Specific Accelerators</a></li>
  </ul>
</li>
  <li>
<a href="#ai-compute-primitives" id="toc-ai-compute-primitives" class="nav-link" data-scroll-target="#ai-compute-primitives"><span class="header-section-number">11.3</span> AI Compute Primitives</a>
  <ul>
<li>
<a href="#vector-operations" id="toc-vector-operations" class="nav-link" data-scroll-target="#vector-operations"><span class="header-section-number">11.3.1</span> Vector Operations</a>
  <ul class="collapse">
<li><a href="#framework-hardware-execution" id="toc-framework-hardware-execution" class="nav-link" data-scroll-target="#framework-hardware-execution">Framework-Hardware Execution</a></li>
  <li><a href="#sequential-scalar-execution" id="toc-sequential-scalar-execution" class="nav-link" data-scroll-target="#sequential-scalar-execution">Sequential Scalar Execution</a></li>
  <li><a href="#parallel-vector-execution" id="toc-parallel-vector-execution" class="nav-link" data-scroll-target="#parallel-vector-execution">Parallel Vector Execution</a></li>
  <li><a href="#vector-processing-history" id="toc-vector-processing-history" class="nav-link" data-scroll-target="#vector-processing-history">Vector Processing History</a></li>
  </ul>
</li>
  <li>
<a href="#matrix-operations" id="toc-matrix-operations" class="nav-link" data-scroll-target="#matrix-operations"><span class="header-section-number">11.3.2</span> Matrix Operations</a>
  <ul class="collapse">
<li><a href="#matrix-operations-in-nns" id="toc-matrix-operations-in-nns" class="nav-link" data-scroll-target="#matrix-operations-in-nns">Matrix Operations in NNs</a></li>
  <li><a href="#matrix-computation-types-in-nns" id="toc-matrix-computation-types-in-nns" class="nav-link" data-scroll-target="#matrix-computation-types-in-nns">Matrix Computation Types in NNs</a></li>
  <li><a href="#matrix-operations-hardware-acceleration" id="toc-matrix-operations-hardware-acceleration" class="nav-link" data-scroll-target="#matrix-operations-hardware-acceleration">Matrix Operations Hardware Acceleration</a></li>
  <li><a href="#historical-foundations-of-matrix-computation" id="toc-historical-foundations-of-matrix-computation" class="nav-link" data-scroll-target="#historical-foundations-of-matrix-computation">Historical Foundations of Matrix Computation</a></li>
  </ul>
</li>
  <li>
<a href="#special-function-units" id="toc-special-function-units" class="nav-link" data-scroll-target="#special-function-units"><span class="header-section-number">11.3.3</span> Special Function Units</a>
  <ul class="collapse">
<li><a href="#non-linear-functions" id="toc-non-linear-functions" class="nav-link" data-scroll-target="#non-linear-functions">Non-Linear Functions</a></li>
  <li><a href="#non-linear-functions-implementation" id="toc-non-linear-functions-implementation" class="nav-link" data-scroll-target="#non-linear-functions-implementation">Non-Linear Functions Implementation</a></li>
  <li><a href="#hardware-acceleration" id="toc-hardware-acceleration" class="nav-link" data-scroll-target="#hardware-acceleration">Hardware Acceleration</a></li>
  <li><a href="#sfus-history" id="toc-sfus-history" class="nav-link" data-scroll-target="#sfus-history">SFUs History</a></li>
  </ul>
</li>
  <li>
<a href="#compute-units-and-execution-models" id="toc-compute-units-and-execution-models" class="nav-link" data-scroll-target="#compute-units-and-execution-models"><span class="header-section-number">11.3.4</span> Compute Units and Execution Models</a>
  <ul class="collapse">
<li><a href="#primitive-execution-unit-mapping" id="toc-primitive-execution-unit-mapping" class="nav-link" data-scroll-target="#primitive-execution-unit-mapping">Primitive-Execution Unit Mapping</a></li>
  <li><a href="#simd-to-simt-transition" id="toc-simd-to-simt-transition" class="nav-link" data-scroll-target="#simd-to-simt-transition">SIMD to SIMT Transition</a></li>
  <li><a href="#tensor-cores" id="toc-tensor-cores" class="nav-link" data-scroll-target="#tensor-cores">Tensor Cores</a></li>
  <li><a href="#processing-elements" id="toc-processing-elements" class="nav-link" data-scroll-target="#processing-elements">Processing Elements</a></li>
  <li><a href="#systolic-arrays" id="toc-systolic-arrays" class="nav-link" data-scroll-target="#systolic-arrays">Systolic Arrays</a></li>
  <li><a href="#numerics-in-ai-acceleration" id="toc-numerics-in-ai-acceleration" class="nav-link" data-scroll-target="#numerics-in-ai-acceleration">Numerics in AI Acceleration</a></li>
  <li><a href="#architectural-integration" id="toc-architectural-integration" class="nav-link" data-scroll-target="#architectural-integration">Architectural Integration</a></li>
  </ul>
</li>
  </ul>
</li>
  <li>
<a href="#ai-memory-systems" id="toc-ai-memory-systems" class="nav-link" data-scroll-target="#ai-memory-systems"><span class="header-section-number">11.4</span> AI Memory Systems</a>
  <ul>
<li>
<a href="#ai-memory-wall" id="toc-ai-memory-wall" class="nav-link" data-scroll-target="#ai-memory-wall"><span class="header-section-number">11.4.1</span> AI Memory Wall</a>
  <ul class="collapse">
<li><a href="#compute-memory-imbalance" id="toc-compute-memory-imbalance" class="nav-link" data-scroll-target="#compute-memory-imbalance">Compute-Memory Imbalance</a></li>
  <li><a href="#memory-intensive-ml-workloads" id="toc-memory-intensive-ml-workloads" class="nav-link" data-scroll-target="#memory-intensive-ml-workloads">Memory-Intensive ML Workloads</a></li>
  <li><a href="#irregular-memory-access" id="toc-irregular-memory-access" class="nav-link" data-scroll-target="#irregular-memory-access">Irregular Memory Access</a></li>
  </ul>
</li>
  <li>
<a href="#memory-hierarchy" id="toc-memory-hierarchy" class="nav-link" data-scroll-target="#memory-hierarchy"><span class="header-section-number">11.4.2</span> Memory Hierarchy</a>
  <ul class="collapse">
<li><a href="#on-chip-memory" id="toc-on-chip-memory" class="nav-link" data-scroll-target="#on-chip-memory">On-Chip Memory</a></li>
  <li><a href="#off-chip-memory" id="toc-off-chip-memory" class="nav-link" data-scroll-target="#off-chip-memory">Off-Chip Memory</a></li>
  </ul>
</li>
  <li>
<a href="#host-accelerator-communication" id="toc-host-accelerator-communication" class="nav-link" data-scroll-target="#host-accelerator-communication"><span class="header-section-number">11.4.3</span> Host-Accelerator Communication</a>
  <ul class="collapse">
<li><a href="#data-transfer-patterns" id="toc-data-transfer-patterns" class="nav-link" data-scroll-target="#data-transfer-patterns">Data Transfer Patterns</a></li>
  <li><a href="#data-transfer-mechanisms" id="toc-data-transfer-mechanisms" class="nav-link" data-scroll-target="#data-transfer-mechanisms">Data Transfer Mechanisms</a></li>
  <li><a href="#data-transfer-overheads" id="toc-data-transfer-overheads" class="nav-link" data-scroll-target="#data-transfer-overheads">Data Transfer Overheads</a></li>
  </ul>
</li>
  <li>
<a href="#model-memory-pressure" id="toc-model-memory-pressure" class="nav-link" data-scroll-target="#model-memory-pressure"><span class="header-section-number">11.4.4</span> Model Memory Pressure</a>
  <ul class="collapse">
<li><a href="#multilayer-perceptrons" id="toc-multilayer-perceptrons" class="nav-link" data-scroll-target="#multilayer-perceptrons">Multilayer Perceptrons</a></li>
  <li><a href="#convolutional-neural-networks" id="toc-convolutional-neural-networks" class="nav-link" data-scroll-target="#convolutional-neural-networks">Convolutional Neural Networks</a></li>
  <li><a href="#transformer-networks" id="toc-transformer-networks" class="nav-link" data-scroll-target="#transformer-networks">Transformer Networks</a></li>
  </ul>
</li>
  <li><a href="#ml-accelerators-implications" id="toc-ml-accelerators-implications" class="nav-link" data-scroll-target="#ml-accelerators-implications"><span class="header-section-number">11.4.5</span> ML Accelerators Implications</a></li>
  </ul>
</li>
  <li>
<a href="#neural-networks-mapping" id="toc-neural-networks-mapping" class="nav-link" data-scroll-target="#neural-networks-mapping"><span class="header-section-number">11.5</span> Neural Networks Mapping</a>
  <ul>
<li>
<a href="#computation-placement" id="toc-computation-placement" class="nav-link" data-scroll-target="#computation-placement"><span class="header-section-number">11.5.1</span> Computation Placement</a>
  <ul class="collapse">
<li><a href="#computation-placement-definition" id="toc-computation-placement-definition" class="nav-link" data-scroll-target="#computation-placement-definition">Computation Placement Definition</a></li>
  <li><a href="#computation-placement-importance" id="toc-computation-placement-importance" class="nav-link" data-scroll-target="#computation-placement-importance">Computation Placement Importance</a></li>
  <li><a href="#effective-computation-placement" id="toc-effective-computation-placement" class="nav-link" data-scroll-target="#effective-computation-placement">Effective Computation Placement</a></li>
  </ul>
</li>
  <li>
<a href="#memory-allocation" id="toc-memory-allocation" class="nav-link" data-scroll-target="#memory-allocation"><span class="header-section-number">11.5.2</span> Memory Allocation</a>
  <ul class="collapse">
<li><a href="#memory-allocation-definition" id="toc-memory-allocation-definition" class="nav-link" data-scroll-target="#memory-allocation-definition">Memory Allocation Definition</a></li>
  <li><a href="#memory-allocation-importance" id="toc-memory-allocation-importance" class="nav-link" data-scroll-target="#memory-allocation-importance">Memory Allocation Importance</a></li>
  <li><a href="#effective-memory-allocation" id="toc-effective-memory-allocation" class="nav-link" data-scroll-target="#effective-memory-allocation">Effective Memory Allocation</a></li>
  </ul>
</li>
  <li>
<a href="#combinatorial-complexity" id="toc-combinatorial-complexity" class="nav-link" data-scroll-target="#combinatorial-complexity"><span class="header-section-number">11.5.3</span> Combinatorial Complexity</a>
  <ul class="collapse">
<li><a href="#configuration-space-mapping" id="toc-configuration-space-mapping" class="nav-link" data-scroll-target="#configuration-space-mapping">Configuration Space Mapping</a></li>
  <li><a href="#computation-and-execution-ordering" id="toc-computation-and-execution-ordering" class="nav-link" data-scroll-target="#computation-and-execution-ordering">Computation and Execution Ordering</a></li>
  <li><a href="#processing-elements-parallelization" id="toc-processing-elements-parallelization" class="nav-link" data-scroll-target="#processing-elements-parallelization">Processing Elements Parallelization</a></li>
  <li><a href="#memory-placement-and-data-movement" id="toc-memory-placement-and-data-movement" class="nav-link" data-scroll-target="#memory-placement-and-data-movement">Memory Placement and Data Movement</a></li>
  <li><a href="#mapping-search-space" id="toc-mapping-search-space" class="nav-link" data-scroll-target="#mapping-search-space">Mapping Search Space</a></li>
  </ul>
</li>
  </ul>
</li>
  <li>
<a href="#optimization-strategies" id="toc-optimization-strategies" class="nav-link" data-scroll-target="#optimization-strategies"><span class="header-section-number">11.6</span> Optimization Strategies</a>
  <ul>
<li>
<a href="#mapping-strategies-building-blocks" id="toc-mapping-strategies-building-blocks" class="nav-link" data-scroll-target="#mapping-strategies-building-blocks"><span class="header-section-number">11.6.1</span> Mapping Strategies Building Blocks</a>
  <ul class="collapse">
<li><a href="#data-movement-patterns" id="toc-data-movement-patterns" class="nav-link" data-scroll-target="#data-movement-patterns">Data Movement Patterns</a></li>
  <li><a href="#memory-aware-tensor-layouts" id="toc-memory-aware-tensor-layouts" class="nav-link" data-scroll-target="#memory-aware-tensor-layouts">Memory-Aware Tensor Layouts</a></li>
  <li><a href="#kernel-fusion" id="toc-kernel-fusion" class="nav-link" data-scroll-target="#kernel-fusion">Kernel Fusion</a></li>
  <li><a href="#tiling-for-memory-efficiency" id="toc-tiling-for-memory-efficiency" class="nav-link" data-scroll-target="#tiling-for-memory-efficiency">Tiling for Memory Efficiency</a></li>
  </ul>
</li>
  <li>
<a href="#mapping-strategies-application" id="toc-mapping-strategies-application" class="nav-link" data-scroll-target="#mapping-strategies-application"><span class="header-section-number">11.6.2</span> Mapping Strategies Application</a>
  <ul class="collapse">
<li><a href="#convolutional-neural-networks-1" id="toc-convolutional-neural-networks-1" class="nav-link" data-scroll-target="#convolutional-neural-networks-1">Convolutional Neural Networks</a></li>
  <li><a href="#transformer-architectures" id="toc-transformer-architectures" class="nav-link" data-scroll-target="#transformer-architectures">Transformer Architectures</a></li>
  <li><a href="#multi-layer-perceptrons" id="toc-multi-layer-perceptrons" class="nav-link" data-scroll-target="#multi-layer-perceptrons">Multi-Layer Perceptrons</a></li>
  </ul>
</li>
  <li>
<a href="#hybrid-mapping-strategies" id="toc-hybrid-mapping-strategies" class="nav-link" data-scroll-target="#hybrid-mapping-strategies"><span class="header-section-number">11.6.3</span> Hybrid Mapping Strategies</a>
  <ul class="collapse">
<li><a href="#layer-specific-mapping" id="toc-layer-specific-mapping" class="nav-link" data-scroll-target="#layer-specific-mapping">Layer-Specific Mapping</a></li>
  </ul>
</li>
  <li><a href="#hybrid-strategies-hardware-implementations" id="toc-hybrid-strategies-hardware-implementations" class="nav-link" data-scroll-target="#hybrid-strategies-hardware-implementations"><span class="header-section-number">11.6.4</span> Hybrid Strategies Hardware Implementations</a></li>
  </ul>
</li>
  <li>
<a href="#compiler-support" id="toc-compiler-support" class="nav-link" data-scroll-target="#compiler-support"><span class="header-section-number">11.7</span> Compiler Support</a>
  <ul>
<li><a href="#ml-vs-traditional-compilers" id="toc-ml-vs-traditional-compilers" class="nav-link" data-scroll-target="#ml-vs-traditional-compilers"><span class="header-section-number">11.7.1</span> ML vs Traditional Compilers</a></li>
  <li><a href="#ml-compilation-pipeline" id="toc-ml-compilation-pipeline" class="nav-link" data-scroll-target="#ml-compilation-pipeline"><span class="header-section-number">11.7.2</span> ML Compilation Pipeline</a></li>
  <li>
<a href="#graph-optimization" id="toc-graph-optimization" class="nav-link" data-scroll-target="#graph-optimization"><span class="header-section-number">11.7.3</span> Graph Optimization</a>
  <ul class="collapse">
<li><a href="#computation-graph-optimization" id="toc-computation-graph-optimization" class="nav-link" data-scroll-target="#computation-graph-optimization">Computation Graph Optimization</a></li>
  <li><a href="#ai-compilers-implementation" id="toc-ai-compilers-implementation" class="nav-link" data-scroll-target="#ai-compilers-implementation">AI Compilers Implementation</a></li>
  <li><a href="#graph-optimization-importance" id="toc-graph-optimization-importance" class="nav-link" data-scroll-target="#graph-optimization-importance">Graph Optimization Importance</a></li>
  </ul>
</li>
  <li>
<a href="#kernel-selection" id="toc-kernel-selection" class="nav-link" data-scroll-target="#kernel-selection"><span class="header-section-number">11.7.4</span> Kernel Selection</a>
  <ul class="collapse">
<li><a href="#kernel-selection-in-ai-compilers" id="toc-kernel-selection-in-ai-compilers" class="nav-link" data-scroll-target="#kernel-selection-in-ai-compilers">Kernel Selection in AI Compilers</a></li>
  <li><a href="#kernel-selection-importance" id="toc-kernel-selection-importance" class="nav-link" data-scroll-target="#kernel-selection-importance">Kernel Selection Importance</a></li>
  </ul>
</li>
  <li>
<a href="#memory-planning" id="toc-memory-planning" class="nav-link" data-scroll-target="#memory-planning"><span class="header-section-number">11.7.5</span> Memory Planning</a>
  <ul class="collapse">
<li><a href="#memory-planning-in-ai-compilers" id="toc-memory-planning-in-ai-compilers" class="nav-link" data-scroll-target="#memory-planning-in-ai-compilers">Memory Planning in AI Compilers</a></li>
  <li><a href="#memory-planning-importance" id="toc-memory-planning-importance" class="nav-link" data-scroll-target="#memory-planning-importance">Memory Planning Importance</a></li>
  </ul>
</li>
  <li>
<a href="#computation-scheduling" id="toc-computation-scheduling" class="nav-link" data-scroll-target="#computation-scheduling"><span class="header-section-number">11.7.6</span> Computation Scheduling</a>
  <ul class="collapse">
<li><a href="#computation-scheduling-in-ai-compilers" id="toc-computation-scheduling-in-ai-compilers" class="nav-link" data-scroll-target="#computation-scheduling-in-ai-compilers">Computation Scheduling in AI Compilers</a></li>
  <li><a href="#computation-scheduling-importance" id="toc-computation-scheduling-importance" class="nav-link" data-scroll-target="#computation-scheduling-importance">Computation Scheduling Importance</a></li>
  <li><a href="#code-generation" id="toc-code-generation" class="nav-link" data-scroll-target="#code-generation">Code Generation</a></li>
  </ul>
</li>
  <li><a href="#compilation-runtime-support" id="toc-compilation-runtime-support" class="nav-link" data-scroll-target="#compilation-runtime-support"><span class="header-section-number">11.7.7</span> Compilation-Runtime Support</a></li>
  </ul>
</li>
  <li>
<a href="#runtime-support" id="toc-runtime-support" class="nav-link" data-scroll-target="#runtime-support"><span class="header-section-number">11.8</span> Runtime Support</a>
  <ul>
<li><a href="#ml-vs-traditional-runtimes" id="toc-ml-vs-traditional-runtimes" class="nav-link" data-scroll-target="#ml-vs-traditional-runtimes"><span class="header-section-number">11.8.1</span> ML vs Traditional Runtimes</a></li>
  <li><a href="#dynamic-kernel-execution" id="toc-dynamic-kernel-execution" class="nav-link" data-scroll-target="#dynamic-kernel-execution"><span class="header-section-number">11.8.2</span> Dynamic Kernel Execution</a></li>
  <li><a href="#runtime-kernel-selection" id="toc-runtime-kernel-selection" class="nav-link" data-scroll-target="#runtime-kernel-selection"><span class="header-section-number">11.8.3</span> Runtime Kernel Selection</a></li>
  <li><a href="#kernel-scheduling-and-utilization" id="toc-kernel-scheduling-and-utilization" class="nav-link" data-scroll-target="#kernel-scheduling-and-utilization"><span class="header-section-number">11.8.4</span> Kernel Scheduling and Utilization</a></li>
  </ul>
</li>
  <li>
<a href="#multi-chip-ai-acceleration" id="toc-multi-chip-ai-acceleration" class="nav-link" data-scroll-target="#multi-chip-ai-acceleration"><span class="header-section-number">11.9</span> Multi-Chip AI Acceleration</a>
  <ul>
<li><a href="#chiplet-based-architectures" id="toc-chiplet-based-architectures" class="nav-link" data-scroll-target="#chiplet-based-architectures">Chiplet-Based Architectures</a></li>
  <li><a href="#multi-gpu-systems" id="toc-multi-gpu-systems" class="nav-link" data-scroll-target="#multi-gpu-systems">Multi-GPU Systems</a></li>
  <li><a href="#tpu-pods" id="toc-tpu-pods" class="nav-link" data-scroll-target="#tpu-pods">TPU Pods</a></li>
  <li><a href="#wafer-scale-ai" id="toc-wafer-scale-ai" class="nav-link" data-scroll-target="#wafer-scale-ai">Wafer-Scale AI</a></li>
  <li><a href="#ai-systems-scaling-trajectory" id="toc-ai-systems-scaling-trajectory" class="nav-link" data-scroll-target="#ai-systems-scaling-trajectory">AI Systems Scaling Trajectory</a></li>
  <li>
<a href="#computation-and-memory-scaling-changes" id="toc-computation-and-memory-scaling-changes" class="nav-link" data-scroll-target="#computation-and-memory-scaling-changes"><span class="header-section-number">11.9.1</span> Computation and Memory Scaling Changes</a>
  <ul class="collapse">
<li><a href="#multi-chip-execution-mapping" id="toc-multi-chip-execution-mapping" class="nav-link" data-scroll-target="#multi-chip-execution-mapping">Multi-chip Execution Mapping</a></li>
  <li><a href="#distributed-access-memory-allocation" id="toc-distributed-access-memory-allocation" class="nav-link" data-scroll-target="#distributed-access-memory-allocation">Distributed Access Memory Allocation</a></li>
  <li><a href="#data-movement-constraints" id="toc-data-movement-constraints" class="nav-link" data-scroll-target="#data-movement-constraints">Data Movement Constraints</a></li>
  <li><a href="#compilers-and-runtimes-adaptation" id="toc-compilers-and-runtimes-adaptation" class="nav-link" data-scroll-target="#compilers-and-runtimes-adaptation">Compilers and Runtimes Adaptation</a></li>
  </ul>
</li>
  <li>
<a href="#execution-models-adaptation" id="toc-execution-models-adaptation" class="nav-link" data-scroll-target="#execution-models-adaptation"><span class="header-section-number">11.9.2</span> Execution Models Adaptation</a>
  <ul class="collapse">
<li><a href="#cross-accelerator-scheduling" id="toc-cross-accelerator-scheduling" class="nav-link" data-scroll-target="#cross-accelerator-scheduling">Cross-Accelerator Scheduling</a></li>
  <li><a href="#cross-accelerator-coordination" id="toc-cross-accelerator-coordination" class="nav-link" data-scroll-target="#cross-accelerator-coordination">Cross-Accelerator Coordination</a></li>
  <li><a href="#cross-accelerator-execution-management" id="toc-cross-accelerator-execution-management" class="nav-link" data-scroll-target="#cross-accelerator-execution-management">Cross-Accelerator Execution Management</a></li>
  <li><a href="#computation-placement-adaptation" id="toc-computation-placement-adaptation" class="nav-link" data-scroll-target="#computation-placement-adaptation">Computation Placement Adaptation</a></li>
  </ul>
</li>
  <li><a href="#navigating-multi-chip-ai-complexities" id="toc-navigating-multi-chip-ai-complexities" class="nav-link" data-scroll-target="#navigating-multi-chip-ai-complexities"><span class="header-section-number">11.9.3</span> Navigating Multi-Chip AI Complexities</a></li>
  </ul>
</li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">11.10</span> Conclusion</a></li>
  <li><a href="#resources" id="toc-resources" class="nav-link" data-scroll-target="#resources"><span class="header-section-number">11.11</span> Resources</a></li>
  </ul><div class="toc-actions"><ul><li><a href="https://github.com/harvard-edge/cs249r_book/edit/widget_quiz/contents/core/hw_acceleration/hw_acceleration.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/harvard-edge/cs249r_book/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li><li><a href="https://github.com/harvard-edge/cs249r_book/blob/widget_quiz/contents/core/hw_acceleration/hw_acceleration.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    window.setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        disableStylesheet(primaryStylesheets)
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      window.setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    window.hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(darkModeDefault) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const darkModeDefault = false;
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !window.hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
    };
    // Switch to dark mode if need be
    if (window.hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script><header id="title-block-header" class="quarto-title-block default"><div class="quarto-title">
<h1 class="title">
<span class="chapter-number">11</span>&nbsp; <span class="chapter-title">AI Acceleration</span>
</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header><p>Resources: <a href="#sec-ai-acceleration-resource">Slides</a>, <a href="#sec-ai-acceleration-resource">Videos</a>, <a href="#sec-ai-acceleration-resource">Exercises</a></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure"><p><a href="images/png/cover_ai_hardware.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="DALL·E 3 Prompt: Create an intricate and colorful representation of a System on Chip (SoC) design in a rectangular format. Showcase a variety of specialized machine learning accelerators and chiplets, all integrated into the processor. Provide a detailed view inside the chip, highlighting the rapid movement of electrons. Each accelerator and chiplet should be designed to interact with neural network neurons, layers, and activations, emphasizing their processing speed. Depict the neural networks as a network of interconnected nodes, with vibrant data streams flowing between the accelerator pieces, showcasing the enhanced computation speed."><img src="images/png/cover_ai_hardware.png" class="img-fluid figure-img" alt="DALL·E 3 Prompt: Create an intricate and colorful representation of a System on Chip (SoC) design in a rectangular format. Showcase a variety of specialized machine learning accelerators and chiplets, all integrated into the processor. Provide a detailed view inside the chip, highlighting the rapid movement of electrons. Each accelerator and chiplet should be designed to interact with neural network neurons, layers, and activations, emphasizing their processing speed. Depict the neural networks as a network of interconnected nodes, with vibrant data streams flowing between the accelerator pieces, showcasing the enhanced computation speed."></a></p>
<figcaption><em>DALL·E 3 Prompt: Create an intricate and colorful representation of a System on Chip (SoC) design in a rectangular format. Showcase a variety of specialized machine learning accelerators and chiplets, all integrated into the processor. Provide a detailed view inside the chip, highlighting the rapid movement of electrons. Each accelerator and chiplet should be designed to interact with neural network neurons, layers, and activations, emphasizing their processing speed. Depict the neural networks as a network of interconnected nodes, with vibrant data streams flowing between the accelerator pieces, showcasing the enhanced computation speed.</em></figcaption></figure>
</div>
<section id="purpose" class="level2 unnumbered"><h2 class="unnumbered anchored" data-anchor-id="purpose">Purpose</h2>
<p><em>How does hardware acceleration impact machine learning system performance, and what principles should ML engineers understand to effectively design and deploy systems?</em></p>
<p>Machine learning systems has driven a fundamental shift in computer architecture. Traditional processors, designed for general-purpose computing, prove inefficient for the repeated mathematical operations and data movement patterns in neural networks. Modern accelerators address this challenge by matching hardware structures to ML computation patterns. These accelerators introduce fundamental trade-offs in performance, power consumption, and flexibility. Effective utilization of hardware acceleration requires an understanding of these trade-offs, as well as the architectural principles that govern accelerator design. By optimizing and learning to map models effectively for specific hardware platforms, engineers can balance computational efficiency.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Learning Objectives">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Learning Objectives
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><p>Understand the historical context of hardware acceleration.</p></li>
<li><p>Identify key AI compute primitives and their role in model execution.</p></li>
<li><p>Explain the memory hierarchy and its impact on AI accelerator performance.</p></li>
<li><p>Describe strategies for mapping neural networks to hardware.</p></li>
<li><p>Analyze the role of compilers and runtimes in optimizing AI workloads.</p></li>
<li><p>Compare single-chip and multi-chip AI architectures.</p></li>
</ul>
</div>
</div>
</section><section id="overview" class="level2" data-number="11.1"><h2 data-number="11.1" class="anchored" data-anchor-id="overview">
<span class="header-section-number">11.1</span> Overview</h2>
<p>Machine learning has driven a fundamental shift in computer architecture, pushing beyond traditional general-purpose processors toward specialized acceleration. The computational demands of modern machine learning models exceed the capabilities of conventional CPUs, which were designed for sequential execution. Instead, machine learning workloads exhibit massive parallelism, high memory bandwidth requirements, and structured computation patterns that demand purpose-built hardware for efficiency and scalability. Machine Learning Accelerators (ML Accelerators) have emerged as a response to these challenges.</p>
<div class="callout callout-style-default callout-note callout-titled" title="Definition of ML Accelerator">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition of ML Accelerator
</div>
</div>
<div class="callout-body-container callout-body">
<p>Machine Learning Accelerator (ML Accelerator) refers to a <em>specialized computing hardware</em> designed to <em>efficiently execute machine learning workloads</em>. These accelerators optimize <em>matrix multiplications, tensor operations, and data movement</em>, enabling <em>high-throughput and energy-efficient</em> computation. ML accelerators operate at various <em>power and performance scales</em>, ranging from <em>edge devices with milliwatt-level consumption</em> to <em>data center-scale accelerators requiring kilowatts of power</em>. They are specifically designed to address <em>the computational and memory demands</em> of machine learning models, often incorporating <em>optimized memory hierarchies, parallel processing units, and custom instruction sets</em> to maximize performance. ML accelerators are widely used in <em>training, inference, and real-time AI applications</em> across cloud, edge, and embedded systems.</p>
</div>
</div>
<p>Unlike CPUs and GPUs, which were originally designed for general-purpose computing and graphics, ML accelerators are optimized for tensor operations, matrix multiplications, and memory-efficient execution—the core computations that drive deep learning. These accelerators span a wide range of power and performance envelopes, from energy-efficient edge devices to large-scale data center accelerators. Their architectures integrate custom processing elements, optimized memory hierarchies, and domain-specific execution models, enabling high-performance training and inference.</p>
<p>As ML models have grown in size and complexity, hardware acceleration has evolved to keep pace. The shift from von Neumann architectures to specialized accelerators reflects a broader trend in computing: reducing the cost of data movement, increasing parallelism, and tailoring hardware to domain-specific workloads. Moving data across memory hierarchies often consumes more energy than computation itself, making efficient memory organization and computation placement critical to overall system performance.</p>
<p>This chapter explores AI acceleration from a systems perspective, examining how computational models, hardware optimizations, and software frameworks interact to enable efficient execution. It covers key operations like matrix multiplications and activation functions, the role of memory hierarchies in data movement, and techniques for mapping neural networks to hardware. The discussion extends to compilers, scheduling strategies, and runtime optimizations, highlighting their impact on performance. Finally, it addresses the challenges of scaling AI systems from single-chip accelerators to multi-chip and distributed architectures, integrating real-world examples to illustrate effective AI acceleration.</p>
</section><section id="hardware-evolution" class="level2 page-columns page-full" data-number="11.2"><h2 data-number="11.2" class="anchored" data-anchor-id="hardware-evolution">
<span class="header-section-number">11.2</span> Hardware Evolution</h2>
<p>The progression of computing architectures follows a recurring pattern: as computational workloads grow in complexity, general-purpose processors become increasingly inefficient, prompting the development of specialized hardware accelerators. This transition is driven by the need for higher computational efficiency, reduced energy consumption, and optimized execution of domain-specific workloads. Machine learning acceleration is the latest stage in this ongoing evolution, following a well-established trajectory observed in prior domains such as floating-point arithmetic, graphics processing, and digital signal processing.</p>
<p>This evolution is not just of academic interest—it provides essential context for understanding how modern ML accelerators like GPUs with tensor cores, Google’s TPUs, and Apple’s Neural Engine came to be. These technologies now power widely deployed applications such as real-time language translation, image recognition, and personalized recommendations. The architectural strategies enabling such capabilities are deeply rooted in decades of hardware specialization.</p>
<p>At the heart of this transition is hardware specialization, which enhances performance and efficiency by optimizing frequently executed computational patterns through dedicated circuit implementations. While this approach leads to significant gains, it also introduces trade-offs in flexibility, silicon area utilization, and programming complexity. As computing demands continue to evolve, specialized accelerators must balance these factors to deliver sustained improvements in efficiency and performance.</p>
<p>Building on this historical trajectory, the evolution of hardware specialization provides a perspective for understanding modern machine learning accelerators. Many of the principles that shaped the development of early floating-point and graphics accelerators now inform the design of AI-specific hardware. Examining these past trends offers a systematic framework for analyzing contemporary approaches to AI acceleration and anticipating future developments in specialized computing.</p>
<section id="specialized-computing" class="level3 page-columns page-full" data-number="11.2.1"><h3 data-number="11.2.1" class="anchored" data-anchor-id="specialized-computing">
<span class="header-section-number">11.2.1</span> Specialized Computing</h3>
<p>The transition toward specialized computing architectures arises from the fundamental limitations of general-purpose processors. Early computing systems relied on central processing units (CPUs) to execute all computational tasks sequentially, following a one-size-fits-all approach. However, as computing workloads diversified and grew in complexity, certain operations—particularly floating-point arithmetic—emerged as critical performance bottlenecks that could not be efficiently handled by CPUs alone. These fundamental inefficiencies prompted the development of specialized hardware architectures designed to accelerate specific computational patterns <span class="citation" data-cites="flynn1966very">(<a href="../references.html#ref-flynn1966very" role="doc-biblioref">Flynn 1966</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-flynn1966very" class="csl-entry" role="listitem">
Flynn, M. J. 1966. <span>“Very High-Speed Computing Systems.”</span> <em>Proceedings of the IEEE</em> 54 (12): 1901–9. <a href="https://doi.org/10.1109/proc.1966.5273">https://doi.org/10.1109/proc.1966.5273</a>.
</div><div id="ref-fisher_8087_1981" class="csl-entry" role="listitem">
Fisher, Lawrence D. 1981. <span>“The 8087 Numeric Data Processor.”</span> <em>IEEE Computer</em> 14 (7): 19–29. <a href="https://doi.org/10.1109/MC.1981.1653991">https://doi.org/10.1109/MC.1981.1653991</a>.
</div></div><p>One of the earliest examples of hardware specialization was the Intel 8087 mathematics coprocessor, introduced in 1980. This floating-point unit (FPU) was designed to offload arithmetic-intensive computations from the main CPU, dramatically improving performance for scientific and engineering applications. The 8087 demonstrated unprecedented efficiency, achieving performance gains of up to 100× for floating-point operations compared to software-based implementations on general-purpose processors <span class="citation" data-cites="fisher_8087_1981">(<a href="../references.html#ref-fisher_8087_1981" role="doc-biblioref">Fisher 1981</a>)</span>. This milestone established a fundamental principle in computer architecture: carefully designed hardware specialization could provide order-of-magnitude improvements for well-defined, computationally intensive tasks.</p>
<p>The success of floating-point coprocessors led to their eventual integration into mainstream processors. For example, the Intel 486DX, released in 1989, incorporated an on-chip floating-point unit, eliminating the need for an external coprocessor. This integration not only improved processing efficiency but also marked a recurring pattern in computer architecture: successful specialized functions tend to become standard features in future generations of general-purpose processors <span class="citation" data-cites="patterson2021computer">(<a href="../references.html#ref-patterson2021computer" role="doc-biblioref">Patterson and Hennessy 2021</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-patterson2021computer" class="csl-entry" role="listitem">
Patterson, David A., and John L. Hennessy. 2021. <em>Computer Organization and Design: The Hardware/Software Interface</em>. 5th ed. Morgan Kaufmann.
</div></div><p>The principles established through early floating-point acceleration continue to influence modern hardware specialization. These include:</p>
<ol type="1">
<li>Identification of computational bottlenecks through workload analysis</li>
<li>Development of specialized circuits for frequent operations</li>
<li>Creation of efficient hardware-software interfaces</li>
<li>Progressive integration of proven specialized functions</li>
</ol>
<p>This progression from domain-specific specialization to general-purpose integration has played a central role in shaping modern computing architectures. As computational workloads expanded beyond arithmetic operations, these same fundamental principles were applied to new domains, such as graphics processing, digital signal processing, and ultimately, machine learning acceleration. Each of these domains introduced specialized architectures tailored to their unique computational requirements, establishing hardware specialization as a cornerstone strategy for advancing computing performance and efficiency in increasingly complex workloads.</p>
<p>The evolution of specialized computing hardware follows a consistent trajectory, wherein architectural innovations are introduced to mitigate emerging computational bottlenecks and are eventually incorporated into mainstream computing platforms. As illustrated in <a href="#fig-timeline" class="quarto-xref">Figure&nbsp;<span>11.1</span></a>, each computing era gave rise to accelerators that addressed the dominant workload characteristics of the time. These developments have not only advanced architectural efficiency but have also shaped the foundation upon which contemporary machine learning systems are built. The computational capabilities required for tasks such as real-time language translation, personalized recommendations, and on-device inference rely on the foundational principles and architectural innovations established in earlier domains, including floating-point computation, graphics processing, and digital signal processing.</p>
<div id="fig-timeline" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-timeline-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="sourceCode" id="cb1"><pre class="sourceCode tikz code-with-copy"><code class="sourceCode latex"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">\begin</span>{<span class="ex">tikzpicture</span>}</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">\tikzset</span>{<span class="co">%</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    helvetica/.style={align=flush center,font=<span class="fu">\usefont</span>{T1}{phv}{m}{n}<span class="fu">\small</span>},</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">\tikzset</span>{</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  Box/.style={inner xsep=1pt,</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    draw=none,node distance=3mm,</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    fill=#1, helvetica,</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    anchor=west,</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    text width=35mm,</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    minimum width=35mm, minimum height=10mm</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  },</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  Box/.default=red</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="fu">\definecolor</span>{col1}{RGB}{128, 179, 255}</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="fu">\definecolor</span>{col2}{RGB}{255, 255, 128}</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="fu">\definecolor</span>{col3}{RGB}{204, 255, 204}</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="fu">\definecolor</span>{col4}{RGB}{230, 179, 255}</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="fu">\definecolor</span>{col5}{RGB}{255, 153, 204}</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="fu">\definecolor</span>{col6}{RGB}{245, 82, 102}</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="fu">\definecolor</span>{col7}{RGB}{255, 102, 102}</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col1}](B1){1980s};</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col2!},right=of B1](B2){1990s};</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col3},right=of B2](B3){2000s};</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col4},right=of B3](B4){2010s};</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col5},right=of B4](B5){2020s};</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\x</span> in{1,2,...,5}</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[dashed,thick,-latex](B<span class="fu">\x</span>)--++(270:8.5);</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="fu">\path</span>[red]([yshift=-8mm]B1.south west)coordinate(P)-|coordinate(K)(B5.south east);</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[line width=2pt,-latex](P)--(K)--++(0:3mm);</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="co">%</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col1!50},below=2 of B1](BB1){Floating-Point <span class="fu">\&amp;</span> Signal Processing};</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col1!50},below=of BB1](BB2){Intel 8087 FPU (1980)};</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col1!50},below=of BB2](BB3){Texas Instruments TMS32010 DSP (1983)};</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col1!50},below=of BB3](BB4){Integration of FPU into Intel 486DX (1989)};</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a><span class="co">%</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col2!50},below=2 of B2](2BB1){3D Graphics <span class="fu">\&amp;</span> Multimedia};</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col2!50},below=of 2BB1](2BB2){Introduction of Early GPUs};</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col2!50},below=of 2BB2](2BB3){NVIDIA GeForce 256 -- First Programmable GPU (1999)};</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col2!50},below=of 2BB3](2BB4){Rise of SIMD Processing Units};</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a><span class="co">%</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col3!50},below=2 of B3](3BB1){Real-time Media Coding <span class="fu">\&amp;</span> Network Processing};</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col3!50},below=of 3BB1](3BB2){Media Codecs<span class="fu">\\</span> (H.264, MP3)};</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col3!50},below=of 3BB2](3BB3){Intel IXP2800 Network Processor};</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col3!50},below=of 3BB3](3BB4){Dedicated hardware for streaming and encoding};</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a><span class="co">%</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col4!50},below=2 of B4](4BB1){Deep Learning Tensor Operations};</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col4!50},below=of 4BB1](4BB2){Google TPU v1 for<span class="fu">\\</span> ML Inference (2016)};</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col4!50},below=of 4BB2](4BB3){NVIDIA Tensor Cores<span class="fu">\\</span> for DL Acceleration};</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col4!50},below=of 4BB3](4BB4){AI-specific memory optimizations};</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="co">%</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col5!50},below=2 of B5](5BB1){Application-Specific Acceleration};</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col5!50},below=of 5BB1](5BB2){AI Engines <span class="fu">\&amp;</span> <span class="fu">\\</span>SmartNICs};</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col5!50},below=of 5BB2](5BB3){Multi-chip and wafer-scale ML acceleration};</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box={col5!50},below=of 5BB3](5BB4){ML frameworks optimizing for specialized hardware};</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a><span class="kw">\end</span>{<span class="ex">tikzpicture</span>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-timeline-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;11.1: Evolution of specialized computing hardware.
</figcaption></figure>
</div>
</section><section id="specialized-computing-expansion" class="level3 page-columns page-full" data-number="11.2.2"><h3 data-number="11.2.2" class="anchored" data-anchor-id="specialized-computing-expansion">
<span class="header-section-number">11.2.2</span> Specialized Computing Expansion</h3>
<p>The principles established through floating-point acceleration provided a blueprint for addressing emerging computational challenges. As computing applications diversified, new computational patterns emerged that exceeded the capabilities of general-purpose processors. This expansion of specialized computing manifested across multiple domains, each contributing unique insights to hardware acceleration strategies.</p>
<p>Graphics processing emerged as a significant driver of hardware specialization in the 1990s. Early graphics accelerators focused on specific operations like bitmap transfers and polygon filling. The introduction of programmable graphics pipelines with NVIDIA’s GeForce 256 in 1999 represented a crucial advancement in specialized computing. Graphics Processing Units (GPUs) demonstrated how parallel processing architectures could efficiently handle data-parallel workloads. For example, in 3D rendering tasks like texture mapping and vertex transformation, GPUs achieved 50-100<span class="math inline">\(\times\)</span> speedups over CPU implementations. By 2004, GPUs could process over 100 million polygons per second—tasks that would overwhelm even the fastest CPUs of the time <span class="citation" data-cites="owens2008gpu">(<a href="../references.html#ref-owens2008gpu" role="doc-biblioref">Owens et al. 2008</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-lyons2011understanding" class="csl-entry" role="listitem">
Lyons, Richard G. 2011. <em>Understanding Digital Signal Processing</em>. 3rd ed. Prentice Hall.
</div></div><p>Digital Signal Processing (DSP) represents another fundamental domain of hardware specialization. DSP processors introduced architectural innovations specifically designed for efficient signal processing operations. These included specialized multiply-accumulate units, circular buffers, and parallel data paths optimized for filtering and transform operations. Texas Instruments’ TMS32010, introduced in 1983, established how domain-specific instruction sets and memory architectures could dramatically improve performance for signal processing applications <span class="citation" data-cites="lyons2011understanding">(<a href="../references.html#ref-lyons2011understanding" role="doc-biblioref">Lyons 2011</a>)</span>.</p>
<p>Network processing introduced additional patterns of specialization. Network processors developed unique architectures to handle packet processing at line rate, incorporating multiple processing cores, specialized packet manipulation units, and sophisticated memory management systems. Intel’s IXP2800 network processor demonstrated how multiple levels of hardware specialization could be combined to address complex processing requirements.</p>
<p>These diverse domains of specialization shared several common themes:</p>
<ol type="1">
<li>Identification of domain-specific computational patterns</li>
<li>Development of specialized processing elements and memory hierarchies</li>
<li>Creation of domain-specific programming models</li>
<li>Progressive evolution toward more flexible architectures</li>
</ol>
<p>This period of expanding specialization demonstrated that hardware acceleration strategies could successfully address diverse computational requirements. The GPU’s success in parallelizing 3D graphics pipelines directly enabled its later adoption for training deep neural networks, such as AlexNet in 2012, which famously ran on consumer-grade NVIDIA GPUs. DSP innovations in low-power signal processing helped pave the way for real-time inference on edge devices, such as voice assistants and wearables. These domains not only informed ML hardware designs but also proved that accelerators could be deployed across both cloud and embedded contexts—a lesson that continues to shape today’s AI ecosystem.</p>
</section><section id="domain-specific-architectures" class="level3 page-columns page-full" data-number="11.2.3"><h3 data-number="11.2.3" class="anchored" data-anchor-id="domain-specific-architectures">
<span class="header-section-number">11.2.3</span> Domain-Specific Architectures</h3>
<p>The emergence of domain-specific architectures (DSA) marks a fundamental shift in computer system design, driven by two key factors: the breakdown of traditional scaling laws and the increasing computational demands of specialized workloads. The slowdown of Moore’s Law—which had previously guaranteed predictable improvements in transistor density every 18-24 months—and the end of Dennard scaling—which had allowed frequency increases without proportional power increases—created a critical performance and efficiency bottleneck in general-purpose computing. As John Hennessy and David Patterson noted in their 2017 Turing Lecture <span class="citation" data-cites="HennessyPatterson2017Turing">(<a href="../references.html#ref-HennessyPatterson2017Turing" role="doc-biblioref">Hennessy and Patterson 2019</a>)</span>, these limitations signaled the onset of a new era in computer architecture—one centered on domain-specific solutions that optimize hardware for specialized workloads.</p>
<div class="no-row-height column-margin column-container"><div id="ref-HennessyPatterson2017Turing" class="csl-entry" role="listitem">
Hennessy, John L., and David A. Patterson. 2019. <span>“A New Golden Age for Computer Architecture.”</span> <em>Communications of the ACM</em> 62 (2): 48–60. <a href="https://doi.org/10.1145/3282307">https://doi.org/10.1145/3282307</a>.
</div></div><p>Historically, improvements in processor performance relied on semiconductor process scaling and increasing clock speeds. However, as power density limitations restricted further frequency scaling, and as transistor miniaturization faced increasing physical and economic constraints, architects were forced to explore alternative approaches to sustain computational growth. The result was a shift toward domain-specific architectures, which dedicate silicon resources to optimize computation for specific application domains, trading flexibility for efficiency. Domain-specific architectures achieve superior performance and energy efficiency through several key principles:</p>
<ol type="1">
<li><p><strong>Customized datapaths</strong>: Design processing paths specifically optimized for target application patterns, enabling direct hardware execution of common operations. For example, matrix multiplication units in AI accelerators implement systolic arrays tailored for neural network computations.</p></li>
<li><p><strong>Specialized memory hierarchies</strong>: Optimize memory systems around domain-specific access patterns and data reuse characteristics. This includes custom cache configurations, prefetching logic, and memory controllers tuned for expected workloads.</p></li>
<li><p><strong>Reduced instruction overhead</strong>: Implement domain-specific instruction sets that minimize decode and dispatch complexity by encoding common operation sequences into single instructions. This improves both performance and energy efficiency.</p></li>
<li><p><strong>Direct hardware implementation</strong>: Create dedicated circuit blocks that natively execute frequently used operations without software intervention. This eliminates instruction processing overhead and maximizes throughput.</p></li>
</ol>
<p>Perhaps the best-known example of success in domain-specific architectures is modern smartphones. Introduced in the late 2000s, modern smartphones can decode 4K video at 60 frames per second while consuming just a few watts of power—even though video processing requires billions of operations per second. This remarkable efficiency is achieved through dedicated hardware video codecs that implement industry standards such as H.264/AVC (introduced in 2003) and H.265/HEVC (finalized in 2013) <span class="citation" data-cites="sullivan2012overview">(<a href="../references.html#ref-sullivan2012overview" role="doc-biblioref">Sullivan et al. 2012</a>)</span>. These specialized circuits offer 100–1000<span class="math inline">\(\times\)</span> improvements in both performance and power efficiency compared to software-based decoding on general-purpose processors.</p>
<div class="no-row-height column-margin column-container"><div id="ref-sullivan2012overview" class="csl-entry" role="listitem">
Sullivan, Gary J., Jens-Rainer Ohm, Woo-Jin Han, and Thomas Wiegand. 2012. <span>“Overview of the High Efficiency Video Coding (HEVC) Standard.”</span> <em>IEEE Transactions on Circuits and Systems for Video Technology</em> 22 (12): 1649–68. <a href="https://doi.org/10.1109/tcsvt.2012.2221191">https://doi.org/10.1109/tcsvt.2012.2221191</a>.
</div><div id="ref-Shang2018GenomicsAccel" class="csl-entry" role="listitem">
Shang, J., G. Wang, and Y. Liu. 2018. <span>“Accelerating Genomic Data Analysis with Domain-Specific Architectures.”</span> <em>IEEE Transactions on Computers</em> 67 (7): 965–78. <a href="https://doi.org/10.1109/TC.2018.2799212">https://doi.org/10.1109/TC.2018.2799212</a>.
</div><div id="ref-Taylor2017ASICMining" class="csl-entry" role="listitem">
Bedford Taylor, Michael. 2017. <span>“The Evolution of Bitcoin Hardware.”</span> <em>Computer</em> 50 (9): 58–66. <a href="https://doi.org/10.1109/mc.2017.3571056">https://doi.org/10.1109/mc.2017.3571056</a>.
</div></div><p>The trend toward specialization continues to accelerate, with new architectures emerging for an expanding range of domains. Genomics processing, for example, benefits from custom accelerators that optimize sequence alignment and variant calling, reducing the time required for DNA analysis <span class="citation" data-cites="Shang2018GenomicsAccel">(<a href="../references.html#ref-Shang2018GenomicsAccel" role="doc-biblioref">Shang, Wang, and Liu 2018</a>)</span>. Similarly, blockchain computation has given rise to application-specific integrated circuits (ASICs) optimized for cryptographic hashing, dramatically increasing the efficiency of mining operations <span class="citation" data-cites="Taylor2017ASICMining">(<a href="../references.html#ref-Taylor2017ASICMining" role="doc-biblioref">Bedford Taylor 2017</a>)</span>. These examples illustrate that domain-specific architecture is not merely a transient trend but a fundamental transformation in computing systems, offering tailored solutions that address the growing complexity and diversity of modern computational workloads.</p>
</section><section id="ml-in-computational-domains" class="level3" data-number="11.2.4"><h3 data-number="11.2.4" class="anchored" data-anchor-id="ml-in-computational-domains">
<span class="header-section-number">11.2.4</span> ML in Computational Domains</h3>
<p>Machine learning has emerged as one of the most computationally demanding fields, demonstrating the need for dedicated hardware that targets its unique characteristics. Domain-specific architectures—once developed for video codecs or other specialized tasks—have now expanded to meet the challenges posed by ML workloads. These specialized designs optimize the execution of dense matrix operations and manage data movement efficiently, a necessity given the inherent memory bandwidth limitations.</p>
<p>A key distinction in ML is the differing requirements between training and inference. Training demands both forward and backward propagation, with high numerical precision (e.g., FP32 or FP16) to ensure stable gradient updates and convergence, while inference can often operate at lower precision (e.g., INT8) without major accuracy loss. This variance not only drives the need for mixed-precision arithmetic hardware but also allows optimizations that improve throughput and energy efficiency—often achieving 4–8<span class="math inline">\(\times\)</span> gains.</p>
<p>The computational foundation of modern ML accelerators is built on common patterns such as dense matrix multiplications and consistent data-flow patterns. These operations underpin architectures like GPUs with tensor cores and Google’s Tensor Processing Unit (TPU). While GPUs extended their original graphics capabilities to handle ML tasks via parallel execution and specialized memory hierarchies, TPUs take a more focused approach. For instance, the TPU’s systolic array architecture is tailored to excel at matrix multiplication, effectively aligning hardware performance with the mathematical structure of neural networks.</p>
</section><section id="application-specific-accelerators" class="level3" data-number="11.2.5"><h3 data-number="11.2.5" class="anchored" data-anchor-id="application-specific-accelerators">
<span class="header-section-number">11.2.5</span> Application-Specific Accelerators</h3>
<p>The shift toward application-specific hardware is evident in how these accelerators are designed for both high-powered data centers and low-power edge devices. In data centers, powerful training accelerators can reduce model development times from weeks to days, thanks to their finely-tuned compute engines and memory systems. Conversely, edge devices benefit from inference engines that deliver millisecond-level responses while consuming very little power.</p>
<p>The success of these dedicated solutions reinforces a broader trend—hardware specialization adapts to the computational demands of evolving applications. By focusing on the core operations of machine learning, from matrix multiplications to flexible numerical precision, application-specific accelerators ensure that systems remain efficient, scalable, and ready to meet future advancements.</p>
<p>The evolution of specialized hardware architectures illustrates a fundamental principle in computing systems: as computational patterns emerge and mature, hardware specialization follows to achieve optimal performance and energy efficiency. This progression is particularly evident in machine learning acceleration, where domain-specific architectures have evolved to meet the increasing computational demands of machine learning models. Unlike general-purpose processors, which prioritize flexibility, specialized accelerators optimize execution for well-defined workloads, balancing performance, energy efficiency, and integration with software frameworks.</p>
<p><a href="#tbl-hw-evolution" class="quarto-xref">Table&nbsp;<span>11.1</span></a> summarizes key milestones in the evolution of hardware specialization, emphasizing how each era produced architectures tailored to the prevailing computational demands. While these accelerators initially emerged to optimize domain-specific workloads—such as floating-point operations, graphics rendering, and media processing—they also introduced architectural strategies that persist in contemporary systems. Notably, the specialization principles outlined in earlier generations now underpin the design of modern AI accelerators. Understanding this historical trajectory provides essential context for analyzing how hardware specialization continues to enable scalable, efficient execution of machine learning workloads across diverse deployment environments.</p>
<div id="tbl-hw-evolution" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-hw-evolution-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;11.1: Evolution of hardware specialization across computing eras.
</figcaption><div aria-describedby="tbl-hw-evolution-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 5%">
<col style="width: 25%">
<col style="width: 31%">
<col style="width: 35%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Era</th>
<th style="text-align: left;">Computational Pattern</th>
<th style="text-align: left;">Architecture Examples</th>
<th style="text-align: left;">Key Characteristics</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1980s</td>
<td style="text-align: left;">Floating-Point &amp; Signal Processing</td>
<td style="text-align: left;">FPU, DSP</td>
<td style="text-align: left;">
<li>
Single-purpose engines
</li>
<li>
Focused instruction sets
</li>
<li>
Coprocessor interfaces
</li>
</td>
</tr>
<tr class="even">
<td style="text-align: left;">1990s</td>
<td style="text-align: left;">3D Graphics &amp; Multimedia</td>
<td style="text-align: left;">GPU, SIMD Units</td>
<td style="text-align: left;">
<li>
Many identical compute units
</li>
<li>
Regular data patterns
</li>
<li>
Wide memory interfaces
</li>
</td>
</tr>
<tr class="odd">
<td style="text-align: left;">2000s</td>
<td style="text-align: left;">Real-time Media Coding</td>
<td style="text-align: left;">Media Codecs, Network Processors</td>
<td style="text-align: left;">
<li>
Fixed-function pipelines
</li>
<li>
High throughput processing
</li>
<li>
Power-performance optimization
</li>
</td>
</tr>
<tr class="even">
<td style="text-align: left;">2010s</td>
<td style="text-align: left;">Deep Learning Tensor Operations</td>
<td style="text-align: left;">TPU, GPU Tensor Cores</td>
<td style="text-align: left;">
<li>
Matrix multiplication units
</li>
<li>
Massive parallelism
</li>
<li>
Memory bandwidth optimization
</li>
</td>
</tr>
<tr class="odd">
<td style="text-align: left;">2020s</td>
<td style="text-align: left;">Application-Specific Acceleration</td>
<td style="text-align: left;">ML Engines, Smart NICs, Domain Accelerators</td>
<td style="text-align: left;">
<li>
Workload-specific datapaths
</li>
<li>
Customized memory hierarchies
</li>
<li>
Application-optimized designs
</li>
</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>This historical progression reveals a recurring pattern: each wave of hardware specialization responded to a computational bottleneck—be it graphics rendering, media encoding, or neural network inference. What distinguishes the 2020s is not just specialization, but its pervasiveness: AI accelerators now underpin everything from product recommendations on YouTube to object detection in autonomous vehicles. Unlike earlier accelerators, today’s AI hardware must integrate tightly with dynamic software frameworks and scale across cloud-to-edge deployments. The table illustrates not just the past but also the trajectory toward increasingly tailored, high-impact computing platforms.</p>
<p>In the case of AI acceleration, this transition has introduced challenges that extend well beyond the confines of hardware design. Machine learning accelerators must integrate seamlessly into comprehensive ML workflows by aligning with optimizations at multiple levels of the computing stack. To achieve this, they are required to operate effectively with widely adopted frameworks such as TensorFlow, PyTorch, and JAX, thereby ensuring that deployment is smooth and consistent across varied hardware platforms. In tandem with this, compiler and runtime support become essential; advanced optimization techniques—including graph-level transformations, kernel fusion, and memory scheduling—are critical for harnessing the full potential of these specialized accelerators.</p>
<p>Moreover, scalability presents an ongoing demand as AI accelerators are deployed in diverse environments ranging from high-throughput data centers to resource-constrained edge and mobile devices, necessitating tailored performance tuning and energy efficiency strategies. Finally, the integration of such accelerators into heterogeneous computing environments underscores the importance of interoperability, ensuring that these specialized units can function in concert with conventional CPUs and GPUs in distributed systems.</p>
<p>The emergence of AI accelerators is therefore not simply a matter of hardware optimization but also a system-level transformation, where improvements in computation must be tightly coupled with advances in compilers, software frameworks, and distributed computing strategies. Understanding these principles is essential for designing and deploying efficient machine learning systems. The following sections explore how modern ML accelerators address these challenges, focusing on their architectural approaches, system-level optimizations, and integration into the broader machine learning ecosystem.</p>
</section></section><section id="ai-compute-primitives" class="level2 page-columns page-full" data-number="11.3"><h2 data-number="11.3" class="anchored" data-anchor-id="ai-compute-primitives">
<span class="header-section-number">11.3</span> AI Compute Primitives</h2>
<p>Modern neural networks are built upon a small number of core computational patterns. Regardless of the layer type, whether fully connected, convolutional, or attention-based, the underlying operation typically involves multiplying input values by learned weights and accumulating the results. This repeated multiply-accumulate process dominates neural network execution and defines the arithmetic foundation of AI workloads. The regularity and frequency of these operations have led to the development of AI compute primitive*: hardware-level abstractions optimized to execute these core computations with high efficiency.</p>
<p>Unlike traditional software applications, which often involve irregular control flow and diverse instruction types, neural networks exhibit highly structured, data-parallel computations applied across large arrays. This characteristic enables architectural simplifications and optimizations, where hardware is tailored to the consistent patterns in AI execution. These patterns emphasize parallelism, predictable data reuse, and fixed operation sequences—making them ideal candidates for specialized accelerator design. AI compute primitives distill these patterns into reusable architectural units that support high-throughput and energy-efficient execution.</p>
<p>To illustrate this decomposition, consider a dense layer defined at the framework level:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>dense <span class="op">=</span> Dense(<span class="dv">512</span>)(input_tensor)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This high-level call expands into mathematical operations:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> matmul(input_weights) <span class="op">+</span> bias</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> activation(output)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>At the processor level, the computation reduces to nested loops that multiply inputs and weights, sum the results, and apply a nonlinear function:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(batch_size):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> m <span class="kw">in</span> <span class="bu">range</span>(output_size):</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">sum</span> <span class="op">=</span> bias[m]</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(input_size):</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>            <span class="bu">sum</span> <span class="op">+=</span> <span class="bu">input</span>[n,k] <span class="op">*</span> weights[k,m]</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        output[n,m] <span class="op">=</span> activation(<span class="bu">sum</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This transformation—from framework-level abstraction to processor-level implementation—reveals four essential computational characteristics. First, data-level parallelism enables simultaneous execution across inputs. Second, structured matrix operations define the computational workload and guide the need for dedicated datapaths. Third, predictable data movement patterns drive memory system design to minimize latency and maximize reuse. Fourth, frequent nonlinear transformations motivate hardware support for activation and normalization functions.</p>
<p>The design of AI compute primitives is guided by three architectural criteria. First, the primitive must be used frequently enough to justify dedicated hardware resources. Second, its specialized implementation must offer substantial performance or energy efficiency gains relative to general-purpose alternatives. Third, the primitive must remain stable across generations of neural network architectures to ensure long-term applicability. These considerations shape the inclusion of primitives such as vector operations, matrix operations, and special function units in modern ML accelerators. Together, they serve as the architectural foundation for efficient and scalable neural network execution.</p>
<section id="vector-operations" class="level3 page-columns page-full" data-number="11.3.1"><h3 data-number="11.3.1" class="anchored" data-anchor-id="vector-operations">
<span class="header-section-number">11.3.1</span> Vector Operations</h3>
<p>Vector operations provide the first level of hardware acceleration by processing multiple data elements simultaneously. This parallelism exists at multiple scales, from individual neurons to entire layers, making vector processing essential for efficient neural network execution. By examining how framework-level code translates to hardware instructions, we can understand the critical role of vector processing in neural accelerators.</p>
<section id="framework-hardware-execution" class="level4"><h4 class="anchored" data-anchor-id="framework-hardware-execution">Framework-Hardware Execution</h4>
<p>Machine learning frameworks hide hardware complexity through high-level abstractions. These abstractions decompose into progressively lower-level operations, revealing opportunities for hardware acceleration. Consider the execution flow of a linear layer:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Framework Level: What ML developers write</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>layer <span class="op">=</span> nn.Linear(<span class="dv">256</span>, <span class="dv">512</span>)  <span class="co"># Layer transforms 256 inputs to</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>                             <span class="co"># 512 outputs</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> layer(input_tensor) <span class="co"># Process a batch of inputs</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This abstraction represents a fully connected layer that transforms input features through learned weights. The framework translates this high-level expression into mathematical operations:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Framework Internal: Mathematical operations</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> matmul(weights, <span class="bu">input</span>) <span class="op">+</span> bias <span class="co"># Each output needs all inputs</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> activation(Z)            <span class="co"># Transform each result</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>These mathematical operations decompose into explicit computational steps during processor execution. Each output value requires a sequence of multiply-accumulate operations:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Computational Level: Implementation</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> batch <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">32</span>):            <span class="co"># Process 32 samples at once</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> out_neuron <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">512</span>):  <span class="co"># Compute each output neuron</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">sum</span> <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> in_feature <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">256</span>): <span class="co"># Each output needs</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>                                      <span class="co"># all inputs</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>            <span class="bu">sum</span> <span class="op">+=</span> <span class="bu">input</span>[batch, in_feature] <span class="op">*</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>                         weights[out_neuron, in_feature]</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        output[batch, out_neuron] <span class="op">=</span> activation(<span class="bu">sum</span> <span class="op">+</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>                                    bias[out_neuron])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section><section id="sequential-scalar-execution" class="level4"><h4 class="anchored" data-anchor-id="sequential-scalar-execution">Sequential Scalar Execution</h4>
<p>Traditional scalar processors execute these operations sequentially, processing individual values one at a time. For the linear layer example above with a batch of 32 samples, computing the outputs requires over 4 million multiply-accumulate operations. Each operation involves loading an input value and a weight value, multiplying them, and accumulating the result. This sequential approach becomes highly inefficient when processing the massive number of identical operations required by neural networks.</p>
</section><section id="parallel-vector-execution" class="level4"><h4 class="anchored" data-anchor-id="parallel-vector-execution">Parallel Vector Execution</h4>
<p>Vector processing units transform this execution pattern by operating on multiple data elements simultaneously. The following RISC-V assembly code demonstrates modern vector processing:</p>
<pre class="assembly"><code># Vector hardware execution (RISC-V Vector Extension)
vsetvli t0, a0, e32   # Process 8 elements at once
loop_batch:
    loop_neuron:
        vxor.vv v0, v0, v0    # Clear 8 accumulators
        loop_feature:
            vle32.v v1, (in_ptr)   # Load 8 inputs together
            vle32.v v2, (wt_ptr)   # Load 8 weights together
            vfmacc.vv v0, v1, v2   # 8 multiply-adds at once
            add in_ptr, in_ptr, 32  # Move to next 8 inputs
            add wt_ptr, wt_ptr, 32  # Move to next 8 weights
            bnez feature_cnt, loop_feature</code></pre>
<p>This vector implementation processes eight data elements in parallel, reducing both computation time and energy consumption. Vector load instructions transfer eight values simultaneously, maximizing memory bandwidth utilization. The vector multiply-accumulate instruction processes eight pairs of values in parallel, dramatically reducing the total instruction count from over 4 million to approximately 500,000.</p>
<p>To clarify how vector instructions map to common deep learning patterns, <a href="#tbl-vector" class="quarto-xref">Table&nbsp;<span>11.2</span></a> introduces key vector operations and their typical applications in neural network computation. These operations, such as reduction, gather, scatter, and masked operations, are frequently encountered in layers like pooling, embedding lookups, and attention mechanisms. Understanding this terminology is essential for interpreting how low-level vector hardware accelerates high-level machine learning workloads.</p>
<div id="tbl-vector" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-vector-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;11.2: Vector operations and their neural network applications.
</figcaption><div aria-describedby="tbl-vector-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 42%">
<col style="width: 36%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Vector Operation</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Neural Network Application</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Reduction</td>
<td style="text-align: left;">Combines elements across a vector (e.g., sum, max)</td>
<td style="text-align: left;">Pooling layers, attention score computation</td>
</tr>
<tr class="even">
<td style="text-align: left;">Gather</td>
<td style="text-align: left;">Loads multiple non-consecutive memory elements</td>
<td style="text-align: left;">Embedding lookups, sparse operations</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Scatter</td>
<td style="text-align: left;">Writes to multiple non-consecutive memory locations</td>
<td style="text-align: left;">Gradient updates for embeddings</td>
</tr>
<tr class="even">
<td style="text-align: left;">Masked operations</td>
<td style="text-align: left;">Selectively operates on vector elements</td>
<td style="text-align: left;">Attention masks, padding handling</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Vector-scalar broadcast</td>
<td style="text-align: left;">Applies scalar to all vector elements</td>
<td style="text-align: left;">Bias addition, scaling operations</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>The efficiency gains from vector processing extend beyond instruction count reduction. Memory bandwidth utilization improves as vector loads transfer multiple values per operation. Energy efficiency increases because control logic is shared across multiple operations. These improvements compound across the deep layers of modern neural networks, where billions of operations execute for each forward pass.</p>
</section><section id="vector-processing-history" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="vector-processing-history">Vector Processing History</h4>
<p>The principles underlying vector operations have long played a central role in high-performance computing. In the 1970s and 1980s, vector processors emerged as a critical architectural solution for scientific computing, weather modeling, and physics simulations, where large arrays of data required efficient parallel processing. Early systems such as the Cray-1, one of the first commercially successful supercomputers, introduced dedicated vector units to perform arithmetic operations on entire data vectors in a single instruction. This approach dramatically improved computational throughput compared to traditional scalar execution <span class="citation" data-cites="jordan1982guide">(<a href="../references.html#ref-jordan1982guide" role="doc-biblioref">Jordan 1982</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-jordan1982guide" class="csl-entry" role="listitem">
Jordan, T. L. 1982. <span>“A Guide to Parallel Computation and Some Cray-1 Experiences.”</span> In <em>Parallel Computations</em>, 1–50. Elsevier. <a href="https://doi.org/10.1016/b978-0-12-592101-5.50006-3">https://doi.org/10.1016/b978-0-12-592101-5.50006-3</a>.
</div></div><p>These foundational concepts have reemerged in the context of machine learning, where neural networks exhibit an inherent structure well suited to vectorized execution. The same fundamental operations—vector addition, multiplication, and reduction—that once accelerated numerical simulations now drive the execution of machine learning workloads. While the scale and specialization of modern AI accelerators differ from their historical predecessors, the underlying architectural principles remain the same. The resurgence of vector processing in neural network acceleration highlights its enduring utility as a mechanism for achieving high computational efficiency.</p>
<p>Vector operations establish the foundation for neural network acceleration by enabling efficient parallel processing of independent data elements. However, the core transformations in neural networks require coordinating computation across multiple dimensions simultaneously. This need for structured parallel computation leads to the next architectural primitive: matrix operations.</p>
</section></section><section id="matrix-operations" class="level3 page-columns page-full" data-number="11.3.2"><h3 data-number="11.3.2" class="anchored" data-anchor-id="matrix-operations">
<span class="header-section-number">11.3.2</span> Matrix Operations</h3>
<p>Matrix operations are the computational workhorse of neural networks, transforming high-dimensional data through structured patterns of weights, activations, and gradients <span class="citation" data-cites="Goodfellow-et-al-2016">(<a href="../references.html#ref-Goodfellow-et-al-2016" role="doc-biblioref">Goodfellow, Courville, and Bengio 2013a</a>)</span>. While vector operations process elements independently, matrix operations orchestrate computations across multiple dimensions simultaneously. Understanding these operations reveals fundamental patterns that drive hardware acceleration strategies.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Goodfellow-et-al-2016" class="csl-entry" role="listitem">
Goodfellow, Ian J., Aaron Courville, and Yoshua Bengio. 2013a. <span>“Scaling up Spike-and-Slab Models for Unsupervised Feature Learning.”</span> <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em> 35 (8): 1902–14. <a href="https://doi.org/10.1109/tpami.2012.273">https://doi.org/10.1109/tpami.2012.273</a>.
</div></div><section id="matrix-operations-in-nns" class="level4"><h4 class="anchored" data-anchor-id="matrix-operations-in-nns">Matrix Operations in NNs</h4>
<p>Neural network computations decompose into hierarchical matrix operations. Consider how a linear layer illustrates this hierarchy, processing multiple input features into output neurons across a batch of samples:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Framework Level: What ML developers write</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>layer <span class="op">=</span> nn.Linear(<span class="dv">256</span>, <span class="dv">512</span>)  <span class="co"># Layer transforms 256 inputs to</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                             <span class="co"># 512 outputs</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> layer(input_batch)  <span class="co"># Process a batch of 32 samples</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Framework Internal: Core operations</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> matmul(weights, <span class="bu">input</span>)   <span class="co"># Matrix: transforms [256 x 32]</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>                             <span class="co"># input to [512 x 32] output</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> Z <span class="op">+</span> bias                 <span class="co"># Vector: adds bias to each</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>                             <span class="co"># output independently</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> relu(Z)             <span class="co"># Vector: applies activation to</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>                             <span class="co"># each element independently</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This computation demonstrates the inherent scale of matrix operations in neural networks. Each output neuron (512 total) must process all input features (256 total) for every sample in the batch (32 samples). The weight matrix alone contains <span class="math inline">\(256 \times 512 = 131,072\)</span> parameters that define these transformations, illustrating why efficient matrix multiplication becomes crucial for performance.</p>
</section><section id="matrix-computation-types-in-nns" class="level4"><h4 class="anchored" data-anchor-id="matrix-computation-types-in-nns">Matrix Computation Types in NNs</h4>
<p>Matrix operations appear consistently across modern neural architectures. Consider these fundamental patterns:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Linear Layers - Direct matrix multiply</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>hidden <span class="op">=</span> matmul(weights, inputs)  <span class="co"># weights: [out_dim x in_dim],</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>                                  <span class="co"># inputs: [in_dim x batch]</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>                                  <span class="co"># Result combines all inputs</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>                                  <span class="co"># for each output</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Attention Mechanisms - Multiple matrix operations</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>Q <span class="op">=</span> matmul(Wq, inputs)       <span class="co"># Project inputs to query space</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>                             <span class="co"># [query_dim x batch]</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> matmul(Wk, inputs)       <span class="co"># Project inputs to key space</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>                             <span class="co">#[key_dim x batch]</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>attention <span class="op">=</span> matmul(Q, K.T)   <span class="co"># Compare all queries with all</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>                             <span class="co"># keys [query_dim x key_dim]</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Convolutions - Matrix multiply after reshaping</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>patches <span class="op">=</span> im2col(<span class="bu">input</span>)           <span class="co"># Convert [H x W x C] image</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>                                  <span class="co"># to matrix of patches</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> matmul(kernel, patches)  <span class="co"># Apply kernels to all</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>                                  <span class="co"># patches simultaneously</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This pervasive pattern of matrix multiplication has direct implications for hardware design. The need for efficient matrix operations drives the development of specialized hardware architectures that can handle these computations at scale. The following sections explore how modern AI accelerators implement matrix operations, focusing on their architectural features and performance optimizations.</p>
</section><section id="matrix-operations-hardware-acceleration" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="matrix-operations-hardware-acceleration">Matrix Operations Hardware Acceleration</h4>
<p>The computational demands of matrix operations have driven specialized hardware optimizations. Modern processors implement dedicated matrix units that extend beyond vector processing capabilities. Consider the following example of matrix acceleration in hardware:</p>
<pre class="assembly"><code># Matrix processing unit operation for a block of the computation
mload mr1, (weight_ptr)     # Load e.g., 16x16 block of
                            # weight matrix
mload mr2, (input_ptr)      # Load corresponding input block
matmul.mm mr3, mr1, mr2     # Multiply and accumulate entire
                            # blocks at once
mstore (output_ptr), mr3    # Store computed output block</code></pre>
<p>This matrix processing unit can handle <span class="math inline">\(16\times16\)</span> blocks of the linear layer computation described earlier, processing 256 multiply-accumulate operations simultaneously compared to the 8 operations possible with vector processing. These matrix operations complement vectorized computation by enabling structured many-to-many transformations. The interplay between matrix and vector operations shapes the efficiency of neural network execution.</p>
<div id="tbl-matrix" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-matrix-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;11.3: Comparison of matrix and vector operation characteristics.
</figcaption><div aria-describedby="tbl-matrix-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 18%">
<col style="width: 28%">
<col style="width: 36%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Operation Type</th>
<th style="text-align: left;">Best For</th>
<th style="text-align: left;">Examples</th>
<th style="text-align: left;">Key Characteristic</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Matrix Operations</td>
<td style="text-align: left;">Many-to-many transforms</td>
<td style="text-align: left;">
<li>
Layer transformations
</li>
<li>
Attention computation
</li>
<li>
Convolutions
</li>
</td>
<td style="text-align: left;">Each output depends on multiple inputs</td>
</tr>
<tr class="even">
<td style="text-align: left;">Vector Operations</td>
<td style="text-align: left;">One-to-one transforms</td>
<td style="text-align: left;">
<li>
Activation functions
</li>
<li>
Layer normalization
</li>
<li>
Element-wise gradients
</li>
</td>
<td style="text-align: left;">Each output depends only on corresponding input</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Matrix operations provide essential computational capabilities for neural networks through coordinated parallel processing across multiple dimensions (see <a href="#tbl-matrix" class="quarto-xref">Table&nbsp;<span>11.3</span></a>). While they enable transformations such as attention mechanisms and convolutions, their performance depends on efficient data handling. Conversely, vector operations are optimized for one-to-one transformations like activation functions and layer normalization. The distinction between these operations highlights the importance of dataflow patterns in neural accelerator design, which we examine next <span class="citation" data-cites="Hwu2011GPU">(<a href="../references.html#ref-Hwu2011GPU" role="doc-biblioref">Hwu 2011</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Hwu2011GPU" class="csl-entry" role="listitem">
Hwu, Wen-mei W. 2011. <span>“Introduction.”</span> In <em>GPU Computing Gems Emerald Edition</em>, xix–xx. Elsevier. <a href="https://doi.org/10.1016/b978-0-12-384988-5.00064-4">https://doi.org/10.1016/b978-0-12-384988-5.00064-4</a>.
</div></div></section><section id="historical-foundations-of-matrix-computation" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="historical-foundations-of-matrix-computation">Historical Foundations of Matrix Computation</h4>
<p>Matrix operations have long served as a cornerstone of computational mathematics, with applications extending from numerical simulations to graphics processing <span class="citation" data-cites="Golub1996Matrix">(<a href="../references.html#ref-Golub1996Matrix" role="doc-biblioref">Golub and Loan 1996</a>)</span>. The structured nature of matrix multiplications and transformations made them a natural target for acceleration in early computing architectures. In the 1980s and 1990s, specialized digital signal processors (DSPs) and graphics processing units (GPUs) optimized for matrix computations played a critical role in accelerating workloads such as image processing, scientific computing, and 3D rendering <span class="citation" data-cites="owens2008gpu">(<a href="../references.html#ref-owens2008gpu" role="doc-biblioref">Owens et al. 2008</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Golub1996Matrix" class="csl-entry" role="listitem">
Golub, Gene H., and Charles F. Van Loan. 1996. <em>Matrix Computations</em>. Johns Hopkins University Press.
</div><div id="ref-owens2008gpu" class="csl-entry" role="listitem">
Owens, J. D., M. Houston, D. Luebke, S. Green, J. E. Stone, and J. C. Phillips. 2008. <span>“GPU Computing.”</span> <em>Proceedings of the IEEE</em> 96 (5): 879–99. <a href="https://doi.org/10.1109/jproc.2008.917757">https://doi.org/10.1109/jproc.2008.917757</a>.
</div></div><p>The widespread adoption of machine learning has reinforced the importance of efficient matrix computation. Neural networks, fundamentally built on matrix multiplications and tensor operations, have driven the development of dedicated hardware architectures that extend beyond traditional vector processing. Modern tensor processing units (TPUs) and AI accelerators implement matrix multiplication at scale, reflecting the same architectural principles that once underpinned early scientific computing and graphics workloads. The resurgence of matrix-centric architectures highlights the deep connection between classical numerical computing and contemporary AI acceleration.</p>
</section></section><section id="special-function-units" class="level3 page-columns page-full" data-number="11.3.3"><h3 data-number="11.3.3" class="anchored" data-anchor-id="special-function-units">
<span class="header-section-number">11.3.3</span> Special Function Units</h3>
<p>While vector and matrix operations efficiently handle the linear transformations in neural networks, non-linear functions present unique computational challenges that require dedicated hardware solutions. Special Function Units (SFUs) provide hardware acceleration for these essential computations, completing the set of fundamental processing primitives needed for efficient neural network execution.</p>
<section id="non-linear-functions" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="non-linear-functions">Non-Linear Functions</h4>
<p>Non-linear functions play a fundamental role in machine learning by enabling neural networks to model complex relationships <span class="citation" data-cites="Goodfellow2016">(<a href="../references.html#ref-Goodfellow2016" role="doc-biblioref">Goodfellow, Courville, and Bengio 2013b</a>)</span>. Consider a typical neural network layer sequence:</p>
<div class="no-row-height column-margin column-container"><div id="ref-Goodfellow2016" class="csl-entry" role="listitem">
———. 2013b. <span>“Scaling up Spike-and-Slab Models for Unsupervised Feature Learning.”</span> <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em> 35 (8): 1902–14. <a href="https://doi.org/10.1109/tpami.2012.273">https://doi.org/10.1109/tpami.2012.273</a>.
</div></div><div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Framework Level Operation</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>layer <span class="op">=</span> nn.Sequential(</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    nn.Linear(<span class="dv">256</span>, <span class="dv">512</span>),</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    nn.ReLU(),</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    nn.BatchNorm1d(<span class="dv">512</span>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> layer(input_tensor)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This sequence introduces multiple non-linear transformations. The framework decomposes it into mathematical operations:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Mathematical Operations</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> matmul(weights, <span class="bu">input</span>) <span class="op">+</span> bias    <span class="co"># Linear transformation</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>H <span class="op">=</span> <span class="bu">max</span>(<span class="dv">0</span>, Z)                        <span class="co"># ReLU activation</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>mean <span class="op">=</span> reduce_mean(H, axis<span class="op">=</span><span class="dv">0</span>)        <span class="co"># BatchNorm statistics</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>var <span class="op">=</span> reduce_mean((H <span class="op">-</span> mean)<span class="op">**</span><span class="dv">2</span>)     <span class="co"># Variance computation</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> gamma <span class="op">*</span> (H <span class="op">-</span> mean)<span class="op">/</span>sqrt(var <span class="op">+</span> eps) <span class="op">+</span> beta</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>                                     <span class="co"># Normalization</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section><section id="non-linear-functions-implementation" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="non-linear-functions-implementation">Non-Linear Functions Implementation</h4>
<p>On traditional processors, these seemingly simple mathematical operations translate into complex sequences of instructions. Consider the computation of batch normalization: calculating the square root requires multiple iterations of numerical approximation, while exponential functions in operations like softmax need series expansion or lookup tables <span class="citation" data-cites="Ioffe2015">(<a href="../references.html#ref-Ioffe2015" role="doc-biblioref">Ioffe and Szegedy 2015</a>)</span>. Even a simple ReLU activation requires conditional branching, which can disrupt instruction pipelining:</p>
<div class="no-row-height column-margin column-container"><div id="ref-Ioffe2015" class="csl-entry" role="listitem">
Ioffe, Sergey, and Christian Szegedy. 2015. <span>“Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift.”</span> <em>International Conference on Machine Learning (ICML)</em>, February, 448–56. <a href="http://arxiv.org/abs/1502.03167v3">http://arxiv.org/abs/1502.03167v3</a>.
</div></div><div class="sourceCode" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Traditional Implementation Overhead</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> batch <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">32</span>):</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">512</span>):</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ReLU: Requires branch prediction and potential</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="co"># pipeline stalls</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> matmul_output[batch, feature]</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        h <span class="op">=</span> <span class="bu">max</span>(<span class="fl">0.0</span>, z)    <span class="co"># Conditional operation</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># BatchNorm: Multiple passes over data</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>        mean_sum[feature] <span class="op">+=</span> h     <span class="co"># First pass for mean</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        var_sum[feature] <span class="op">+=</span> h <span class="op">*</span> h  <span class="co"># Additional pass for variance</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>        temp[batch, feature] <span class="op">=</span> h   <span class="co"># Extra memory storage needed</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Normalization requires complex arithmetic</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> feature <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">512</span>):</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    mean <span class="op">=</span> mean_sum[feature] <span class="op">/</span> batch_size</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    var <span class="op">=</span> (var_sum[feature] <span class="op">/</span> batch_size) <span class="op">-</span> mean <span class="op">*</span> mean</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Square root computation: Multiple iterations</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>    scale <span class="op">=</span> gamma[feature] <span class="op">/</span> sqrt(var <span class="op">+</span> eps)  <span class="co"># Iterative</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>                                              <span class="co"># approximation</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>    shift <span class="op">=</span> beta[feature] <span class="op">-</span> mean <span class="op">*</span> scale</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Additional pass over data for final computation</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> batch <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">32</span>):</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>        output[batch, feature] <span class="op">=</span> temp[batch, feature] <span class="op">*</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>                                 scale <span class="op">+</span> shift</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>These operations introduce several key inefficiencies:</p>
<ol type="1">
<li>Multiple passes over data, increasing memory bandwidth requirements</li>
<li>Complex arithmetic requiring many instruction cycles</li>
<li>Conditional operations that can cause pipeline stalls</li>
<li>Additional memory storage for intermediate results</li>
<li>Poor utilization of vector processing units</li>
</ol>
<p>More specifically, each operation introduces distinct challenges. Batch normalization requires multiple passes through data: one for mean computation, another for variance, and a final pass for output transformation. Each pass loads and stores data through the memory hierarchy. Operations that appear simple in mathematical notation often expand into many instructions. The square root computation typically requires 10-20 iterations of numerical methods like Newton-Raphson approximation for suitable precision <span class="citation" data-cites="Goldberg1991">(<a href="../references.html#ref-Goldberg1991" role="doc-biblioref">Goldberg 1991</a>)</span>. Conditional operations like ReLU’s max function require branch instructions that can stall the processor’s pipeline. The implementation needs temporary storage for intermediate values, increasing memory usage and bandwidth consumption. While vector units excel at regular computations, functions like exponentials and square roots often require scalar operations that cannot fully utilize vector processing capabilities.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Goldberg1991" class="csl-entry" role="listitem">
Goldberg, David. 1991. <span>“What Every Computer Scientist Should Know about Floating-Point Arithmetic.”</span> <em>ACM Computing Surveys</em> 23 (1): 5–48. <a href="https://doi.org/10.1145/103162.103163">https://doi.org/10.1145/103162.103163</a>.
</div></div></section><section id="hardware-acceleration" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="hardware-acceleration">Hardware Acceleration</h4>
<p>SFUs address these inefficiencies through dedicated hardware implementation. Modern ML accelerators include specialized circuits that transform these complex operations into single-cycle or fixed-latency computations. The accelerator can load a vector of values and apply non-linear functions directly, eliminating the need for multiple passes and complex instruction sequences:</p>
<pre class="assembly"><code># Example hardware execution with Special Function Units
vld.v v1, (input_ptr)      # Load vector of values
vrelu.v v2, v1             # Single-cycle ReLU on entire vector
vsigm.v v3, v1             # Fixed-latency sigmoid computation
vtanh.v v4, v1             # Direct hardware tanh implementation
vrsqrt.v v5, v1            # Fast reciprocal square root</code></pre>
<p>Each SFU implements a specific function through specialized circuitry. For instance, a ReLU unit performs the comparison and selection in dedicated logic, eliminating branching overhead. Square root operations use hardware implementations of algorithms like Newton-Raphson with fixed iteration counts, providing guaranteed latency. Exponential and logarithmic functions often combine small lookup tables with hardware interpolation circuits <span class="citation" data-cites="Lauterbach2019">(<a href="../references.html#ref-Lauterbach2019" role="doc-biblioref">Costa et al. 2019</a>)</span>. Using these custom instructions, the SFU implementation eliminates multiple passes over data, removes complex arithmetic sequences, and maintains high computational efficiency. <a href="#tbl-sfu" class="quarto-xref">Table&nbsp;<span>11.4</span></a> shows the various hardware implementations and their typical latencies.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Lauterbach2019" class="csl-entry" role="listitem">
Costa, Tiago, Chen Shi, Kevin Tien, and Kenneth L. Shepard. 2019. <span>“A CMOS 2D Transmit Beamformer with Integrated PZT Ultrasound Transducers for Neuromodulation.”</span> In <em>2019 IEEE Custom Integrated Circuits Conference (CICC)</em>, 1–4. IEEE. <a href="https://doi.org/10.1109/cicc.2019.8780236">https://doi.org/10.1109/cicc.2019.8780236</a>.
</div></div><div id="tbl-sfu" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-sfu-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;11.4: Special function unit implementation.
</figcaption><div aria-describedby="tbl-sfu-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 21%">
<col style="width: 39%">
<col style="width: 17%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Function Unit</th>
<th style="text-align: left;">Operation</th>
<th style="text-align: left;">Implementation Strategy</th>
<th style="text-align: left;">Typical Latency</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Activation Unit</td>
<td style="text-align: left;">ReLU, sigmoid, tanh</td>
<td style="text-align: left;">Piece-wise approximation circuits</td>
<td style="text-align: left;">1-2 cycles</td>
</tr>
<tr class="even">
<td style="text-align: left;">Statistics Unit</td>
<td style="text-align: left;">Mean, variance</td>
<td style="text-align: left;">Parallel reduction trees</td>
<td style="text-align: left;">log(N) cycles</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Exponential Unit</td>
<td style="text-align: left;">exp, log</td>
<td style="text-align: left;">Table lookup + hardware interpolation</td>
<td style="text-align: left;">2-4 cycles</td>
</tr>
<tr class="even">
<td style="text-align: left;">Root/Power Unit</td>
<td style="text-align: left;">sqrt, rsqrt</td>
<td style="text-align: left;">Fixed-iteration Newton-Raphson</td>
<td style="text-align: left;">4-8 cycles</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</section><section id="sfus-history" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="sfus-history">SFUs History</h4>
<p>The need for efficient non-linear function evaluation has shaped computer architecture for decades. Early processors incorporated hardware support for complex mathematical functions, such as logarithms and trigonometric operations, to accelerate workloads in scientific computing and signal processing <span class="citation" data-cites="Smith1997">(<a href="../references.html#ref-Smith1997" role="doc-biblioref">Smith 1997</a>)</span>. In the 1970s and 1980s, floating-point co-processors were introduced to handle complex mathematical operations separately from the main CPU <span class="citation" data-cites="palmer_8087_1981">(<a href="../references.html#ref-palmer_8087_1981" role="doc-biblioref">Palmer 1980</a>)</span>. In the 1990s, instruction set extensions such as Intel’s SSE and ARM’s NEON provided dedicated hardware for vectorized mathematical transformations, improving efficiency for multimedia and signal processing applications.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Smith1997" class="csl-entry" role="listitem">
Smith, Steven W. 1997. <em>The Scientist and Engineer’s Guide to Digital Signal Processing</em>. California Technical Publishing. <a href="https://www.dspguide.com/">https://www.dspguide.com/</a>.
</div><div id="ref-palmer_8087_1981" class="csl-entry" role="listitem">
Palmer, John F. 1980. <span>“The INTEL 8087 Numeric Data Processor.”</span> In <em>Proceedings of the May 19-22, 1980, National Computer Conference on - AFIPS ’80</em>, 887. ACM Press. <a href="https://doi.org/10.1145/1500518.1500674">https://doi.org/10.1145/1500518.1500674</a>.
</div></div><p>Machine learning workloads have reintroduced a strong demand for specialized functional units, as activation functions, normalization layers, and exponential transformations are fundamental to neural network computations. Rather than relying on iterative software approximations, modern AI accelerators implement fast, fixed-latency SFUs for these operations, mirroring historical trends in scientific computing. The reemergence of dedicated special function units underscores the ongoing cycle in hardware evolution, where domain-specific requirements drive the reinvention of classical architectural concepts in new computational paradigms.</p>
<p>The combination of vector, matrix, and special function units provides the computational foundation for modern AI accelerators. However, the effective utilization of these processing primitives depends critically on data movement and access patterns. This leads us to examine the architectures, hierarchies, and strategies that enable efficient data flow in neural network execution.</p>
</section></section><section id="compute-units-and-execution-models" class="level3 page-columns page-full" data-number="11.3.4"><h3 data-number="11.3.4" class="anchored" data-anchor-id="compute-units-and-execution-models">
<span class="header-section-number">11.3.4</span> Compute Units and Execution Models</h3>
<p>The vector operations, matrix operations, and special function units examined previously represent the fundamental computational primitives in AI accelerators. Modern AI processors package these primitives into distinct execution units, such as SIMD units, tensor cores, and processing elements, which define how computations are structured and exposed to users. Understanding this organization reveals both the theoretical capabilities and practical performance characteristics that developers can leverage in contemporary AI accelerators.</p>
<section id="primitive-execution-unit-mapping" class="level4"><h4 class="anchored" data-anchor-id="primitive-execution-unit-mapping">Primitive-Execution Unit Mapping</h4>
<p>The progression from computational primitives to execution units follows a structured hierarchy that reflects the increasing complexity and specialization of AI accelerators:</p>
<ul>
<li>Vector operations → SIMD/SIMT units that enable parallel processing of independent data elements</li>
<li>Matrix operations → Tensor cores and systolic arrays that provide structured matrix multiplication</li>
<li>Special functions → Dedicated hardware units integrated within processing elements</li>
</ul>
<p>Each execution unit combines these computational primitives with specialized memory and control mechanisms, optimizing both performance and energy efficiency. This structured packaging allows hardware vendors to expose standardized programming interfaces while implementing diverse underlying architectures tailored to specific workload requirements. The choice of execution unit significantly influences overall system efficiency, affecting data locality, compute density, and workload adaptability. Subsequent sections examine how these execution units operate within AI accelerators to maximize performance across different machine learning tasks.</p>
</section><section id="simd-to-simt-transition" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="simd-to-simt-transition">SIMD to SIMT Transition</h4>
<p>Single Instruction Multiple Data (SIMD) execution applies identical operations to multiple data elements in parallel, minimizing instruction overhead while maximizing data throughput. This execution model is widely used to accelerate workloads with regular, independent data parallelism, such as neural network computations. The ARM Scalable Vector Extension (SVE) provides a representative example of how modern architectures implement SIMD operations efficiently:</p>
<pre class="assembly"><code># Vector operation implementation using ARM SVE
ptrue p0.s              # Create predicate for vector length
ld1w z0.s, p0/z, [x0]   # Load vector of inputs
fmul z1.s, z0.s, z0.s   # Multiply elements
fadd z2.s, z1.s, z0.s   # Add elements
st1w z2.s, p0, [x1]     # Store results</code></pre>
<p>Processor architectures continue to expand SIMD capabilities to accommodate increasing computational demands. Intel’s Advanced Matrix Extensions (AMX) and ARM’s SVE2 architecture provide flexible SIMD execution, enabling software to scale across different hardware implementations <span class="citation" data-cites="stephens2017arm">(<a href="../references.html#ref-stephens2017arm" role="doc-biblioref">Stephens et al. 2017</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-stephens2017arm" class="csl-entry" role="listitem">
Stephens, Nigel, Stuart Biles, Matthias Boettcher, Jacob Eapen, Mbou Eyole, Giacomo Gabrielli, Matt Horsnell, et al. 2017. <span>“The ARM Scalable Vector Extension.”</span> <em>IEEE Micro</em> 37 (2): 26–39. <a href="https://doi.org/10.1109/mm.2017.35">https://doi.org/10.1109/mm.2017.35</a>.
</div><div id="ref-lindholm2008nvidia" class="csl-entry" role="listitem">
Lindholm, Erik, John Nickolls, Stuart Oberman, and John Montrym. 2008. <span>“NVIDIA Tesla: A Unified Graphics and Computing Architecture.”</span> <em>IEEE Micro</em> 28 (2): 39–55. <a href="https://doi.org/10.1109/mm.2008.31">https://doi.org/10.1109/mm.2008.31</a>.
</div></div><p>To address these limitations, SIMT extends SIMD principles by enabling parallel execution across multiple independent threads, each maintaining its own program counter and architectural state <span class="citation" data-cites="lindholm2008nvidia">(<a href="../references.html#ref-lindholm2008nvidia" role="doc-biblioref">Lindholm et al. 2008</a>)</span>. This model maps naturally to matrix computations, where each thread processes different portions of a workload while still benefiting from shared instruction execution. In NVIDIA’s GPU architectures, each Streaming Multiprocessor (SM) coordinates thousands of threads executing in parallel, allowing for efficient scaling of neural network computations:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">// CUDA kernel demonstrating SIMT execution</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>__global__ <span class="dt">void</span> matrix_multiply<span class="op">(</span><span class="dt">float</span><span class="op">*</span> C<span class="op">,</span> <span class="dt">float</span><span class="op">*</span> A<span class="op">,</span> <span class="dt">float</span><span class="op">*</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>                                B<span class="op">,</span> <span class="dt">int</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Each thread processes one output element</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> row <span class="op">=</span> blockIdx<span class="op">.</span>y <span class="op">*</span> blockDim<span class="op">.</span>y <span class="op">+</span> threadIdx<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> col <span class="op">=</span> blockIdx<span class="op">.</span>x <span class="op">*</span> blockDim<span class="op">.</span>x <span class="op">+</span> threadIdx<span class="op">.</span>x<span class="op">;</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> sum <span class="op">=</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> N<span class="op">;</span> k<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Threads in a warp execute in parallel</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>        sum <span class="op">+=</span> A<span class="op">[</span>row <span class="op">*</span> N <span class="op">+</span> k<span class="op">]</span> <span class="op">*</span> B<span class="op">[</span>k <span class="op">*</span> N <span class="op">+</span> col<span class="op">];</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    C<span class="op">[</span>row <span class="op">*</span> N <span class="op">+</span> col<span class="op">]</span> <span class="op">=</span> sum<span class="op">;</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>SIMT execution allows neural network computations to scale efficiently across thousands of threads while maintaining flexibility for divergent execution paths. Similar execution models appear in AMD’s RDNA and Intel’s Xe architectures, reinforcing SIMT as a fundamental mechanism for AI acceleration.</p>
</section><section id="tensor-cores" class="level4"><h4 class="anchored" data-anchor-id="tensor-cores">Tensor Cores</h4>
<p>While SIMD and SIMT units provide efficient execution of vector operations, neural networks rely heavily on matrix computations that require specialized execution units for structured multi-dimensional processing. Tensor processing units extend SIMD and SIMT principles by enabling efficient matrix operations through dedicated hardware blocks. These units execute matrix multiplications and accumulations on entire matrix blocks in a single operation, reducing instruction overhead and optimizing data movement.</p>
<p>Tensor cores, implemented in architectures such as NVIDIA’s Ampere GPUs, provide an example of this approach. They expose matrix computation capabilities through specialized instructions, such as the following tensor core operation in the NVIDIA A100 GPU:</p>
<pre class="text"><code>Tensor Core Operation (NVIDIA A100):
mma.sync.aligned.m16n16k16.f16.f16
  {d0,d1,d2,d3},     // Destination registers
  {a0,a1,a2,a3},     // Source matrix A
  {b0,b1,b2,b3},     // Source matrix B
  {c0,c1,c2,c3}      // Accumulator</code></pre>
<p>A single tensor core instruction processes an entire matrix block while maintaining intermediate results in local registers, significantly improving computational efficiency compared to implementations based on scalar or vector operations. This structured approach enables hardware to achieve high throughput while reducing the burden of explicit loop unrolling and data management at the software level.</p>
<p>Tensor processing unit architectures differ based on design priorities. NVIDIA’s Ampere architecture incorporates tensor cores optimized for general-purpose deep learning acceleration. Google’s TPUv4 utilizes large-scale matrix units arranged in systolic arrays to maximize sustained training throughput. Apple’s M1 neural engine integrates smaller matrix processors optimized for mobile inference workloads, while Intel’s Sapphire Rapids architecture introduces AMX tiles designed for high-performance datacenter applications.</p>
<p>The increasing specialization of AI hardware has driven significant performance improvements in deep learning workloads. <a href="#fig-ai-performance" class="quarto-xref">Figure&nbsp;<span>11.2</span></a> illustrates the trajectory of AI accelerator performance in NVIDIA GPUs, highlighting the transition from general-purpose floating-point execution units to highly optimized tensor processing cores.</p>
<div id="fig-ai-performance" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-ai-performance-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/png/int8_tops_nvidia.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Figure&nbsp;11.2: Single-chip performance scaling."><img src="images/png/int8_tops_nvidia.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ai-performance-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;11.2: Single-chip performance scaling.
</figcaption></figure>
</div>
</section><section id="processing-elements" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="processing-elements">Processing Elements</h4>
<p>The highest level of execution unit organization integrates multiple tensor cores with local memory into processing elements (PEs). A processing element serves as a fundamental building block in many AI accelerators, combining different computational units to efficiently execute neural network operations. Each PE typically includes vector units for element-wise operations, tensor cores for matrix computation, special function units for non-linear transformations, and dedicated memory resources to optimize data locality and minimize data movement overhead.</p>
<p>Processing elements play an essential role in AI hardware by balancing computational density with memory access efficiency. Their design varies across different architectures to support diverse workloads and scalability requirements. Graphcore’s Intelligence Processing Unit (IPU) distributes computation across 1,472 tiles, each containing independent processing elements optimized for fine-grained parallelism <span class="citation" data-cites="Graphcore2020">(<a href="../references.html#ref-Graphcore2020" role="doc-biblioref">Graphcore 2020</a>)</span>. Cerebras extends this approach in the CS-2 system, integrating 850,000 processing elements across a wafer-scale device to accelerate sparse computations. Tesla’s D1 processor arranges processing elements with substantial local memory, optimizing throughput and latency for real-time autonomous vehicle workloads <span class="citation" data-cites="Tesla2021">(<a href="../references.html#ref-Tesla2021" role="doc-biblioref">Inc. 2021</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Graphcore2020" class="csl-entry" role="listitem">
Graphcore. 2020. <span>“The Colossus MK2 IPU Processor.”</span> <em>Graphcore Technical Paper</em>.
</div><div id="ref-Tesla2021" class="csl-entry" role="listitem">
Inc., Tesla. 2021. <span>“Tesla AI Day: D1 Dojo Chip.”</span> <em>Tesla AI Day Presentation</em>.
</div></div><p>Processing elements provide the structural foundation for large-scale AI acceleration. Their efficiency depends not only on computational capability but also on interconnect strategies and memory hierarchy design. The next sections explore how these architectural choices impact performance across different AI workloads.</p>
<p>Tensor processing units have enabled substantial efficiency gains in AI workloads by leveraging hardware-accelerated matrix computation. Their role continues to evolve as architectures incorporate support for advanced execution techniques, including structured sparsity and workload-specific optimizations. The effectiveness of these units, however, depends not only on their computational capabilities but also on how they interact with memory hierarchies and data movement mechanisms, which are examined in subsequent sections.</p>
</section><section id="systolic-arrays" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="systolic-arrays">Systolic Arrays</h4>
<p>While tensor cores package matrix operations into structured computational units, systolic arrays provide an alternative approach optimized for continuous data flow and operand reuse. A systolic array arranges processing elements in a grid pattern, where data flows rhythmically between neighboring units in a synchronized manner. This structured movement of data enables efficient execution of matrix multiplication, reducing memory access overhead and maximizing computational throughput.</p>
<p>The concept of systolic arrays was first introduced by H.T. Kung, who formalized their use in parallel computing architectures for efficient matrix operations <span class="citation" data-cites="Kung1982">(<a href="../references.html#ref-Kung1982" role="doc-biblioref">Kung 1982</a>)</span>. Unlike general-purpose execution units, systolic arrays exploit spatial and temporal locality by reusing operands as they propagate through the grid. Google’s Tensor Processing Unit (TPU) exemplifies this architectural approach. In the TPUv4, a <span class="math inline">\(128\times128\)</span> systolic array of multiply-accumulate units processes matrix operations by streaming data through the array in a pipelined manner, as shown in <a href="#fig-systolic-array" class="quarto-xref">Figure&nbsp;<span>11.3</span></a>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Kung1982" class="csl-entry" role="listitem">
Kung. 1982. <span>“Why Systolic Architectures?”</span> <em>Computer</em> 15 (1): 37–46. <a href="https://doi.org/10.1109/mc.1982.1653825">https://doi.org/10.1109/mc.1982.1653825</a>.
</div></div><div id="fig-systolic-array" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-systolic-array-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="sourceCode" id="cb19"><pre class="sourceCode tikz code-with-copy"><code class="sourceCode latex"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">\resizebox</span>{<span class="fu">\textwidth</span>}{!}{<span class="co">%</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">\begin</span>{<span class="ex">tikzpicture</span>}[font=<span class="fu">\usefont</span>{T1}{phv}{m}{n}]</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">%</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="fu">\tikzset</span>{<span class="co">%</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    helvetica/.style={align=flush center,font=<span class="fu">\usefont</span>{T1}{phv}{m}{n}},</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    Line/.style={line width=1.3pt,black!70,rounded corners}</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[line width=0.75pt, draw=VioletLine,fill=VioletL!30, rectangle,</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>minimum width=200,minimum height=200](B){};</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\x</span>/<span class="fu">\y</span> in{0.08/1,0.33/2,0.58/3,0.95/4}</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,line cap=round](<span class="ss">$(B.south west)!</span><span class="sc">\x</span><span class="ss">!(B.south east)$</span>)coordinate(G<span class="fu">\y</span>)</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>                --++(270:0.7)coordinate(D<span class="fu">\y</span>);</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a><span class="co">%</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\a</span> in{1,2,3,4}{</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a><span class="kw">\begin</span>{<span class="ex">scope</span>}[shift={(D<span class="fu">\a</span>)}, yshift=-33]</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[line width=1.25pt, draw,fill=GreenL!30,</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>              minimum width=22, minimum height=32](MB<span class="fu">\a</span>){};</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\x</span> in{0.2,0.4,0.6,0.8}</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[line width=1.25pt](<span class="ss">$(MB</span><span class="sc">\a</span><span class="ss">.north west)!</span><span class="sc">\x</span><span class="ss">!(MB</span><span class="sc">\a</span><span class="ss">.south west)$</span>)--</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>            (<span class="ss">$(MB</span><span class="sc">\a</span><span class="ss">.north east)!</span><span class="sc">\x</span><span class="ss">!(MB</span><span class="sc">\a</span><span class="ss">.south east)$</span>);</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[circle,line width=1.25pt,draw,minimum width=19,</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>           above=0.22 of MB<span class="fu">\a</span>,fill=white](C<span class="fu">\a</span>){};</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[font=<span class="fu">\bfseries</span>]at(C<span class="fu">\a</span>){+};</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line](C<span class="fu">\a</span>)--(MB<span class="fu">\a</span>);</span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line](MB<span class="fu">\a</span>.south)--++(270:0.3)--++(180:0.9)|-(C<span class="fu">\a</span>.west)coordinate(T<span class="fu">\a</span>);</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a><span class="kw">\end</span>{<span class="ex">scope</span>}</span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](MB1)--(MB2);</span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](MB2)--(MB3);</span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[font=<span class="fu">\Huge</span>](DL)at(<span class="ss">$(MB3.east)!0.44!(MB4.west)$</span>){...};</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](MB3)--(DL);</span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](DL)--(MB4);</span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](MB4)--++(0:1)node[right]{Done};</span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\x</span>/<span class="fu">\y</span> in{0.08/1,0.31/2,0.55/3,0.95/4}</span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,line cap=round](<span class="ss">$(B.north west)!</span><span class="sc">\x</span><span class="ss">!(B.south west)$</span>)coordinate(GG<span class="fu">\y</span>)</span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a>                --++(180:0.7)coordinate(DD<span class="fu">\y</span>);</span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\a</span> in{1,2,3,4}{</span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a><span class="kw">\begin</span>{<span class="ex">scope</span>}[shift={(DD<span class="fu">\a</span>)}, xshift=-12,line cap=round]</span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[line width=1.25pt, draw=none,fill=GreenL!80,</span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a>              minimum width=32, minimum height=20](2MB<span class="fu">\a</span>){};</span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\x</span> in{0,0.25,0.5,0.75}</span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[line width=1.25pt](<span class="ss">$(2MB</span><span class="sc">\a</span><span class="ss">.north west)!</span><span class="sc">\x</span><span class="ss">!(2MB</span><span class="sc">\a</span><span class="ss">.north east)$</span>)--</span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a>            (<span class="ss">$(2MB</span><span class="sc">\a</span><span class="ss">.south west)!</span><span class="sc">\x</span><span class="ss">!(2MB</span><span class="sc">\a</span><span class="ss">.south east)$</span>);</span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[line width=1.25pt,line cap=round,red](2MB<span class="fu">\a</span>.north west)</span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a>--++(180:2mm)coordinate(Z);</span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[line width=1.25pt,line cap=round,red](2MB<span class="fu">\a</span>.south west)</span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a>--++(180:2mm)coordinate(DZ);</span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[line width=1.25pt,line cap=round](Z)--(2MB<span class="fu">\a</span>.north east)|-(DZ);</span>
<span id="cb19-52"><a href="#cb19-52" aria-hidden="true" tabindex="-1"></a><span class="kw">\end</span>{<span class="ex">scope</span>}</span>
<span id="cb19-53"><a href="#cb19-53" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb19-54"><a href="#cb19-54" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](2MB1)--(2MB2);</span>
<span id="cb19-55"><a href="#cb19-55" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](2MB2)--(2MB3);</span>
<span id="cb19-56"><a href="#cb19-56" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[font=<span class="fu">\Huge</span>,rotate=90](2DL)at(<span class="ss">$(2MB3.south)!0.52!(2MB4.north)$</span>){...};</span>
<span id="cb19-57"><a href="#cb19-57" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](2MB3)--(2DL);</span>
<span id="cb19-58"><a href="#cb19-58" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](2DL)--(2MB4);</span>
<span id="cb19-59"><a href="#cb19-59" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](2MB4)|-(MB1);</span>
<span id="cb19-60"><a href="#cb19-60" aria-hidden="true" tabindex="-1"></a><span class="co">%</span></span>
<span id="cb19-61"><a href="#cb19-61" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[line width=1.25pt, draw,fill=BlueL,</span>
<span id="cb19-62"><a href="#cb19-62" aria-hidden="true" tabindex="-1"></a>             <span class="co">% minimum width=22mm, minimum height=10mm,</span></span>
<span id="cb19-63"><a href="#cb19-63" aria-hidden="true" tabindex="-1"></a>             inner ysep=8,inner xsep=10,</span>
<span id="cb19-64"><a href="#cb19-64" aria-hidden="true" tabindex="-1"></a>              above left=0.25 and 1.2 of 2MB1](CO){Control};</span>
<span id="cb19-65"><a href="#cb19-65" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](CO.350)-|(2MB1);</span>
<span id="cb19-66"><a href="#cb19-66" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](CO.10)-|(B.north west);</span>
<span id="cb19-67"><a href="#cb19-67" aria-hidden="true" tabindex="-1"></a><span class="co">%%</span></span>
<span id="cb19-68"><a href="#cb19-68" aria-hidden="true" tabindex="-1"></a><span class="fu">\def\di</span>{0.5}</span>
<span id="cb19-69"><a href="#cb19-69" aria-hidden="true" tabindex="-1"></a><span class="fu">\def\du</span>{1.0}</span>
<span id="cb19-70"><a href="#cb19-70" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](GG1)++(<span class="fu">\di</span>,0)--++(0:<span class="fu">\du</span>)coordinate(H);</span>
<span id="cb19-71"><a href="#cb19-71" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](H)++(<span class="fu">\di</span>,0)--++(0:<span class="fu">\du</span>)coordinate(H1);</span>
<span id="cb19-72"><a href="#cb19-72" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](H1)++(<span class="fu">\di</span>,0)--++(0:<span class="fu">\du</span>)coordinate(H2)</span>
<span id="cb19-73"><a href="#cb19-73" aria-hidden="true" tabindex="-1"></a>node[right]{Data};</span>
<span id="cb19-74"><a href="#cb19-74" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](GG2)++(<span class="fu">\di</span>,0)--++(0:<span class="fu">\du</span>)coordinate(2H);</span>
<span id="cb19-75"><a href="#cb19-75" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](2H)++(<span class="fu">\di</span>,0)--++(0:<span class="fu">\du</span>)coordinate(2H1);</span>
<span id="cb19-76"><a href="#cb19-76" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](GG3)++(<span class="fu">\di</span>,0)--++(0:<span class="fu">\du</span>)coordinate(3H);</span>
<span id="cb19-77"><a href="#cb19-77" aria-hidden="true" tabindex="-1"></a><span class="co">%</span></span>
<span id="cb19-78"><a href="#cb19-78" aria-hidden="true" tabindex="-1"></a><span class="fu">\path</span>[](H)-|coordinate(V1)(G4);</span>
<span id="cb19-79"><a href="#cb19-79" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](V1)++(0,-5mm)--++(270:<span class="fu">\du</span>)coordinate(V2);</span>
<span id="cb19-80"><a href="#cb19-80" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](V2)++(0,-5mm)--++(270:<span class="fu">\du</span>)coordinate(V3);</span>
<span id="cb19-81"><a href="#cb19-81" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](V3)++(0,-5mm)--++(270:<span class="fu">\du</span>)coordinate(V4);</span>
<span id="cb19-82"><a href="#cb19-82" aria-hidden="true" tabindex="-1"></a><span class="co">%</span></span>
<span id="cb19-83"><a href="#cb19-83" aria-hidden="true" tabindex="-1"></a><span class="fu">\path</span>[](2H)-|coordinate(2V1)(G3);</span>
<span id="cb19-84"><a href="#cb19-84" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](2V1)++(0,-0.8*<span class="fu">\di</span>)--++(270:0.8*<span class="fu">\du</span>)coordinate(2V2);</span>
<span id="cb19-85"><a href="#cb19-85" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](2V2)++(0,-0.8*<span class="fu">\di</span>)--++(270:0.8*<span class="fu">\du</span>)coordinate(2V3);</span>
<span id="cb19-86"><a href="#cb19-86" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](2V3)++(0,-0.8*<span class="fu">\di</span>)--++(270:0.8*<span class="fu">\du</span>)node[below]{Partial Sums};</span>
<span id="cb19-87"><a href="#cb19-87" aria-hidden="true" tabindex="-1"></a><span class="co">%</span></span>
<span id="cb19-88"><a href="#cb19-88" aria-hidden="true" tabindex="-1"></a><span class="fu">\path</span>[](3H)-|coordinate(3V1)(G2);</span>
<span id="cb19-89"><a href="#cb19-89" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](3V1)--++(270:0.8*<span class="fu">\du</span>)coordinate(3V2);</span>
<span id="cb19-90"><a href="#cb19-90" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](3V2)++(0,-0.6*<span class="fu">\di</span>)--++(270:0.8*<span class="fu">\du</span>)coordinate(3V3);</span>
<span id="cb19-91"><a href="#cb19-91" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](3V3)++(0,-0.6*<span class="fu">\di</span>)--++(270:0.8*<span class="fu">\du</span>)coordinate(3V4);</span>
<span id="cb19-92"><a href="#cb19-92" aria-hidden="true" tabindex="-1"></a><span class="kw">\end</span>{<span class="ex">tikzpicture</span>}}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-systolic-array-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;11.3: Data flow movement in a systolic array.
</figcaption></figure>
</div>
<p>Each processing element in the array performs a multiply-accumulate operation in every cycle:</p>
<ol type="1">
<li>Receives an input activation from above</li>
<li>Receives a weight value from the left</li>
<li>Multiplies these values and adds to its running sum</li>
<li>Passes the input activation downward and the weight value rightward to neighboring elements</li>
</ol>
<p>This structured computation model minimizes data movement between global memory and processing elements, improving both efficiency and scalability. As systolic arrays operate in a streaming fashion, they are particularly effective for high-throughput workloads such as deep learning training and inference.</p>
<p>While the diagram in <a href="#fig-systolic-array" class="quarto-xref">Figure&nbsp;<span>11.3</span></a> illustrates one common systolic array implementation, systolic architectures vary significantly across different accelerator designs. Training-focused architectures like Google’s TPU employ large arrays optimized for high computational throughput, while inference-oriented designs found in edge devices prioritize energy efficiency with smaller configurations.</p>
<p>The fundamental principle remains consistent: data flows systematically through processing elements, with inputs moving horizontally and vertically to compute partial sums in a synchronized fashion. However, the practical effectiveness of systolic arrays extends beyond their computational structure—it depends heavily on efficient memory access patterns and careful scheduling strategies, topics we explore in detail in subsequent sections.</p>
</section><section id="numerics-in-ai-acceleration" class="level4"><h4 class="anchored" data-anchor-id="numerics-in-ai-acceleration">Numerics in AI Acceleration</h4>
<p>The efficiency of AI accelerators is not determined by computational power alone but also by the precision of numerical representations. The choice of numerical format shapes the balance between accuracy, throughput, and energy consumption, influencing how different execution units—SIMD and SIMT units, tensor cores, and systolic arrays—are designed and deployed.</p>
<section id="precision-trade-offs" class="level5"><h5 class="anchored" data-anchor-id="precision-trade-offs">Precision Trade-offs</h5>
<p>Numerical precision represents a critical design parameter in modern AI accelerators. While higher precision formats provide mathematical stability and accuracy, they come with substantial costs in terms of power consumption, memory bandwidth, and computational throughput. Finding the optimal precision point has become a central challenge in AI hardware architecture.</p>
<p>Early deep learning models primarily relied on single-precision floating point (FP32) for both training and inference. While FP32 offers sufficient dynamic range and precision for stable learning, it imposes high computational and memory costs, limiting efficiency, especially as model sizes increase. Over time, hardware architectures evolved to support lower precision formats such as half-precision floating point (FP16) and bfloat16 (BF16), which reduce memory usage and increase computational throughput while maintaining sufficient accuracy for deep learning tasks. More recently, integer formats (INT8, INT4) have gained prominence in inference workloads, where small numerical representations significantly improve energy efficiency without compromising model accuracy beyond acceptable limits.</p>
<p>The transition from high-precision to lower-precision formats is deeply integrated into hardware execution models. SIMD and SIMT units provide flexible support for multiple precisions, dynamically adapting to workload requirements. Tensor cores are designed explicitly for matrix multiplications, accelerating computation using reduced-precision floating point and integer arithmetic. Systolic arrays, with their structured data flow, further optimize performance by minimizing memory bandwidth constraints, often favoring low-precision formats that maximize operand reuse.</p>
<p>Despite the advantages of reduced precision, deep learning models cannot always rely solely on low-bit representations. To address this challenge, modern AI accelerators implement mixed-precision computing, where different numerical formats are used at different stages of execution. For example, matrix multiplications may be performed in FP16 or BF16, while accumulations are maintained in FP32 to prevent precision loss. Similarly, inference engines leverage INT8 arithmetic while preserving key activations in higher precision when necessary.RetryClaude can make mistakes. Please double-check responses.</p>
</section><section id="mixed-precision-computing" class="level5"><h5 class="anchored" data-anchor-id="mixed-precision-computing">Mixed-Precision Computing</h5>
<p>Modern AI accelerators increasingly support mixed-precision execution, allowing different numerical formats to be used at various stages of computation. Training workloads often leverage FP16 or BF16 for matrix multiplications, while maintaining FP32 accumulations to preserve precision. Inference workloads, by contrast, optimize for INT8 or even INT4, achieving high efficiency while retaining acceptable accuracy.</p>
<p>This shift toward precision diversity is evident in the evolution of AI hardware. Early architectures such as NVIDIA Volta provided limited support for lower precision beyond FP16, whereas later architectures, including Turing and Ampere, expanded the range of supported formats. Ampere GPUs introduced TF32 as a hybrid between FP32 and FP16, alongside broader support for BF16, INT8, and INT4. <a href="#tbl-numerics" class="quarto-xref">Table&nbsp;<span>11.5</span></a> illustrates this trend.</p>
<div id="tbl-numerics" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-numerics-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;11.5: Tensor core and cuda core precisions across GPU architectures.
</figcaption><div aria-describedby="tbl-numerics-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 13%">
<col style="width: 13%">
<col style="width: 37%">
<col style="width: 32%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Architecture</th>
<th style="text-align: left;">Year</th>
<th style="text-align: left;">Supported Tensor Core Precisions</th>
<th style="text-align: left;">Supported CUDA Core Precisions</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Volta</td>
<td style="text-align: left;">2017</td>
<td style="text-align: left;">FP16</td>
<td style="text-align: left;">FP64, FP32, FP16</td>
</tr>
<tr class="even">
<td style="text-align: left;">Turing</td>
<td style="text-align: left;">2018</td>
<td style="text-align: left;">FP16, INT8</td>
<td style="text-align: left;">FP64, FP32, FP16, INT8</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Ampere</td>
<td style="text-align: left;">2020</td>
<td style="text-align: left;">FP64, TF32, bfloat16, FP16, INT8, INT4</td>
<td style="text-align: left;">FP64, FP32, FP16, bfloat16, INT8</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p><a href="#tbl-numerics" class="quarto-xref">Table&nbsp;<span>11.5</span></a> highlights how newer architectures incorporate a growing diversity of numerical formats, reflecting the need for greater flexibility across different AI workloads. This trend suggests that future AI accelerators will continue expanding support for adaptive precision, optimizing both computational efficiency and model accuracy. The selection now reads:</p>
<p>The precision format used in hardware design has far-reaching implications. By adopting lower-precision formats, the data transferred between execution units and memory is reduced, leading to decreased memory bandwidth requirements and storage. Moreover, tensor cores and systolic arrays can process more lower-precision elements in parallel, thereby increasing the effective throughput in terms of FLOPs. Energy efficiency is also improved, as integer-based computations (e.g., INT8) require lower power compared to floating-point arithmetic—a clear advantage for inference workloads.</p>
<p>As AI models continue to scale in size, accelerator architectures are evolving to support more efficient numerical formats. Future designs are expected to incorporate adaptive precision techniques, dynamically adjusting computation precision based on workload characteristics. This evolution promises further optimization of deep learning performance while striking an optimal balance between accuracy and energy efficiency.</p>
</section></section><section id="architectural-integration" class="level4"><h4 class="anchored" data-anchor-id="architectural-integration">Architectural Integration</h4>
<p>The organization of computational primitives into execution units determines the efficiency of AI accelerators. While SIMD, tensor cores, and systolic arrays serve as fundamental building blocks, their integration into full-chip architectures varies significantly across different AI processors. The choice of execution units, their numerical precision support, and their connectivity impact how effectively hardware can scale for deep learning workloads.</p>
<p>Modern AI processors exhibit a range of design trade-offs based on their intended applications. Some architectures, such as NVIDIA’s A100, integrate large numbers of tensor cores optimized for FP16-based training, while Google’s TPUv4 prioritizes high-throughput BF16 matrix multiplications. Inference-focused processors, such as Intel’s Sapphire Rapids, incorporate INT8-optimized tensor cores to maximize efficiency. The Apple M1, designed for mobile workloads, employs smaller processing elements optimized for low-power FP16 execution. These design choices reflect the growing flexibility in numerical precision and execution unit organization, as discussed in the previous section.</p>
<p><a href="#tbl-execution-units" class="quarto-xref">Table&nbsp;<span>11.6</span></a> summarizes the execution unit configurations across contemporary AI processors.</p>
<div id="tbl-execution-units" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-execution-units-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;11.6: Execution unit configurations across modern AI processors
</figcaption><div aria-describedby="tbl-execution-units-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 16%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 19%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Processor</th>
<th style="text-align: left;">SIMD Width</th>
<th style="text-align: left;">Tensor Core Size</th>
<th style="text-align: left;">Processing Elements</th>
<th style="text-align: left;">Primary Workloads</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">NVIDIA A100</td>
<td style="text-align: left;">1024-bit</td>
<td style="text-align: left;">
<span class="math inline">\(4\times4\times4\)</span> FP16</td>
<td style="text-align: left;">108 SMs</td>
<td style="text-align: left;">Training, HPC</td>
</tr>
<tr class="even">
<td style="text-align: left;">Google TPUv4</td>
<td style="text-align: left;">128-wide</td>
<td style="text-align: left;">
<span class="math inline">\(128\times128\)</span> BF16</td>
<td style="text-align: left;">2 cores/chip</td>
<td style="text-align: left;">Training</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Intel Sapphire</td>
<td style="text-align: left;">512-bit AVX</td>
<td style="text-align: left;">
<span class="math inline">\(32\times32\)</span> INT8/BF16</td>
<td style="text-align: left;">56 cores</td>
<td style="text-align: left;">Inference</td>
</tr>
<tr class="even">
<td style="text-align: left;">Apple M1</td>
<td style="text-align: left;">128-bit NEON</td>
<td style="text-align: left;">
<span class="math inline">\(16\times16\)</span> FP16</td>
<td style="text-align: left;">8 NPU cores</td>
<td style="text-align: left;">Mobile inference</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p><a href="#tbl-execution-units" class="quarto-xref">Table&nbsp;<span>11.6</span></a> highlights how execution unit configurations vary across architectures to optimize for different deep learning workloads. Training accelerators prioritize high-throughput floating-point tensor operations, whereas inference processors focus on low-precision integer execution for efficiency. Meanwhile, mobile accelerators balance precision and power efficiency to meet real-time constraints.</p>
<p>While execution units define the compute potential of an accelerator, their effectiveness is fundamentally constrained by data movement and memory hierarchy. Achieving high utilization of compute resources requires efficient memory systems that minimize data transfer overhead and optimize locality. The next section explores these architectural challenges, focusing on how memory hierarchy impacts AI accelerator performance.</p>
</section></section></section><section id="ai-memory-systems" class="level2 page-columns page-full" data-number="11.4"><h2 data-number="11.4" class="anchored" data-anchor-id="ai-memory-systems">
<span class="header-section-number">11.4</span> AI Memory Systems</h2>
<p>Machine learning accelerators are designed to maximize computational throughput, leveraging specialized primitives such as vector units, matrix engines, and systolic arrays. However, the efficiency of these compute units is fundamentally constrained by the availability of data. Unlike conventional workloads, ML models require frequent access to large volumes of parameters, activations, and intermediate results, leading to substantial memory bandwidth demands. If data cannot be delivered to the processing elements at the required rate, memory bottlenecks can significantly limit performance, regardless of the accelerator’s raw computational capability.</p>
<p>Modern AI hardware leverages advanced memory hierarchies, efficient data movement techniques, and compression strategies to alleviate bottlenecks and enhance performance. By examining the interplay between ML workloads and memory systems along with memory bandwidth constraints, we can gain insights into architectural innovations that promote efficient execution and improved AI acceleration.</p>
<section id="ai-memory-wall" class="level3 page-columns page-full" data-number="11.4.1"><h3 data-number="11.4.1" class="anchored" data-anchor-id="ai-memory-wall">
<span class="header-section-number">11.4.1</span> AI Memory Wall</h3>
<p>Machine learning accelerators are capable of performing vast amounts of computation per cycle, but their efficiency is increasingly limited by data movement rather than raw processing power. The disparity between rapid computational advancements and slower memory performance has led to a growing bottleneck, often referred to as the AI memory wall. Even the most optimized hardware architectures struggle to sustain peak throughput if data cannot be delivered at the required rate. Ensuring that compute units remain fully utilized without being stalled by memory latency and bandwidth constraints is one of the central challenges in AI acceleration.</p>
<section id="compute-memory-imbalance" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="compute-memory-imbalance">Compute-Memory Imbalance</h4>
<p>As we have seen, neural networks rely on specialized computational primitives such as vector operations, matrix multiplications, and domain-specific functional units that accelerate key aspects of machine learning workloads. These operations are designed for highly parallel execution, enabling accelerators to perform vast amounts of computation in each cycle. Given this level of specialization, one might expect neural networks to execute efficiently without significant bottlenecks. However, the primary constraint is not the raw compute power but rather the ability to continuously supply data to these processing units.</p>
<p>While these compute units can execute millions of operations per second, they remain heavily dependent on memory bandwidth to sustain peak performance. Each matrix multiplication or vector operation requires a steady flow of weights, activations, and intermediate results, all of which must be fetched from memory. If data cannot be delivered at the required rate, memory stalls occur, leaving many compute units idle. This imbalance between computational capability and data availability is often referred to as the memory wall—a fundamental challenge in AI acceleration.</p>
<p>Over time, the gap between computation and memory performance has widened. As illustrated in <a href="#fig-compute-memory-imbalance" class="quarto-xref">Figure&nbsp;<span>11.4</span></a>, the shaded region—termed the “AI Memory Wall”—highlights the growing disparity between compute performance and memory bandwidth over time. This visualization underscores the compute-memory imbalance, where computational capabilities advance rapidly while memory bandwidth lags, leading to potential bottlenecks in data-intensive applications. Over the past 20 years, peak server hardware FLOPs have scaled at 3.0x every two years, far outpacing the growth of DRAM bandwidth (1.6x/2yrs) <span class="citation" data-cites="gholami2024ai">(<a href="../references.html#ref-gholami2024ai" role="doc-biblioref">Gholami et al. 2024</a>)</span>. This growing imbalance has made memory bandwidth, rather than compute, the primary constraint in AI acceleration.</p>
<div class="no-row-height column-margin column-container"><div id="ref-gholami2024ai" class="csl-entry" role="listitem">
Gholami, Amir, Zhewei Yao, Sehoon Kim, Coleman Hooper, Michael W. Mahoney, and Kurt Keutzer. 2024. <span>“AI and Memory Wall.”</span> <em>IEEE Micro</em> 44 (3): 33–39. <a href="https://doi.org/10.1109/mm.2024.3373763">https://doi.org/10.1109/mm.2024.3373763</a>.
</div></div><div class="cell">
<div class="cell-output-display">
<div id="fig-compute-memory-imbalance" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-compute-memory-imbalance-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="hw_acceleration_files/figure-html/fig-compute-memory-imbalance-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="Figure&nbsp;11.4: Compute performance versus memory bandwidth over time."><img src="hw_acceleration_files/figure-html/fig-compute-memory-imbalance-1.png" class="img-fluid figure-img" width="672"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-compute-memory-imbalance-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;11.4: Compute performance versus memory bandwidth over time.
</figcaption></figure>
</div>
</div>
</div>
<p>Beyond performance limitations, memory access imposes a significant energy cost. Fetching data from off-chip DRAM, in particular, consumes far more energy than performing arithmetic operations <span class="citation" data-cites="Horowitz2014">(<a href="../references.html#ref-Horowitz2014" role="doc-biblioref">Horowitz 2014</a>)</span>. This inefficiency is particularly evident in machine learning models, where large parameter sizes, frequent memory accesses, and non-uniform data movement patterns exacerbate memory bottlenecks.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Horowitz2014" class="csl-entry" role="listitem">
Horowitz, Mark. 2014. <span>“1.1 Computing’s Energy Problem (and What We Can Do about It).”</span> In <em>2014 IEEE International Solid-State Circuits Conference Digest of Technical Papers (ISSCC)</em>. IEEE. <a href="https://doi.org/10.1109/isscc.2014.6757323">https://doi.org/10.1109/isscc.2014.6757323</a>.
</div></div></section><section id="memory-intensive-ml-workloads" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="memory-intensive-ml-workloads">Memory-Intensive ML Workloads</h4>
<p>Machine learning workloads place substantial demands on memory systems due to the large volume of data involved in computation. Unlike traditional compute-bound applications, where performance is often dictated by the speed of arithmetic operations, ML workloads are characterized by high data movement requirements. The efficiency of an accelerator is not solely determined by its computational throughput but also by its ability to continuously supply data to processing units without introducing stalls or delays.</p>
<p>A neural network processes multiple types of data throughout its execution, each with distinct memory access patterns:</p>
<ul>
<li>
<strong>Model parameters (weights and biases)</strong>: Machine learning models, particularly those used in large-scale applications such as natural language processing and computer vision, often contain millions to billions of parameters. Storing and accessing these weights efficiently is essential for maintaining throughput.</li>
<li>
<strong>Intermediate activations</strong>: During both training and inference, each layer produces intermediate results that must be temporarily stored and retrieved for subsequent operations. These activations can contribute significantly to memory overhead, particularly in deep architectures.</li>
<li>
<strong>Gradients (during training)</strong>: Backpropagation requires storing and accessing gradients for every parameter, further increasing the volume of data movement between compute units and memory.</li>
</ul>
<p>As models increase in size and complexity, improvements in memory capacity and bandwidth become essential. Although specialized compute units accelerate operations like matrix multiplications, their overall performance depends on the continuous, efficient delivery of data to the processing elements. In large-scale applications, such as natural language processing and computer vision, models often incorporate millions to billions of parameters <span class="citation" data-cites="Brown2020">(<a href="../references.html#ref-Brown2020" role="doc-biblioref">Brown et al. 2020</a>)</span>. Consequently, achieving high performance necessitates minimizing delays and stalls caused by inefficient data movement between memory and compute units <span class="citation" data-cites="Narayanan2021 Huang2019">(<a href="../references.html#ref-Narayanan2021" role="doc-biblioref">Narayanan et al. 2021</a>; <a href="../references.html#ref-Huang2019" role="doc-biblioref">Xingyu 2019</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Huang2019" class="csl-entry" role="listitem">
Xingyu, Huang et al. 2019. <span>“Addressing the Memory Bottleneck in AI Accelerators.”</span> <em>IEEE Micro</em>.
</div></div><p>One way to quantify this challenge is by comparing the data transfer time with the time required for computations. Specifically, we define the memory transfer time as <span class="math display">\[
T_{\text{mem}} = \frac{M_{\text{total}}}{B_{\text{mem}}},
\]</span> where <span class="math inline">\(M_{\text{total}}\)</span> is the total data volume and <span class="math inline">\(B_{\text{mem}}\)</span> is the available memory bandwidth. In contrast, the compute time is given by <span class="math display">\[
T_{\text{compute}} = \frac{\text{FLOPs}}{P_{\text{peak}}},
\]</span> with the number of floating-point operations (FLOPs) divided by the peak hardware throughput, <span class="math inline">\(P_{\text{peak}}\)</span>. When <span class="math inline">\(T_{\text{mem}} &gt; T_{\text{compute}}\)</span>, the system becomes memory-bound, meaning that the processing elements spend more time waiting for data than performing computations. This imbalance demonstrates the need for memory-optimized architectures and efficient data movement strategies to sustain high performance.</p>
<p><a href="#fig-memory-wall" class="quarto-xref">Figure&nbsp;<span>11.5</span></a> demonstrates the emerging challenge between model growth and hardware memory capabilities, illustrating the “AI Memory Wall.” The figure tracks AI model sizes (red dots) and hardware memory bandwidth (blue dots) over time on a log scale. Model parameters have grown exponentially, from AlexNet’s modest 60M parameters in 2012 to Gemini 1’s trillion-scale parameters in 2023, as shown by the steeper red trend line. In contrast, hardware memory bandwidth, represented by successive generations of NVIDIA GPUs (~100-200 GB/s) and Google TPUs (~2-3 TB/s), has increased more gradually (blue trend line). The expanding shaded region between these trends corresponds to the “AI Memory Wall,” which will be an architectural challenge where model scaling outpaces available memory bandwidth. This growing disparity necessitates increasingly sophisticated memory management and model optimization techniques to maintain computational efficiency.</p>
</section><section id="irregular-memory-access" class="level4"><h4 class="anchored" data-anchor-id="irregular-memory-access">Irregular Memory Access</h4>
<p>Unlike traditional computing workloads, where memory access follows well-structured and predictable patterns, machine learning models often exhibit irregular memory access behaviors that make efficient data retrieval a challenge. These irregularities arise due to the nature of ML computations, where memory access patterns are influenced by factors such as batch size, layer type, and sparsity. As a result, standard caching mechanisms and memory hierarchies often struggle to optimize performance, leading to increased memory latency and inefficient bandwidth utilization.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-memory-wall" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-memory-wall-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="hw_acceleration_files/figure-html/fig-memory-wall-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-4" title="Figure&nbsp;11.5: Model growth (in parameters) versus memory bandwidth (in GB/s)."><img src="hw_acceleration_files/figure-html/fig-memory-wall-1.png" class="img-fluid figure-img" width="672"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-memory-wall-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;11.5: Model growth (in parameters) versus memory bandwidth (in GB/s).
</figcaption></figure>
</div>
</div>
</div>
<p>To better understand how ML workloads differ from traditional computing workloads, it is useful to compare their respective memory access patterns (<a href="#tbl-traditional-vs-ml-mem" class="quarto-xref">Table&nbsp;<span>11.7</span></a>). Traditional workloads, such as scientific computing, general-purpose CPU applications, and database processing, typically exhibit well-defined memory access characteristics that benefit from standard caching and prefetching techniques. ML workloads, on the other hand, introduce highly dynamic access patterns that challenge conventional memory optimization strategies.</p>
<div id="tbl-traditional-vs-ml-mem" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-traditional-vs-ml-mem-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;11.7: Memory access patterns in traditional vs.&nbsp;ML workloads.
</figcaption><div aria-describedby="tbl-traditional-vs-ml-mem-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 43%">
<col style="width: 37%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Feature</th>
<th style="text-align: left;">Traditional Computing Workloads</th>
<th style="text-align: left;">Machine Learning Workloads</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Memory Access Pattern</td>
<td style="text-align: left;">Regular and predictable (e.g., sequential reads, structured patterns)</td>
<td style="text-align: left;">Irregular and dynamic (e.g., sparsity, attention mechanisms)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Cache Locality</td>
<td style="text-align: left;">High temporal and spatial locality</td>
<td style="text-align: left;">Often low locality, especially in large models</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Data Reuse</td>
<td style="text-align: left;">Structured loops with frequent data reuse</td>
<td style="text-align: left;">Sparse and dynamic reuse depending on layer type</td>
</tr>
<tr class="even">
<td style="text-align: left;">Data Dependencies</td>
<td style="text-align: left;">Well-defined dependencies allow efficient prefetching</td>
<td style="text-align: left;">Variable dependencies based on network structure</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Workload Example</td>
<td style="text-align: left;">Scientific computing (e.g., matrix factorizations, physics simulations)</td>
<td style="text-align: left;">Neural networks (e.g., CNNs, Transformers, sparse models)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Memory Bottleneck</td>
<td style="text-align: left;">DRAM latency, cache misses</td>
<td style="text-align: left;">Off-chip bandwidth constraints, memory fragmentation</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Impact on Energy Consumption</td>
<td style="text-align: left;">Moderate, driven by FLOP-heavy execution</td>
<td style="text-align: left;">High, dominated by data movement costs</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>One key source of irregularity in ML workloads stems from batch size and execution order. The way input data is processed in batches directly affects memory reuse, creating a complex optimization challenge. Small batch sizes decrease the likelihood of reusing cached activations and weights, resulting in frequent memory fetches from slower, off-chip memory. Larger batch sizes can improve reuse and amortize memory access costs, but simultaneously place higher demands on available memory bandwidth, potentially creating congestion at different memory hierarchy levels. This delicate balance requires careful consideration of model architecture and available hardware resources.</p>
<p>In addition to batch size, different neural network layers interact with memory in distinct ways. Convolutional layers benefit from spatial locality, as neighboring pixels in an image are processed together, allowing for efficient caching of small weight kernels. Conversely, fully connected layers require frequent access to large weight matrices, often leading to more randomized memory access patterns that poorly align with standard caching policies. Transformers introduce additional complexity, as attention mechanisms demand accessing large key-value pairs stored across varied memory locations. The dynamic nature of sequence length and attention span renders traditional prefetching strategies ineffective, resulting in unpredictable memory latencies.</p>
<p>Another significant factor contributing to irregular memory access is sparsity in neural networks. Many modern ML models employ techniques such as weight pruning, activation sparsity, and structured sparsity to reduce computational overhead. However, these optimizations often lead to non-uniform memory access, as sparse representations necessitate fetching scattered elements rather than sequential blocks, making hardware caching less effective. Furthermore, models that incorporate dynamic computation paths, such as Mixture of Experts and Adaptive Computation Time, introduce highly non-deterministic memory access patterns, where the active neurons or model components can vary with each inference step. This variability challenges efficient prefetching and caching strategies.</p>
<p>The consequences of these irregularities are significant. ML workloads often experience reduced cache efficiency, as activations and weights may not be accessed in predictable sequences. This leads to increased reliance on off-chip memory traffic, which not only slows down execution but also consumes more energy. Additionally, irregular access patterns contribute to memory fragmentation, where the way data is allocated and retrieved results in inefficient utilization of available memory resources. The combined effect of these factors is that ML accelerators frequently encounter memory bottlenecks that limit their ability to fully utilize available compute power.</p>
</section></section><section id="memory-hierarchy" class="level3 page-columns page-full" data-number="11.4.2"><h3 data-number="11.4.2" class="anchored" data-anchor-id="memory-hierarchy">
<span class="header-section-number">11.4.2</span> Memory Hierarchy</h3>
<p>To address the memory challenges in ML acceleration, hardware designers implement sophisticated memory hierarchies that balance speed, capacity, and energy efficiency. Understanding this hierarchy is essential before examining how different ML architectures utilize memory resources. Unlike general-purpose computing, where memory access patterns are often unpredictable, ML workloads exhibit structured reuse patterns that can be optimized through careful organization of data across multiple memory levels.</p>
<p>Unlike general-purpose computing, where memory access patterns are often unpredictable, machine learning workloads exhibit structured reuse patterns that can be optimized by carefully organizing data across multiple levels of memory. At the highest level, large-capacity but slow storage devices provide long-term model storage. At the lowest level, high-speed registers and caches ensure that compute units can access operands with minimal latency. Between these extremes, intermediate memory levels—including scratchpad memory, high-bandwidth memory (HBM), and off-chip DRAM—offer trade-offs between performance and capacity.</p>
<p><a href="#tbl-memory-heirarchy" class="quarto-xref">Table&nbsp;<span>11.8</span></a> summarizes the key characteristics of different memory levels in modern AI accelerators. Each level in the hierarchy has distinct latency, bandwidth, and capacity properties, which directly influence how neural network data, such as weights, activations, and intermediate results, should be allocated.</p>
<div id="tbl-memory-heirarchy" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-memory-heirarchy-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;11.8: Memory hierarchy characteristics and their impact on machine learning.
</figcaption><div aria-describedby="tbl-memory-heirarchy-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 21%">
<col style="width: 14%">
<col style="width: 10%">
<col style="width: 9%">
<col style="width: 43%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Memory Level</th>
<th style="text-align: left;">Approx. Latency</th>
<th style="text-align: left;">Bandwidth</th>
<th style="text-align: left;">Capacity</th>
<th style="text-align: left;">Example Use in Deep Learning</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Registers</td>
<td style="text-align: left;">~1 cycle</td>
<td style="text-align: left;">Highest</td>
<td style="text-align: left;">Few values</td>
<td style="text-align: left;">Storing operands for immediate computation</td>
</tr>
<tr class="even">
<td style="text-align: left;">L1/L2 Cache (SRAM)</td>
<td style="text-align: left;">~1-10 ns</td>
<td style="text-align: left;">High</td>
<td style="text-align: left;">KBs-MBs</td>
<td style="text-align: left;">Caching frequently accessed activations and small weight blocks</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Scratchpad Memory</td>
<td style="text-align: left;">~5-20 ns</td>
<td style="text-align: left;">High</td>
<td style="text-align: left;">MBs</td>
<td style="text-align: left;">Software-managed storage for intermediate computations</td>
</tr>
<tr class="even">
<td style="text-align: left;">High-Bandwidth Memory (HBM)</td>
<td style="text-align: left;">~100 ns</td>
<td style="text-align: left;">Very High</td>
<td style="text-align: left;">GBs</td>
<td style="text-align: left;">Storing large model parameters and activations for high-speed access</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Off-Chip DRAM (DDR, GDDR, LPDDR)</td>
<td style="text-align: left;">~50-150 ns</td>
<td style="text-align: left;">Moderate</td>
<td style="text-align: left;">GBs-TBs</td>
<td style="text-align: left;">Storing entire model weights that do not fit on-chip</td>
</tr>
<tr class="even">
<td style="text-align: left;">Flash Storage (SSD/NVMe)</td>
<td style="text-align: left;">~100 µs - 1 ms</td>
<td style="text-align: left;">Low</td>
<td style="text-align: left;">TBs</td>
<td style="text-align: left;">Storing pre-trained models and checkpoints for later loading</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<section id="on-chip-memory" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="on-chip-memory">On-Chip Memory</h4>
<p>Each level of the memory hierarchy serves a distinct role in AI acceleration, with different trade-offs in speed, capacity, and accessibility. Registers, located within compute cores, provide the fastest access but can only store a few operands at a time. These are best utilized for immediate computations, where the operands needed for an operation can be loaded and consumed within a few cycles. However, because register storage is so limited, frequent memory accesses are required to fetch new operands and store intermediate results.</p>
<p>To reduce the need for constant data movement between registers and external memory, small but fast caches serve as an intermediary buffer. These caches store recently accessed activations, weights, and intermediate values, ensuring that frequently used data remains available with minimal delay. However, the size of caches is limited, making them insufficient for storing full feature maps or large weight tensors in machine learning models. As a result, only the most frequently used portions of a model’s parameters or activations can reside here at any given time.</p>
<p>For larger working datasets, many AI accelerators include scratchpad memory, which offers more storage than caches but with a crucial difference: it allows explicit software control over what data is stored and when it is evicted. Unlike caches, which rely on hardware-based eviction policies, scratchpad memory enables machine learning workloads to retain key values such as activations and filter weights for multiple layers of computation. This capability is particularly useful in models like convolutional neural networks, where the same input feature maps and filter weights are reused across multiple operations. By keeping this data in scratchpad memory rather than reloading it from external memory, accelerators can significantly reduce unnecessary memory transfers and improve overall efficiency <span class="citation" data-cites="Chen2016">(<a href="../references.html#ref-Chen2016" role="doc-biblioref">Chen, Emer, and Sze 2017</a>)</span>.</p>
<div class="no-row-height column-margin column-container"></div></section><section id="off-chip-memory" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="off-chip-memory">Off-Chip Memory</h4>
<p>Beyond on-chip memory, high-bandwidth memory provides rapid access to larger model parameters and activations that do not fit within caches or scratchpad buffers. HBM achieves its high performance by stacking multiple memory dies and using wide memory interfaces, allowing it to transfer large amounts of data with minimal latency compared to traditional DRAM. Because of its high bandwidth and lower latency, HBM is often used to store entire layers of machine learning models that must be accessed quickly during execution. However, its cost and power consumption limit its use primarily to high-performance AI accelerators, making it less common in power-constrained environments such as edge devices.</p>
<p>When a machine learning model exceeds the capacity of on-chip memory and HBM, it must rely on off-chip DRAM, such as DDR, GDDR, or LPDDR. While DRAM offers significantly greater storage capacity, its access latency is higher, meaning that frequent retrievals from DRAM can introduce execution bottlenecks. To make effective use of DRAM, models must be structured so that only the necessary portions of weights and activations are retrieved at any given time, minimizing the impact of long memory fetch times.</p>
<p>At the highest level of the hierarchy, flash storage and solid-state drives (SSDs) store large pre-trained models, datasets, and checkpointed weights. These storage devices offer large capacities but are too slow for real-time execution, requiring models to be loaded into faster memory tiers before computation begins. For instance, in training scenarios, checkpointed models stored in SSDs must be loaded into DRAM or HBM before resuming computation, as direct execution from SSDs would be too slow to maintain efficient accelerator utilization <span class="citation" data-cites="Narayanan2021">(<a href="../references.html#ref-Narayanan2021" role="doc-biblioref">Narayanan et al. 2021</a>)</span>.</p>
<div class="no-row-height column-margin column-container"></div><p>The memory hierarchy balances competing objectives of speed, capacity, and energy efficiency. However, moving data through multiple memory levels introduces bottlenecks that limit accelerator performance. Data transfers between memory levels incur latency costs, particularly for off-chip accesses. Limited bandwidth restricts data flow between memory tiers. Memory capacity constraints force constant data movement as models exceed local storage.</p>
</section></section><section id="host-accelerator-communication" class="level3" data-number="11.4.3"><h3 data-number="11.4.3" class="anchored" data-anchor-id="host-accelerator-communication">
<span class="header-section-number">11.4.3</span> Host-Accelerator Communication</h3>
<p>Machine learning accelerators, such as GPUs and TPUs, achieve high computational throughput through parallel execution. However, their efficiency is fundamentally constrained by data movement between the host (CPU) and accelerator memory. Unlike general-purpose workloads that operate entirely within a CPU’s memory subsystem, AI workloads require frequent data transfers between CPU main memory and the accelerator, introducing latency, consuming bandwidth, and affecting overall performance.</p>
<p>Host-accelerator data movement follows a structured sequence, as illustrated in <a href="#fig-host-accelerator-data-movement" class="quarto-xref">Figure&nbsp;<span>11.6</span></a>. Before computation begins, data is copied from CPU memory to the accelerator’s memory. The CPU then issues execution instructions, and the accelerator processes the data in parallel. Once computation completes, the results are stored in accelerator memory and transferred back to the CPU. Each step introduces potential inefficiencies that must be managed to optimize performance.</p>
<div id="fig-host-accelerator-data-movement" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-host-accelerator-data-movement-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="sourceCode" id="cb20"><pre class="sourceCode tikz code-with-copy"><code class="sourceCode latex"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">\begin</span>{<span class="ex">tikzpicture</span>}[font=<span class="fu">\usefont</span>{T1}{phv}{m}{n}<span class="fu">\small</span>]</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="fu">\tikzset</span>{<span class="co">%</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    helvetica/.style={align=flush center,font=<span class="fu">\footnotesize\usefont</span>{T1}{phv}{m}{n}},</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    Line/.style={line width=1.0pt,black!50}</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="fu">\tikzset</span>{</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>  Box/.style={inner xsep=2pt,</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    draw=GreenLine,</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    line width=0.75pt,</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    node distance=1.0,</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    fill=GreenL!70,</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    align=flush center,</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    text width=26mm,</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    minimum width=26mm,</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    minimum height=10mm</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>  },</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a><span class="kw">\begin</span>{<span class="ex">scope</span>}</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box](B1){Main Memory};</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box,right=of B1](B2){CPU};</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box,right=of B2](B3){Memory for GPU};</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box,right=of B3](B4){GPU};</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a><span class="kw">\end</span>{<span class="ex">scope</span>}</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a><span class="co">%</span></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a><span class="kw">\begin</span>{<span class="ex">scope</span>}[shift={(0,-6)}]</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a><span class="fu">\colorlet</span>{GreenL}{OrangeL}</span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a><span class="fu">\colorlet</span>{GreenLine}{OrangeLine}</span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box](2B1){Main Memory};</span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box,right=of 2B1](2B2){CPU};</span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box,right=of 2B2](2B3){Memory for GPU};</span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box,right=of 2B3](2B4){GPU};</span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a><span class="co">%</span></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a><span class="kw">\end</span>{<span class="ex">scope</span>}</span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a><span class="co">%</span></span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\x</span> in {1,2,3,4} {</span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a> <span class="fu">\draw</span>[Line] (B<span class="fu">\x</span>) -- (2B<span class="fu">\x</span>);</span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true" tabindex="-1"></a><span class="co">%</span></span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](<span class="ss">$(B1)!0.2!(2B1)$</span>)--</span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true" tabindex="-1"></a>node[above,text=black,helvetica,pos=0.26]{Copy processing data (1)}</span>
<span id="cb20-43"><a href="#cb20-43" aria-hidden="true" tabindex="-1"></a>(<span class="ss">$(B3)!0.2!(2B3)$</span>);</span>
<span id="cb20-44"><a href="#cb20-44" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](<span class="ss">$(B2)!0.37!(2B2)$</span>)--</span>
<span id="cb20-45"><a href="#cb20-45" aria-hidden="true" tabindex="-1"></a>node[above,text=black,helvetica,pos=0.26]{Instruct the processing (2)}</span>
<span id="cb20-46"><a href="#cb20-46" aria-hidden="true" tabindex="-1"></a>(<span class="ss">$(B4)!0.37!(2B4)$</span>);</span>
<span id="cb20-47"><a href="#cb20-47" aria-hidden="true" tabindex="-1"></a><span class="co">%</span></span>
<span id="cb20-48"><a href="#cb20-48" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](<span class="ss">$(B4)!0.75!(2B4)$</span>)--</span>
<span id="cb20-49"><a href="#cb20-49" aria-hidden="true" tabindex="-1"></a>node[above,text=black,helvetica,pos=0.5]{Store results}</span>
<span id="cb20-50"><a href="#cb20-50" aria-hidden="true" tabindex="-1"></a>(<span class="ss">$(B3)!0.75!(2B3)$</span>);</span>
<span id="cb20-51"><a href="#cb20-51" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](<span class="ss">$(B3)!0.85!(2B3)$</span>)--</span>
<span id="cb20-52"><a href="#cb20-52" aria-hidden="true" tabindex="-1"></a>node[above,text=black,helvetica,pos=0.25]{Copy the result (4)}</span>
<span id="cb20-53"><a href="#cb20-53" aria-hidden="true" tabindex="-1"></a>(<span class="ss">$(B1)!0.85!(2B1)$</span>);</span>
<span id="cb20-54"><a href="#cb20-54" aria-hidden="true" tabindex="-1"></a><span class="co">%</span></span>
<span id="cb20-55"><a href="#cb20-55" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[Line,-latex](<span class="ss">$(B4)!0.57!(2B4)$</span>)</span>
<span id="cb20-56"><a href="#cb20-56" aria-hidden="true" tabindex="-1"></a>to [out=10,in=350,distance=42]</span>
<span id="cb20-57"><a href="#cb20-57" aria-hidden="true" tabindex="-1"></a>node[above,text=black,helvetica,pos=0.1,fill=white]{Execute parallel in each core (3)}</span>
<span id="cb20-58"><a href="#cb20-58" aria-hidden="true" tabindex="-1"></a>(<span class="ss">$(B4)!0.62!(2B4)$</span>);</span>
<span id="cb20-59"><a href="#cb20-59" aria-hidden="true" tabindex="-1"></a><span class="kw">\end</span>{<span class="ex">tikzpicture</span>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-host-accelerator-data-movement-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;11.6: Host-accelerator memory access interactions.
</figcaption></figure>
</div>
<p>The key challenges in host-accelerator data movement include latency, bandwidth constraints, and synchronization overheads. Optimizing data transfers through efficient memory management and interconnect technologies is essential for maximizing accelerator utilization.</p>
<section id="data-transfer-patterns" class="level4"><h4 class="anchored" data-anchor-id="data-transfer-patterns">Data Transfer Patterns</h4>
<p>The efficiency of ML accelerators depends not only on their computational power but also on the continuous supply of data. Even high-performance GPUs and TPUs remain underutilized if data transfers are inefficient. Host and accelerator memory exist as separate domains, requiring explicit transfers over interconnects such as PCIe, NVLink, or proprietary links. Ineffective data movement can cause execution stalls, making transfer optimization critical.</p>
<p><a href="#fig-host-accelerator-data-movement" class="quarto-xref">Figure&nbsp;<span>11.6</span></a> illustrates this structured sequence. In step (1), data is copied from CPU memory to accelerator memory, as GPUs cannot directly access host memory at high speeds. A direct memory access (DMA) engine typically handles this transfer without consuming CPU cycles. In step (2), the CPU issues execution commands via APIs like CUDA, ROCm, or OpenCL. Step (3) involves parallel execution on the accelerator, where stalls can occur if data is not available when needed. Finally, in step (4), computed results are copied back to CPU memory for further processing.</p>
<p>Latency and bandwidth limitations significantly impact AI workloads. PCIe, with a peak bandwidth of 32 GB/s (PCIe 4.0), is much slower than an accelerator’s high-bandwidth memory, which can exceed 1 TB/s. Large data transfers exacerbate bottlenecks, particularly in deep learning tasks. Additionally, synchronization overheads arise when computation must wait for data transfers to complete. Efficient scheduling and overlapping transfers with execution are essential to mitigate these inefficiencies.</p>
</section><section id="data-transfer-mechanisms" class="level4"><h4 class="anchored" data-anchor-id="data-transfer-mechanisms">Data Transfer Mechanisms</h4>
<p>The movement of data between the host (CPU) and the accelerator (GPU, TPU, or other AI hardware) depends on the interconnect technology that links the two processing units. The choice of interconnect determines the bandwidth available for transfers, the latency of communication, and the overall efficiency of host-accelerator execution. The most commonly used transfer mechanisms include PCIe (Peripheral Component Interconnect Express), NVLink, Direct Memory Access, and Unified Memory Architectures. Each of these plays a crucial role in optimizing the four-step data movement process illustrated in <a href="#fig-host-accelerator-data-movement" class="quarto-xref">Figure&nbsp;<span>11.6</span></a>.</p>
<section id="pcie-interface" class="level5"><h5 class="anchored" data-anchor-id="pcie-interface">PCIe Interface</h5>
<p>Most accelerators communicate with the CPU via PCIe, the industry-standard interconnect for data movement. PCIe 4.0 provides up to 32 GB/s bandwidth, while PCIe 5.0 doubles this to 64 GB/s. However, this is still significantly lower than HBM bandwidth within accelerators, making PCIe a bottleneck for large AI workloads.</p>
<p>PCIe also introduces latency overheads due to its packet-based communication and memory-mapped I/O model. Frequent small transfers are inefficient, so batching data movement reduces overhead. Computation commands, issued over PCIe, further contribute to latency, requiring careful optimization of execution scheduling.</p>
</section><section id="nvlink-interface" class="level5"><h5 class="anchored" data-anchor-id="nvlink-interface">NVLink Interface</h5>
<p>To address the bandwidth limitations of PCIe, NVIDIA developed NVLink, a proprietary high-speed interconnect that provides significantly higher bandwidth between GPUs and, in some configurations, between the CPU and GPU. Unlike PCIe, which operates as a shared bus, NVLink enables direct point-to-point communication between connected devices, reducing contention and improving efficiency for AI workloads.</p>
<p>For host-accelerator transfers, NVLink can be used in step (1) to transfer input data from main memory to GPU memory at speeds far exceeding PCIe, with bandwidths reaching up to 600 GB/s in NVLink 4.0. This significantly reduces the data movement bottleneck, allowing accelerators to access input data with lower latency. In multi-GPU configurations, NVLink also accelerates peer-to-peer transfers, allowing accelerators to exchange data without routing through main memory, thereby optimizing step (3) of the computation process.</p>
<p>Although NVLink offers substantial performance benefits, it is not universally available. Unlike PCIe, which is an industry standard across all accelerators, NVLink is specific to NVIDIA hardware, limiting its applicability to systems designed with NVLink-enabled GPUs.</p>
</section><section id="dma-for-data-transfers" class="level5"><h5 class="anchored" data-anchor-id="dma-for-data-transfers">DMA for Data Transfers</h5>
<p>In conventional memory transfers, the CPU issues load/store instructions, consuming processing cycles. DMA offloads this task, enabling asynchronous data movement without CPU intervention.</p>
<p>During data transfers, the CPU initiates a DMA request, allowing data to be copied to accelerator memory in the background. Similarly, result transfers back to main memory occur without blocking execution. This enables overlapping computation with data movement, reducing idle time and improving accelerator utilization.</p>
<p>DMA is essential for enabling asynchronous data movement, which allows transfers to overlap with computation. Instead of waiting for transfers to complete before execution begins, AI workloads can stream data into the accelerator while earlier computations are still in progress, reducing idle time and improving accelerator utilization.</p>
</section><section id="unified-memory" class="level5"><h5 class="anchored" data-anchor-id="unified-memory">Unified Memory</h5>
<p>While PCIe, NVLink, and DMA optimize explicit memory transfers, some AI workloads require a more flexible memory model that eliminates the need for manual data copying. Unified Memory provides an abstraction that allows both the host and accelerator to access a single, shared memory space, automatically handling data movement when needed.</p>
<p>With Unified Memory, data does not need to be explicitly copied between CPU and GPU memory before execution. Instead, when a computation requires a memory region that is currently located in host memory, the system automatically migrates it to the accelerator, handling step (1) transparently. Similarly, when computed results are accessed by the CPU, step (4) occurs automatically, eliminating the need for manual memory management.</p>
<p>Although Unified Memory simplifies programming, it introduces performance trade-offs. Since memory migrations occur on demand, they can lead to unpredictable latencies, particularly if large datasets need to be transferred frequently. Additionally, since Unified Memory is implemented through page migration techniques, small memory accesses can trigger excessive data movement, further reducing efficiency.</p>
<p>For AI workloads that require fine-grained memory control, explicit data transfers using PCIe, NVLink, and DMA often provide better performance. However, for applications where ease of development is more important than absolute speed, Unified Memory offers a convenient alternative.</p>
</section></section><section id="data-transfer-overheads" class="level4"><h4 class="anchored" data-anchor-id="data-transfer-overheads">Data Transfer Overheads</h4>
<p>Host-accelerator data movement introduces overheads that impact AI workload execution. Unlike on-chip memory accesses, which occur at nanosecond latencies, host-accelerator transfers traverse system interconnects, adding latency, bandwidth constraints, and synchronization delays.</p>
<p>Interconnect latency affects transfer speed, with PCIe, the standard host-accelerator link, incurring significant overhead due to packet-based transactions and memory-mapped I/O. This makes frequent small transfers inefficient. Faster alternatives like NVLink reduce latency and improve bandwidth but are limited to specific hardware ecosystems.</p>
<p>Synchronization delays further contribute to inefficiencies. Synchronous transfers block execution until data movement completes, ensuring data consistency but introducing idle time. Asynchronous transfers allow computation and data movement to overlap, reducing stalls but requiring careful coordination to avoid execution mismatches.</p>
<p>These factors—interconnect latency, bandwidth limitations, and synchronization overheads—determine AI workload efficiency. While optimization techniques mitigate these limitations, understanding these fundamental transfer mechanics is essential for improving performance.</p>
</section></section><section id="model-memory-pressure" class="level3 page-columns page-full" data-number="11.4.4"><h3 data-number="11.4.4" class="anchored" data-anchor-id="model-memory-pressure">
<span class="header-section-number">11.4.4</span> Model Memory Pressure</h3>
<p>Machine learning models impose varying memory access patterns that significantly influence accelerator performance. The way data is transferred between the host and accelerator, how frequently memory is accessed, and the efficiency of caching mechanisms all determine overall execution efficiency. While multilayer perceptrons (MLPs), convolutional neural networks (CNNs), and transformer networks each require large parameter sets, their distinct memory demands necessitate tailored optimization strategies for accelerators. Understanding these differences provides insight into why different hardware architectures exhibit varying levels of efficiency across workloads.</p>
<section id="multilayer-perceptrons" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="multilayer-perceptrons">Multilayer Perceptrons</h4>
<p>MLPs, also referred to as fully connected networks, are among the simplest neural architectures. Each layer consists of a dense matrix multiplication, requiring every neuron to interact with all neurons in the preceding layer. This results in high memory bandwidth demands, particularly for weights, as every input activation contributes to a large set of computations.</p>
<p>From a memory perspective, MLPs rely on large, dense weight matrices that frequently exceed on-chip memory capacity, necessitating off-chip memory accesses. Since accelerators cannot directly access host memory at high speed, data transfers must be explicitly managed via interconnects such as PCIe or NVLink. These transfers introduce latency and consume bandwidth, affecting execution efficiency.</p>
<p>Despite their bandwidth-heavy nature, MLPs exhibit regular and predictable memory access patterns, making them amenable to optimizations such as prefetching and streaming memory accesses. Dedicated AI accelerators mitigate transfer overhead by staging weight matrices in fast SRAM caches and overlapping data movement with computation through direct memory access engines, reducing execution stalls. These optimizations allow accelerators to sustain high throughput even when handling large parameter sets <span class="citation" data-cites="Chen2016">(<a href="../references.html#ref-Chen2016" role="doc-biblioref">Chen, Emer, and Sze 2017</a>)</span>.</p>
<div class="no-row-height column-margin column-container"></div></section><section id="convolutional-neural-networks" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="convolutional-neural-networks">Convolutional Neural Networks</h4>
<p>Convolutional Neural Networks (CNNs) are widely used in image processing and computer vision tasks. Unlike MLPs, which require dense matrix multiplications, CNNs process input feature maps using small filter kernels that slide across the image. This localized computation structure results in high spatial data reuse, where the same input pixels contribute to multiple convolutions.</p>
<p>CNN accelerators benefit from on-chip memory optimizations, as convolution filters exhibit extensive reuse, allowing weights to be stored in fast local SRAM instead of frequently accessing off-chip memory. However, activation maps require careful management due to their size. Since accessing main memory over interconnects like PCIe introduces latency and bandwidth bottlenecks, CNN accelerators employ tiling techniques to divide feature maps into smaller regions that fit within on-chip buffers. This minimizes costly external memory transfers, improving overall efficiency <span class="citation" data-cites="Chen2016">(<a href="../references.html#ref-Chen2016" role="doc-biblioref">Chen, Emer, and Sze 2017</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Chen2016" class="csl-entry" role="listitem">
Chen, Yu-Hsin, Joel Emer, and Vivienne Sze. 2017. <span>“Eyeriss: A Spatial Architecture for Energy-Efficient Dataflow for Convolutional Neural Networks.”</span> <em>IEEE Micro</em>, 1–1. <a href="https://doi.org/10.1109/mm.2017.265085944">https://doi.org/10.1109/mm.2017.265085944</a>.
</div></div><p>While CNN workloads are more memory-efficient than MLPs, managing intermediate activations remains a challenge. Accelerators use hierarchical caching strategies and DMA engines to optimize memory movement, ensuring that computations are not stalled by inefficient host-accelerator data transfers. These memory optimizations help CNN accelerators maintain high throughput by reducing reliance on off-chip memory bandwidth <span class="citation" data-cites="Chen2016">(<a href="../references.html#ref-Chen2016" role="doc-biblioref">Chen, Emer, and Sze 2017</a>)</span>.</p>
</section><section id="transformer-networks" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="transformer-networks">Transformer Networks</h4>
<p>Transformers have become the dominant architecture for natural language processing and are increasingly used in other domains such as vision and speech recognition. Unlike CNNs, which rely on local computations, transformers perform global attention mechanisms, where each token in an input sequence can interact with all other tokens. This leads to irregular and bandwidth-intensive memory access patterns, as large key-value matrices must be fetched and updated frequently.</p>
<p>These models are particularly challenging for accelerators due to their massive parameter sizes, which often exceed on-chip memory capacity. As a result, frequent memory transfers between host and accelerator introduce substantial latency overheads, particularly when relying on interconnects such as PCIe. Unified Memory architectures can mitigate some of these issues by dynamically handling data movement, but they introduce additional latency due to unpredictable on-demand memory migrations. Because transformers are memory-bound rather than compute-bound, accelerators optimized for them rely on high-bandwidth memory, tensor tiling, and memory partitioning to sustain performance <span class="citation" data-cites="Brown2020">(<a href="../references.html#ref-Brown2020" role="doc-biblioref">Brown et al. 2020</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Brown2020" class="csl-entry" role="listitem">
Brown, Tom B., Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhariwal, Arvind Neelakantan, et al. 2020. <span>“Language Models Are Few-Shot Learners.”</span> <em>NeurIPS</em>, May. <a href="http://arxiv.org/abs/2005.14165v4">http://arxiv.org/abs/2005.14165v4</a>.
</div><div id="ref-Narayanan2021" class="csl-entry" role="listitem">
Narayanan, Deepak, Mohammad Shoeybi, Jared Casper, Patrick LeGresley, Mostofa Patwary, Vijay Anand Korthikanti, Dmitri Vainbrand, et al. 2021. <span>“Efficient Large-Scale Language Model Training on GPU Clusters Using Megatron-LM.”</span> <em>NeurIPS</em>, April. <a href="http://arxiv.org/abs/2104.04473v5">http://arxiv.org/abs/2104.04473v5</a>.
</div></div><p>Additionally, attention caching mechanisms and specialized tensor layouts reduce redundant memory fetches, improving execution efficiency. Given the bandwidth limitations of traditional interconnects, NVLink-enabled architectures offer significant advantages for large-scale transformer training, as they provide higher throughput and lower latency compared to PCIe. Furthermore, DMA-based asynchronous memory transfers enable overlapping computation with data movement, reducing execution stalls <span class="citation" data-cites="Narayanan2021">(<a href="../references.html#ref-Narayanan2021" role="doc-biblioref">Narayanan et al. 2021</a>)</span>.</p>
</section></section><section id="ml-accelerators-implications" class="level3" data-number="11.4.5"><h3 data-number="11.4.5" class="anchored" data-anchor-id="ml-accelerators-implications">
<span class="header-section-number">11.4.5</span> ML Accelerators Implications</h3>
<p>The diverse memory requirements of MLPs, CNNs, and Transformers highlight the need to tailor memory architectures to specific workloads. <a href="#tbl-model-mem-compare" class="quarto-xref">Table&nbsp;<span>11.9</span></a> compares the memory access patterns across these different models.</p>
<div id="tbl-model-mem-compare" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-model-mem-compare-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;11.9: Memory access characteristics across different ML models.
</figcaption><div aria-describedby="tbl-model-mem-compare-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 11%">
<col style="width: 15%">
<col style="width: 15%">
<col style="width: 27%">
<col style="width: 26%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Model Type</th>
<th style="text-align: left;">Weight Size</th>
<th style="text-align: left;">Activation Reuse</th>
<th style="text-align: left;">Memory Access Pattern</th>
<th style="text-align: left;">Primary Bottleneck</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">MLP (Dense)</td>
<td style="text-align: left;">Large, dense</td>
<td style="text-align: left;">Low</td>
<td style="text-align: left;">Regular, sequential (streamed)</td>
<td style="text-align: left;">Bandwidth (off-chip)</td>
</tr>
<tr class="even">
<td style="text-align: left;">CNN</td>
<td style="text-align: left;">Small, reused</td>
<td style="text-align: left;">High</td>
<td style="text-align: left;">Spatial locality</td>
<td style="text-align: left;">Feature map movement</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Transformer</td>
<td style="text-align: left;">Massive, sparse</td>
<td style="text-align: left;">Low</td>
<td style="text-align: left;">Irregular, high-bandwidth</td>
<td style="text-align: left;">Memory capacity + Interconnect</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Each model type presents unique challenges that directly impact accelerator design. MLPs benefit from fast streaming access to dense weight matrices, making memory bandwidth a critical factor in performance, especially when transferring large weights from host memory to accelerator memory. CNNs, with their high activation reuse and structured memory access patterns, can leverage on-chip caching and tiling strategies to minimize off-chip memory transfers. Transformers, however, impose significant demands on both bandwidth and capacity, as attention mechanisms require frequent access to large key-value matrices, leading to high interconnect traffic and increased memory pressure.</p>
<p>To address these challenges, modern AI accelerators incorporate multi-tier memory hierarchies that balance speed, capacity, and energy efficiency. On-chip SRAM caches and scratchpad memories store frequently accessed data, while high-bandwidth external memory provides scalability for large models. Efficient interconnects, such as NVLink, help alleviate host-accelerator transfer bottlenecks, particularly in transformer workloads where memory movement constraints can dominate execution time.</p>
<p>As ML workloads continue to grow in complexity, memory efficiency is becoming as critical as raw compute power. Efficient data movement strategies, asynchronous memory transfers (DMA), and unified memory architectures play a fundamental role in sustaining high performance. The following section explores the design of memory hierarchies in AI accelerators, detailing how different levels of memory interact to optimize execution efficiency.</p>
</section></section><section id="neural-networks-mapping" class="level2 page-columns page-full" data-number="11.5"><h2 data-number="11.5" class="anchored" data-anchor-id="neural-networks-mapping">
<span class="header-section-number">11.5</span> Neural Networks Mapping</h2>
<p>Efficient execution of machine learning models on specialized AI acceleration hardware requires a structured approach to computation, ensuring that available resources are fully utilized while minimizing performance bottlenecks. Unlike general-purpose processors, which rely on dynamic task scheduling, AI accelerators operate under a structured execution model that maximizes throughput by carefully assigning computations to processing elements. This process, known as mapping, dictates how computations are distributed across hardware resources, influencing execution speed, memory access patterns, and overall efficiency.</p>
<div class="callout callout-style-default callout-note callout-titled" title="Definition of Mapping in AI Acceleration">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition of Mapping in AI Acceleration
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Mapping in AI Acceleration</strong> refers to the <em>assignment of machine learning computations</em> to <em>hardware processing units</em> to optimize <em>execution efficiency</em>. This process involves <em>spatial allocation</em>, which distributes computations across <em>processing elements</em>; <em>temporal scheduling</em>, which sequences operations to maintain <em>balanced workloads</em>; and <em>memory-aware execution</em>, which strategically places <em>data</em> to minimize <em>access latency</em>. Effective mapping ensures <em>high resource utilization, reduced memory stalls, and energy-efficient execution</em>, making it a critical factor in <em>AI acceleration</em>.</p>
</div>
</div>
<p>Mapping machine learning models onto AI accelerators presents several challenges due to hardware constraints and the diversity of model architectures. Given the hierarchical memory system of modern accelerators, mapping strategies must carefully manage when and where data is accessed to minimize latency and power overhead while ensuring that compute units remain actively engaged. Poor mapping decisions can lead to underutilized compute resources, excessive data movement, and increased execution time, ultimately reducing overall efficiency.</p>
<p>Mapping encompasses three interrelated aspects that form the foundation of effective AI accelerator design.</p>
<ul>
<li>
<strong>Computation Placement</strong>: Systematically assigns operations (e.g., matrix multiplications, convolutions) to processing elements to maximize parallelism and reduce idle time.</li>
<li>
<strong>Memory Allocation</strong>: Carefully determines where model parameters, activations, and intermediate results reside within the memory hierarchy to optimize access efficiency.</li>
<li>
<strong>Dataflow and Execution Scheduling</strong>: Structures the movement of data between compute units to reduce bandwidth bottlenecks and ensure smooth, continuous execution.</li>
</ul>
<p>Effective mapping strategies minimize off-chip memory accesses, maximize compute utilization, and efficiently manage data movement across different levels of the memory hierarchy. The following sections explore the key mapping choices that influence execution efficiency and lay the groundwork for optimization strategies that refine these decisions.</p>
<section id="computation-placement" class="level3 page-columns page-full" data-number="11.5.1"><h3 data-number="11.5.1" class="anchored" data-anchor-id="computation-placement">
<span class="header-section-number">11.5.1</span> Computation Placement</h3>
<p>Modern AI accelerators are designed to execute machine learning models with massive parallelism, leveraging thousands to millions of processing elements to perform computations simultaneously. However, simply having a large number of compute units is not enough—how computations are assigned to these units determines overall efficiency.</p>
<p>Without careful placement, some processing elements may sit idle while others are overloaded, leading to wasted resources, increased memory traffic, and reduced performance. Computation placement is the process of strategically mapping operations onto available hardware resources to sustain high throughput, minimize stalls, and optimize execution efficiency.</p>
<section id="computation-placement-definition" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="computation-placement-definition">Computation Placement Definition</h4>
<p>AI accelerators contain thousands to millions of processing elements, making computation placement a large-scale problem. Modern GPUs, such as the NVIDIA H100, feature over 16,000 CUDA cores and more than 500 specialized tensor cores, each designed to accelerate matrix operations <span class="citation" data-cites="Jouppi2017">(<a href="../references.html#ref-Jouppi2017" role="doc-biblioref">Jouppi, Young, et al. 2017</a>)</span>. TPUs utilize systolic arrays composed of thousands of interconnected multiply-accumulate (MAC) units, while wafer-scale processors like Cerebras’ CS-2 push parallelism even further, integrating over 850,000 cores on a single chip <span class="citation" data-cites="Cerebras2021">(<a href="../references.html#ref-Cerebras2021" role="doc-biblioref">Systems 2021b</a>)</span>. In these architectures, even minor inefficiencies in computation placement can lead to significant performance losses, as idle cores or excessive memory movement compound across the system.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Jouppi2017" class="csl-entry" role="listitem">
Jouppi, Norman P., Cliff Young, Nishant Patil, David Patterson, Gaurav Agrawal, Raminder Bajwa, Sarah Bates, et al. 2017. <span>“In-Datacenter Performance Analysis of a Tensor Processing Unit.”</span> In <em>Proceedings of the 44th Annual International Symposium on Computer Architecture</em>, 1–12. ACM. <a href="https://doi.org/10.1145/3079856.3080246">https://doi.org/10.1145/3079856.3080246</a>.
</div><div id="ref-Cerebras2021" class="csl-entry" role="listitem">
———. 2021b. <span>“Wafer-Scale Deep Learning Acceleration with the Cerebras CS-2.”</span> <em>Cerebras Technical Paper</em>.
</div></div><p>Computation placement ensures that all processing elements contribute effectively to execution. This means that workloads must be distributed in a way that avoids imbalanced execution, where some processing elements sit idle while others remain overloaded. Similarly, placement must minimize unnecessary data movement, as excessive memory transfers introduce latency and power overheads that degrade system performance.</p>
<p>Neural network computations vary significantly based on the model architecture, influencing how placement strategies are applied. For example, in a convolutional neural network (CNN), placement focuses on dividing image regions across processing elements to maximize parallelism. A <span class="math inline">\(256\times256\)</span> image processed through thousands of GPU cores might be broken into small tiles, each mapped to a different processing unit to execute convolutional operations simultaneously. In contrast, a transformer-based model requires placement strategies that accommodate self-attention mechanisms, where each token in a sequence interacts with all others, leading to irregular and memory-intensive computation patterns. Meanwhile, Graph Neural Networks (GNNs) introduce additional complexity, as computations depend on sparse and dynamic graph structures that require adaptive workload distribution <span class="citation" data-cites="Zheng2020">(<a href="../references.html#ref-Zheng2020" role="doc-biblioref">Zheng et al. 2020</a>)</span>.</p>
<div class="no-row-height column-margin column-container"></div><p>Because computation placement directly impacts resource utilization, execution speed, and power efficiency, it is one of the most critical factors in AI acceleration. A well-placed computation can reduce latency by orders of magnitude, while a poorly placed one can render thousands of processing units underutilized. The next section explores why efficient computation placement is essential and the consequences of suboptimal mapping strategies.</p>
</section><section id="computation-placement-importance" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="computation-placement-importance">Computation Placement Importance</h4>
<p>While computation placement is a hardware-driven process, its importance is fundamentally shaped by the structure of neural network workloads. Different types of machine learning models exhibit distinct computation patterns, which directly influence how efficiently they can be mapped onto accelerators. Without careful placement, workloads can become unbalanced, memory access patterns can become inefficient, and the overall performance of the system can degrade significantly.</p>
<p>For models with structured computation patterns, such as CNNs, computation placement is relatively straightforward. CNNs process images using filters that are applied to small, localized regions, meaning their computations can be evenly distributed across processing elements. Because these operations are highly parallelizable, CNNs benefit from spatial partitioning, where the input is divided into tiles that are processed independently. This structured execution makes CNNs well-suited for accelerators that favor regular dataflows, minimizing the complexity of placement decisions.</p>
<p>However, for models with irregular computation patterns, such as transformers and GNNs, computation placement becomes significantly more challenging. Transformers, which rely on self-attention mechanisms, require each token in a sequence to interact with all others, resulting in non-uniform computation demands. Unlike CNNs, where each processing element performs a similar amount of work, transformers introduce workload imbalance, where certain operations—such as computing attention scores—require far more computation than others. Without careful placement, this imbalance can lead to stalls, where some processing elements remain idle while others struggle to keep up.</p>
<p>The challenge is even greater in graph neural networks (GNNs), where computation depends on sparse and dynamically changing graph structures. Unlike CNNs, which operate on dense and regularly structured data, GNNs must process nodes and edges with highly variable degrees of connectivity. Some regions of a graph may require significantly more computation than others, making workload balancing across processing elements difficult <span class="citation" data-cites="Zheng2020">(<a href="../references.html#ref-Zheng2020" role="doc-biblioref">Zheng et al. 2020</a>)</span>. If computations are not placed strategically, some compute units will sit idle while others remain overloaded, leading to underutilization and inefficiencies in execution.</p>
<div class="no-row-height column-margin column-container"></div><p>Poor computation placement adversely affects AI execution by creating workload imbalance, inducing excessive data movement, and causing execution stalls and bottlenecks. Specifically, an uneven distribution of computations can lead to idle processing elements, thereby preventing full hardware utilization and diminishing throughput. In addition, inefficient execution assignment increases memory traffic by necessitating frequent data transfers between memory hierarchies, which in turn introduces latency and raises power consumption. Finally, such misallocation can cause operations to wait on data dependencies, resulting in pipeline inefficiencies that ultimately lower overall system performance.</p>
<p>Ultimately, computation placement is not just about assigning operations to processing elements—it is about ensuring that models execute efficiently given their unique computational structure. A well-placed workload reduces execution time, memory overhead, and power consumption, while a poorly placed one can lead to stalled execution pipelines and inefficient resource utilization. The next section explores the key considerations that must be addressed to ensure that computation placement is both efficient and adaptable to different model architectures.</p>
</section><section id="effective-computation-placement" class="level4"><h4 class="anchored" data-anchor-id="effective-computation-placement">Effective Computation Placement</h4>
<p>Computation placement is a balancing act between hardware constraints and workload characteristics. To achieve high efficiency, placement strategies must account for parallelism, memory access, and workload variability while ensuring that processing elements remain fully utilized. Poor placement leads to imbalanced execution, increased data movement, and performance degradation, making it essential to consider key factors when designing placement strategies.</p>
<p>As summarized in <a href="#tbl-placement-challenges" class="quarto-xref">Table&nbsp;<span>11.10</span></a>, computation placement faces several critical challenges that impact execution efficiency. Effective mapping strategies must address these challenges by balancing workload distribution, minimizing data movement, and optimizing communication across processing elements.</p>
<div id="tbl-placement-challenges" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-placement-challenges-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;11.10: Primary challenges in computation placement and key considerations for effective mapping strategies.
</figcaption><div aria-describedby="tbl-placement-challenges-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 13%">
<col style="width: 47%">
<col style="width: 38%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Challenge</th>
<th style="text-align: left;">Impact on Execution</th>
<th style="text-align: left;">Key Considerations for Placement</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Workload Imbalance</td>
<td style="text-align: left;">Some processing elements finish early while others remain overloaded, leading to idle compute resources.</td>
<td style="text-align: left;">Distribute operations evenly to prevent stalls and ensure full utilization of PEs.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Irregular Computation Patterns</td>
<td style="text-align: left;">Models like transformers and GNNs introduce non-uniform computation demands, making static placement difficult.</td>
<td style="text-align: left;">Use adaptive placement strategies that adjust execution based on workload characteristics.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Excessive Data Movement</td>
<td style="text-align: left;">Frequent memory transfers introduce latency and increase power consumption.</td>
<td style="text-align: left;">Keep frequently used data close to the compute units and minimize off-chip memory accesses.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Limited Interconnect Bandwidth</td>
<td style="text-align: left;">Poorly placed operations can create congestion, slowing data movement between PEs.</td>
<td style="text-align: left;">Optimize spatial and temporal placement to reduce communication overhead.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Model-Specific Execution Needs</td>
<td style="text-align: left;">CNNs, transformers, and GNNs require different execution patterns, making a single placement strategy ineffective.</td>
<td style="text-align: left;">Tailor placement strategies to match the computational structure of each model type.</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Each of these challenges highlights a core trade-off in computation placement: maximizing parallelism while minimizing memory overhead. For CNNs, placement strategies prioritize structured tiling to maintain efficient data reuse. For transformers, placement must ensure balanced execution across attention layers. For GNNs, placement must dynamically adjust to sparse computation patterns.</p>
<p>Beyond model-specific needs, effective computation placement must also be scalable. As models grow in size and complexity, placement strategies must adapt dynamically rather than relying on static execution patterns. Future AI accelerators increasingly integrate runtime-aware scheduling mechanisms, where placement is optimized based on real-time workload behavior rather than predetermined execution plans.</p>
<p>Ultimately, effective computation placement requires a holistic approach that balances hardware capabilities with model characteristics. The next section explores how computation placement interacts with memory allocation and data movement, ensuring that AI accelerators operate at peak efficiency.</p>
</section></section><section id="memory-allocation" class="level3" data-number="11.5.2"><h3 data-number="11.5.2" class="anchored" data-anchor-id="memory-allocation">
<span class="header-section-number">11.5.2</span> Memory Allocation</h3>
<p>Efficient memory allocation is a key requirement for high-performance AI acceleration. As AI models grow in complexity, accelerators must manage vast amounts of data movement—loading model parameters, storing intermediate activations, and handling gradient computations. The way this data is allocated across the memory hierarchy directly affects execution efficiency, power consumption, and overall system throughput.</p>
<section id="memory-allocation-definition" class="level4"><h4 class="anchored" data-anchor-id="memory-allocation-definition">Memory Allocation Definition</h4>
<p>While computation placement determines where operations are executed, memory allocation defines where data is stored and how it is accessed throughout execution. As discussed earlier, all AI accelerators rely on hierarchical memory systems, ranging from on-chip caches and scratchpads to HBM and DRAM. Poor memory allocation can lead to excessive off-chip memory accesses, increasing bandwidth contention and slowing down execution. Since AI accelerators operate at teraflop and petaflop scales, inefficient memory access patterns can result in substantial performance bottlenecks.</p>
<p>The primary goal of memory allocation is to minimize latency and reduce power consumption by keeping frequently accessed data as close as possible to the processing elements. Different hardware architectures implement memory hierarchies tailored for AI workloads. GPUs rely on a mix of global memory, shared memory, and registers, requiring careful tiling strategies to optimize locality. TPUs use on-chip SRAM scratchpads, where activations and weights must be efficiently preloaded to sustain systolic array execution. Wafer-scale processors, with their hundreds of thousands of cores, demand sophisticated memory partitioning strategies to avoid excessive interconnect traffic. In all cases, the effectiveness of memory allocation determines the overall throughput, power efficiency, and scalability of AI execution.</p>
</section><section id="memory-allocation-importance" class="level4"><h4 class="anchored" data-anchor-id="memory-allocation-importance">Memory Allocation Importance</h4>
<p>Memory allocation is important in AI acceleration because how and where data is stored directly impacts execution efficiency. Unlike general-purpose computing, where memory management is abstracted by caches and dynamic allocation, AI accelerators require explicit data placement strategies to sustain high throughput and avoid unnecessary stalls. When memory is not allocated efficiently, AI workloads suffer from latency overhead, excessive power consumption, and bottlenecks that limit computational performance.</p>
<p>Neural network architectures have varying memory demands, which influence the importance of proper allocation. CNNs rely on structured and localized data access patterns, meaning that inefficient memory allocation can lead to redundant data loads and cache inefficiencies. In contrast, transformer models require frequent access to large model parameters and intermediate activations, making them highly sensitive to memory bandwidth constraints. GNNs introduce even greater challenges, as their irregular and sparse data structures result in unpredictable memory access patterns that can lead to inefficient use of memory resources. Poor memory allocation has three major consequences for AI execution:</p>
<ol type="1">
<li>
<strong>Increased Memory Latency</strong>: When frequently accessed data is not stored in the right location, accelerators must retrieve it from higher-latency memory, slowing down execution.</li>
<li>
<strong>Higher Power Consumption</strong>: Off-chip memory accesses consume significantly more energy than on-chip storage, leading to inefficiencies at scale.</li>
<li>
<strong>Reduced Computational Throughput</strong>: If data is not available when needed, processing elements remain idle, reducing the overall performance of the system.</li>
</ol>
<p>As AI models continue to grow in size and complexity, the importance of scalable and efficient memory allocation increases. Memory limitations can dictate how large of a model can be deployed on a given accelerator, affecting feasibility and performance. The next section explores the key considerations that impact memory allocation strategies and the constraints that must be addressed to optimize execution efficiency.</p>
</section><section id="effective-memory-allocation" class="level4"><h4 class="anchored" data-anchor-id="effective-memory-allocation">Effective Memory Allocation</h4>
<p>Inefficient allocation leads to frequent stalls, excessive memory traffic, and power inefficiencies, all of which degrade overall performance. As summarized in <a href="#tbl-memory-allocation" class="quarto-xref">Table&nbsp;<span>11.11</span></a>, memory allocation in AI accelerators must address several key challenges that influence execution efficiency. Effective allocation strategies mitigate high latency, bandwidth limitations, and irregular access patterns by carefully managing data placement and movement. Ensuring that frequently accessed data is stored in faster memory locations while minimizing unnecessary transfers is essential for maintaining performance and energy efficiency.</p>
<p>Each of these challenges requires careful memory management to balance execution efficiency with hardware constraints. While structured models may benefit from well-defined memory layouts that facilitate predictable access, others, like transformer-based and graph-based models, require more adaptive allocation strategies to handle variable and complex memory demands.</p>
<div id="tbl-memory-allocation" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-memory-allocation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;11.11: Key challenges in memory allocation and considerations for efficient execution.
</figcaption><div aria-describedby="tbl-memory-allocation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 39%">
<col style="width: 44%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Challenge</th>
<th style="text-align: left;">Impact on Execution</th>
<th style="text-align: left;">Key Considerations for Allocation</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">High Memory Latency</td>
<td style="text-align: left;">Slow data access delays execution and reduces throughput.</td>
<td style="text-align: left;">Prioritize placing frequently accessed data in faster memory locations.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Limited On-Chip Storage</td>
<td style="text-align: left;">Small local memory constrains the amount of data available near compute units.</td>
<td style="text-align: left;">Allocate storage efficiently to maximize data availability without exceeding hardware limits.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">High Off-Chip Bandwidth Demand</td>
<td style="text-align: left;">Frequent access to external memory increases delays and power consumption.</td>
<td style="text-align: left;">Reduce unnecessary memory transfers by carefully managing when and how data is moved.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Irregular Memory Access Patterns</td>
<td style="text-align: left;">Some models require accessing data unpredictably, leading to inefficient memory usage.</td>
<td style="text-align: left;">Organize memory layout to align with access patterns and minimize unnecessary data movement.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Model-Specific Memory Needs</td>
<td style="text-align: left;">Different models require different allocation strategies to optimize performance.</td>
<td style="text-align: left;">Tailor allocation decisions based on the structure and execution characteristics of the workload.</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Beyond workload-specific considerations, memory allocation must also be scalable. As model sizes continue to grow, accelerators must dynamically manage memory resources rather than relying on static allocation schemes. Ensuring that frequently used data is accessible when needed without overwhelming memory capacity is essential for maintaining high efficiency.</p>
<p>In summary, mapping neural network computations to specialized hardware is a foundational step in AI acceleration, directly influencing performance, memory efficiency, and energy consumption. However, selecting an effective mapping strategy is not a trivial task—hardware constraints, workload variability, and execution dependencies create a vast and complex design space.</p>
<p>While the principles of computation placement, memory allocation, and data movement provide a structured foundation, optimizing these decisions requires advanced techniques to navigate the trade-offs involved. The next section explores optimization strategies that refine mapping decisions, focusing on techniques that efficiently search the design space to maximize execution efficiency while balancing hardware constraints.</p>
</section></section><section id="combinatorial-complexity" class="level3 page-columns page-full" data-number="11.5.3"><h3 data-number="11.5.3" class="anchored" data-anchor-id="combinatorial-complexity">
<span class="header-section-number">11.5.3</span> Combinatorial Complexity</h3>
<p>The efficient execution of machine learning models on AI accelerators requires careful consideration of placement—the spatial assignment of computations and data—and allocation—the temporal distribution of resources. These decisions are interdependent, and each introduces trade-offs that impact performance, energy efficiency, and scalability. <a href="#tbl-combinatorial-complexity" class="quarto-xref">Table&nbsp;<span>11.12</span></a> outlines the fundamental trade-offs between computation placement and resource allocation in AI accelerators. Placement decisions influence parallelism, memory access patterns, and communication overhead, while allocation strategies determine how resources are distributed over time to balance execution efficiency. The interplay between these factors shapes overall performance, requiring a careful balance to avoid bottlenecks such as excessive synchronization, memory congestion, or underutilized compute resources. Optimizing these trade-offs is essential for ensuring that AI accelerators operate at peak efficiency.</p>
<div id="tbl-combinatorial-complexity" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-combinatorial-complexity-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;11.12: Trade-offs between computation placement and resource allocation in AI accelerators.
</figcaption><div aria-describedby="tbl-combinatorial-complexity-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 43%">
<col style="width: 41%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Dimension</th>
<th style="text-align: left;">Placement Considerations</th>
<th style="text-align: left;">Allocation Considerations</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Computational Granularity</td>
<td style="text-align: left;">Fine-grained placement enables greater parallelism but increases synchronization overhead.</td>
<td style="text-align: left;">Coarse-grained allocation reduces synchronization overhead but may limit flexibility.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Spatial vs.&nbsp;Temporal Mapping</td>
<td style="text-align: left;">Spatial placement enhances parallel execution but can lead to resource contention and memory congestion.</td>
<td style="text-align: left;">Temporal allocation balances resource sharing but may reduce overall throughput.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Memory and Data Locality</td>
<td style="text-align: left;">Placing data closer to compute units minimizes latency but may reduce overall memory availability.</td>
<td style="text-align: left;">Allocating data across multiple memory levels increases capacity but introduces higher access costs.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Communication and Synchronization</td>
<td style="text-align: left;">Co-locating compute units reduces communication latency but may introduce contention.</td>
<td style="text-align: left;">Allocating synchronization mechanisms mitigates stalls but can introduce additional overhead.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Dataflow and Execution Ordering</td>
<td style="text-align: left;">Static placement simplifies execution but limits adaptability to workload variations.</td>
<td style="text-align: left;">Dynamic allocation improves adaptability but adds scheduling complexity.</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Each of these dimensions requires balancing trade-offs between placement and allocation. For instance, spatially distributing computations across multiple processing elements can increase throughput; however, if data allocation is not optimized, memory bandwidth limitations may introduce bottlenecks. Likewise, allocating resources for fine-grained computations may enhance flexibility but, without appropriate placement strategies, may lead to excessive synchronization overhead.</p>
<p>Because AI accelerator architectures impose constraints on both where computations execute and how resources are assigned over time, selecting an effective mapping strategy necessitates a coordinated approach to placement and allocation. Understanding how these trade-offs influence execution efficiency is essential for optimizing performance on AI accelerators.</p>
<section id="configuration-space-mapping" class="level4"><h4 class="anchored" data-anchor-id="configuration-space-mapping">Configuration Space Mapping</h4>
<p>The efficiency of AI accelerators is determined not only by their computational capabilities but also by how neural network computations are mapped to hardware resources. Mapping defines how computations are assigned to processing elements, how data is placed and moved through the memory hierarchy, and how execution is scheduled. The choices made in this process significantly impact performance, influencing compute utilization, memory bandwidth efficiency, and energy consumption.</p>
<p>Mapping machine learning models to hardware presents a large and complex design space. Unlike traditional computational workloads, model execution involves multiple interacting factors—computation, data movement, parallelism, and scheduling—each introducing constraints and trade-offs. The hierarchical memory structure of accelerators, as discussed in the Memory Systems section, further complicates this process by imposing limits on bandwidth, latency, and data reuse. As a result, effective mapping strategies must carefully balance competing objectives to maximize efficiency.</p>
<p>At the heart of this design space lie three interconnected aspects: data placement, computation scheduling, and data movement timing. Data placement refers to the allocation of data across various memory hierarchies—including on-chip buffers, caches, and off-chip DRAM—and its effective management is critical because it influences both latency and energy consumption. Inefficient placement often results in frequent, costly memory accesses, whereas strategic placement ensures that data used regularly remains in fast-access storage. Computation scheduling governs the order in which operations execute, impacting compute efficiency and memory access patterns; for instance, some execution orders may optimize parallelism while introducing synchronization overheads, and others may improve data locality at the expense of throughput. Meanwhile, timing in data movement is equally essential, as transferring data between memory levels incurs significant latency and energy costs. Efficient mapping strategies thus focus on minimizing unnecessary transfers by reusing data and overlapping communication with computation to enhance overall performance.</p>
<p>These factors define a vast combinatorial design space, where small variations in mapping decisions can lead to large differences in performance and energy efficiency. A poor mapping strategy can result in underutilized compute resources, excessive data movement, or imbalanced workloads, creating bottlenecks that degrade overall efficiency. Conversely, a well-designed mapping maximizes both throughput and resource utilization, making efficient use of available hardware.</p>
<p>Because of the interconnected nature of mapping decisions, there is no single optimal solution—different workloads and hardware architectures demand different approaches. The next sections examine the structure of this design space and how different mapping choices shape the execution of machine learning workloads.</p>
<p>Mapping machine learning computations onto specialized hardware requires balancing multiple constraints, including compute efficiency, memory bandwidth, and execution scheduling. The challenge arises from the vast number of possible ways to assign computations to processing elements, order execution, and manage data movement. Each decision contributes to a high-dimensional search space, where even minor variations in mapping choices can significantly impact performance.</p>
<p>Unlike traditional workloads with predictable execution patterns, machine learning models introduce diverse computational structures that require flexible mappings adapted to data reuse, parallelization opportunities, and memory constraints. The search space grows combinatorially, making exhaustive search infeasible. To understand this complexity, we analyze three key sources of variation:</p>
</section><section id="computation-and-execution-ordering" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="computation-and-execution-ordering">Computation and Execution Ordering</h4>
<p>Machine learning workloads are often structured as nested loops, iterating over various dimensions of computation. For instance, a matrix multiplication kernel may loop over batch size (<span class="math inline">\(N\)</span>), input features (<span class="math inline">\(C\)</span>), and output features (<span class="math inline">\(K\)</span>). The order in which these loops execute has a profound effect on data locality, reuse patterns, and computational efficiency.</p>
<p>The number of ways to arrange <span class="math inline">\(d\)</span> loops follows a factorial growth pattern: <span class="math display">\[
\mathcal{O} = d!
\]</span> which scales rapidly. A typical convolutional layer may involve up to seven loop dimensions, leading to: <span class="math display">\[
7! = 5,040 \text{ possible execution orders.}
\]</span></p>
<p>Furthermore, when considering multiple memory levels, the search space expands as: <span class="math display">\[
(d!)^l
\]</span> where <span class="math inline">\(l\)</span> is the number of memory hierarchy levels. This rapid expansion highlights why execution order optimization is crucial—poor loop ordering can lead to excessive memory traffic, while an optimized order improves cache utilization <span class="citation" data-cites="sze2017efficient">(<a href="../references.html#ref-sze2017efficient" role="doc-biblioref">Sze et al. 2017a</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-sze2017efficient" class="csl-entry" role="listitem">
Sze, Vivienne, Yu-Hsin Chen, Tien-Ju Yang, and Joel Emer. 2017a. <span>“Efficient Processing of Deep Neural Networks: A Tutorial and Survey.”</span> <em>Proceedings of the IEEE</em> 105 (12): 2295–2329. <a href="https://doi.org/10.1109/jproc.2017.2761740">https://doi.org/10.1109/jproc.2017.2761740</a>.
</div></div></section><section id="processing-elements-parallelization" class="level4"><h4 class="anchored" data-anchor-id="processing-elements-parallelization">Processing Elements Parallelization</h4>
<p>Modern AI accelerators leverage thousands of processing elements to maximize parallelism, but determining which computations should be parallelized is non-trivial. Excessive parallelization can introduce synchronization overheads and increased bandwidth demands, while insufficient parallelization leads to underutilized hardware.</p>
<p>The number of ways to distribute computations among parallel units follows the binomial coefficient: <span class="math display">\[
\mathcal{P} = \frac{d!}{(d-k)!}
\]</span> where <span class="math inline">\(d\)</span> is the number of loops, and <span class="math inline">\(k\)</span> is the number selected for parallel execution. For a six-loop computation where three loops are chosen for parallel execution, the number of valid configurations is: <span class="math display">\[
\frac{6!}{(6-3)!} = 120.
\]</span></p>
<p>Even for a single layer, there can be hundreds of valid parallelization strategies, each affecting data synchronization, memory contention, and overall compute efficiency. Expanding this across multiple layers and model architectures further magnifies the complexity.</p>
</section><section id="memory-placement-and-data-movement" class="level4"><h4 class="anchored" data-anchor-id="memory-placement-and-data-movement">Memory Placement and Data Movement</h4>
<p>The hierarchical memory structure of AI accelerators introduces additional constraints, as data must be efficiently placed across registers, caches, shared memory, and off-chip DRAM. Data placement impacts latency, bandwidth consumption, and energy efficiency—frequent access to slow memory creates bottlenecks, while optimized placement reduces costly memory transfers.</p>
<p>The number of ways to allocate data across memory levels follows an exponential growth function: <span class="math display">\[
\mathcal{M} = n^{d \times l}
\]</span> where:</p>
<ul>
<li>
<span class="math inline">\(n\)</span> = number of placement choices per level,</li>
<li>
<span class="math inline">\(d\)</span> = number of computational dimensions,</li>
<li>
<span class="math inline">\(l\)</span> = number of memory hierarchy levels.</li>
</ul>
<p>For a model with:</p>
<ul>
<li>
<span class="math inline">\(d = 5\)</span> computational dimensions,</li>
<li>
<span class="math inline">\(l = 3\)</span> memory levels,</li>
<li>
<span class="math inline">\(n = 4\)</span> possible placement choices per level,</li>
</ul>
<p>the number of possible memory allocations is: <span class="math display">\[
4^{5 \times 3} = 4^{15} = 1,073,741,824.
\]</span></p>
<p>This highlights how even a single layer may have over a billion possible memory configurations, making manual optimization impractical.</p>
</section><section id="mapping-search-space" class="level4"><h4 class="anchored" data-anchor-id="mapping-search-space">Mapping Search Space</h4>
<p>By combining the complexity from computation ordering, parallelization, and memory placement, the total mapping search space can be approximated as: <span class="math display">\[
\mathcal{S} = \left( n^d \times d! \times \frac{d!}{(d-k)!} \right)^l
\]</span> where:</p>
<ul>
<li>
<span class="math inline">\(n^d\)</span> represents memory placement choices,</li>
<li>
<span class="math inline">\(d!\)</span> accounts for computation ordering choices,</li>
<li>
<span class="math inline">\(\frac{d!}{(d-k)!}\)</span> captures parallelization possibilities,</li>
<li>
<span class="math inline">\(l\)</span> is the number of memory hierarchy levels.</li>
</ul>
<p>This equation illustrates the exponential growth of the search space, making brute-force search infeasible for all but the simplest cases.</p>
</section></section></section><section id="optimization-strategies" class="level2 page-columns page-full" data-number="11.6"><h2 data-number="11.6" class="anchored" data-anchor-id="optimization-strategies">
<span class="header-section-number">11.6</span> Optimization Strategies</h2>
<p>Efficiently mapping machine learning computations onto hardware is a complex challenge due to the vast number of possible configurations. As models grow in complexity, the number of potential mappings increases exponentially. Even for a single layer, there are thousands of ways to order computation loops, hundreds of parallelization strategies, and an exponentially growing number of memory placement choices. This combinatorial explosion makes exhaustive search impractical.</p>
<p>To overcome this challenge, AI accelerators rely on structured mapping strategies that systematically balance computational efficiency, data locality, and parallel execution. Rather than evaluating every possible configuration, these approaches use a combination of heuristic, analytical, and machine learning-based techniques to find high-performance mappings efficiently.</p>
<p>The key to effective mapping lies in understanding and applying a set of core techniques that optimize data movement, memory access, and computation. These building blocks of mapping strategies provide a structured foundation for efficient execution, which we explore in the next section.</p>
<section id="mapping-strategies-building-blocks" class="level3 page-columns page-full" data-number="11.6.1"><h3 data-number="11.6.1" class="anchored" data-anchor-id="mapping-strategies-building-blocks">
<span class="header-section-number">11.6.1</span> Mapping Strategies Building Blocks</h3>
<p>To navigate the complexity of mapping decisions, a set of foundational techniques is leveraged that optimizes execution across data movement, memory access, and computation efficiency. These techniques provide the necessary structure for mapping strategies that maximize hardware performance while minimizing bottlenecks.</p>
<p>Key techniques include data movement strategies, which determine where data is staged during computation in order to reduce redundant transfers, such as in weight stationary, output stationary, and input stationary approaches. Memory-aware tensor layouts also play an important role by influencing memory access patterns and cache efficiency through the organization of data in formats such as row-major or channel-major.</p>
<p>Other strategies involve kernel fusion, a method that minimizes redundant memory writes by combining multiple operations into a single computational step. Tiling is employed as a technique that partitions large computations into smaller, memory-friendly blocks to improve cache efficiency and reduce memory bandwidth requirements. Finally, balancing computation and communication is essential for managing the trade-offs between parallel execution and memory access to achieve high throughput.</p>
<p>Each of these building blocks plays a crucial role in structuring high-performance execution, forming the basis for both heuristic and model-driven optimization techniques. In the next section, we explore how these strategies are adapted to different types of AI models.</p>
<section id="data-movement-patterns" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="data-movement-patterns">Data Movement Patterns</h4>
<p>While computational mapping determines where and when operations occur, its success depends heavily on how efficiently data is accessed and transferred across the memory hierarchy. Unlike traditional computing workloads, which often exhibit structured and predictable memory access patterns, machine learning workloads present irregular access behaviors due to frequent retrieval of weights, activations, and intermediate values.</p>
<p>Even when computational units are mapped efficiently, poor data movement strategies can severely degrade performance, leading to frequent memory stalls and underutilized hardware resources. If data cannot be supplied to processing elements at the required rate, computational units remain idle, increasing latency, memory traffic, and energy consumption <span class="citation" data-cites="chen2016eyeriss">(<a href="../references.html#ref-chen2016eyeriss" role="doc-biblioref">Chen et al. 2016</a>)</span>.</p>
<div class="no-row-height column-margin column-container"></div><p>To illustrate the impact of data movement inefficiencies, consider a typical matrix multiplication operation, which forms the backbone of many machine learning models:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Matrix multiplication where:</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="co">## weights: [512 x 256] - model parameters</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co">## input:   [256 x 32]  - batch of activations</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="co">## Z:       [512 x 32]  - output activations</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="co">## Computing each output element Z[i,j]:</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">512</span>):</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">32</span>):</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">256</span>):</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>            Z[i,j] <span class="op">+=</span> weights[i,k] <span class="op">*</span> <span class="bu">input</span>[k,j]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This computation reveals several critical dataflow challenges.</p>
<p>The first challenge is the number of memory accesses required. For each output <span class="math inline">\(Z[i, j]\)</span>, the computation must fetch an entire row of weights from the weight matrix and a full column of activations from the input matrix. Since the weight matrix contains 512 rows and the input matrix contains 32 columns, this results in repeated memory accesses that place a significant burden on memory bandwidth.</p>
<p>The second challenge comes from weight reuse. The same weights are applied to multiple inputs, meaning that an ideal mapping strategy should maximize weight locality to avoid redundant memory fetches. Without proper reuse, the accelerator would waste bandwidth loading the same weights multiple times <span class="citation" data-cites="chen2018tvm">(<a href="../references.html#ref-chen2018tvm" role="doc-biblioref">Tianqi et al. 2018</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-chen2018tvm" class="csl-entry" role="listitem">
Tianqi, Chen et al. 2018. <span>“TVM: An Automated End-to-End Optimizing Compiler for Deep Learning.”</span> <em>13th USENIX Symposium on Operating Systems Design and Implementation (OSDI 18)</em>, 578–94.
</div></div><p>The third challenge involves the accumulation of intermediate results. Since each element in <span class="math inline">\(Z[i,j]\)</span> requires contributions from 256 different weight-input pairs, partial sums must be stored and retrieved before the final value is computed. If these intermediate values are stored inefficiently, the system will require frequent memory accesses, further increasing bandwidth demands.</p>
<p>A natural way to mitigate these challenges is to leverage SIMD and SIMT execution models, which allow multiple values to be fetched in parallel. However, even with these optimizations, data movement remains a bottleneck. The issue is not just how quickly data is retrieved but how often it must be moved and where it is placed within the memory hierarchy <span class="citation" data-cites="han2016eie">(<a href="../references.html#ref-han2016eie" role="doc-biblioref">Han et al. 2016</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-han2016eie" class="csl-entry" role="listitem">
Han, Song, Xingyu Liu, Huizi Mao, Jing Pu, Ardavan Pedram, Mark A. Horowitz, and William J. Dally. 2016. <span>“EIE: Efficient Inference Engine on Compressed Deep Neural Network.”</span> In <em>2016 ACM/IEEE 43rd Annual International Symposium on Computer Architecture (ISCA)</em>, 243–54. IEEE. <a href="https://doi.org/10.1109/isca.2016.30">https://doi.org/10.1109/isca.2016.30</a>.
</div></div><p>To address these constraints, accelerators implement dataflow strategies that determine which data remains fixed in memory and which data is streamed dynamically. These strategies aim to maximize reuse of frequently accessed data, thereby reducing the need for redundant memory fetches. The effectiveness of a given dataflow strategy depends on the specific workload—for example, deep convolutional networks benefit from keeping weights stationary, while fully connected layers may require a different approach.</p>
<section id="weight-stationary" class="level5"><h5 class="anchored" data-anchor-id="weight-stationary">Weight Stationary</h5>
<p>The Weight Stationary strategy keeps weights fixed in local memory, while input activations and partial sums are streamed through the system. This approach is particularly beneficial in CNNs and matrix multiplications, where the same set of weights is applied across multiple inputs. By ensuring weights remain stationary, this method reduces redundant memory fetches, which helps alleviate bandwidth bottlenecks and improves energy efficiency.</p>
<p>A key advantage of the weight stationary approach is that it maximizes weight reuse, reducing the frequency of memory accesses to external storage. Since weight parameters are often shared across multiple computations, keeping them in local memory eliminates unnecessary data movement, lowering the overall energy cost of computation. This makes it particularly effective for architectures where weights represent the dominant memory overhead, such as systolic arrays and custom accelerators designed for machine learning.</p>
<p>A simplified Weight Stationary implementation for matrix multiplication is illustrated below:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Weight Stationary Matrix Multiplication</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="co">## - Weights remain fixed in local memory</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co">## - Input activations stream through</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co">## - Partial sums accumulate for final output</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> weight_block <span class="kw">in</span> weights:  <span class="co"># Load and keep weights stationary</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    load_to_local(weight_block)  <span class="co"># Fixed in local storage</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> input_block <span class="kw">in</span> inputs:   <span class="co"># Stream inputs dynamically</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> output_block <span class="kw">in</span> outputs:  <span class="co"># Compute results</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>            output_block <span class="op">+=</span> compute(weight_block, input_block)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Reuse weights across inputs</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In weight stationary execution, weights are loaded once into local memory and remain fixed throughout the computation, while inputs are streamed dynamically, thereby reducing redundant memory accesses. At the same time, partial sums are accumulated in an efficient manner that minimizes unnecessary data movement, ensuring that the system maintains high throughput and energy efficiency.</p>
<p>By keeping weights fixed in local storage, memory bandwidth requirements are significantly reduced, as weights do not need to be reloaded for each new computation. Instead, the system efficiently reuses the stored weights across multiple input activations, allowing for high throughput execution. This makes weight stationary dataflow highly effective for workloads with heavy weight reuse patterns, such as CNNs and matrix multiplications.</p>
<p>However, while this strategy reduces weight-related memory traffic, it introduces trade-offs in input and output movement. Since inputs must be streamed dynamically while weights remain fixed, the efficiency of this approach depends on how well input activations can be delivered to the computational units without causing stalls. Additionally, partial sums—representing intermediate results—must be carefully accumulated to avoid excessive memory traffic. The total performance gain depends on the size of available on-chip memory, as storing larger weight matrices locally can become a constraint in models with millions or billions of parameters.</p>
<p>The weight stationary strategy is well-suited for workloads where weights exhibit high reuse and memory bandwidth is a limiting factor. It is commonly employed in CNNs, systolic arrays, and matrix multiplication kernels, where structured weight reuse leads to significant performance improvements. However, for models where input or output reuse is more critical, alternative dataflow strategies, such as output stationary or input stationary, may provide better trade-offs.</p>
</section><section id="output-stationary" class="level5 page-columns page-full"><h5 class="anchored" data-anchor-id="output-stationary">Output Stationary</h5>
<p>The Output Stationary strategy keeps partial sums fixed in local memory, while weights and input activations stream through the system. This approach is particularly effective for fully connected layers, systolic arrays, and other operations where an output element accumulates contributions from multiple weight-input pairs. By keeping partial sums stationary, this method reduces redundant memory writes, minimizing bandwidth consumption and improving energy efficiency <span class="citation" data-cites="chen2016eyeriss">(<a href="../references.html#ref-chen2016eyeriss" role="doc-biblioref">Chen et al. 2016</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-chen2016eyeriss" class="csl-entry" role="listitem">
Chen, Yu-Hsin, Tushar Krishna, Joel S. Emer, and Vivienne Sze. 2016. <span>“Eyeriss: A Spatial Architecture for Energy-Efficient Dataflow for Convolutional Neural Networks.”</span> <em>IEEE Journal of Solid-State Circuits</em> 51 (1): 186–98. <a href="https://doi.org/10.1109/JSSC.2015.2488709">https://doi.org/10.1109/JSSC.2015.2488709</a>.
</div></div><p>A key advantage of the output stationary approach is that it optimizes accumulation efficiency, ensuring that each output element is computed as efficiently as possible before being written to memory. Unlike Weight Stationary, which prioritizes weight reuse, Output Stationary execution is designed to minimize memory bandwidth overhead caused by frequent writes of intermediate results. This makes it well-suited for workloads where accumulation dominates the computational pattern, such as fully connected layers and matrix multiplications in transformer-based models.</p>
<p>A simplified Output Stationary implementation for matrix multiplication is illustrated below:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Output Stationary Matrix Multiplication</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co">## - Partial sums remain in local memory</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="co">## - Weights and input activations stream through dynamically</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="co">## - Final outputs are written only once</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> output_block <span class="kw">in</span> outputs:   <span class="co"># Keep partial sums stationary</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    accumulator <span class="op">=</span> <span class="dv">0</span>             <span class="co"># Initialize accumulation buffer</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> weight_block, input_block <span class="kw">in</span> <span class="bu">zip</span>(weights, inputs):</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>        accumulator <span class="op">+=</span> compute(weight_block, input_block)</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Accumulate partial sums</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    store_output(accumulator)  <span class="co"># Single write to memory</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This implementation follows the core principles of output stationary execution: - Partial sums are kept in local memory throughout the computation. - Weights and inputs are streamed dynamically, ensuring that intermediate results remain locally accessible. - Final outputs are written back to memory only once, reducing unnecessary memory traffic.</p>
<p>By accumulating partial sums locally, this approach eliminates excessive memory writes, improving overall system efficiency. In architectures such as systolic arrays, where computation progresses through a grid of processing elements, keeping partial sums stationary aligns naturally with structured accumulation workflows, reducing synchronization overhead.</p>
<p>However, while Output Stationary reduces memory write traffic, it introduces trade-offs in weight and input movement. Since weights and activations must be streamed dynamically, the efficiency of this approach depends on how well data can be fed into the system without causing stalls. Additionally, parallel implementations must carefully synchronize updates to partial sums, especially in architectures where multiple processing elements contribute to the same output.</p>
<p>The Output Stationary strategy is most effective for workloads where accumulation is the dominant operation and minimizing intermediate memory writes is critical. It is commonly employed in fully connected layers, attention mechanisms, and systolic arrays, where structured accumulation leads to significant performance improvements. However, for models where input reuse is more critical, alternative dataflow strategies, such as Input Stationary, may provide better trade-offs.</p>
</section><section id="input-stationary" class="level5"><h5 class="anchored" data-anchor-id="input-stationary">Input Stationary</h5>
<p>The Input Stationary strategy keeps input activations fixed in local memory, while weights and partial sums stream through the system. This approach is particularly effective for batch processing, transformer models, and sequence-based architectures, where input activations are reused across multiple computations. By ensuring that activations remain in local memory, this method reduces redundant input fetches, improving data locality and minimizing memory traffic.</p>
<p>A key advantage of the Input Stationary approach is that it maximizes input reuse, reducing the frequency of memory accesses for activations. Since many models, especially those in natural language processing (NLP) and recommendation systems, process the same input data across multiple computations, keeping inputs stationary eliminates unnecessary memory transfers, thereby lowering energy consumption. This strategy is particularly useful when dealing with large batch sizes, where a single batch of input activations contributes to multiple weight transformations.</p>
<p>A simplified Input Stationary implementation for matrix multiplication is illustrated below:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Input Stationary Matrix Multiplication</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="co">## - Input activations remain in local memory</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="co">## - Weights stream through dynamically</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="co">## - Partial sums accumulate and are written out</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> input_block <span class="kw">in</span> inputs:   <span class="co"># Keep input activations stationary</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    load_to_local(input_block)  <span class="co"># Fixed in local storage</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> weight_block <span class="kw">in</span> weights:   <span class="co"># Stream weights dynamically</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> output_block <span class="kw">in</span> outputs:  <span class="co"># Compute results</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>            output_block <span class="op">+=</span> compute(weight_block, input_block)</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Reuse inputs across weights</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This implementation follows the core principles of input stationary execution:</p>
<ul>
<li>
<strong>Input activations are loaded into local memory</strong> and remain fixed during computation.</li>
<li>
<strong>Weights are streamed dynamically</strong>, ensuring efficient application across multiple inputs.</li>
<li>
<strong>Partial sums are accumulated and written out</strong>, optimizing memory bandwidth usage.</li>
</ul>
<p>By keeping input activations stationary, this strategy minimizes redundant memory accesses to input data, significantly reducing external memory bandwidth requirements. This is particularly beneficial in transformer architectures, where each token in an input sequence is used across multiple attention heads and layers. Additionally, in batch processing scenarios, keeping input activations in local memory improves data locality, making it well-suited for fully connected layers and matrix multiplications.</p>
<p>However, while Input Stationary reduces memory traffic for activations, it introduces trade-offs in weight and output movement. Since weights must be streamed dynamically while inputs remain fixed, the efficiency of this approach depends on how well weights can be delivered to the computational units without causing stalls. Additionally, partial sums must be accumulated efficiently before being written back to memory, which may require additional buffering mechanisms.</p>
<p>The Input Stationary strategy is most effective for workloads where input activations exhibit high reuse, and memory bandwidth for inputs is a critical constraint. It is commonly employed in transformers, recurrent networks, and batch processing workloads, where structured input reuse leads to significant performance improvements. However, for models where output accumulation is more critical, alternative dataflow strategies, such as Output Stationary, may provide better trade-offs.</p>
</section></section><section id="memory-aware-tensor-layouts" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="memory-aware-tensor-layouts">Memory-Aware Tensor Layouts</h4>
<p>Efficient execution of machine learning workloads depends not only on how data moves (dataflow strategies) but also on how data is stored and accessed in memory. Tensor layouts—the way multidimensional data is arranged in memory—can significantly impact memory access efficiency, cache performance, and computational throughput. Poorly chosen layouts can lead to excessive memory stalls, inefficient cache usage, and increased data movement costs.</p>
<p>In AI accelerators, tensor layout optimization is particularly important because data is frequently accessed in patterns dictated by the underlying hardware architecture. Choosing the right layout ensures that memory accesses align with hardware-friendly access patterns, minimizing overhead from costly memory transactions <span class="citation" data-cites="nvidia2021cudnn">(<a href="../references.html#ref-nvidia2021cudnn" role="doc-biblioref">N. Corporation 2021</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-nvidia2021cudnn" class="csl-entry" role="listitem">
———. 2021. <em>NVIDIA cuDNN: GPU Accelerated Deep Learning</em>. <a href="https://developer.nvidia.com/cudnn">https://developer.nvidia.com/cudnn</a>.
</div><div id="ref-xla2020" class="csl-entry" role="listitem">
He, Xuzhen. 2023a. <span>“Accelerated Linear Algebra Compiler for Computationally Efficient Numerical Models: Success and Potential Area of Improvement.”</span> <em>PLOS ONE</em> 18 (2): e0282265. <a href="https://doi.org/10.1371/journal.pone.0282265">https://doi.org/10.1371/journal.pone.0282265</a>.
</div></div><p>While developers can sometimes manually specify tensor layouts, the choice is often determined automatically by machine learning frameworks (e.g., TensorFlow, PyTorch, JAX), compilers, or AI accelerator runtimes. Low-level optimization tools such as cuDNN (for NVIDIA GPUs), XLA (for TPUs), and MLIR (for custom accelerators) may rearrange tensor layouts dynamically to optimize performance <span class="citation" data-cites="xla2020">(<a href="../references.html#ref-xla2020" role="doc-biblioref">He 2023a</a>)</span>. In high-level frameworks, layout transformations are typically applied transparently, but developers working with custom kernels or low-level libraries (e.g., CUDA, Metal, or OpenCL) may have direct control over tensor format selection.</p>
<p>For example, in PyTorch, users can manually modify layouts using tensor.permute() or tensor.contiguous() to ensure efficient memory access <span class="citation" data-cites="paszke2019pytorch">(<a href="../references.html#ref-paszke2019pytorch" role="doc-biblioref">Paszke et al. 2019</a>)</span>. In TensorFlow, layout optimizations are often applied internally by the XLA compiler, choosing between NHWC (row-major) and NCHW (channel-major) based on the target hardware <span class="citation" data-cites="tensorflow2022">(<a href="../references.html#ref-tensorflow2022" role="doc-biblioref">Brain 2022</a>)</span>. Hardware-aware machine learning libraries, such as cuDNN for GPUs or OneDNN for CPUs, enforce specific memory layouts to maximize cache locality and SIMD efficiency. Ultimately, while developers may have some control over tensor layout selection, most layout decisions are driven by the compiler and runtime system, ensuring that tensors are stored in memory in a way that best suits the underlying hardware.</p>
<div class="no-row-height column-margin column-container"><div id="ref-paszke2019pytorch" class="csl-entry" role="listitem">
Paszke, Adam et al. 2019. <span>“PyTorch: An Imperative Style, High-Performance Deep Learning Library.”</span> <em>NeurIPS</em>.
</div><div id="ref-tensorflow2022" class="csl-entry" role="listitem">
———. 2022. <em>TensorFlow Documentation</em>. <a href="https://www.tensorflow.org/">https://www.tensorflow.org/</a>.
</div></div><section id="row-major-layout" class="level5 page-columns page-full"><h5 class="anchored" data-anchor-id="row-major-layout">Row-Major Layout</h5>
<p>Row-major layout refers to the way multi-dimensional tensors are stored in memory, where elements are arranged row by row, ensuring that all values in a given row are placed contiguously before moving to the next row. This storage format is widely used in general-purpose CPUs and some machine learning frameworks because it aligns naturally with sequential memory access patterns, making it more cache-efficient for certain types of operations <span class="citation" data-cites="oneDNN2021">(<a href="../references.html#ref-oneDNN2021" role="doc-biblioref">I. Corporation 2021</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-oneDNN2021" class="csl-entry" role="listitem">
Corporation, Intel. 2021. <em>oneDNN: Intel’s Deep Learning Neural Network Library</em>. <a href="https://github.com/oneapi-src/oneDNN">https://github.com/oneapi-src/oneDNN</a>.
</div></div><p>To understand how row-major layout works, consider a single RGB image represented as a tensor of shape (Height, Width, Channels). If the image has a size of <span class="math inline">\(3\times 3\)</span> pixels with 3 channels (RGB), the corresponding tensor is structured as (3, 3, 3). The values are stored in memory as follows: <span class="math display">\[\begin{gather*}
I(0,0,0), I(0,0,1), I(0,0,2), I(0,1,0), I(0,1,1), \\
I(0,1,2), I(0,2,0), I(0,2,1), I(0,2,2), \ldots
\end{gather*}\]</span></p>
<p>Each row is stored contiguously, meaning all pixel values in the first row are placed sequentially in memory before moving on to the second row. This ordering is advantageous because CPUs and cache hierarchies are optimized for sequential memory access. When data is accessed in a row-wise fashion, such as when applying element-wise operations like activation functions or basic arithmetic transformations, memory fetches are efficient, and cache utilization is maximized <span class="citation" data-cites="sodani2017knl">(<a href="../references.html#ref-sodani2017knl" role="doc-biblioref">Sodani 2015</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-sodani2017knl" class="csl-entry" role="listitem">
Sodani, Avinash. 2015. <span>“Knights Landing (KNL): 2nd Generation Intel Xeon Phi Processor.”</span> In <em>2015 IEEE Hot Chips 27 Symposium (HCS)</em>, 1–24. IEEE. <a href="https://doi.org/10.1109/hotchips.2015.7477467">https://doi.org/10.1109/hotchips.2015.7477467</a>.
</div></div><p>The efficiency of row-major storage becomes particularly evident in CPU-based machine learning workloads, where operations such as batch normalization, matrix multiplications, and element-wise arithmetic frequently process rows of data sequentially. Since modern CPUs employ cache prefetching mechanisms, a row-major layout allows the next required data values to be preloaded into cache ahead of execution, reducing memory latency and improving overall computational throughput.</p>
<p>However, row-major layout can introduce inefficiencies when performing operations that require accessing data across channels rather than across rows. Consider a convolutional layer that applies a filter across multiple channels of an input image. Since channel values are interleaved in row-major storage, the convolution operation must jump across memory locations to fetch all the necessary channel values for a given pixel. These strided memory accesses can be costly on hardware architectures that rely on vectorized execution and coalesced memory access, such as GPUs and TPUs.</p>
<p>Despite these limitations, row-major layout remains a dominant storage format in CPU-based machine learning frameworks. TensorFlow, for instance, defaults to the NHWC (row-major) format on CPUs, ensuring that cache locality is optimized for sequential processing. However, when targeting GPUs, frameworks often rearrange data dynamically to take advantage of more efficient memory layouts, such as channel-major storage, which aligns better with parallelized computation.</p>
</section><section id="channel-major-layout" class="level5 page-columns page-full"><h5 class="anchored" data-anchor-id="channel-major-layout">Channel-Major Layout</h5>
<p>In contrast to row-major layout, channel-major layout arranges data in memory such that all values for a given channel are stored together before moving to the next channel. This format is particularly beneficial for GPUs, TPUs, and other AI accelerators, where vectorized operations and memory coalescing significantly impact computational efficiency.</p>
<p>To understand how channel-major layout works, consider the same RGB image tensor of size (Height, Width, Channels) = (3, 3, 3). Instead of storing pixel values row by row, the data is structured channel-first in memory as follows: <span class="math display">\[\begin{gather*}
I(0,0,0), I(1,0,0), I(2,0,0), I(0,1,0), I(1,1,0), I(2,1,0), \ldots, \\
I(0,0,1), I(1,0,1), I(2,0,1), \ldots, I(0,0,2), I(1,0,2), I(2,0,2), \ldots
\end{gather*}\]</span></p>
<p>In this format, all red channel values for the entire image are stored first, followed by all green values, and then all blue values. This ordering allows hardware accelerators to efficiently load and process data across channels in parallel, which is crucial for convolution operations and SIMD (Single Instruction, Multiple Data) execution models <span class="citation" data-cites="chetlur2014cudnn">(<a href="../references.html#ref-chetlur2014cudnn" role="doc-biblioref">Chetlur et al. 2014</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-chetlur2014cudnn" class="csl-entry" role="listitem">
Chetlur, Sharan, Cliff Woolley, Philippe Vandermersch, Jonathan Cohen, John Tran, Bryan Catanzaro, and Evan Shelhamer. 2014. <span>“cuDNN: Efficient Primitives for Deep Learning.”</span> <em>arXiv Preprint arXiv:1410.0759</em>, October. <a href="http://arxiv.org/abs/1410.0759v3">http://arxiv.org/abs/1410.0759v3</a>.
</div></div><p>The advantage of channel-major layout becomes clear when performing convolutions in machine learning models. Convolutional layers process images by applying a shared set of filters across all channels. When the data is stored in a channel-major format, a convolution kernel can load an entire channel efficiently, reducing the number of scattered memory fetches. This reduces memory latency, improves throughput, and enhances data locality for matrix multiplications, which are fundamental to machine learning workloads.</p>
<p>Because GPUs and TPUs rely on memory coalescing—a technique where consecutive threads fetch contiguous memory addresses—channel-major layout aligns naturally with the way these processors execute parallel computations. For example, in NVIDIA GPUs, each thread in a warp (a group of threads executed simultaneously) processes different elements of the same channel, ensuring that memory accesses are efficient and reducing the likelihood of strided memory accesses, which can degrade performance.</p>
<p>Despite its advantages in machine learning accelerators, channel-major layout can introduce inefficiencies when running on general-purpose CPUs. Since CPUs optimize for sequential memory access, storing all values for a single channel before moving to the next disrupts cache locality for row-wise operations. This is why many machine learning frameworks (e.g., TensorFlow, PyTorch) default to row-major (NHWC) on CPUs and channel-major (NCHW) on GPUs—optimizing for the strengths of each hardware type.</p>
<p>Modern AI frameworks and compilers often transform tensor layouts dynamically depending on the execution environment. For instance, TensorFlow and PyTorch automatically switch between NHWC and NCHW based on whether a model is running on a CPU, GPU, or TPU, ensuring that the memory layout aligns with the most efficient execution path.</p>
</section><section id="row-major-vs-channel-major-layouts" class="level5"><h5 class="anchored" data-anchor-id="row-major-vs-channel-major-layouts">Row-Major vs Channel-Major Layouts</h5>
<p>Both row-major (NHWC) and channel-major (NCHW) layouts serve distinct purposes in machine learning workloads, with their efficiency largely determined by the hardware architecture, memory access patterns, and computational requirements. The choice of layout directly influences cache utilization, memory bandwidth efficiency, and processing throughput. <a href="#tbl-major" class="quarto-xref">Table&nbsp;<span>11.13</span></a> summarizes the differences between row-major (NHWC) and channel-major (NCHW) layouts in terms of performance trade-offs and hardware compatibility.</p>
<div id="tbl-major" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-major-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;11.13: Comparison of row-major (NHWC) vs.&nbsp;channel-major (NCHW) layouts.
</figcaption><div aria-describedby="tbl-major-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 39%">
<col style="width: 41%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Feature</th>
<th style="text-align: left;">Row-Major (NHWC)</th>
<th style="text-align: left;">Channel-Major (NCHW)</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Memory Storage Order</td>
<td style="text-align: left;">Pixels are stored row-by-row, channel interleaved</td>
<td style="text-align: left;">All values for a given channel are stored together first</td>
</tr>
<tr class="even">
<td style="text-align: left;">Best for</td>
<td style="text-align: left;">CPUs, element-wise operations</td>
<td style="text-align: left;">GPUs, TPUs, convolution operations</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Cache Efficiency</td>
<td style="text-align: left;">High cache locality for sequential row access</td>
<td style="text-align: left;">Optimized for memory coalescing across channels</td>
</tr>
<tr class="even">
<td style="text-align: left;">Convolution Performance</td>
<td style="text-align: left;">Requires strided memory accesses (inefficient on GPUs)</td>
<td style="text-align: left;">Efficient for GPU convolution kernels</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Memory Fetching</td>
<td style="text-align: left;">Good for operations that process rows sequentially</td>
<td style="text-align: left;">Optimized for SIMD execution across channels</td>
</tr>
<tr class="even">
<td style="text-align: left;">Default in Frameworks</td>
<td style="text-align: left;">Default on CPUs (e.g., TensorFlow NHWC)</td>
<td style="text-align: left;">Default on GPUs (e.g., cuDNN prefers NCHW)</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>The decision to use row-major (NHWC) or channel-major (NCHW) layouts is not always made manually by developers. Instead, machine learning frameworks and AI compilers often determine the optimal layout dynamically based on the target hardware and operation type. CPUs tend to favor NHWC due to cache-friendly sequential memory access, while GPUs perform better with NCHW, which reduces memory fetch overhead for machine learning computations.</p>
<p>In practice, modern AI compilers such as TensorFlow’s XLA and PyTorch’s TorchScript perform automatic layout transformations, converting tensors between NHWC and NCHW as needed to optimize performance across different processing units. This ensures that machine learning models achieve the highest possible throughput without requiring developers to manually specify tensor layouts.</p>
</section></section><section id="kernel-fusion" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="kernel-fusion">Kernel Fusion</h4>
<section id="intermediate-memory-write" class="level5 page-columns page-full"><h5 class="anchored" data-anchor-id="intermediate-memory-write">Intermediate Memory Write</h5>
<p>Optimizing memory access is a fundamental challenge in AI acceleration. While AI models rely on high-throughput computation, their performance is often constrained by memory bandwidth and intermediate memory writes rather than pure arithmetic operations. Every time an operation produces an intermediate result that must be written to memory and later read back, execution stalls occur due to data movement overhead.</p>
<p>To better understand why kernel fusion is necessary, consider a simple sequence of operations in a machine learning model. Many AI workloads, particularly those involving element-wise transformations, introduce unnecessary intermediate memory writes, leading to increased memory bandwidth consumption and reduced execution efficiency <span class="citation" data-cites="nvidia2017gpu">(<a href="../references.html#ref-nvidia2017gpu" role="doc-biblioref">N. Corporation 2017</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-nvidia2017gpu" class="csl-entry" role="listitem">
Corporation, NVIDIA. 2017. <span>“GPU-Accelerated Machine Learning and Deep Learning.”</span> <em>Technical Report</em>.
</div></div><p>In a naïve execution model, each operation is treated as a separate kernel, meaning that each intermediate result is written to memory, only to be read back for the next operation. The execution flow looks like this:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="co">## Input tensor</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> torch.randn(<span class="dv">1024</span>, <span class="dv">1024</span>).cuda()</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="co">## Step-by-step execution (naïve approach)</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>X1 <span class="op">=</span> torch.relu(X)         <span class="co"># Intermediate tensor stored in memory</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>X2 <span class="op">=</span> torch.batch_norm(X1)  <span class="co"># Another intermediate tensor stored</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>Y  <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> X2 <span class="op">+</span> <span class="fl">1.0</span>        <span class="co"># Final result</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Each operation produces an intermediate tensor that must be written to memory and retrieved for the next operation. On large tensors, this overhead of moving data can outweigh the computational cost of the operations <span class="citation" data-cites="shazeer2018mesh">(<a href="../references.html#ref-shazeer2018mesh" role="doc-biblioref">Shazeer et al. 2018</a>)</span>. <a href="#tbl-memory-footprint" class="quarto-xref">Table&nbsp;<span>11.14</span></a> illustrates the memory overhead in a naïve execution model. While only the final result <span class="math inline">\(Y\)</span> is needed, storing multiple intermediate tensors creates unnecessary memory traffic and inefficient memory usage. This data movement bottleneck significantly impacts performance, making memory optimization crucial for AI accelerators.</p>
<div class="no-row-height column-margin column-container"><div id="ref-shazeer2018mesh" class="csl-entry" role="listitem">
Shazeer, Noam, Youlong Cheng, Niki Parmar, Dustin Tran, Ashish Vaswani, Penporn Koanantakool, Peter Hawkins, et al. 2018. <span>“Mesh-TensorFlow: Deep Learning for Supercomputers.”</span> <em>arXiv Preprint arXiv:1811.02084</em>, November. <a href="http://arxiv.org/abs/1811.02084v1">http://arxiv.org/abs/1811.02084v1</a>.
</div></div><div id="tbl-memory-footprint" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-memory-footprint-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;11.14: Memory footprint of a naïve execution model with intermediate tensor storage.
</figcaption><div aria-describedby="tbl-memory-footprint-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 58%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Tensor</th>
<th style="text-align: center;">Size (MB) for 1024 <span class="math inline">\(\times\)</span> 1024 Tensor</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">X</td>
<td style="text-align: center;">4 MB</td>
</tr>
<tr class="even">
<td style="text-align: left;">X’</td>
<td style="text-align: center;">4 MB</td>
</tr>
<tr class="odd">
<td style="text-align: left;">X’’</td>
<td style="text-align: center;">4 MB</td>
</tr>
<tr class="even">
<td style="text-align: left;">Y</td>
<td style="text-align: center;">4 MB</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Total Memory</td>
<td style="text-align: center;">16 MB</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Even though only the final result <span class="math inline">\(Y\)</span> is needed, three additional intermediate tensors consume extra memory without contributing to final output storage. This excessive memory usage limits scalability and wastes memory bandwidth, particularly in AI accelerators where minimizing data movement is critical.</p>
</section><section id="kernel-fusion-for-memory-efficiency" class="level5 page-columns page-full"><h5 class="anchored" data-anchor-id="kernel-fusion-for-memory-efficiency">Kernel Fusion for Memory Efficiency</h5>
<p>Kernel fusion is a key optimization technique that aims to minimize intermediate memory writes, reducing the memory footprint and bandwidth consumption of machine learning workloads <span class="citation" data-cites="jia2018beyond">(<a href="../references.html#ref-jia2018beyond" role="doc-biblioref">Zhihao Jia, Zaharia, and Aiken 2018</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-jia2018beyond" class="csl-entry" role="listitem">
Jia, Zhihao, Matei Zaharia, and Alex Aiken. 2018. <span>“Beyond Data and Model Parallelism for Deep Neural Networks.”</span> <em>arXiv Preprint arXiv:1807.05358</em>, July. <a href="http://arxiv.org/abs/1807.05358v1">http://arxiv.org/abs/1807.05358v1</a>.
</div></div><p>Kernel fusion involves merging multiple computation steps into a single, optimized operation, eliminating the need for storing and reloading intermediate tensors. Instead of executing each layer or element-wise operation separately—where each step writes its output to memory before the next step begins—fusion enables direct data propagation between operations, keeping computations within high-speed registers or local memory.</p>
<p>A common machine learning sequence might involve applying a nonlinear activation function (e.g., ReLU), followed by batch normalization, and then scaling the values for input to the next layer. In a naïve implementation, each of these steps generates an intermediate tensor, which is written to memory, read back, and then modified again: <span class="math display">\[
X' = \text{ReLU}(X)
X'' = \text{BatchNorm}(X')
Y = \alpha \cdot X'' + \beta
\]</span></p>
<p>With kernel fusion, these operations are combined into a single computation step, allowing the entire transformation to occur without generating unnecessary intermediate tensors: <span class="math display">\[
Y = \alpha \cdot \text{BatchNorm}\big(\text{ReLU}(X)\big) + \beta
\]</span></p>
<p><a href="#tbl-fusion-benefits" class="quarto-xref">Table&nbsp;<span>11.15</span></a> highlights the impact of operation fusion on memory efficiency. By keeping intermediate results in registers or local memory rather than writing them to main memory, fusion significantly reduces memory traffic. This optimization is especially beneficial on highly parallel architectures like GPUs and TPUs, where minimizing memory accesses translates directly into improved execution throughput. Compared to the naïve execution model, fused execution eliminates the need for storing intermediate tensors, dramatically lowering the total memory footprint and improving overall efficiency.</p>
<div id="tbl-fusion-benefits" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-fusion-benefits-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;11.15: Reduction in memory usage through operation fusion.
</figcaption><div aria-describedby="tbl-fusion-benefits-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 24%">
<col style="width: 40%">
<col style="width: 34%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Execution Model</th>
<th style="text-align: center;">Intermediate Tensors Stored</th>
<th style="text-align: center;">Total Memory Usage (MB)</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Naïve Execution</td>
<td style="text-align: center;">X’, X’’</td>
<td style="text-align: center;">16 MB</td>
</tr>
<tr class="even">
<td style="text-align: left;">Fused Execution</td>
<td style="text-align: center;">None</td>
<td style="text-align: center;">4 MB</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Kernel fusion reduces total memory consumption from 16 MB to 4 MB, eliminating redundant memory writes while improving execution efficiency.</p>
</section><section id="performance-benefits-and-constraints" class="level5 page-columns page-full"><h5 class="anchored" data-anchor-id="performance-benefits-and-constraints">Performance Benefits and Constraints</h5>
<p>Kernel fusion brings several key advantages that enhance memory efficiency and computation throughput. By reducing memory accesses, fused kernels ensure that intermediate values stay within registers instead of being repeatedly written to and read from memory. This significantly lowers memory traffic, which is one of the primary bottlenecks in machine learning workloads. GPUs and TPUs, in particular, benefit from kernel fusion because high-bandwidth memory is a scarce resource, and reducing memory transactions leads to better utilization of compute units <span class="citation" data-cites="nvidia2020ampere">(<a href="../references.html#ref-nvidia2020ampere" role="doc-biblioref">Qi, Kantarci, and Liu 2017</a>)</span>.</p>
<div class="no-row-height column-margin column-container"></div><p>However, not all operations can be fused. Element-wise operations, such as ReLU, batch normalization, and simple arithmetic transformations, are ideal candidates for fusion since their computations depend only on single elements from the input tensor. In contrast, operations with complex data dependencies, such as matrix multiplications and convolutions, involve global data movement, making direct fusion impractical. These operations require values from multiple input elements to compute a single output, which prevents them from being executed as a single fused kernel.</p>
<p>Another major consideration is register pressure. Fusing multiple operations means all temporary values must be kept in registers rather than memory. While this eliminates redundant memory writes, it also increases register demand. If a fused kernel exceeds the available registers per thread, the system must spill excess values into shared memory, introducing additional latency and potentially negating the benefits of fusion. On GPUs, where thread occupancy (the number of threads that can run in parallel) is limited by available registers, excessive fusion can reduce parallelism, leading to diminishing returns.</p>
<p>Different AI accelerators and compilers handle fusion in distinct ways. NVIDIA GPUs, for example, favor warp-level parallelism, where element-wise fusion is straightforward. TPUs, on the other hand, prioritize systolic array execution, which is optimized for matrix-matrix operations rather than element-wise fusion <span class="citation" data-cites="nvidia2020ampere">(<a href="../references.html#ref-nvidia2020ampere" role="doc-biblioref">Qi, Kantarci, and Liu 2017</a>)</span>. AI compilers such as XLA (TensorFlow), TorchScript (PyTorch), TensorRT (NVIDIA), and MLIR automatically detect fusion opportunities and apply heuristics to balance memory savings and execution efficiency <span class="citation" data-cites="xla2021">(<a href="../references.html#ref-xla2021" role="doc-biblioref">He 2023b</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-nvidia2020ampere" class="csl-entry" role="listitem">
Qi, Xuan, Burak Kantarci, and Chen Liu. 2017. <span>“GPU-Based Acceleration of SDN Controllers.”</span> In <em>Network as a Service for Next Generation Internet</em>, 339–56. Institution of Engineering; Technology. <a href="https://doi.org/10.1049/pbte073e%5C_ch14">https://doi.org/10.1049/pbte073e\_ch14</a>.
</div><div id="ref-xla2021" class="csl-entry" role="listitem">
———. 2023b. <span>“Accelerated Linear Algebra Compiler for Computationally Efficient Numerical Models: Success and Potential Area of Improvement.”</span> <em>PLOS ONE</em> 18 (2): e0282265. <a href="https://doi.org/10.1371/journal.pone.0282265">https://doi.org/10.1371/journal.pone.0282265</a>.
</div></div><p>Despite its advantages, fusion is not always beneficial. Some AI frameworks allow developers to disable fusion selectively, especially when debugging performance issues or making frequent model modifications. The decision to fuse operations must consider trade-offs between memory efficiency, register usage, and hardware execution constraints to ensure that fusion leads to tangible performance improvements.</p>
</section></section><section id="tiling-for-memory-efficiency" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="tiling-for-memory-efficiency">Tiling for Memory Efficiency</h4>
<p>While modern AI accelerators offer high computational throughput, their performance is often limited by memory bandwidth rather than raw processing power. If data cannot be supplied to processing units fast enough, execution stalls occur, leading to wasted cycles and inefficient hardware utilization.</p>
<p>Tiling is a technique used to mitigate this issue by restructuring computations into smaller, memory-friendly subproblems. Instead of processing entire matrices or tensors at once—leading to excessive memory traffic—tiling partitions computations into smaller blocks (tiles) that fit within fast local memory (e.g., caches, shared memory, or registers) <span class="citation" data-cites="lam1991cache">(<a href="../references.html#ref-lam1991cache" role="doc-biblioref">Lam, Rothberg, and Wolf 1991</a>)</span>. By doing so, tiling increases data reuse, minimizes memory fetches, and improves overall computational efficiency.</p>
<div class="no-row-height column-margin column-container"><div id="ref-lam1991cache" class="csl-entry" role="listitem">
Lam, Monica D., Edward E. Rothberg, and Michael E. Wolf. 1991. <span>“The Cache Performance and Optimizations of Blocked Algorithms.”</span> In <em>Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems - ASPLOS-IV</em>, 63–74. ACM Press. <a href="https://doi.org/10.1145/106972.106981">https://doi.org/10.1145/106972.106981</a>.
</div></div><p>A classic example of inefficient memory access is matrix multiplication, which is widely used in AI models. Without tiling, the naïve approach results in repeated memory accesses for the same data, leading to unnecessary bandwidth consumption:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Naïve Matrix Multiplication (No Tiling)</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>            C[i, j] <span class="op">+=</span> A[i, k] <span class="op">*</span> B[k, j]  <span class="co"># Repeatedly fetching</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>                                          <span class="co"># A[i, k] and B[k, j]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Each iteration requires loading elements from matrices <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> multiple times from memory, causing excessive data movement. As the size of the matrices increases, the memory bottleneck worsens, limiting performance.</p>
<p>Tiling addresses this problem by ensuring that smaller portions of matrices are loaded into fast memory, reused efficiently, and only written back to main memory when necessary. This technique is especially crucial in AI accelerators, where memory accesses dominate execution time.</p>
<p>In the following sections, we will explore the fundamental principles of tiling, its different strategies, and the key trade-offs involved in selecting an effective tiling approach.</p>
<section id="tiling-fundamentals" class="level5"><h5 class="anchored" data-anchor-id="tiling-fundamentals">Tiling Fundamentals</h5>
<p>Tiling is based on a simple but powerful principle: instead of operating on an entire data structure at once, computations are divided into smaller tiles that fit within the available fast memory. By structuring execution around these tiles, data reuse is maximized, reducing redundant memory accesses and improving overall efficiency.</p>
<p>Consider matrix multiplication, a key operation in machine learning workloads. The operation computes the output matrix <span class="math inline">\(C\)</span> from two input matrices <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>: <span class="math display">\[
C = A \times B
\]</span> where each element <span class="math inline">\(C[i,j]\)</span> is computed as: <span class="math display">\[
C[i,j] = \sum_{k} A[i,k] \times B[k,j]
\]</span></p>
<p>A naïve implementation follows this formula directly:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Naïve Matrix Multiplication (No Tiling)</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>            C[i, j] <span class="op">+=</span> A[i, k] <span class="op">*</span> B[k, j]  <span class="co"># Repeatedly fetching</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>                                          <span class="co"># A[i, k] and B[k, j]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>At first glance, this approach seems correct—it computes the desired result and follows the mathematical definition. However, the issue lies in how memory is accessed. Every time the innermost loop runs, it fetches an element from matrix <span class="math inline">\(A\)</span> and matrix <span class="math inline">\(B\)</span> from memory, performs a multiplication, and updates an element in matrix <span class="math inline">\(C\)</span>. Because matrices are large, the processor frequently reloads the same values from memory, even though they were just used in previous computations.</p>
<p>This unnecessary data movement is expensive. Fetching values from main memory (DRAM) is hundreds of times slower than accessing values stored in on-chip cache or registers. If the same values must be reloaded multiple times instead of being stored in fast memory, execution slows down significantly.</p>
</section><section id="tiling-performance-improvement" class="level5"><h5 class="anchored" data-anchor-id="tiling-performance-improvement">Tiling Performance Improvement</h5>
<p>Instead of computing one element at a time and constantly moving data in and out of slow memory, tiling processes submatrices (tiles) at a time, keeping frequently used values in fast memory. The idea is to divide the matrices into smaller blocks that fit within the processor’s cache or shared memory, ensuring that once a block is loaded, it is reused multiple times before moving to the next one.</p>
<p>A tiled implementation of matrix multiplication looks like this:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Tiled Matrix Multiplication</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>TILE_SIZE <span class="op">=</span> <span class="dv">32</span> <span class="co"># Choose a tile size based on hardware constraints</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, N, TILE_SIZE):</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, N, TILE_SIZE):</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, N, TILE_SIZE):</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>          <span class="co"># Compute the submatrix C[i:i+TILE_SIZE, j:j+TILE_SIZE]</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> ii <span class="kw">in</span> <span class="bu">range</span>(i, i <span class="op">+</span> TILE_SIZE):</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> jj <span class="kw">in</span> <span class="bu">range</span>(j, j <span class="op">+</span> TILE_SIZE):</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> kk <span class="kw">in</span> <span class="bu">range</span>(k, k <span class="op">+</span> TILE_SIZE):</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>                        C[ii, jj] <span class="op">+=</span> A[ii, kk] <span class="op">*</span> B[kk, jj]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This restructuring significantly improves performance for three main reasons:</p>
<ol type="1">
<li><p><strong>Better Memory Reuse</strong>: Instead of fetching elements from <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> repeatedly from slow memory, this approach loads a small tile of data into fast memory, performs multiple computations using it, and only then moves on to the next tile. This minimizes redundant memory accesses.</p></li>
<li><p><strong>Reduced Memory Bandwidth Usage</strong>: Since each tile is used multiple times before being evicted, memory traffic is reduced. Instead of repeatedly accessing DRAM, most required data is available in L1/L2 cache or shared memory, leading to faster execution.</p></li>
<li><p><strong>Increased Compute Efficiency</strong>: Processors spend less time waiting for data and more time performing useful computations. In architectures like GPUs and TPUs, where thousands of parallel processing units operate simultaneously, tiling ensures that data is read and processed in a structured manner, avoiding unnecessary stalls.</p></li>
</ol>
<p>This technique is particularly effective in AI accelerators, where machine learning workloads consist of large matrix multiplications and tensor transformations. Without tiling, these workloads quickly become memory-bound, meaning performance is constrained by how fast data can be retrieved rather than by the raw computational power of the processor.</p>
</section><section id="tiling-methods" class="level5"><h5 class="anchored" data-anchor-id="tiling-methods">Tiling Methods</h5>
<p>While the general principle of tiling remains the same—partitioning large computations into smaller subproblems to improve memory reuse—there are different ways to apply tiling based on the structure of the computation and hardware constraints. The two primary tiling strategies are spatial tiling and temporal tiling. These strategies optimize different aspects of computation and memory access, and in practice, they are often combined to achieve the best performance.</p>
<section id="spatial-tiling" class="level6"><h6 class="anchored" data-anchor-id="spatial-tiling">Spatial Tiling</h6>
<p>Spatial tiling focuses on partitioning data structures into smaller blocks that fit within the fast memory of the processor. This approach ensures that each tile is fully processed before moving to the next, reducing redundant memory accesses. Spatial tiling is widely used in operations such as matrix multiplication, convolutions, and attention mechanisms in transformer models.</p>
<p>Returning to our tiled matrix multiplication example, we can see spatial tiling in action:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Tiled Matrix Multiplication (Spatial Tiling)</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>TILE_SIZE <span class="op">=</span> <span class="dv">32</span>  <span class="co"># Tile size chosen based on available fast memory</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, N, TILE_SIZE):</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, N, TILE_SIZE):</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, N, TILE_SIZE):</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Process a submatrix (tile) at a time</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> ii <span class="kw">in</span> <span class="bu">range</span>(i, i <span class="op">+</span> TILE_SIZE):</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> jj <span class="kw">in</span> <span class="bu">range</span>(j, j <span class="op">+</span> TILE_SIZE):</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> kk <span class="kw">in</span> <span class="bu">range</span>(k, k <span class="op">+</span> TILE_SIZE):</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>                        C[ii, jj] <span class="op">+=</span> A[ii, kk] <span class="op">*</span> B[kk, jj]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In this implementation, each tile of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is loaded into cache or shared memory before processing, ensuring that the same data does not need to be fetched repeatedly from slower memory. The tile is fully used before moving to the next block, minimizing redundant memory accesses. Since data is accessed in a structured, localized way, cache efficiency improves significantly.</p>
<p>Spatial tiling is particularly beneficial when dealing with large tensors that do not fit entirely in fast memory. By breaking them into smaller tiles, computations remain localized, avoiding excessive data movement between memory levels. This technique is widely used in AI accelerators where machine learning workloads involve large-scale tensor operations that require careful memory management to achieve high performance.</p>
</section><section id="temporal-tiling" class="level6"><h6 class="anchored" data-anchor-id="temporal-tiling">Temporal Tiling</h6>
<p>While spatial tiling optimizes how data is partitioned, temporal tiling focuses on reorganizing the computation itself to improve data reuse over time. Many machine learning workloads involve operations where the same data is accessed repeatedly across multiple iterations. Without temporal tiling, this often results in redundant memory fetches, leading to inefficiencies. Temporal tiling, also known as loop blocking, restructures the computation to ensure that frequently used data stays in fast memory for as long as possible before moving on to the next computation.</p>
<p>A classic example where temporal tiling is beneficial is convolutional operations, where the same set of weights is applied to multiple input regions. Without loop blocking, these weights might be loaded from memory multiple times for each computation. With temporal tiling, the computation is reordered so that the weights remain in fast memory across multiple inputs, reducing unnecessary memory fetches and improving overall efficiency.</p>
<p>A simplified example of loop blocking in matrix multiplication is shown below:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Matrix Multiplication with Temporal Tiling (Loop Blocking)</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, N, TILE_SIZE):</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, N, TILE_SIZE):</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, N, TILE_SIZE):</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Load tile into fast memory before computation</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>            A_tile <span class="op">=</span> A[i:i<span class="op">+</span>TILE_SIZE, k:k<span class="op">+</span>TILE_SIZE]</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>            B_tile <span class="op">=</span> B[k:k<span class="op">+</span>TILE_SIZE, j:j<span class="op">+</span>TILE_SIZE]</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> ii <span class="kw">in</span> <span class="bu">range</span>(TILE_SIZE):</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> jj <span class="kw">in</span> <span class="bu">range</span>(TILE_SIZE):</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> kk <span class="kw">in</span> <span class="bu">range</span>(TILE_SIZE):</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>                        C[i<span class="op">+</span>ii, j<span class="op">+</span>jj] <span class="op">+=</span> A_tile[ii, kk] <span class="op">*</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>                                         B_tile[kk, jj]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Temporal tiling improves performance by ensuring that the data loaded into fast memory is used multiple times before being evicted. In this implementation, small tiles of matrices <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are explicitly loaded into temporary storage before performing computations, reducing memory fetch overhead. This restructuring allows the computation to process an entire tile before moving to the next, thereby reducing the number of times data must be loaded from slower memory.</p>
<p>This technique is particularly useful in workloads where certain values are used repeatedly, such as convolutions, recurrent neural networks (RNNs), and self-attention mechanisms in transformers. By applying loop blocking, AI accelerators can significantly reduce memory stalls and improve execution throughput.</p>
</section></section><section id="tiling-challenges-and-trade-offs" class="level5"><h5 class="anchored" data-anchor-id="tiling-challenges-and-trade-offs">Tiling Challenges and Trade-offs</h5>
<p>While tiling significantly improves performance by optimizing memory reuse and reducing redundant memory accesses, it introduces several challenges and trade-offs. Selecting the right tile size is a critical decision, as it directly affects computational efficiency and memory bandwidth usage. If the tile size is too small, the benefits of tiling diminish, as memory fetches still dominate execution time. On the other hand, if the tile size is too large, it may exceed the available fast memory, causing cache thrashing and performance degradation.</p>
<p>Load balancing is another key concern. In architectures such as GPUs and TPUs, computations are executed in parallel across thousands of processing units. If tiles are not evenly distributed, some units may remain idle while others are overloaded, leading to suboptimal utilization of computational resources. Effective tile scheduling ensures that parallel execution remains balanced and efficient.</p>
<p>Data movement overhead is also an important consideration. Although tiling reduces the number of slow memory accesses, transferring tiles between different levels of memory still incurs a cost. This is especially relevant in hierarchical memory systems, where accessing data from cache is much faster than accessing it from DRAM. Efficient memory prefetching and scheduling strategies are required to minimize latency and ensure that data is available when needed.</p>
<p>Beyond spatial and temporal tiling, hybrid approaches combine elements of both strategies to achieve optimal performance. Hybrid tiling adapts to workload-specific constraints by dynamically adjusting tile sizes or reordering computations based on real-time execution conditions. For example, some AI accelerators use spatial tiling for matrix multiplications while employing temporal tiling for weight reuse in convolutional layers.</p>
<p>In addition to tiling, there are other methods for optimizing memory usage and computational efficiency. Techniques such as register blocking, double buffering, and hierarchical tiling extend the basic tiling principles to further optimize execution. AI compilers and runtime systems, such as TensorFlow XLA, TVM, and MLIR, automatically select tiling strategies based on hardware constraints, allowing for fine-tuned performance optimization without manual intervention.</p>
<p><a href="#tbl-tiling-strategies" class="quarto-xref">Table&nbsp;<span>11.16</span></a> provides a comparative overview of spatial, temporal, and hybrid tiling approaches, highlighting their respective benefits and trade-offs.</p>
<div id="tbl-tiling-strategies" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-tiling-strategies-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;11.16: Comparative analysis of spatial, temporal, and hybrid tiling strategies.
</figcaption><div aria-describedby="tbl-tiling-strategies-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 9%">
<col style="width: 36%">
<col style="width: 28%">
<col style="width: 25%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Aspect</th>
<th style="text-align: left;">Spatial Tiling (Data Tiling)</th>
<th style="text-align: left;">Temporal Tiling (Loop Blocking)</th>
<th style="text-align: left;">Hybrid Tiling</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Primary Goal</td>
<td style="text-align: left;">Reduce memory accesses by keeping data in fast memory longer</td>
<td style="text-align: left;">Increase data reuse across loop iterations</td>
<td style="text-align: left;">Adapt dynamically to workload constraints</td>
</tr>
<tr class="even">
<td style="text-align: left;">Optimization Focus</td>
<td style="text-align: left;">Partitioning data structures into smaller, memory-friendly blocks</td>
<td style="text-align: left;">Reordering computations to maximize reuse before eviction</td>
<td style="text-align: left;">Balancing spatial and temporal reuse strategies</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Memory Usage</td>
<td style="text-align: left;">Improves cache locality and reduces DRAM access</td>
<td style="text-align: left;">Keeps frequently used data in fast memory for multiple iterations</td>
<td style="text-align: left;">Minimizes data movement while ensuring high reuse</td>
</tr>
<tr class="even">
<td style="text-align: left;">Common Use Cases</td>
<td style="text-align: left;">Matrix multiplications, CNNs, self-attention in transformers</td>
<td style="text-align: left;">Convolutions, recurrent neural networks (RNNs), iterative computations</td>
<td style="text-align: left;">AI accelerators with hierarchical memory, mixed workloads</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Performance Gains</td>
<td style="text-align: left;">Reduced memory bandwidth requirements, better cache utilization</td>
<td style="text-align: left;">Lower memory fetch latency, improved data locality</td>
<td style="text-align: left;">Maximized efficiency across multiple hardware types</td>
</tr>
<tr class="even">
<td style="text-align: left;">Challenges</td>
<td style="text-align: left;">Requires careful tile size selection, inefficient for workloads with minimal spatial reuse</td>
<td style="text-align: left;">Can increase register pressure, requires loop restructuring</td>
<td style="text-align: left;">Complexity in tuning tile size and execution order dynamically</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Best When</td>
<td style="text-align: left;">Data is large and needs to be partitioned for efficient processing</td>
<td style="text-align: left;">The same data is accessed multiple times across iterations</td>
<td style="text-align: left;">Both data partitioning and iteration-based reuse are important</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>As machine learning models continue to grow in size and complexity, tiling remains a critical tool for improving hardware efficiency, ensuring that AI accelerators operate at their full potential. While manual tiling strategies can provide substantial benefits, modern compilers and hardware-aware optimization techniques further enhance performance by automatically selecting the most effective tiling strategies for a given workload.</p>
</section></section></section><section id="mapping-strategies-application" class="level3" data-number="11.6.2"><h3 data-number="11.6.2" class="anchored" data-anchor-id="mapping-strategies-application">
<span class="header-section-number">11.6.2</span> Mapping Strategies Application</h3>
<p>While the foundational mapping techniques we discussed apply broadly, their effectiveness varies based on the computational structure, data access patterns, and parallelization opportunities of different neural network architectures. Each architecture imposes distinct constraints on data movement, memory hierarchy, and computation scheduling, requiring tailored mapping strategies to optimize performance.</p>
<p>A structured approach to mapping is essential to address the combinatorial explosion of choices that arise when assigning computations to AI accelerators. Rather than treating each model as a separate optimization problem, we recognize that the same fundamental principles apply across different architectures—only their priority shifts based on workload characteristics. The goal is to systematically select and apply mapping strategies that maximize efficiency for different types of machine learning models.</p>
<p>To demonstrate these principles, we examine three representative AI workloads, each characterized by distinct computational demands. CNNs benefit from spatial data reuse, making weight-stationary execution and the application of tiling techniques especially effective. In contrast, Transformers are inherently memory-bound and rely on strategies such as efficient KV-cache management, fused attention mechanisms, and highly parallel execution to mitigate memory traffic. MLPs, which involve substantial matrix multiplication operations, demand the use of structured tiling, optimized weight layouts, and memory-aware execution to enhance overall performance.</p>
<p>Despite their differences, each of these models follows a common set of mapping principles, with variations in how optimizations are prioritized. The following table provides a structured mapping between different optimization strategies and their suitability for CNNs, Transformers, and MLPs. This table serves as a roadmap for selecting appropriate mapping strategies for different machine learning workloads.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 11%">
<col style="width: 9%">
<col style="width: 8%">
<col style="width: 7%">
<col style="width: 61%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Optimization Technique</th>
<th style="text-align: left;">CNNs</th>
<th style="text-align: left;">Transformers</th>
<th style="text-align: left;">MLPs</th>
<th style="text-align: left;">Rationale</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Dataflow Strategy</td>
<td style="text-align: left;">Weight Stationary</td>
<td style="text-align: left;">Activation Stationary</td>
<td style="text-align: left;">Weight Stationary</td>
<td style="text-align: left;">CNNs reuse filters across spatial locations; Transformers reuse activations (KV-cache); MLPs reuse weights across batches.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Memory-Aware Tensor Layouts</td>
<td style="text-align: left;">NCHW (Channel-Major)</td>
<td style="text-align: left;">NHWC (Row-Major)</td>
<td style="text-align: left;">NHWC</td>
<td style="text-align: left;">CNNs favor channel-major for convolution efficiency; Transformers and MLPs prioritize row-major for fast memory access.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Kernel Fusion</td>
<td style="text-align: left;">Convolution + Activation</td>
<td style="text-align: left;">Fused Attention</td>
<td style="text-align: left;">GEMM Fusion</td>
<td style="text-align: left;">CNNs optimize convolution+activation fusion; Transformers fuse attention mechanisms; MLPs benefit from fused matrix multiplications.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Tiling for Memory Efficiency</td>
<td style="text-align: left;">Spatial Tiling</td>
<td style="text-align: left;">Temporal Tiling</td>
<td style="text-align: left;">Blocked Tiling</td>
<td style="text-align: left;">CNNs tile along spatial dimensions; Transformers use loop blocking to improve sequence memory efficiency; MLPs use blocked tiling for large matrix multiplications.</td>
</tr>
</tbody>
</table>
<p>This table highlights that each machine learning model benefits from a different combination of optimization techniques, reinforcing the importance of tailoring execution strategies to the computational and memory characteristics of the workload.</p>
<p>In the following sections, we explore how these optimizations apply to each network type, explaining how CNNs, Transformers, and MLPs leverage specific mapping strategies to improve execution efficiency and hardware utilization.</p>
<section id="convolutional-neural-networks-1" class="level4"><h4 class="anchored" data-anchor-id="convolutional-neural-networks-1">Convolutional Neural Networks</h4>
<p>CNNs are characterized by their structured spatial computations, where small filters (or kernels) are repeatedly applied across an input feature map. This structured weight reuse makes weight stationary execution the most effective strategy for CNNs. Keeping filter weights in fast memory while streaming activations ensures that weights do not need to be repeatedly fetched from slower external memory, significantly reducing memory bandwidth demands. Since each weight is applied to multiple spatial locations, weight stationary execution maximizes arithmetic intensity and minimizes redundant memory transfers.</p>
<p>Memory-aware tensor layouts also play a critical role in CNN execution. Convolution operations benefit from a channel-major memory format, often represented as NCHW (batch, channels, height, width). This layout aligns with the access patterns of convolutions, enabling efficient memory coalescing on accelerators such as GPUs and TPUs. By storing data in a format that optimizes cache locality, accelerators can fetch contiguous memory blocks efficiently, reducing latency and improving throughput.</p>
<p>Kernel fusion is another important optimization for CNNs. In a typical machine learning pipeline, convolution operations are often followed by activation functions such as ReLU and batch normalization. Instead of treating these operations as separate computational steps, fusing them into a single kernel reduces intermediate memory writes and improves execution efficiency. This optimization minimizes memory bandwidth pressure by keeping intermediate values in registers rather than writing them to memory and fetching them back in subsequent steps.</p>
<p>Given the size of input images and feature maps, tiling is necessary to ensure that computations fit within fast memory hierarchies. Spatial tiling, where input feature maps are processed in smaller subregions, allows for efficient utilization of on-chip memory while avoiding excessive off-chip memory transfers. This technique ensures that input activations, weights, and intermediate outputs remain within high-speed caches or shared memory as long as possible, reducing memory stalls and improving overall performance.</p>
<p>Together, these optimizations ensure that CNNs make efficient use of available compute resources by maximizing weight reuse, optimizing memory access patterns, reducing redundant memory writes, and structuring computation to fit within fast memory constraints.</p>
</section><section id="transformer-architectures" class="level4"><h4 class="anchored" data-anchor-id="transformer-architectures">Transformer Architectures</h4>
<p>Unlike CNNs, which rely on structured spatial computations, Transformers process variable-length sequences and rely heavily on attention mechanisms. The primary computational bottleneck in Transformers is memory bandwidth, as attention mechanisms require frequent access to stored key-value pairs across multiple query vectors. Given this access pattern, activation stationary execution is the most effective strategy. By keeping key-value activations in fast memory and streaming query vectors dynamically, activation reuse is maximized while minimizing redundant memory fetches. This approach is critical in reducing bandwidth overhead, especially in long-sequence tasks such as natural language processing.</p>
<p>Memory layout optimization is equally important for Transformers. Unlike CNNs, which benefit from channel-major layouts, Transformers require efficient access to sequences of activations, making a row-major format (NHWC) the preferred choice. This layout ensures that activations are accessed contiguously in memory, reducing cache misses and improving memory coalescing for matrix multiplications.</p>
<p>Kernel fusion plays a key role in optimizing Transformer execution. In self-attention, multiple computational steps—including query-key dot products, softmax normalization, and weighted summation—can be fused into a single operation. Fused attention kernels eliminate intermediate memory writes by computing attention scores and performing weighted summations within a single execution step. This optimization significantly reduces memory traffic, particularly for large batch sizes and long sequences.</p>
<p>Due to the nature of sequence processing, tiling must be adapted to improve memory efficiency. Instead of spatial tiling, which is effective for CNNs, Transformers benefit from temporal tiling, where computations are structured to process sequence blocks efficiently. This method ensures that activations are loaded into fast memory in manageable chunks, reducing excessive memory transfers. Temporal tiling is particularly beneficial for long-sequence models, where the memory footprint of key-value activations grows significantly. By tiling sequences into smaller segments, memory locality is improved, enabling efficient cache utilization and reducing bandwidth pressure.</p>
<p>These optimizations collectively address the primary bottlenecks in Transformer models by prioritizing activation reuse, structuring memory layouts for efficient batched computations, fusing attention operations to reduce intermediate memory writes, and employing tiling techniques suited to sequence-based processing.</p>
</section><section id="multi-layer-perceptrons" class="level4"><h4 class="anchored" data-anchor-id="multi-layer-perceptrons">Multi-Layer Perceptrons</h4>
<p>MLPs primarily consist of fully connected layers, where large matrices of weights and activations are multiplied to produce output representations. Given this structure, weight stationary execution is the most effective strategy for MLPs. Similar to CNNs, MLPs benefit from keeping weights in local memory while streaming activations dynamically, as this ensures that weight matrices, which are typically reused across multiple activations in a batch, do not need to be frequently reloaded.</p>
<p>The preferred memory layout for MLPs aligns with that of Transformers, as matrix multiplications are more efficient when using a row-major (NHWC) format. Since activation matrices are processed in batches, this layout ensures that input activations are accessed efficiently without introducing memory fragmentation. By aligning tensor storage with compute-friendly memory access patterns, cache utilization is improved, reducing memory stalls.</p>
<p>Kernel fusion in MLPs is primarily applied to General Matrix Multiplication (GEMM) operations. Since dense layers are often followed by activation functions and bias additions, fusing these operations into a single computation step reduces memory traffic. GEMM fusion ensures that activations, weights, and biases are processed within a single optimized kernel, avoiding unnecessary memory writes and reloads.</p>
<p>To further improve memory efficiency, MLPs rely on blocked tiling strategies, where large matrix multiplications are divided into smaller sub-blocks that fit within the accelerator’s shared memory. This method ensures that frequently accessed portions of matrices remain in fast memory throughout computation, reducing external memory accesses. By structuring computations in a way that balances memory utilization with efficient parallel execution, blocked tiling minimizes bandwidth limitations and maximizes throughput.</p>
<p>These optimizations ensure that MLPs achieve high computational efficiency by structuring execution around weight reuse, optimizing memory layouts for dense matrix operations, reducing redundant memory writes through kernel fusion, and employing blocked tiling strategies to maximize on-chip memory utilization.</p>
</section></section><section id="hybrid-mapping-strategies" class="level3 page-columns page-full" data-number="11.6.3"><h3 data-number="11.6.3" class="anchored" data-anchor-id="hybrid-mapping-strategies">
<span class="header-section-number">11.6.3</span> Hybrid Mapping Strategies</h3>
<p>While general mapping strategies provide a structured framework for optimizing machine learning models, real-world architectures often involve diverse computational requirements that cannot be effectively addressed with a single, fixed approach. Hybrid mapping strategies allow AI accelerators to dynamically apply different optimizations to specific layers or components within a model, ensuring that each computation is executed with maximum efficiency.</p>
<p>Machine learning models typically consist of multiple layer types, each exhibiting distinct memory access patterns, data reuse characteristics, and parallelization opportunities. By tailoring mapping strategies to these specific properties, hybrid approaches achieve higher computational efficiency, improved memory bandwidth utilization, and reduced data movement overhead compared to a uniform mapping approach <span class="citation" data-cites="sze2020efficient">(<a href="../references.html#ref-sze2020efficient" role="doc-biblioref">Sze et al. 2017b</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-sze2020efficient" class="csl-entry" role="listitem">
Sze, Vivienne, Yu-Hsin Chen, Tien-Ju Yang, and Joel S. Emer. 2017b. <span>“Efficient Processing of Deep Neural Networks: A Tutorial and Survey.”</span> <em>Proceedings of the IEEE</em> 105 (12): 2295–2329. <a href="https://doi.org/10.1109/jproc.2017.2761740">https://doi.org/10.1109/jproc.2017.2761740</a>.
</div></div><section id="layer-specific-mapping" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="layer-specific-mapping">Layer-Specific Mapping</h4>
<p>Hybrid mapping strategies are particularly beneficial in models that combine spatially localized computations, such as convolutions, with fully connected operations, such as dense layers or attention mechanisms. These operations possess distinct characteristics that require different mapping strategies for optimal performance.</p>
<p>In convolutional neural networks, hybrid strategies are frequently employed to optimize performance. Specifically, weight stationary execution is applied to convolutional layers, ensuring that filters remain in local memory while activations are streamed dynamically. For fully connected layers, output stationary execution is utilized to minimize redundant memory writes during matrix multiplications. Additionally, kernel fusion is integrated to combine activation functions, batch normalization, and element wise operations into a single computational step, thereby reducing intermediate memory traffic. Collectively, these approaches enhance computational efficiency and memory utilization, contributing to the overall performance of the network.</p>
<p>Transformers employ several strategies to enhance performance by optimizing memory usage and computational efficiency. Specifically, they use activation stationary mapping in self-attention layers to maximize the reuse of stored key-value pairs, thereby reducing memory fetches. In feedforward layers, weight stationary mapping is applied to ensure that large weight matrices are efficiently reused across computations. Additionally, these models incorporate fused attention kernels that integrate softmax and weighted summation into a single computation step, significantly enhancing execution speed <span class="citation" data-cites="dao2022flashattention">(<a href="../references.html#ref-dao2022flashattention" role="doc-biblioref">Jacobs et al. 2002</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-dao2022flashattention" class="csl-entry" role="listitem">
Jacobs, David, Bas Rokers, Archisman Rudra, and Zili Liu. 2002. <span>“Fragment Completion in Humans and Machines.”</span> In <em>Advances in Neural Information Processing Systems 14</em>, 35:27–34. The MIT Press. <a href="https://doi.org/10.7551/mitpress/1120.003.0008">https://doi.org/10.7551/mitpress/1120.003.0008</a>.
</div></div><p>For multilayer perceptrons, hybrid mapping strategies are employed to optimize performance through a combination of techniques that enhance both memory efficiency and computational throughput. Specifically, weight stationary execution is utilized to maximize the reuse of weights across activations, ensuring that these frequently accessed parameters remain readily available and reduce redundant memory accesses. In addition, blocked tiling strategies are implemented for large matrix multiplications, which significantly improve cache locality by partitioning the computation into manageable sub-blocks that fit within fast memory. Complementing these approaches, general matrix multiplication fusion is applied, effectively reducing memory stalls by merging consecutive matrix multiplication operations with subsequent functional transformations. Collectively, these optimizations illustrate how tailored mapping strategies can systematically balance memory constraints with computational demands in multilayer perceptron architectures.</p>
<p>Hybrid mapping strategies are widely employed in vision transformers, which seamlessly integrate convolutional and self-attention operations. In these models, the patch embedding layer performs a convolution-like operation that benefits from weight stationary mapping <span class="citation" data-cites="Dosovitskiy2020ViT">(<a href="../references.html#ref-Dosovitskiy2020ViT" role="doc-biblioref">Dosovitskiy et al. 2020</a>)</span>. The self-attention layers, on the other hand, require activation stationary execution to efficiently reuse the key-value cache across multiple queries. Additionally, the MLP component leverages general matrix multiplication fusion and blocked tiling to execute dense matrix multiplications efficiently. This layer-specific optimization framework effectively balances memory locality with computational efficiency, rendering vision transformers particularly well-suited for AI accelerators.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Dosovitskiy2020ViT" class="csl-entry" role="listitem">
Dosovitskiy, Alexey, Lucas Beyer, Alexander Kolesnikov, Dirk Weissenborn, Xiaohua Zhai, Thomas Unterthiner, Mostafa Dehghani, et al. 2020. <span>“An Image Is Worth 16x16 Words: Transformers for Image Recognition at Scale.”</span> <em>International Conference on Learning Representations (ICLR)</em>, October. <a href="http://arxiv.org/abs/2010.11929v2">http://arxiv.org/abs/2010.11929v2</a>.
</div></div></section></section><section id="hybrid-strategies-hardware-implementations" class="level3" data-number="11.6.4"><h3 data-number="11.6.4" class="anchored" data-anchor-id="hybrid-strategies-hardware-implementations">
<span class="header-section-number">11.6.4</span> Hybrid Strategies Hardware Implementations</h3>
<p>Several modern AI accelerators incorporate hybrid mapping strategies to optimize execution by tailoring layer-specific techniques to the unique computational requirements of diverse neural network architectures. For example, Google TPUs employ weight stationary mapping for convolutional layers and activation stationary mapping for attention layers within transformer models, ensuring that the most critical data remains in fast memory. Likewise, NVIDIA GPUs leverage fused kernels alongside hybrid memory layouts, which enable the application of different mapping strategies within the same model to maximize performance. In addition, Graphcore IPUs dynamically select execution strategies on a per-layer basis to optimize memory access, thereby enhancing overall computational efficiency.</p>
<p>These real-world implementations illustrate how hybrid mapping strategies bridge the gap between different types of machine learning computations, ensuring that each layer executes with maximum efficiency. However, hardware support is essential for these techniques to be practical. Accelerators must provide architectural features such as programmable memory hierarchies, efficient interconnects, and specialized execution pipelines to fully exploit hybrid mapping.</p>
<p>Hybrid mapping provides a flexible and efficient approach to deep learning execution, enabling AI accelerators to adapt to the diverse computational requirements of modern architectures. By selecting the optimal mapping technique for each layer, hybrid strategies help reduce memory bandwidth constraints, improve data locality, and maximize parallelism.</p>
<p>While hybrid mapping strategies offer an effective way to optimize computations at a layer-specific level, they remain static design-time optimizations. In real-world AI workloads, execution conditions can change dynamically due to varying input sizes, memory contention, or hardware resource availability. Machine learning compilers and runtime systems extend these mapping techniques by introducing dynamic scheduling, memory optimizations, and automatic tuning mechanisms. These systems ensure that hybrid strategies are not just predefined execution choices, but rather adaptive mechanisms that allow deep learning workloads to operate efficiently across different accelerators and deployment environments. In the next section, we explore how machine learning compilers and runtime stacks enable these adaptive optimizations through just-in-time scheduling, memory-aware execution, and workload balancing strategies.</p>
</section></section><section id="compiler-support" class="level2 page-columns page-full" data-number="11.7"><h2 data-number="11.7" class="anchored" data-anchor-id="compiler-support">
<span class="header-section-number">11.7</span> Compiler Support</h2>
<p>The performance of machine learning acceleration depends not only on hardware capabilities but also on how efficiently models are translated into executable operations. The optimizations discussed earlier in this chapter—kernel fusion, tiling, memory scheduling, and data movement strategies—are essential for maximizing efficiency. However, these optimizations must be systematically applied before execution to ensure they align with hardware constraints and computational requirements.</p>
<p>This process is handled by machine learning compilers, which form the software stack responsible for bridging high-level model representations with low-level hardware execution. The compiler optimizes the model by restructuring computations, selecting efficient execution kernels, and placing operations in a way that maximizes hardware utilization <span class="citation" data-cites="chen_tvmlang_2018">(<a href="../references.html#ref-chen_tvmlang_2018" role="doc-biblioref">0001 et al. 2018a</a>)</span>.</p>
<div class="no-row-height column-margin column-container"></div><p>While traditional compilers are designed for general-purpose computing, machine learning workloads require specialized approaches due to their reliance on tensor computations, parallel execution, and memory-intensive operations. To understand how these systems differ, we first compare machine learning compilers to their traditional counterparts.</p>
<section id="ml-vs-traditional-compilers" class="level3 page-columns page-full" data-number="11.7.1"><h3 data-number="11.7.1" class="anchored" data-anchor-id="ml-vs-traditional-compilers">
<span class="header-section-number">11.7.1</span> ML vs Traditional Compilers</h3>
<p>Machine learning workloads introduce unique challenges that traditional compilers were not designed to handle. Unlike conventional software execution, which primarily involves sequential or multi-threaded program flow, machine learning models are expressed as computation graphs that describe large-scale tensor operations. These graphs require specialized optimizations that traditional compilers cannot efficiently apply <span class="citation" data-cites="cui_mlcompilers_2019">(<a href="../references.html#ref-cui_mlcompilers_2019" role="doc-biblioref">Cui, Li, and Xie 2019</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-cui_mlcompilers_2019" class="csl-entry" role="listitem">
Cui, Hongyi, Jiajun Li, and Peng et al. Xie. 2019. <span>“A Survey on Machine Learning Compilers: Taxonomy, Challenges, and Future Directions.”</span> <em>ACM Computing Surveys</em> 52 (4): 1–39.
</div></div><p><a href="#tbl-ml-vs-traditional-compilers" class="quarto-xref">Table&nbsp;<span>11.17</span></a> outlines the fundamental differences between traditional compilers and those designed for machine learning workloads. While traditional compilers optimize linear program execution through techniques like instruction scheduling and register allocation, ML compilers focus on optimizing computation graphs for efficient tensor operations. This distinction is critical, as ML compilers must incorporate domain-specific transformations such as kernel fusion, memory-aware scheduling, and hardware-accelerated execution plans to achieve high performance on specialized accelerators like GPUs and TPUs.</p>
<div id="tbl-ml-vs-traditional-compilers" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-ml-vs-traditional-compilers-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;11.17: Traditional vs.&nbsp;machine learning compilers and their optimization priorities.
</figcaption><div aria-describedby="tbl-ml-vs-traditional-compilers-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 40%">
<col style="width: 42%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Aspect</th>
<th style="text-align: left;">Traditional Compiler</th>
<th style="text-align: left;">Machine Learning Compiler</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Input Representation</td>
<td style="text-align: left;">Linear program code (C, Python)</td>
<td style="text-align: left;">Computational graph (ML models)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Execution Model</td>
<td style="text-align: left;">Sequential or multi-threaded execution</td>
<td style="text-align: left;">Massively parallel tensor-based execution</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Optimization Priorities</td>
<td style="text-align: left;">Instruction scheduling, loop unrolling, register allocation</td>
<td style="text-align: left;">Graph transformations, kernel fusion, memory-aware execution</td>
</tr>
<tr class="even">
<td style="text-align: left;">Memory Management</td>
<td style="text-align: left;">Stack and heap memory allocation</td>
<td style="text-align: left;">Tensor layout transformations, tiling, memory-aware scheduling</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Target Hardware</td>
<td style="text-align: left;">CPUs (general-purpose execution)</td>
<td style="text-align: left;">GPUs, TPUs, and custom accelerators</td>
</tr>
<tr class="even">
<td style="text-align: left;">Compilation Output</td>
<td style="text-align: left;">CPU-specific machine code</td>
<td style="text-align: left;">Hardware-specific execution plan (kernels, memory scheduling)</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>This comparison highlights why machine learning models require a different compilation approach. Instead of optimizing instruction-level execution, machine learning compilers must transform entire computation graphs, apply tensor-aware memory optimizations, and schedule operations across thousands of parallel processing elements. These requirements make traditional compiler techniques insufficient for modern deep learning workloads.</p>
</section><section id="ml-compilation-pipeline" class="level3 page-columns page-full" data-number="11.7.2"><h3 data-number="11.7.2" class="anchored" data-anchor-id="ml-compilation-pipeline">
<span class="header-section-number">11.7.2</span> ML Compilation Pipeline</h3>
<p>Machine learning models, as defined in frameworks such as TensorFlow and PyTorch, are initially represented in a high-level computation graph that describes operations on tensors. However, these representations are not directly executable on hardware accelerators such as GPUs, TPUs, and custom AI chips. To achieve efficient execution, models must go through a compilation process that transforms them into optimized execution plans suited for the target hardware <span class="citation" data-cites="tensorflow_xla_2020">(<a href="../references.html#ref-tensorflow_xla_2020" role="doc-biblioref">Brain 2020</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-tensorflow_xla_2020" class="csl-entry" role="listitem">
Brain, Google. 2020. <span>“XLA: Optimizing Compiler for Machine Learning.”</span> <em>TensorFlow Blog</em>. <a href="https://tensorflow.org/xla">https://tensorflow.org/xla</a>.
</div></div><p>The machine learning compilation workflow consists of several key stages, each responsible for applying specific optimizations that ensure minimal memory overhead, maximum parallel execution, and optimal compute utilization. These stages include:</p>
<ol type="1">
<li>
<strong>Graph Optimization</strong>: The computation graph is restructured to eliminate inefficiencies.</li>
<li>
<strong>Kernel Selection</strong>: Each operation is mapped to an optimized hardware-specific implementation.</li>
<li>
<strong>Memory Planning</strong>: Tensor layouts and memory access patterns are optimized to reduce bandwidth consumption.</li>
<li>
<strong>Computation Scheduling</strong>: Workloads are distributed across parallel processing elements to maximize hardware utilization.</li>
<li>
<strong>Code Generation</strong>: The optimized execution plan is translated into machine-specific instructions for execution.</li>
</ol>
<p>At each stage, the compiler applies theoretical optimizations discussed earlier—such as kernel fusion, tiling, data movement strategies, and computation placement—ensuring that these optimizations are systematically incorporated into the final execution plan.</p>
<p>By understanding this workflow, we can see how machine learning acceleration is realized not just through hardware improvements but also through compiler-driven software optimizations.</p>
</section><section id="graph-optimization" class="level3 page-columns page-full" data-number="11.7.3"><h3 data-number="11.7.3" class="anchored" data-anchor-id="graph-optimization">
<span class="header-section-number">11.7.3</span> Graph Optimization</h3>
<p>AI accelerators provide specialized hardware to speed up computation, but raw model representations are not inherently optimized for execution on these accelerators. Machine learning frameworks define models using high-level computation graphs, where nodes represent operations (such as convolutions, matrix multiplications, and activations), and edges define data dependencies. However, if executed as defined, these graphs often contain redundant operations, inefficient memory access patterns, and suboptimal execution sequences that can prevent the hardware from operating at peak efficiency.</p>
<p>For example, in a Transformer model, the self-attention mechanism involves repeated accesses to the same key-value pairs across multiple attention heads. If compiled naïvely, the model may reload the same data multiple times, leading to excessive memory traffic <span class="citation" data-cites="shoeybi_megatron_2020">(<a href="../references.html#ref-shoeybi_megatron_2020" role="doc-biblioref">Shoeybi et al. 2019a</a>)</span>. Similarly, in a Convolutional Neural Network (CNN), applying batch normalization and activation functions as separate operations after each convolution leads to unnecessary intermediate memory writes, increasing memory bandwidth usage. These inefficiencies are addressed during graph optimization, where the compiler restructures the computation graph to eliminate unnecessary operations and improve memory locality <span class="citation" data-cites="chen_tvmlang_2018">(<a href="../references.html#ref-chen_tvmlang_2018" role="doc-biblioref">0001 et al. 2018a</a>)</span>.</p>
<div class="no-row-height column-margin column-container"></div><p>The graph optimization phase of compilation is responsible for transforming this high-level computation graph into an optimized execution plan before it is mapped to hardware. Rather than requiring manual optimization, the compiler systematically applies transformations that improve data movement, reduce redundant computations, and restructure operations for efficient parallel execution <span class="citation" data-cites="nvidia_tensorRT_2021">(<a href="../references.html#ref-nvidia_tensorRT_2021" role="doc-biblioref">NVIDIA 2021</a>)</span>.</p>
<p>At this stage, the compiler is still working at a hardware-agnostic level, focusing on high-level restructuring that improves efficiency before more hardware-specific optimizations are applied later.</p>
<section id="computation-graph-optimization" class="level4"><h4 class="anchored" data-anchor-id="computation-graph-optimization">Computation Graph Optimization</h4>
<p>Graph optimization transforms the computation graph through a series of structured techniques designed to enhance execution efficiency. One key technique, which we discussed earlier, is kernel fusion, which merges consecutive operations to eliminate unnecessary memory writes and reduce the number of kernel launches. This approach is particularly effective in convolutional neural networks, where fusing convolution, batch normalization, and activation functions notably accelerates processing. Another important technique is computation reordering, which adjusts the execution order of operations to improve data locality and maximize parallel execution. For instance, in Transformer models, such reordering enables the reuse of cached key-value pairs rather than reloading them repeatedly from memory, thereby reducing latency.</p>
<p>Additionally, redundant computation elimination plays an important role. By identifying and removing duplicate or unnecessary operations, this method is especially beneficial in models with residual connections where common subexpressions might otherwise be redundantly computed. Furthermore, memory-aware dataflow adjustments enhance overall performance by refining tensor layouts and optimizing memory movement. For example, tiling matrix multiplications to meet the structural requirements of systolic arrays in TPUs ensures that hardware resources are utilized optimally. This combined approach not only reduces unnecessary processing but also aligns data storage and movement with the accelerator’s strengths, leading to efficient execution across diverse AI workloads. Together, these techniques prepare the model for acceleration by minimizing overhead and ensuring an optimal balance between computational and memory resources.</p>
</section><section id="ai-compilers-implementation" class="level4"><h4 class="anchored" data-anchor-id="ai-compilers-implementation">AI Compilers Implementation</h4>
<p>Modern AI compilers perform graph optimization through the use of automated pattern recognition and structured rewrite rules, systematically transforming computation graphs to maximize efficiency without manual intervention. For example, Google’s XLA (Accelerated Linear Algebra) in TensorFlow applies graph-level transformations such as fusion and layout optimizations that streamline execution on TPUs and GPUs. Similarly, TVM (Tensor Virtual Machine) not only refines tensor layouts and adjusts computational structures but also tunes execution strategies across diverse hardware backends, which is particularly beneficial for deploying models on embedded Tiny ML devices with strict memory constraints.</p>
<p>NVIDIA’s TensorRT, another specialized deep learning compiler, focuses on minimizing kernel launch overhead by fusing operations and optimizing execution scheduling on GPUs, thereby improving utilization and reducing inference latency in large-scale convolutional neural network applications. Additionally, MLIR (Multi-Level Intermediate Representation) facilitates flexible graph optimization across various AI accelerators by enabling multi-stage transformations that improve execution order and memory access patterns, thus easing the transition of models from CPU-based implementations to accelerator-optimized versions. These compilers preserve the mathematical integrity of the models while rewriting the computation graph to ensure that the subsequent hardware-specific optimizations can be effectively applied.</p>
</section><section id="graph-optimization-importance" class="level4"><h4 class="anchored" data-anchor-id="graph-optimization-importance">Graph Optimization Importance</h4>
<p>Graph optimization enables AI accelerators to operate at peak efficiency. Without this phase, even the most optimized hardware would be underutilized, as models would be executed in a way that introduces unnecessary memory stalls, redundant computations, and inefficient data movement. By systematically restructuring computation graphs, the compiler arranges operations for efficient execution that mitigates bottlenecks before mapping to hardware, minimizes memory movement to keep tensors in high-speed memory, and optimizes parallel execution to reduce unnecessary serialization while enhancing hardware utilization. For instance, without proper graph optimization, a large Transformer model running on an edge device may experience excessive memory stalls due to suboptimal data access patterns; however, through effective graph restructuring, the model can operate with significantly reduced memory bandwidth consumption and latency, thus enabling real-time inference on devices with constrained resources.</p>
<p>With the computation graph now fully optimized, the next step in compilation is kernel selection, where the compiler determines which hardware-specific implementation should be used for each operation. This ensures that the structured execution plan is translated into optimized low-level instructions for the target accelerator.</p>
</section></section><section id="kernel-selection" class="level3 page-columns page-full" data-number="11.7.4"><h3 data-number="11.7.4" class="anchored" data-anchor-id="kernel-selection">
<span class="header-section-number">11.7.4</span> Kernel Selection</h3>
<p>At this stage, the compiler translates the abstract operations in the computation graph into optimized low-level functions, ensuring that execution is performed as efficiently as possible given the constraints of the target accelerator. A kernel is a specialized implementation of a computational operation designed to run efficiently on a particular hardware architecture. Most accelerators, including GPUs, TPUs, and custom AI chips, provide multiple kernel implementations for the same operation, each optimized for different execution scenarios. Choosing the right kernel for each operation is essential for maximizing computational throughput, minimizing memory stalls, and ensuring that the accelerator’s specialized processing elements are fully utilized <span class="citation" data-cites="nvidia_tensorRT_2021">(<a href="../references.html#ref-nvidia_tensorRT_2021" role="doc-biblioref">NVIDIA 2021</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-chen_tvmlang_2018" class="csl-entry" role="listitem">
0001, Tianqi Chen, Thierry Moreau, Ziheng Jiang, Lianmin Zheng, Eddie Q. Yan, Haichen Shen, Meghan Cowan, et al. 2018a. <span>“TVM: An Automated End-to-End Optimizing Compiler for Deep Learning.”</span> In <em>13th USENIX Symposium on Operating Systems Design and Implementation (OSDI 18)</em>, 578–94. <a href="https://www.usenix.org/conference/osdi18/presentation/chen">https://www.usenix.org/conference/osdi18/presentation/chen</a>.
</div></div><p>Kernel selection builds upon the graph optimization phase, ensuring that the structured execution plan is mapped to the most efficient implementation available. While graph optimization eliminates inefficiencies at the model level, kernel selection ensures that each individual operation is executed using the most efficient hardware-specific routine. The effectiveness of this process directly impacts the model’s overall performance, as poor kernel choices can nullify the benefits of prior optimizations by introducing unnecessary computation overhead or memory bottlenecks <span class="citation" data-cites="chen_tvmlang_2018">(<a href="../references.html#ref-chen_tvmlang_2018" role="doc-biblioref">0001 et al. 2018a</a>)</span>.</p>
<p>In a Transformer model, the matrix multiplications that dominate self-attention computations can be executed using different strategies depending on the available hardware. On a CPU, a general-purpose matrix multiplication routine is typically employed, exploiting vectorized execution to improve efficiency. In contrast, on a GPU, the compiler may select an implementation that leverages tensor cores to accelerate matrix multiplications using mixed-precision arithmetic. When the model is deployed on a TPU, the operation can be mapped onto a systolic array, ensuring that data flows through the accelerator in a manner that maximizes reuse and minimizes off-chip memory accesses. Additionally, for inference workloads, an integer arithmetic kernel may be preferable, as it facilitates computations in INT8 instead of floating-point precision, thereby reducing power consumption without significantly compromising accuracy.</p>
<p>In many cases, compilers do not generate custom kernels from scratch but instead select from vendor-optimized kernel libraries that provide highly tuned implementations for different architectures. For instance, cuDNN and cuBLAS offer optimized kernels for deep learning on NVIDIA GPUs, while oneDNN provides optimized execution for Intel architectures. Similarly, ACL (Arm Compute Library) is optimized for Arm-based devices, and Eigen and BLIS provide efficient CPU-based implementations of deep learning operations. These libraries allow the compiler to choose pre-optimized, high-performance kernels rather than having to reinvent execution strategies for each hardware platform.</p>
<section id="kernel-selection-in-ai-compilers" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="kernel-selection-in-ai-compilers">Kernel Selection in AI Compilers</h4>
<p>AI compilers use heuristics, profiling, and cost models to determine the best kernel for each operation. These strategies ensure that each computation is executed in a way that maximizes throughput and minimizes memory bottlenecks.</p>
<p>In rule-based selection, the compiler applies predefined heuristics based on the known capabilities of the hardware. For instance, XLA, the compiler used in TensorFlow, automatically selects tensor core-optimized kernels for NVIDIA GPUs when mixed-precision execution is enabled. These predefined rules allow the compiler to make fast, reliable decisions about which kernel to use without requiring extensive analysis.</p>
<p>Profile-guided selection takes a more dynamic approach, benchmarking different kernel options and choosing the one that performs best for a given workload. TVM, an open-source AI compiler, uses AutoTVM to empirically evaluate kernel performance, tuning execution strategies based on real-world execution times. By testing different kernels before deployment, profile-guided selection helps ensure that operations are assigned to the most efficient implementation under actual execution conditions.</p>
<p>Another approach, cost model-based selection, relies on performance predictions to estimate execution time and memory consumption for various kernels before choosing the most efficient one. MLIR, a compiler infrastructure designed for machine learning workloads, applies this technique to determine the most effective tiling and memory access strategies <span class="citation" data-cites="mlir_framework_2021">(<a href="../references.html#ref-mlir_framework_2021" role="doc-biblioref">Lattner et al. 2020</a>)</span>. By modeling how different kernels interact with the accelerator’s compute units and memory hierarchy, the compiler can select the kernel that minimizes execution cost while maximizing performance.</p>
<div class="no-row-height column-margin column-container"><div id="ref-mlir_framework_2021" class="csl-entry" role="listitem">
Lattner, Chris, Mehdi Amini, Uday Bondhugula, Albert Cohen, Andy Davis, Jacques Pienaar, River Riddle, Tatiana Shpeisman, Nicolas Vasilache, and Oleksandr Zinenko. 2020. <span>“MLIR: A Compiler Infrastructure for the End of Moore’s Law.”</span> <em>arXiv Preprint arXiv:2002.11054</em>, February. <a href="http://arxiv.org/abs/2002.11054v2">http://arxiv.org/abs/2002.11054v2</a>.
</div></div><p>Many AI compilers also incorporate precision-aware kernel selection, where the selected kernel is optimized for specific numerical formats such as FP32, FP16, BF16, or INT8. Training workloads often prioritize higher precision (FP32, BF16) to maintain model accuracy, whereas inference workloads favor lower precision (FP16, INT8) to increase speed and reduce power consumption. For example, an NVIDIA GPU running inference with TensorRT can dynamically select FP16 or INT8 kernels based on a model’s accuracy constraints. This trade-off between precision and performance is a key aspect of kernel selection, especially when deploying models in resource-constrained environments.</p>
<p>Some compilers go beyond static kernel selection and implement adaptive kernel tuning, where execution strategies are adjusted at runtime based on the system’s workload and available resources. AutoTVM in TVM measures kernel performance across different workloads and dynamically refines execution strategies. TensorRT applies real-time optimizations based on batch size, memory constraints, and GPU load, adjusting kernel selection dynamically. Google’s TPU compiler takes a similar approach, optimizing kernel selection based on cloud resource availability and execution environment constraints.</p>
</section><section id="kernel-selection-importance" class="level4"><h4 class="anchored" data-anchor-id="kernel-selection-importance">Kernel Selection Importance</h4>
<p>The efficiency of AI acceleration depends not only on how computations are structured but also on how they are executed. Even the best-designed computation graph will fail to achieve peak performance if the selected kernels do not fully utilize the hardware’s capabilities.</p>
<p>Proper kernel selection allows models to execute using the most efficient algorithms available for the given hardware, ensuring that memory is accessed in a way that avoids unnecessary stalls and that specialized acceleration features, such as tensor cores or systolic arrays, are leveraged wherever possible. Selecting an inappropriate kernel can lead to underutilized compute resources, excessive memory transfers, and increased power consumption, all of which limit the performance of AI accelerators.</p>
<p>For instance, if a Transformer model running on a GPU is assigned a non-tensor-core kernel for its matrix multiplications, it may execute at only a fraction of the possible performance. Conversely, if a model designed for FP32 execution is forced to run on an INT8-optimized kernel, it may experience significant numerical instability, degrading accuracy. These choices illustrate why kernel selection is as much about maintaining numerical correctness as it is about optimizing performance.</p>
<p>With kernel selection complete, the next stage in compilation involves execution scheduling and memory management, where the compiler determines how kernels are launched and how data is transferred between different levels of the memory hierarchy. These final steps in the compilation pipeline ensure that computations run with maximum parallelism while minimizing the overhead of data movement. As kernel selection determines what to execute, execution scheduling and memory management dictate when and how those kernels are executed, ensuring that AI accelerators operate at peak efficiency.</p>
</section></section><section id="memory-planning" class="level3 page-columns page-full" data-number="11.7.5"><h3 data-number="11.7.5" class="anchored" data-anchor-id="memory-planning">
<span class="header-section-number">11.7.5</span> Memory Planning</h3>
<p>The memory planning phase ensures that data is allocated and accessed in a way that minimizes memory bandwidth consumption, reduces latency, and maximizes cache efficiency <span class="citation" data-cites="zhang2020optimizing">(<a href="../references.html#ref-zhang2020optimizing" role="doc-biblioref">Zhang, Li, and Ouyang 2020</a>)</span>. Even with the most optimized execution plan, a model can still suffer from severe performance degradation if memory is not managed efficiently.</p>
<div class="no-row-height column-margin column-container"><div id="ref-zhang2020optimizing" class="csl-entry" role="listitem">
Zhang, Y., J. Li, and H. Ouyang. 2020. <span>“Optimizing Memory Access for Deep Learning Workloads.”</span> <em>IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems</em> 39 (11): 2345–58.
</div></div><p>Machine learning workloads are often memory-intensive. They require frequent movement of large tensors between different levels of the memory hierarchy. The compiler must determine how tensors are stored, how they are accessed, and how intermediate results are handled to ensure that memory does not become a bottleneck.</p>
<p>The memory planning phase focuses on optimizing tensor layouts, memory access patterns, and buffer reuse to prevent unnecessary stalls and memory contention during execution. In this phase, tensors are arranged in a memory-efficient format that aligns with hardware access patterns, thereby minimizing the need for format conversions. Additionally, memory accesses are structured to reduce cache misses and stalls, which in turn lowers overall bandwidth consumption. Buffer reuse is also a critical aspect, as it reduces redundant memory allocations by intelligently managing intermediate results. Together, these strategies ensure that data is efficiently placed and accessed, thereby enhancing both computational performance and energy efficiency in AI workloads.</p>
<section id="memory-planning-in-ai-compilers" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="memory-planning-in-ai-compilers">Memory Planning in AI Compilers</h4>
<p>Memory planning is a complex problem because AI models must balance memory availability, reuse, and access efficiency while operating across multiple levels of the memory hierarchy. AI compilers use several key strategies to manage memory effectively and prevent unnecessary data movement.</p>
<p>The first step in memory planning is tensor layout optimization, where the compiler determines how tensors should be arranged in memory to maximize locality and prevent unnecessary data format conversions. Different hardware accelerators have different preferred storage layouts—for instance, NVIDIA GPUs often use row-major storage (NHWC format), while TPUs favor channel-major layouts (NCHW format) to optimize memory coalescing <span class="citation" data-cites="abadi2016tensorflow">(<a href="../references.html#ref-abadi2016tensorflow" role="doc-biblioref">Abadi et al. 2016</a>)</span>. The compiler automatically transforms tensor layouts based on the expected access patterns of the target hardware, ensuring that memory accesses are aligned for maximum efficiency.</p>
<div class="no-row-height column-margin column-container"><div id="ref-abadi2016tensorflow" class="csl-entry" role="listitem">
Abadi, M. et al. 2016. <span>“TensorFlow: A System for Large-Scale Machine Learning.”</span> <em>12th USENIX Symposium on Operating Systems Design and Implementation (OSDI 16)</em>, 265–83.
</div><div id="ref-moreau2018relay" class="csl-entry" role="listitem">
Jones, Gareth A. 2018. <span>“Joining Dessins Together.”</span> <em>arXiv Preprint arXiv:1810.03960</em>, October. <a href="http://arxiv.org/abs/1810.03960v1">http://arxiv.org/abs/1810.03960v1</a>.
</div></div><p>Beyond layout optimization, memory planning also includes buffer allocation and reuse, where the compiler minimizes memory footprint by reusing intermediate storage whenever possible. Deep learning workloads generate many temporary tensors, such as activations and gradients, which can quickly overwhelm on-chip memory if not carefully managed. Instead of allocating new memory for each tensor, the compiler analyzes the computation graph to identify opportunities for buffer reuse, ensuring that intermediate values are stored and overwritten efficiently <span class="citation" data-cites="moreau2018relay">(<a href="../references.html#ref-moreau2018relay" role="doc-biblioref">Jones 2018</a>)</span>.</p>
<p>Another critical aspect of memory planning is minimizing data movement between different levels of the memory hierarchy. AI accelerators typically have a mix of high-speed on-chip memory (such as caches or shared SRAM) and larger, but slower, external DRAM. If tensor data is repeatedly moved between these memory levels, the model may become memory-bound, reducing computational efficiency. To prevent this, compilers use tiling strategies that break large computations into smaller, memory-friendly chunks, allowing execution to fit within fast, local memory and reducing the need for costly off-chip memory accesses.</p>
</section><section id="memory-planning-importance" class="level4"><h4 class="anchored" data-anchor-id="memory-planning-importance">Memory Planning Importance</h4>
<p>Without proper memory planning, even the most optimized computation graph and kernel selection will fail to deliver high performance. Excessive memory transfers, inefficient memory layouts, and redundant memory allocations can all lead to bottlenecks that prevent AI accelerators from reaching their peak throughput.</p>
<p>For instance, a CNN running on a GPU may achieve high computational efficiency in theory, but if its convolutional feature maps are stored in an incompatible format—say, using a row-major layout that requires conversion to a channel-friendly format like NCHW or even a variant such as NHCW—constant tensor format conversions can introduce significant overhead. Similarly, a Transformer model deployed on an edge device may struggle to meet real-time inference requirements if memory is not carefully planned, leading to frequent off-chip memory accesses that increase latency and power consumption.</p>
<p>Through careful management of tensor placement, optimizing memory access patterns, and reducing unnecessary data movement, memory planning guarantees efficient operation of AI accelerators, leading to tangible performance improvements in real-world applications.</p>
</section></section><section id="computation-scheduling" class="level3 page-columns page-full" data-number="11.7.6"><h3 data-number="11.7.6" class="anchored" data-anchor-id="computation-scheduling">
<span class="header-section-number">11.7.6</span> Computation Scheduling</h3>
<p>With graph optimization completed, kernels selected, and memory planning finalized, the next step in the compilation pipeline is computation scheduling. This phase determines when and where each computation should be executed, ensuring that workloads are efficiently distributed across available processing elements while avoiding unnecessary stalls and resource contention <span class="citation" data-cites="Rajbhandari2020 Zheng2020">(<a href="../references.html#ref-Rajbhandari2020" role="doc-biblioref">Rajbhandari et al. 2020</a>; <a href="../references.html#ref-Zheng2020" role="doc-biblioref">Zheng et al. 2020</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Rajbhandari2020" class="csl-entry" role="listitem">
Rajbhandari, Samyam, Jeff Rasley, Olatunji Ruwase, and Yuxiong He. 2020. <span>“ZeRO: Memory Optimization Towards Training Trillion Parameter Models.”</span> <em>Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis (SC)</em>. <a href="https://doi.org/10.5555/3433701.3433721">https://doi.org/10.5555/3433701.3433721</a>.
</div><div id="ref-Zheng2020" class="csl-entry" role="listitem">
Zheng, Lianmin, Ziheng Jia, Yida Gao, Jiacheng Lin, Song Han, Xuehai Geng, Eric Zhao, and Tianqi Wu. 2020. <span>“Ansor: Generating High-Performance Tensor Programs for Deep Learning.”</span> <em>USENIX Symposium on Operating Systems Design and Implementation (OSDI)</em>, 863–79.
</div><div id="ref-Jia2019" class="csl-entry" role="listitem">
Jia, Ziheng, Nathan Tillman, Luis Vega, Po-An Ouyang, Matei Zaharia, and Joseph E. Gonzalez. 2019. <span>“Optimizing DNN Computation with Relaxed Graph Substitutions.”</span> <em>Conference on Machine Learning and Systems (MLSys)</em>.
</div></div><p>AI accelerators achieve high performance through massive parallelism, but without an effective scheduling strategy, computational units may sit idle, memory bandwidth may be underutilized, and execution efficiency may degrade. Computation scheduling is responsible for ensuring that all processing elements remain active, execution dependencies are managed correctly, and workloads are distributed optimally <span class="citation" data-cites="Jia2019">(<a href="../references.html#ref-Jia2019" role="doc-biblioref">Ziheng Jia et al. 2019</a>)</span>.</p>
<p>In the scheduling phase, parallel execution, synchronization, and resource allocation are managed systematically. Task partitioning decomposes extensive computations into smaller, manageable tasks that can be distributed efficiently among multiple compute cores. Execution order optimization then determines the most effective sequence for launching these operations, maximizing hardware performance while reducing execution stalls. Additionally, resource allocation and synchronization are orchestrated to ensure that compute cores, memory bandwidth, and shared caches are utilized effectively, avoiding contention. Through these coordinated strategies, computation scheduling achieves optimal hardware utilization, minimizes memory access delays, and supports a streamlined and efficient execution process.</p>
<section id="computation-scheduling-in-ai-compilers" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="computation-scheduling-in-ai-compilers">Computation Scheduling in AI Compilers</h4>
<p>Computation scheduling is highly dependent on the underlying hardware architecture, as different AI accelerators have unique execution models that must be considered when determining how workloads are scheduled. AI compilers implement several key strategies to optimize scheduling for efficient execution.</p>
<p>One of the most fundamental aspects of scheduling is task partitioning, where the compiler divides large computational graphs into smaller, manageable units that can be executed in parallel. On GPUs, this typically means mapping matrix multiplications and convolutions to thousands of CUDA cores, while on TPUs, tasks are partitioned to fit within systolic arrays that operate on structured data flows <span class="citation" data-cites="norrie2021design">(<a href="../references.html#ref-norrie2021design" role="doc-biblioref">Norrie et al. 2021</a>)</span>. In CPUs, partitioning is often focused on breaking computations into vectorized chunks that align with SIMD execution. The goal is to map workloads to available processing units efficiently, ensuring that each core remains active throughout execution.</p>
<div class="no-row-height column-margin column-container"><div id="ref-norrie2021design" class="csl-entry" role="listitem">
Norrie, Thomas, Nishant Patil, Doe Hyun Yoon, George Kurian, Sheng Li, James Laudon, Cliff Young, Norman Jouppi, and David Patterson. 2021. <span>“The Design Process for Google’s Training Chips: TPUv2 and TPUv3.”</span> <em>IEEE Micro</em> 41 (2): 56–63. <a href="https://doi.org/10.1109/mm.2021.3058217">https://doi.org/10.1109/mm.2021.3058217</a>.
</div><div id="ref-Shoeybi2019" class="csl-entry" role="listitem">
———. 2019b. <span>“Megatron-LM: Training Multi-Billion Parameter Language Models Using Model Parallelism.”</span> <em>arXiv Preprint arXiv:1909.08053</em>, September. <a href="http://arxiv.org/abs/1909.08053v4">http://arxiv.org/abs/1909.08053v4</a>.
</div></div><p>In addition to task partitioning, scheduling also involves optimizing execution order to minimize dependencies and maximize throughput. Many AI models include operations that can be computed independently (e.g., different batches in a batch processing pipeline) alongside operations that have strict dependencies (e.g., recurrent layers in an RNN). AI compilers analyze these dependencies and attempt to rearrange execution where possible, reducing idle time and improving parallel efficiency. For example, in Transformer models, scheduling may prioritize preloading attention matrices into memory while earlier layers are still executing, ensuring that data is ready when needed <span class="citation" data-cites="Shoeybi2019">(<a href="../references.html#ref-Shoeybi2019" role="doc-biblioref">Shoeybi et al. 2019b</a>)</span>.</p>
<p>Another crucial aspect of computation scheduling is resource allocation and synchronization, where the compiler determines how compute cores share memory and coordinate execution. Modern AI accelerators often support overlapping computation and data transfers, meaning that while one task executes, the next task can begin fetching its required data. Compilers take advantage of this by scheduling tasks in a way that hides memory latency, ensuring that execution remains compute-bound rather than memory-bound <span class="citation" data-cites="Chen2018">(<a href="../references.html#ref-Chen2018" role="doc-biblioref">0001 et al. 2018b</a>)</span>. TensorRT and XLA, for example, employ streaming execution strategies where multiple kernels are launched in parallel, and synchronization is carefully managed to prevent execution stalls <span class="citation" data-cites="GoogleXLA">(<a href="../references.html#ref-GoogleXLA" role="doc-biblioref">Google, n.d.</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Chen2018" class="csl-entry" role="listitem">
———, et al. 2018b. <span>“TVM: An Automated End-to-End Optimizing Compiler for Deep Learning.”</span> In <em>OSDI</em>, 578–94. <a href="https://www.usenix.org/conference/osdi18/presentation/chen">https://www.usenix.org/conference/osdi18/presentation/chen</a>.
</div><div id="ref-GoogleXLA" class="csl-entry" role="listitem">
Google. n.d. <span>“XLA: Optimizing Compiler for Machine Learning.”</span> &lt;https://www.tensorflow.org/xla&gt;.
</div></div></section><section id="computation-scheduling-importance" class="level4"><h4 class="anchored" data-anchor-id="computation-scheduling-importance">Computation Scheduling Importance</h4>
<p>Without effective scheduling, even the most optimized model can suffer from underutilized compute resources, memory bottlenecks, and execution inefficiencies. Poor scheduling decisions can lead to idle processing elements, forcing expensive compute cores to wait for data or synchronization events before continuing execution.</p>
<p>For instance, a CNN running on a GPU may have highly optimized kernels and efficient memory layouts, but if its execution is not scheduled correctly, compute units may remain idle between kernel launches, reducing throughput. Similarly, a Transformer model deployed on a TPU may perform matrix multiplications efficiently but could experience performance degradation if attention layers are not scheduled to overlap efficiently with memory transfers.</p>
<p>Effective computation scheduling occupies a central role in the orchestration of parallel workloads, ensuring that processing elements are utilized to their fullest capacity while preventing idle cores—a critical aspect for maximizing overall throughput. By strategically overlapping computation with data movement, the scheduling mechanism effectively conceals memory latency, thereby preventing operational stalls during data retrieval. Moreover, by resolving execution dependencies with precision, it minimizes waiting periods and enhances the concurrent progression of computation and data transfer. This systematic integration of scheduling and data handling serves to not only elevate performance but also exemplify the rigorous engineering principles that underpin modern accelerator design.</p>
</section><section id="code-generation" class="level4"><h4 class="anchored" data-anchor-id="code-generation">Code Generation</h4>
<p>Unlike the previous phases, which required AI-specific optimizations, code generation follows many of the same principles as traditional compilers. This process includes instruction selection, register allocation, and final optimization passes, ensuring that execution makes full use of hardware-specific features such as vectorized execution, memory prefetching, and instruction reordering.</p>
<p>For CPUs and GPUs, AI compilers typically generate machine code or optimized assembly instructions, while for TPUs, FPGAs, and other accelerators, the output may be optimized bytecode or execution graphs that are interpreted by the hardware’s runtime system.</p>
<p>At this point, the compilation pipeline is complete: the original high-level model representation has been transformed into an optimized, executable format tailored for efficient execution on the target hardware. The combination of graph transformations, kernel selection, memory-aware execution, and parallel scheduling ensures that AI accelerators run workloads with maximum efficiency, minimal memory overhead, and optimal computational throughput.</p>
</section></section><section id="compilation-runtime-support" class="level3" data-number="11.7.7"><h3 data-number="11.7.7" class="anchored" data-anchor-id="compilation-runtime-support">
<span class="header-section-number">11.7.7</span> Compilation-Runtime Support</h3>
<p>The compiler plays a fundamental role in AI acceleration, transforming high-level machine learning models into optimized execution plans tailored to the constraints of specialized hardware. Throughout this section, we have seen how graph optimization restructures computation, kernel selection maps operations to hardware-efficient implementations, memory planning optimizes data placement, and computation scheduling ensures efficient parallel execution. Each of these phases is crucial in enabling AI models to fully leverage modern accelerators, ensuring high throughput, minimal memory overhead, and efficient execution pipelines.</p>
<p>However, compilation alone is not enough to guarantee efficient execution in real-world AI workloads. While compilers statically optimize computation based on known model structures and hardware capabilities, AI execution environments are often dynamic and unpredictable. Batch sizes fluctuate, hardware resources may be shared across multiple workloads, and accelerators must adapt to real-time performance constraints. In these cases, a static execution plan is insufficient, and runtime management becomes critical in ensuring that models execute optimally under real-world conditions.</p>
<p>This transition from static compilation to adaptive execution is where AI runtimes come into play. Runtimes provide dynamic memory allocation, real-time kernel selection, workload scheduling, and multi-chip coordination, allowing AI models to adapt to varying execution conditions while maintaining efficiency. In the next section, we explore how AI runtimes extend the capabilities of compilers, enabling models to run effectively in diverse and scalable deployment scenarios.</p>
</section></section><section id="runtime-support" class="level2 page-columns page-full" data-number="11.8"><h2 data-number="11.8" class="anchored" data-anchor-id="runtime-support">
<span class="header-section-number">11.8</span> Runtime Support</h2>
<p>While compilers optimize AI models before execution, real-world deployment introduces dynamic and unpredictable conditions that static compilation alone cannot fully address <span class="citation" data-cites="nvidia_tensorRT_2021">(<a href="../references.html#ref-nvidia_tensorRT_2021" role="doc-biblioref">NVIDIA 2021</a>)</span>. AI workloads operate in varied execution environments, where factors such as fluctuating batch sizes, shared hardware resources, memory contention, and latency constraints necessitate real-time adaptation. Precompiled execution plans, optimized for a fixed set of assumptions, may become suboptimal when actual runtime conditions change.</p>
<div class="no-row-height column-margin column-container"><div id="ref-nvidia_tensorRT_2021" class="csl-entry" role="listitem">
NVIDIA. 2021. <span>“TensorRT: High-Performance Deep Learning Inference Library.”</span> <em>NVIDIA Developer Blog</em>. <a href="https://developer.nvidia.com/tensorrt">https://developer.nvidia.com/tensorrt</a>.
</div></div><p>To bridge this gap, AI runtimes provide a dynamic layer of execution management, extending the optimizations performed at compile time with real-time decision-making. Unlike traditional compiled programs that execute a fixed sequence of instructions, AI workloads require adaptive control over memory allocation, kernel execution, and resource scheduling. AI runtimes continuously monitor execution conditions and make on-the-fly adjustments to ensure that machine learning models fully utilize available hardware while maintaining efficiency and performance guarantees.</p>
<p>At a high level, AI runtimes manage three critical aspects of execution:</p>
<ol type="1">
<li>
<strong>Kernel Execution Management</strong>: AI runtimes dynamically select and dispatch computation kernels based on the current system state, ensuring that workloads are executed with minimal latency.</li>
<li>
<strong>Memory Adaptation and Allocation</strong>: Since AI workloads frequently process large tensors with varying memory footprints, runtimes adjust memory allocation dynamically to prevent bottlenecks and excessive data movement <span class="citation" data-cites="deepmind_gpipe_2019">(<a href="../references.html#ref-deepmind_gpipe_2019" role="doc-biblioref">Huang et al. 2019</a>)</span>.</li>
<li>
<strong>Execution Scaling</strong>: AI runtimes handle workload distribution across multiple accelerators, supporting large-scale execution in multi-chip, multi-node, or cloud environments <span class="citation" data-cites="mirhoseini_device_placement_2017">(<a href="../references.html#ref-mirhoseini_device_placement_2017" role="doc-biblioref">Mirhoseini et al. 2017</a>)</span>.</li>
</ol>
<div class="no-row-height column-margin column-container"><div id="ref-deepmind_gpipe_2019" class="csl-entry" role="listitem">
Huang, Yanping et al. 2019. <span>“GPipe: Efficient Training of Giant Neural Networks Using Pipeline Parallelism.”</span> In <em>Advances in Neural Information Processing Systems (NeurIPS)</em>.
</div><div id="ref-mirhoseini_device_placement_2017" class="csl-entry" role="listitem">
Mirhoseini, Azalia et al. 2017. <span>“Device Placement Optimization with Reinforcement Learning.”</span> <em>International Conference on Machine Learning (ICML)</em>.
</div></div><p>By dynamically handling these execution aspects, AI runtimes complement compiler-based optimizations, ensuring that models continue to perform efficiently under varying runtime conditions. The next section explores how AI runtimes differ from traditional software runtimes, highlighting why machine learning workloads require fundamentally different execution strategies compared to conventional CPU-based programs.</p>
<section id="ml-vs-traditional-runtimes" class="level3" data-number="11.8.1"><h3 data-number="11.8.1" class="anchored" data-anchor-id="ml-vs-traditional-runtimes">
<span class="header-section-number">11.8.1</span> ML vs Traditional Runtimes</h3>
<p>Traditional software runtimes are designed for managing general-purpose program execution, primarily handling sequential and multi-threaded workloads on CPUs. These runtimes allocate memory, schedule tasks, and optimize execution at the level of individual function calls and instructions. In contrast, AI runtimes are specialized for machine learning workloads, which require massively parallel computation, large-scale tensor operations, and dynamic memory management.</p>
<p><a href="#tbl-runtime-comparison" class="quarto-xref">Table&nbsp;<span>11.18</span></a> highlights the fundamental differences between traditional and AI runtimes. One of the key distinctions lies in execution flow. Traditional software runtimes operate on a predictable, structured execution model where function calls and CPU threads follow a predefined control path. AI runtimes, however, execute computational graphs, requiring complex scheduling decisions that account for dependencies between tensor operations, parallel kernel execution, and efficient memory access.</p>
<div id="tbl-runtime-comparison" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-runtime-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;11.18: Key differences between traditional and AI runtimes.
</figcaption><div aria-describedby="tbl-runtime-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 32%">
<col style="width: 46%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Aspect</th>
<th style="text-align: left;">Traditional Runtime</th>
<th style="text-align: left;">AI Runtime</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Execution Model</td>
<td style="text-align: left;">Sequential or multi-threaded execution</td>
<td style="text-align: left;">Massively parallel tensor execution</td>
</tr>
<tr class="even">
<td style="text-align: left;">Task Scheduling</td>
<td style="text-align: left;">CPU thread management</td>
<td style="text-align: left;">Kernel dispatch across accelerators</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Memory Management</td>
<td style="text-align: left;">Static allocation (stack/heap)</td>
<td style="text-align: left;">Dynamic tensor allocation, buffer reuse</td>
</tr>
<tr class="even">
<td style="text-align: left;">Optimization Priorities</td>
<td style="text-align: left;">Low-latency instruction execution</td>
<td style="text-align: left;">Minimizing memory stalls, maximizing parallel execution</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Adaptability</td>
<td style="text-align: left;">Mostly static execution plan</td>
<td style="text-align: left;">Adapts to batch size and hardware availability</td>
</tr>
<tr class="even">
<td style="text-align: left;">Target Hardware</td>
<td style="text-align: left;">CPUs (general-purpose execution)</td>
<td style="text-align: left;">GPUs, TPUs, and custom accelerators</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Memory management is another major differentiator. Traditional software runtimes handle small, frequent memory allocations, optimizing for cache efficiency and low-latency access. AI runtimes, in contrast, must dynamically allocate, reuse, and optimize large tensors, ensuring that memory access patterns align with accelerator-friendly execution. Poor memory management in AI workloads can lead to performance bottlenecks, particularly due to excessive off-chip memory transfers and inefficient cache usage.</p>
<p>Moreover, AI runtimes are inherently designed for adaptability. While traditional runtimes often follow a mostly static execution plan, AI workloads typically operate in highly variable execution environments, such as cloud-based accelerators or multi-tenant hardware. As a result, AI runtimes must continuously adjust batch sizes, reallocate compute resources, and manage real-time scheduling decisions to maintain high throughput and minimize execution delays.</p>
<p>These distinctions demonstrate why AI runtimes require fundamentally different execution strategies compared to traditional software runtimes. Rather than simply managing CPU processes, AI runtimes must oversee large-scale tensor execution, multi-device coordination, and real-time workload adaptation to ensure that machine learning models can run efficiently under diverse and ever-changing deployment conditions.</p>
</section><section id="dynamic-kernel-execution" class="level3" data-number="11.8.2"><h3 data-number="11.8.2" class="anchored" data-anchor-id="dynamic-kernel-execution">
<span class="header-section-number">11.8.2</span> Dynamic Kernel Execution</h3>
<p>Dynamic kernel execution is the process of mapping machine learning models to hardware and optimizing runtime execution. While static compilation provides a solid foundation, efficient execution of machine learning workloads requires real-time adaptation to fluctuating conditions such as available memory, data sizes, and computational loads. The runtime functions as an intermediary that continuously adjusts execution strategies to match both the constraints of the underlying hardware and the characteristics of the workload.</p>
<p>When mapping a machine learning model to hardware, individual computational operations —such as matrix multiplications, convolutions, and activation functions—must be assigned to the most appropriate processing units. This mapping is not fixed; it must be modified during runtime in response to changes in input data, memory availability, and overall system load. Dynamic kernel execution allows the runtime to make real-time decisions regarding kernel selection, execution order, and memory management, ensuring that workloads remain efficient despite these changing conditions.</p>
<p>For example, consider an AI accelerator executing a deep neural network (DNN) for image classification. If an incoming batch of high-resolution images requires significantly more memory than expected, a statically planned execution may cause cache thrashing or excessive off-chip memory accesses. Instead, a dynamic runtime can adjust tiling strategies on the fly, breaking down tensor operations into smaller tiles that fit within the high-speed on-chip memory. This prevents memory stalls and ensures optimal utilization of caches.</p>
<p>Similarly, when running a transformer-based natural language processing (NLP) model, the sequence length of input text may vary between inference requests. A static execution plan optimized for a fixed sequence length may lead to underutilization of compute resources when processing shorter sequences or excessive memory pressure with longer sequences. Dynamic kernel execution can mitigate this by selecting different kernel implementations based on the actual sequence length, dynamically adjusting memory allocations and execution strategies to maintain efficiency.</p>
<p>Moreover, overlapping computation with memory movement is a vital strategy to mitigate performance bottlenecks. AI workloads often encounter delays due to memory-bound issues, where data movement between memory hierarchies limits computation speed. To combat this, AI runtimes implement techniques like asynchronous execution and double buffering, ensuring that computations proceed without waiting for memory transfers to complete. In a large-scale model, for instance, image data can be prefetched while computations are performed on the previous batch, thus maintaining a steady flow of data and avoiding pipeline stalls.</p>
<p>Another practical example is the execution of convolutional layers in a CNN on a GPU. If multiple convolution kernels need to be scheduled, a static scheduling approach may lead to inefficient resource utilization due to variation in layer sizes and compute requirements. By dynamically scheduling kernel execution, AI runtimes can prioritize smaller kernels when compute units are partially occupied, improving hardware utilization. For instance, in NVIDIA’s TensorRT runtime, fusion of small kernels into larger execution units is done dynamically to avoid launch overhead, optimizing latency-sensitive inference tasks.</p>
<p>Dynamic kernel execution plays an essential role in ensuring that machine learning models are executed efficiently. By dynamically adjusting execution strategies in response to real-time system conditions, AI runtimes optimize both training and inference performance across various hardware platforms.</p>
</section><section id="runtime-kernel-selection" class="level3 page-columns page-full" data-number="11.8.3"><h3 data-number="11.8.3" class="anchored" data-anchor-id="runtime-kernel-selection">
<span class="header-section-number">11.8.3</span> Runtime Kernel Selection</h3>
<p>While compilers may perform an initial selection of kernels based on static analysis of the machine learning model and hardware target, AI runtimes often need to override these decisions during execution. Real-time factors, such as available memory, hardware utilization, and workload priorities, may differ significantly from the assumptions made during compilation. By dynamically selecting and switching kernels at runtime, AI runtimes can adapt to these changing conditions, ensuring that models continue to perform efficiently.</p>
<p>For instance, consider transformer-based language models, where a significant portion of execution time is spent on matrix multiplications. The AI runtime must determine the most efficient way to execute these operations based on the current system state. If the model is running on a GPU with specialized Tensor Cores, the runtime may switch from a standard FP32 kernel to an FP16 kernel to take advantage of hardware acceleration <span class="citation" data-cites="shoeybi_megatron_2020">(<a href="../references.html#ref-shoeybi_megatron_2020" role="doc-biblioref">Shoeybi et al. 2019a</a>)</span>. Conversely, if the lower precision of FP16 causes unacceptable numerical instability, the runtime can opt for mixed-precision execution, selectively using FP32 where higher precision is necessary.</p>
<div class="no-row-height column-margin column-container"><div id="ref-shoeybi_megatron_2020" class="csl-entry" role="listitem">
Shoeybi, Mohammad, Mostofa Patwary, Raul Puri, Patrick LeGresley, Jared Casper, and Bryan Catanzaro. 2019a. <span>“Megatron-LM: Training Multi-Billion Parameter Language Models Using Model Parallelism.”</span> <em>arXiv Preprint arXiv:1909.08053</em>, September. <a href="http://arxiv.org/abs/1909.08053v4">http://arxiv.org/abs/1909.08053v4</a>.
</div></div><p>Memory constraints also influence kernel selection. When memory bandwidth is limited, the runtime may adjust its execution strategy, reordering operations or changing the tiling strategy to fit computations into the available cache rather than relying on slower main memory. For example, a large matrix multiplication may be broken into smaller chunks, ensuring that the computation fits into the on-chip memory of the GPU, reducing overall latency.</p>
<p>Additionally, batch size can influence kernel selection. For workloads that handle a mix of small and large batches, the AI runtime may choose a latency-optimized kernel for small batches and a throughput-optimized kernel for large-scale batch processing. This adjustment ensures that the model continues to operate efficiently across different execution scenarios, without the need for manual tuning.</p>
</section><section id="kernel-scheduling-and-utilization" class="level3 page-columns page-full" data-number="11.8.4"><h3 data-number="11.8.4" class="anchored" data-anchor-id="kernel-scheduling-and-utilization">
<span class="header-section-number">11.8.4</span> Kernel Scheduling and Utilization</h3>
<p>Once the AI runtime selects an appropriate kernel, the next step is scheduling it in a way that maximizes parallelism and resource utilization. Unlike traditional task schedulers, which are designed to manage CPU threads, AI runtimes must coordinate a much larger number of tasks across parallel execution units such as GPU cores, tensor processing units, or custom AI accelerators <span class="citation" data-cites="google_tpu_2017">(<a href="../references.html#ref-google_tpu_2017" role="doc-biblioref">Jouppi et al. 2017</a>)</span>. Effective scheduling ensures that these computational resources are kept fully engaged, preventing bottlenecks and maximizing throughput.</p>
<div class="no-row-height column-margin column-container"><div id="ref-google_tpu_2017" class="csl-entry" role="listitem">
Jouppi, Norman P. et al. 2017. <span>“In-Datacenter Performance Analysis of a Tensor Processing Unit.”</span> <em>Proceedings of the 44th Annual International Symposium on Computer Architecture (ISCA)</em>.
</div></div><p>For example, in image recognition models that use convolutional layers, operations can be distributed across multiple processing units, enabling different filters to run concurrently. This parallelization ensures that the available hardware is fully utilized, speeding up execution. Similarly, batch normalization and activation functions must be scheduled efficiently to avoid unnecessary delays. If these operations are not interleaved with other computations, they may block the pipeline and reduce overall throughput.</p>
<p>Efficient kernel scheduling can also be influenced by real-time memory management . AI runtimes ensure that intermediate data, such as feature maps in deep neural networks, are preloaded into cache before they are needed. This proactive management helps prevent delays caused by waiting for data to be loaded from slower memory tiers, ensuring continuous execution.</p>
<p>These techniques enable AI runtimes to ensure optimal resource utilization and efficient parallel computation, which are essential for the high-performance execution of machine learning models, particularly in environments that require scaling across multiple hardware accelerators.</p>
</section></section><section id="multi-chip-ai-acceleration" class="level2 page-columns page-full" data-number="11.9"><h2 data-number="11.9" class="anchored" data-anchor-id="multi-chip-ai-acceleration">
<span class="header-section-number">11.9</span> Multi-Chip AI Acceleration</h2>
<p>Modern AI workloads increasingly demand computational resources that exceed the capabilities of single-chip accelerators. This section examines how AI systems scale from individual processors to multi-chip architectures, analyzing the motivation behind different scaling approaches and their impact on system design. By understanding this progression, we can better appreciate how each component of the AI hardware stack—from compute units to memory systems—must adapt to support large-scale machine learning workloads.</p>
<p>The scaling of AI systems follows a natural progression, starting with integration within a single package through chiplet architectures, extending to multi-GPU configurations within a server, expanding to distributed accelerator pods, and culminating in wafer-scale integration. Each approach presents unique trade-offs between computational density, communication overhead, and system complexity. For instance, chiplet architectures maintain high-speed interconnects within a package, while distributed systems sacrifice communication latency for massive parallelism.</p>
<p>Understanding these scaling strategies is essential for several reasons. First, it provides insight into how different hardware architectures address the growing computational demands of AI workloads. Second, it reveals the fundamental challenges that arise when extending beyond single-chip execution, such as managing inter-chip communication and coordinating distributed computation. Finally, it establishes the foundation for subsequent discussions on how mapping strategies, compilation techniques, and runtime systems evolve to support efficient execution at scale.</p>
<section id="chiplet-based-architectures" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="chiplet-based-architectures">Chiplet-Based Architectures</h4>
<p>The first step in scaling AI accelerators is to move beyond a single monolithic chip while still maintaining a compact, tightly integrated design. Chiplet architectures achieve this by partitioning large designs into smaller, modular dies that are interconnected within a single package.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure"><p><a href="images/png/chiplets.png" class="lightbox" data-gallery="quarto-lightbox-gallery-5" title="AMD’s chiplet-based architecture."><img src="images/png/chiplets.png" class="img-fluid figure-img" alt="AMD’s chiplet-based architecture."></a></p>
<figcaption>AMD’s chiplet-based architecture.</figcaption></figure>
</div>
<p>Modern AI accelerators, such as AMD’s Instinct MI300, take this approach by integrating multiple compute chiplets alongside memory chiplets, linked by high-speed die-to-die interconnects <span class="citation" data-cites="Kannan2023chiplet">(<a href="../references.html#ref-Kannan2023chiplet" role="doc-biblioref">Kannan, Dubey, and Horowitz 2023</a>)</span>. This modular design allows manufacturers to bypass the manufacturing limits of monolithic chips while still achieving high-density compute.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Kannan2023chiplet" class="csl-entry" role="listitem">
Kannan, Harish, Pradeep Dubey, and Mark Horowitz. 2023. <span>“Chiplet-Based Architectures: The Future of AI Accelerators.”</span> <em>IEEE Micro</em> 43 (1): 46–55. <a href="https://doi.org/10.1109/MM.2022.1234567">https://doi.org/10.1109/MM.2022.1234567</a>.
</div></div><p>However, even within a single package, scaling is not without challenges. Inter-chiplet communication latency, memory coherence, and thermal management become critical factors as more chiplets are integrated. Unlike traditional multi-chip systems, chiplet-based designs must carefully balance latency-sensitive workloads across multiple dies without introducing excessive bottlenecks.</p>
</section><section id="multi-gpu-systems" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="multi-gpu-systems">Multi-GPU Systems</h4>
<p>Beyond chiplet-based designs, AI workloads often require multiple discrete GPUs working together. In multi-GPU systems, each accelerator has its own dedicated memory and compute resources, but they must efficiently share data and synchronize execution.</p>
<p>A common example is NVIDIA DGX systems, which integrate multiple GPUs connected via NVLink or PCIe. This architecture enables workloads to be split across GPUs, typically using data parallelism (where each GPU processes a different batch of data) or model parallelism (where different GPUs handle different parts of a neural network) <span class="citation" data-cites="Ben-Nun2019data">(<a href="../references.html#ref-Ben-Nun2019data" role="doc-biblioref">Ben-Nun and Hoefler 2019</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Ben-Nun2019data" class="csl-entry" role="listitem">
Ben-Nun, Tal, and Torsten Hoefler. 2019. <span>“Demystifying Parallel and Distributed Deep Learning: An in-Depth Concurrency Analysis.”</span> <em>ACM Computing Surveys</em> 52 (4): 1–43. <a href="https://doi.org/10.1145/3320060">https://doi.org/10.1145/3320060</a>.
</div></div><p>As illustrated in <a href="#fig-multi-gpu" class="quarto-xref">Figure&nbsp;<span>11.7</span></a>, NVSwitch interconnects enable high-speed communication between GPUs, reducing bottlenecks in distributed training. However, scaling up the number of GPUs introduces new challenges. Cross-GPU communication bandwidth, memory consistency, and workload scheduling become critical constraints, particularly for large-scale models requiring frequent data exchanges. Unlike chiplets, which leverage high-speed die-to-die interconnects, discrete GPUs rely on external links, incurring higher latency and synchronization overhead.</p>
<div id="fig-multi-gpu" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-env="figure" data-fig-pos="htb">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-multi-gpu-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="sourceCode" id="cb31"><pre class="sourceCode tikz code-with-copy"><code class="sourceCode latex"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="kw">\begin</span>{<span class="ex">tikzpicture</span>}[font=<span class="fu">\usefont</span>{T1}{phv}{m}{n}<span class="fu">\small</span>]</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="fu">\tikzset</span>{<span class="co">%</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>myline/.style={line width=0.5pt,draw=black!40,latex-},</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>mylineR/.style={line width=0.75pt,draw=red},</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="co">%</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>helvetica/.style={align=flush center,font=<span class="fu">\usefont</span>{T1}{phv}{m}{n}},</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="co">%</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>  Box/.style={helvetica,</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>    inner xsep=2pt,</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>    draw=RedLine,</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>    line width=0.75pt,</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>    fill=RedL!20,</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>    minimum width=20mm, minimum height=20mm</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>  },</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a><span class="co">%</span></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>  Box2/.style={helvetica,</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>    inner xsep=2pt,</span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>    draw=GreenLine,</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>    line width=0.75pt,</span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>    fill=GreenL,</span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>    minimum width=20mm, minimum height=10mm</span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>  },</span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a><span class="co">%</span></span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a>Line/.style={line width=1.0pt,black!50}</span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a><span class="fu">\definecolor</span>{CPU}{RGB}{0,120,176}</span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a><span class="kw">\begin</span>{<span class="ex">scope</span>}[local bounding box = CPU1]]</span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[fill=CPU,minimum width=66, minimum height=66,</span>
<span id="cb31-30"><a href="#cb31-30" aria-hidden="true" tabindex="-1"></a>            rounded corners=8] (C1) {};</span>
<span id="cb31-31"><a href="#cb31-31" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[fill=white,minimum width=54, minimum height=54] (C2) {};</span>
<span id="cb31-32"><a href="#cb31-32" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[fill=CPU!40,minimum width=44, minimum height=44] (C3) {CPU};</span>
<span id="cb31-33"><a href="#cb31-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-34"><a href="#cb31-34" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\x</span>/<span class="fu">\y</span> in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{</span>
<span id="cb31-35"><a href="#cb31-35" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[fill=CPU,minimum width=3, minimum height=15,outer sep=2pt,</span>
<span id="cb31-36"><a href="#cb31-36" aria-hidden="true" tabindex="-1"></a>           inner sep=0pt,anchor=south](GO<span class="fu">\y</span>)at(<span class="ss">$(C1.north west)!</span><span class="sc">\x</span><span class="ss">!(C1.north east)$</span>){};</span>
<span id="cb31-37"><a href="#cb31-37" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-38"><a href="#cb31-38" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\x</span>/<span class="fu">\y</span> in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{</span>
<span id="cb31-39"><a href="#cb31-39" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[fill=CPU,minimum width=3, minimum height=15,outer sep=2pt,</span>
<span id="cb31-40"><a href="#cb31-40" aria-hidden="true" tabindex="-1"></a>            inner sep=0pt,anchor=north](DO<span class="fu">\y</span>)at(<span class="ss">$(C1.south west)!</span><span class="sc">\x</span><span class="ss">!(C1.south east)$</span>){};</span>
<span id="cb31-41"><a href="#cb31-41" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-42"><a href="#cb31-42" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\x</span>/<span class="fu">\y</span> in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{</span>
<span id="cb31-43"><a href="#cb31-43" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[fill=CPU,minimum width=15, minimum height=3,outer sep=2pt,</span>
<span id="cb31-44"><a href="#cb31-44" aria-hidden="true" tabindex="-1"></a>            inner sep=0pt,anchor=east](LE<span class="fu">\y</span>)at(<span class="ss">$(C1.north west)!</span><span class="sc">\x</span><span class="ss">!(C1.south west)$</span>){};</span>
<span id="cb31-45"><a href="#cb31-45" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-46"><a href="#cb31-46" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\x</span>/<span class="fu">\y</span> in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{</span>
<span id="cb31-47"><a href="#cb31-47" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[fill=CPU,minimum width=15, minimum height=3,outer sep=2pt,</span>
<span id="cb31-48"><a href="#cb31-48" aria-hidden="true" tabindex="-1"></a>            inner sep=0pt,anchor=west](DE<span class="fu">\y</span>)at(<span class="ss">$(C1.north east)!</span><span class="sc">\x</span><span class="ss">!(C1.south east)$</span>){};</span>
<span id="cb31-49"><a href="#cb31-49" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-50"><a href="#cb31-50" aria-hidden="true" tabindex="-1"></a><span class="co">%%</span></span>
<span id="cb31-51"><a href="#cb31-51" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[draw=CPU,minimum width=45, minimum height=66,</span>
<span id="cb31-52"><a href="#cb31-52" aria-hidden="true" tabindex="-1"></a>          anchor=east,align=center,line width=1pt](SYS)at(<span class="ss">$(LE1.west)!0.5!(LE6.west)$</span>){System<span class="fu">\\</span> RAM};</span>
<span id="cb31-53"><a href="#cb31-53" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[draw=CPU,minimum width=66, minimum height=26,</span>
<span id="cb31-54"><a href="#cb31-54" aria-hidden="true" tabindex="-1"></a>          anchor=south,align=center,line width=1pt](CPU)at(<span class="ss">$(GO1.north)!0.5!(GO6.north)$</span>){CPU<span class="fu">\\</span> Interconnect};</span>
<span id="cb31-55"><a href="#cb31-55" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[draw=CPU,minimum width=66, minimum height=26,</span>
<span id="cb31-56"><a href="#cb31-56" aria-hidden="true" tabindex="-1"></a>          anchor=north,align=center,line width=1pt,rotate=90](PCI)at(<span class="ss">$(DE1.east)!0.5!(DE6.east)$</span>){PCIe<span class="fu">\\</span> Interconnect};</span>
<span id="cb31-57"><a href="#cb31-57" aria-hidden="true" tabindex="-1"></a><span class="kw">\end</span>{<span class="ex">scope</span>}</span>
<span id="cb31-58"><a href="#cb31-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-59"><a href="#cb31-59" aria-hidden="true" tabindex="-1"></a><span class="kw">\begin</span>{<span class="ex">scope</span>}[node distance=0.5,shift={(5.0,3.8)},local bounding box = SGPU1]</span>
<span id="cb31-60"><a href="#cb31-60" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box](GPU1){GPU};</span>
<span id="cb31-61"><a href="#cb31-61" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box,below=of GPU1](GPU2){GPU};</span>
<span id="cb31-62"><a href="#cb31-62" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box,below=of GPU2](GPU3){GPU};</span>
<span id="cb31-63"><a href="#cb31-63" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box,below=of GPU3](GPU4){GPU};</span>
<span id="cb31-64"><a href="#cb31-64" aria-hidden="true" tabindex="-1"></a><span class="kw">\end</span>{<span class="ex">scope</span>}</span>
<span id="cb31-65"><a href="#cb31-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-66"><a href="#cb31-66" aria-hidden="true" tabindex="-1"></a><span class="kw">\begin</span>{<span class="ex">scope</span>}[node distance=0.45,shift={(9,4.15)},local bounding box = NVS]</span>
<span id="cb31-67"><a href="#cb31-67" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box2](NVS1){NVSwitch};</span>
<span id="cb31-68"><a href="#cb31-68" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box2,below=of NVS1](NVS2){NVSwitch};</span>
<span id="cb31-69"><a href="#cb31-69" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box2,below=of NVS2](NVS3){NVSwitch};</span>
<span id="cb31-70"><a href="#cb31-70" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box2,node distance=1.3,,below=of NVS3](NVS4){NVSwitch};</span>
<span id="cb31-71"><a href="#cb31-71" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box2,below=of NVS4](NVS5){NVSwitch};</span>
<span id="cb31-72"><a href="#cb31-72" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box2,below=of NVS5](NVS6){NVSwitch};</span>
<span id="cb31-73"><a href="#cb31-73" aria-hidden="true" tabindex="-1"></a><span class="kw">\end</span>{<span class="ex">scope</span>}</span>
<span id="cb31-74"><a href="#cb31-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-75"><a href="#cb31-75" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\z</span> in {1,3,4} {</span>
<span id="cb31-76"><a href="#cb31-76" aria-hidden="true" tabindex="-1"></a>   <span class="fu">\foreach</span> <span class="fu">\x</span> [count=<span class="fu">\y</span>] in {0.10,0.26,0.42,0.58,0.74,0.9} {</span>
<span id="cb31-77"><a href="#cb31-77" aria-hidden="true" tabindex="-1"></a>      <span class="fu">\draw</span>[myline]</span>
<span id="cb31-78"><a href="#cb31-78" aria-hidden="true" tabindex="-1"></a>        (<span class="ss">$(GPU</span><span class="sc">\z</span><span class="ss">.north east)!</span><span class="sc">\x</span><span class="ss">!(GPU</span><span class="sc">\z</span><span class="ss">.south east)$</span>)</span>
<span id="cb31-79"><a href="#cb31-79" aria-hidden="true" tabindex="-1"></a>        -- ++(0:0.5) coordinate(<span class="fu">\z</span> GPU<span class="fu">\y</span>);</span>
<span id="cb31-80"><a href="#cb31-80" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb31-81"><a href="#cb31-81" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-82"><a href="#cb31-82" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\z</span> in {2} {</span>
<span id="cb31-83"><a href="#cb31-83" aria-hidden="true" tabindex="-1"></a>   <span class="fu">\foreach</span> <span class="fu">\x</span> [count=<span class="fu">\y</span>] in {0.10,0.26,0.42,0.58,0.74,0.9} {</span>
<span id="cb31-84"><a href="#cb31-84" aria-hidden="true" tabindex="-1"></a>      <span class="fu">\draw</span>[mylineR,,latex-]</span>
<span id="cb31-85"><a href="#cb31-85" aria-hidden="true" tabindex="-1"></a>        (<span class="ss">$(GPU</span><span class="sc">\z</span><span class="ss">.north east)!</span><span class="sc">\x</span><span class="ss">!(GPU</span><span class="sc">\z</span><span class="ss">.south east)$</span>)</span>
<span id="cb31-86"><a href="#cb31-86" aria-hidden="true" tabindex="-1"></a>        -- ++(0:0.5) coordinate(<span class="fu">\z</span> GPU<span class="fu">\y</span>);</span>
<span id="cb31-87"><a href="#cb31-87" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb31-88"><a href="#cb31-88" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-89"><a href="#cb31-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-90"><a href="#cb31-90" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\z</span> in {1,2,3,4,5,6} {</span>
<span id="cb31-91"><a href="#cb31-91" aria-hidden="true" tabindex="-1"></a>   <span class="fu">\foreach</span> <span class="fu">\x</span> [count=<span class="fu">\y</span>] in {0.14,0.62,0.86} {</span>
<span id="cb31-92"><a href="#cb31-92" aria-hidden="true" tabindex="-1"></a>      <span class="fu">\draw</span>[myline]</span>
<span id="cb31-93"><a href="#cb31-93" aria-hidden="true" tabindex="-1"></a>        (<span class="ss">$(NVS</span><span class="sc">\z</span><span class="ss">.north west)!</span><span class="sc">\x</span><span class="ss">!(NVS</span><span class="sc">\z</span><span class="ss">.south west)$</span>)</span>
<span id="cb31-94"><a href="#cb31-94" aria-hidden="true" tabindex="-1"></a>        -- ++(180:0.5) coordinate(<span class="fu">\z</span> NVS<span class="fu">\y</span>);</span>
<span id="cb31-95"><a href="#cb31-95" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb31-96"><a href="#cb31-96" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-97"><a href="#cb31-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-98"><a href="#cb31-98" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\z</span> in {1,2,3,4,5,6} {</span>
<span id="cb31-99"><a href="#cb31-99" aria-hidden="true" tabindex="-1"></a>   <span class="fu">\foreach</span> <span class="fu">\x</span> [count=<span class="fu">\y</span>] in {0.38} {</span>
<span id="cb31-100"><a href="#cb31-100" aria-hidden="true" tabindex="-1"></a>      <span class="fu">\draw</span>[mylineR,latex-]</span>
<span id="cb31-101"><a href="#cb31-101" aria-hidden="true" tabindex="-1"></a>        (<span class="ss">$(NVS</span><span class="sc">\z</span><span class="ss">.north west)!</span><span class="sc">\x</span><span class="ss">!(NVS</span><span class="sc">\z</span><span class="ss">.south west)$</span>)</span>
<span id="cb31-102"><a href="#cb31-102" aria-hidden="true" tabindex="-1"></a>        -- ++(180:0.5) coordinate(<span class="fu">\z</span> RNVS<span class="fu">\y</span>);</span>
<span id="cb31-103"><a href="#cb31-103" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb31-104"><a href="#cb31-104" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-105"><a href="#cb31-105" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\z</span> in {1} {</span>
<span id="cb31-106"><a href="#cb31-106" aria-hidden="true" tabindex="-1"></a>   <span class="fu">\foreach</span> <span class="fu">\x</span> [count=<span class="fu">\y</span>] in {1,2,3,4,5,6} {</span>
<span id="cb31-107"><a href="#cb31-107" aria-hidden="true" tabindex="-1"></a>      <span class="fu">\draw</span>[line width=0.5pt,draw=black!40] (<span class="fu">\z</span> GPU<span class="fu">\x</span>) -- (<span class="fu">\x</span> NVS1);</span>
<span id="cb31-108"><a href="#cb31-108" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb31-109"><a href="#cb31-109" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-110"><a href="#cb31-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-111"><a href="#cb31-111" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\z</span> in {3} {</span>
<span id="cb31-112"><a href="#cb31-112" aria-hidden="true" tabindex="-1"></a>   <span class="fu">\foreach</span> <span class="fu">\x</span> [count=<span class="fu">\y</span>] in {1,2,3,4,5,6} {</span>
<span id="cb31-113"><a href="#cb31-113" aria-hidden="true" tabindex="-1"></a>      <span class="fu">\draw</span>[line width=0.5pt,draw=black!40] (<span class="fu">\z</span> GPU<span class="fu">\x</span>) -- (<span class="fu">\x</span> NVS2);</span>
<span id="cb31-114"><a href="#cb31-114" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb31-115"><a href="#cb31-115" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-116"><a href="#cb31-116" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\z</span> in {4} {</span>
<span id="cb31-117"><a href="#cb31-117" aria-hidden="true" tabindex="-1"></a>   <span class="fu">\foreach</span> <span class="fu">\x</span> [count=<span class="fu">\y</span>] in {1,2,3,4,5,6} {</span>
<span id="cb31-118"><a href="#cb31-118" aria-hidden="true" tabindex="-1"></a>      <span class="fu">\draw</span>[line width=0.5pt,draw=black!40] (<span class="fu">\z</span> GPU<span class="fu">\x</span>) -- (<span class="fu">\x</span> NVS3);</span>
<span id="cb31-119"><a href="#cb31-119" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb31-120"><a href="#cb31-120" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-121"><a href="#cb31-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-122"><a href="#cb31-122" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\z</span> in {2} {</span>
<span id="cb31-123"><a href="#cb31-123" aria-hidden="true" tabindex="-1"></a>   <span class="fu">\foreach</span> <span class="fu">\x</span> [count=<span class="fu">\y</span>] in {1,2,3,4,5,6} {</span>
<span id="cb31-124"><a href="#cb31-124" aria-hidden="true" tabindex="-1"></a>      <span class="fu">\draw</span>[mylineR] (<span class="fu">\z</span> GPU<span class="fu">\x</span>) -- (<span class="fu">\x</span> RNVS1);</span>
<span id="cb31-125"><a href="#cb31-125" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb31-126"><a href="#cb31-126" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-127"><a href="#cb31-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-128"><a href="#cb31-128" aria-hidden="true" tabindex="-1"></a><span class="kw">\begin</span>{<span class="ex">scope</span>}[node distance=0.5,shift={(13,3.8)},local bounding box = SGPU2]</span>
<span id="cb31-129"><a href="#cb31-129" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box](2GPU1){GPU};</span>
<span id="cb31-130"><a href="#cb31-130" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box,below=of 2GPU1](2GPU2){GPU};</span>
<span id="cb31-131"><a href="#cb31-131" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box,below=of 2GPU2](2GPU3){GPU};</span>
<span id="cb31-132"><a href="#cb31-132" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[Box,below=of 2GPU3](2GPU4){GPU};</span>
<span id="cb31-133"><a href="#cb31-133" aria-hidden="true" tabindex="-1"></a><span class="kw">\end</span>{<span class="ex">scope</span>}</span>
<span id="cb31-134"><a href="#cb31-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-135"><a href="#cb31-135" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\z</span> in {1,2,3,4} {</span>
<span id="cb31-136"><a href="#cb31-136" aria-hidden="true" tabindex="-1"></a>   <span class="fu">\foreach</span> <span class="fu">\x</span> [count=<span class="fu">\y</span>] in {0.10,0.26,0.42,0.58,0.74,0.9} {</span>
<span id="cb31-137"><a href="#cb31-137" aria-hidden="true" tabindex="-1"></a>      <span class="fu">\draw</span>[mylineR,latex-]</span>
<span id="cb31-138"><a href="#cb31-138" aria-hidden="true" tabindex="-1"></a>        (<span class="ss">$(2GPU</span><span class="sc">\z</span><span class="ss">.north west)!</span><span class="sc">\x</span><span class="ss">!(2GPU</span><span class="sc">\z</span><span class="ss">.south west)$</span>)</span>
<span id="cb31-139"><a href="#cb31-139" aria-hidden="true" tabindex="-1"></a>        -- ++(180:0.5) coordinate(<span class="fu">\z</span> DGPU<span class="fu">\y</span>);</span>
<span id="cb31-140"><a href="#cb31-140" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb31-141"><a href="#cb31-141" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-142"><a href="#cb31-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-143"><a href="#cb31-143" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\z</span> in {1,2,3,4,5,6} {</span>
<span id="cb31-144"><a href="#cb31-144" aria-hidden="true" tabindex="-1"></a>   <span class="fu">\foreach</span> <span class="fu">\x</span> [count=<span class="fu">\y</span>] in {0.14,0.38,0.62,0.86} {</span>
<span id="cb31-145"><a href="#cb31-145" aria-hidden="true" tabindex="-1"></a>      <span class="fu">\draw</span>[mylineR,latex-]</span>
<span id="cb31-146"><a href="#cb31-146" aria-hidden="true" tabindex="-1"></a>        (<span class="ss">$(NVS</span><span class="sc">\z</span><span class="ss">.north east)!</span><span class="sc">\x</span><span class="ss">!(NVS</span><span class="sc">\z</span><span class="ss">.south east)$</span>)</span>
<span id="cb31-147"><a href="#cb31-147" aria-hidden="true" tabindex="-1"></a>        -- ++(0:0.5) coordinate(<span class="fu">\z</span> DNVS<span class="fu">\y</span>);</span>
<span id="cb31-148"><a href="#cb31-148" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb31-149"><a href="#cb31-149" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-150"><a href="#cb31-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-151"><a href="#cb31-151" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\z</span> in {1,2,3,4} {</span>
<span id="cb31-152"><a href="#cb31-152" aria-hidden="true" tabindex="-1"></a>   <span class="fu">\foreach</span> <span class="fu">\x</span> [count=<span class="fu">\y</span>] in {1,2,3,4,5,6} {</span>
<span id="cb31-153"><a href="#cb31-153" aria-hidden="true" tabindex="-1"></a>      <span class="fu">\draw</span>[mylineR] (<span class="fu">\z</span> DGPU<span class="fu">\x</span>) -- (<span class="fu">\x</span> DNVS<span class="fu">\z</span>);</span>
<span id="cb31-154"><a href="#cb31-154" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb31-155"><a href="#cb31-155" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-156"><a href="#cb31-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-157"><a href="#cb31-157" aria-hidden="true" tabindex="-1"></a><span class="co">%CPU2</span></span>
<span id="cb31-158"><a href="#cb31-158" aria-hidden="true" tabindex="-1"></a><span class="kw">\begin</span>{<span class="ex">scope</span>}[shift={(18.0,0)},local bounding box = CPU2]</span>
<span id="cb31-159"><a href="#cb31-159" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[fill=CPU,minimum width=66, minimum height=66,</span>
<span id="cb31-160"><a href="#cb31-160" aria-hidden="true" tabindex="-1"></a>            rounded corners=8] (2C1) {};</span>
<span id="cb31-161"><a href="#cb31-161" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[fill=white,minimum width=54, minimum height=54] (2C2) {};</span>
<span id="cb31-162"><a href="#cb31-162" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[fill=CPU!40,minimum width=44, minimum height=44] (2C3) {CPU};</span>
<span id="cb31-163"><a href="#cb31-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-164"><a href="#cb31-164" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\x</span>/<span class="fu">\y</span> in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{</span>
<span id="cb31-165"><a href="#cb31-165" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[fill=CPU,minimum width=3, minimum height=15,outer sep=2pt,</span>
<span id="cb31-166"><a href="#cb31-166" aria-hidden="true" tabindex="-1"></a>           inner sep=0pt,anchor=south](2GO<span class="fu">\y</span>)at(<span class="ss">$(2C1.north west)!</span><span class="sc">\x</span><span class="ss">!(2C1.north east)$</span>){};</span>
<span id="cb31-167"><a href="#cb31-167" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-168"><a href="#cb31-168" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\x</span>/<span class="fu">\y</span> in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{</span>
<span id="cb31-169"><a href="#cb31-169" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[fill=CPU,minimum width=3, minimum height=15,outer sep=2pt,</span>
<span id="cb31-170"><a href="#cb31-170" aria-hidden="true" tabindex="-1"></a>            inner sep=0pt,anchor=north](2DO<span class="fu">\y</span>)at(<span class="ss">$(2C1.south west)!</span><span class="sc">\x</span><span class="ss">!(2C1.south east)$</span>){};</span>
<span id="cb31-171"><a href="#cb31-171" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-172"><a href="#cb31-172" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\x</span>/<span class="fu">\y</span> in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{</span>
<span id="cb31-173"><a href="#cb31-173" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[fill=CPU,minimum width=15, minimum height=3,outer sep=2pt,</span>
<span id="cb31-174"><a href="#cb31-174" aria-hidden="true" tabindex="-1"></a>            inner sep=0pt,anchor=east](2LE<span class="fu">\y</span>)at(<span class="ss">$(2C1.north west)!</span><span class="sc">\x</span><span class="ss">!(2C1.south west)$</span>){};</span>
<span id="cb31-175"><a href="#cb31-175" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-176"><a href="#cb31-176" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\x</span>/<span class="fu">\y</span> in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{</span>
<span id="cb31-177"><a href="#cb31-177" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[fill=CPU,minimum width=15, minimum height=3,outer sep=2pt,</span>
<span id="cb31-178"><a href="#cb31-178" aria-hidden="true" tabindex="-1"></a>            inner sep=0pt,anchor=west](2DE<span class="fu">\y</span>)at(<span class="ss">$(2C1.north east)!</span><span class="sc">\x</span><span class="ss">!(2C1.south east)$</span>){};</span>
<span id="cb31-179"><a href="#cb31-179" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-180"><a href="#cb31-180" aria-hidden="true" tabindex="-1"></a><span class="co">%%</span></span>
<span id="cb31-181"><a href="#cb31-181" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[draw=CPU,minimum width=66, minimum height=26,</span>
<span id="cb31-182"><a href="#cb31-182" aria-hidden="true" tabindex="-1"></a>          anchor=south,align=center,line width=1pt,rotate=90](2PCI)at(<span class="ss">$(2LE1.west)!0.5!(2LE6.west)$</span>){PCIe<span class="fu">\\</span> Interconnect};</span>
<span id="cb31-183"><a href="#cb31-183" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[draw=CPU,minimum width=66, minimum height=26,</span>
<span id="cb31-184"><a href="#cb31-184" aria-hidden="true" tabindex="-1"></a>          anchor=south,align=center,line width=1pt](2CPU)at(<span class="ss">$(2GO1.north)!0.5!(2GO6.north)$</span>){CPU<span class="fu">\\</span> Interconnect};</span>
<span id="cb31-185"><a href="#cb31-185" aria-hidden="true" tabindex="-1"></a><span class="fu">\node</span>[draw=CPU,minimum width=45, minimum height=66,</span>
<span id="cb31-186"><a href="#cb31-186" aria-hidden="true" tabindex="-1"></a>          anchor=west,align=center,line width=1pt](2SYS)at(<span class="ss">$(2DE1.east)!0.5!(2DE6.east)$</span>){System<span class="fu">\\</span> RAM};</span>
<span id="cb31-187"><a href="#cb31-187" aria-hidden="true" tabindex="-1"></a><span class="kw">\end</span>{<span class="ex">scope</span>}</span>
<span id="cb31-188"><a href="#cb31-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-189"><a href="#cb31-189" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[CPU,line width=0.75pt,dashed](CPU)--++</span>
<span id="cb31-190"><a href="#cb31-190" aria-hidden="true" tabindex="-1"></a>            (90:3.5)-|node[fill=white,pos=0.25,text=black]{CPU Interconnect}(2CPU);</span>
<span id="cb31-191"><a href="#cb31-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-192"><a href="#cb31-192" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[CPU,line width=0.75pt,dashed](PCI.330)--++(0:0.5)|-(GPU1);</span>
<span id="cb31-193"><a href="#cb31-193" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[CPU,line width=0.75pt,dashed](PCI.300)--++(0:0.9)|-(GPU2);</span>
<span id="cb31-194"><a href="#cb31-194" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[CPU,line width=0.75pt,dashed](PCI.240)--++(0:0.9)|-(GPU3);</span>
<span id="cb31-195"><a href="#cb31-195" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[CPU,line width=0.75pt,dashed](PCI.210)--++(0:0.5)|-(GPU4);</span>
<span id="cb31-196"><a href="#cb31-196" aria-hidden="true" tabindex="-1"></a><span class="co">%</span></span>
<span id="cb31-197"><a href="#cb31-197" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[CPU,line width=0.75pt,dashed](2PCI.30)--++(180:0.5)|-(2GPU1);</span>
<span id="cb31-198"><a href="#cb31-198" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[CPU,line width=0.75pt,dashed](2PCI.60)--++(180:0.9)|-(2GPU2);</span>
<span id="cb31-199"><a href="#cb31-199" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[CPU,line width=0.75pt,dashed](2PCI.120)--++(180:0.9)|-(2GPU3);</span>
<span id="cb31-200"><a href="#cb31-200" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[CPU,line width=0.75pt,dashed](2PCI.150)--++(180:0.5)|-(2GPU4);</span>
<span id="cb31-201"><a href="#cb31-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-202"><a href="#cb31-202" aria-hidden="true" tabindex="-1"></a><span class="fu">\coordinate</span>(D2)at(<span class="ss">$(GPU4.south east)+(0,-7mm)$</span>);</span>
<span id="cb31-203"><a href="#cb31-203" aria-hidden="true" tabindex="-1"></a><span class="fu">\coordinate</span>(DD1)at(<span class="ss">$(GPU4.south west)+(0,-17mm)$</span>);</span>
<span id="cb31-204"><a href="#cb31-204" aria-hidden="true" tabindex="-1"></a><span class="fu">\coordinate</span>(DD2)at(<span class="ss">$(2GPU4.south east)+(0,-17mm)$</span>);</span>
<span id="cb31-205"><a href="#cb31-205" aria-hidden="true" tabindex="-1"></a><span class="fu">\coordinate</span>(D3)at(<span class="ss">$(2GPU4.south west)+(0,-7mm)$</span>);</span>
<span id="cb31-206"><a href="#cb31-206" aria-hidden="true" tabindex="-1"></a><span class="fu">\path</span>[red](D2)-|coordinate(D1)(SYS);</span>
<span id="cb31-207"><a href="#cb31-207" aria-hidden="true" tabindex="-1"></a><span class="fu">\path</span>[red](D3)-|coordinate(D4)(2SYS);</span>
<span id="cb31-208"><a href="#cb31-208" aria-hidden="true" tabindex="-1"></a><span class="fu">\coordinate</span>(DDD1)at(<span class="ss">$(D1)+(0,-19mm)$</span>);</span>
<span id="cb31-209"><a href="#cb31-209" aria-hidden="true" tabindex="-1"></a><span class="fu">\coordinate</span>(DDD2)at(<span class="ss">$(D4)+(0,-19mm)$</span>);</span>
<span id="cb31-210"><a href="#cb31-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-211"><a href="#cb31-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-212"><a href="#cb31-212" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\z</span> in {1,2,3,4} {</span>
<span id="cb31-213"><a href="#cb31-213" aria-hidden="true" tabindex="-1"></a><span class="fu">\fill</span>[CPU](D<span class="fu">\z</span>)circle(3pt);</span>
<span id="cb31-214"><a href="#cb31-214" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-215"><a href="#cb31-215" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[CPU,line width=0.75pt,dashed](D1)--</span>
<span id="cb31-216"><a href="#cb31-216" aria-hidden="true" tabindex="-1"></a>           node[fill=white,text=black]{Host to Device Copy <span class="fu">\&amp;</span> Retrieving Results}(D2);</span>
<span id="cb31-217"><a href="#cb31-217" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[CPU,line width=0.75pt,dashed](D3)--</span>
<span id="cb31-218"><a href="#cb31-218" aria-hidden="true" tabindex="-1"></a>           node[fill=white,text=black]{Host to Device Copy <span class="fu">\&amp;</span> Retrieving Results}(D4);</span>
<span id="cb31-219"><a href="#cb31-219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-220"><a href="#cb31-220" aria-hidden="true" tabindex="-1"></a><span class="fu">\foreach</span> <span class="fu">\z</span> in {1,2} {</span>
<span id="cb31-221"><a href="#cb31-221" aria-hidden="true" tabindex="-1"></a><span class="fu">\fill</span>[red](DD<span class="fu">\z</span>)circle(3pt);</span>
<span id="cb31-222"><a href="#cb31-222" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-223"><a href="#cb31-223" aria-hidden="true" tabindex="-1"></a><span class="fu">\draw</span>[red,line width=0.75pt,dashed](DD1)--</span>
<span id="cb31-224"><a href="#cb31-224" aria-hidden="true" tabindex="-1"></a>           node[fill=white]{Distributed Training Communication}(DD2);</span>
<span id="cb31-225"><a href="#cb31-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-226"><a href="#cb31-226" aria-hidden="true" tabindex="-1"></a> <span class="kw">\end</span>{<span class="ex">tikzpicture</span>}</span>
<span id="cb31-227"><a href="#cb31-227" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-multi-gpu-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;11.7: Multi-GPU architecture with NVSwitch interconnects.
</figcaption></figure>
</div>
</section><section id="tpu-pods" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="tpu-pods">TPU Pods</h4>
<p>As models and datasets continue to expand, training and inference workloads must extend beyond single-server configurations. This scaling requirement has led to the development of sophisticated distributed systems where multiple accelerators communicate across networks. Google’s TPU Pods represent a pioneering approach to this challenge, interconnecting hundreds of TPUs to function as a unified system <span class="citation" data-cites="Jouppi2020tpuv4">(<a href="../references.html#ref-Jouppi2020tpuv4" role="doc-biblioref">Jouppi et al. 2020</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Jouppi2020tpuv4" class="csl-entry" role="listitem">
Jouppi, Norman P., Doe Hyun Yoon, George Kurian, Sheng Li, Nishant Patil, James Laudon, Cliff Young, and David Patterson. 2020. <span>“A Domain-Specific Supercomputer for Training Deep Neural Networks.”</span> <em>Communications of the ACM</em> 63 (7): 67–78. <a href="https://doi.org/10.1145/3360307">https://doi.org/10.1145/3360307</a>.
</div></div><p>The architectural design of TPU Pods differs fundamentally from traditional multi-GPU systems. While multi-GPU configurations typically rely on NVLink or PCIe connections within a single machine, TPU Pods employ high-bandwidth optical links to interconnect accelerators at data center scale. This design implements a 2D torus interconnect topology, enabling efficient data exchange between accelerators while minimizing communication bottlenecks as workloads scale across nodes.</p>
<p>The effectiveness of this architecture is demonstrated in its performance scaling capabilities. As illustrated in <a href="#fig-tpu-pod-perf" class="quarto-xref">Figure&nbsp;<span>11.8</span></a>, TPU Pod performance exhibits near-linear scaling when running ResNet-50, from quarter-pod to full-pod configurations. The system achieves a remarkable 33.0x speedup when scaled to 1024 chips compared to a 16-TPU baseline. This scaling efficiency is particularly noteworthy in larger configurations, where performance continues to scale strongly even as the system expands from 128 to 1024 chips.</p>
<div id="fig-tpu-pod-perf" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-tpu-pod-perf-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/png/tpu-pod-perf.png" class="lightbox" data-gallery="quarto-lightbox-gallery-6" title="Figure&nbsp;11.8: Cloud TPU v3 pods and their performance on ResNet-50 across a range of slice sizes relative to a 16-TPU-chip baseline."><img src="images/png/tpu-pod-perf.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-tpu-pod-perf-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;11.8: Cloud TPU v3 pods and their performance on ResNet-50 across a range of slice sizes relative to a 16-TPU-chip baseline.
</figcaption></figure>
</div>
<p>However, distributing AI workloads across an entire data center introduces unique challenges. Systems must contend with interconnect congestion, synchronization delays, and the complexities of efficient workload partitioning. Unlike multi-GPU setups where accelerators share memory hierarchies, TPU Pods operate in a fully distributed memory system. This architecture necessitates explicit communication strategies to manage data movement effectively, requiring careful consideration of data placement and transfer patterns to maintain scaling efficiency.</p>
</section><section id="wafer-scale-ai" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="wafer-scale-ai">Wafer-Scale AI</h4>
<p>At the frontier of AI scaling, wafer-scale integration represents a paradigm shift—abandoning traditional multi-chip architectures in favor of a single, massive AI processor. Rather than partitioning computation across discrete chips, this approach treats an entire silicon wafer as a unified compute fabric, eliminating the inefficiencies of inter-chip communication.</p>
<p>As shown in <a href="#fig-processor-trends" class="quarto-xref">Figure&nbsp;<span>11.9</span></a>, Cerebras’ Wafer-Scale Engine (WSE) processors break away from the historical transistor scaling trends of CPUs, GPUs, and TPUs. While these architectures have steadily increased transistor counts along an exponential trajectory, WSE introduces an entirely new scaling paradigm, integrating trillions of transistors onto a single wafer—far surpassing even the most advanced GPUs and TPUs. With WSE-3, this trajectory continues, pushing wafer-scale AI to unprecedented levels <span class="citation" data-cites="Cerebras2021wse2">(<a href="../references.html#ref-Cerebras2021wse2" role="doc-biblioref">Systems 2021a</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Cerebras2021wse2" class="csl-entry" role="listitem">
Systems, Cerebras. 2021a. <span>“The Wafer-Scale Engine 2: Scaling AI Compute Beyond GPUs.”</span> <em>Cerebras White Paper</em>. <a href="https://cerebras.ai/product-chip/">https://cerebras.ai/product-chip/</a>.
</div></div><p>The fundamental advantage of wafer-scale AI is its ultra-fast, on-die communication. Unlike chiplets, GPUs, or TPU Pods, where data must traverse physical boundaries between separate devices, wafer-scale AI enables near-instantaneous data transfer across its vast compute array. This architecture drastically reduces communication latency, unlocking performance levels that are unachievable with conventional multi-chip systems.</p>
<p>However, achieving this level of integration introduces formidable engineering challenges. Thermal dissipation, fault tolerance, and manufacturing yield become major constraints when fabricating a processor of this scale. Unlike distributed TPU systems, which mitigate failures by dynamically re-routing workloads, wafer-scale AI must incorporate built-in redundancy mechanisms to tolerate localized defects in the silicon. Successfully addressing these challenges is essential to realizing the full potential of wafer-scale computing as the next frontier in AI acceleration.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div id="fig-processor-trends" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-processor-trends-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="hw_acceleration_files/figure-html/fig-processor-trends-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-7" title="Figure&nbsp;11.9: Processor transistor count over time."><img src="hw_acceleration_files/figure-html/fig-processor-trends-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="672"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-processor-trends-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;11.9: Processor transistor count over time.
</figcaption></figure>
</div>
</div>
</div>
</section><section id="ai-systems-scaling-trajectory" class="level4"><h4 class="anchored" data-anchor-id="ai-systems-scaling-trajectory">AI Systems Scaling Trajectory</h4>
<p><a href="#tbl-scaling-trajectory" class="quarto-xref">Table&nbsp;<span>11.19</span></a> illustrates the progressive scaling of AI acceleration, from single-chip processors to increasingly complex architectures such as chiplet-based designs, multi-GPU systems, TPU Pods, and wafer-scale AI. Each step in this evolution introduces new challenges related to data movement, memory access, interconnect efficiency, and workload distribution. While chiplets enable modular scaling within a package, they introduce latency and memory coherence issues. Multi-GPU systems rely on high-speed interconnects like NVLink but face synchronization and communication bottlenecks. TPU Pods push scalability further by distributing workloads across clusters, yet they must contend with interconnect congestion and workload partitioning. At the extreme end, wafer-scale AI integrates an entire wafer into a single computational unit, presenting unique challenges in thermal management and fault tolerance.</p>
<div id="tbl-scaling-trajectory" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-scaling-trajectory-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;11.19: Scaling trajectory of AI systems and associated challenges.
</figcaption><div aria-describedby="tbl-scaling-trajectory-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 33%">
<col style="width: 48%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Scaling Approach</th>
<th style="text-align: left;">Key Feature</th>
<th style="text-align: left;">Challenges</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Chiplets</td>
<td style="text-align: left;">Modular scaling within a package</td>
<td style="text-align: left;">Inter-chiplet latency, memory coherence</td>
</tr>
<tr class="even">
<td style="text-align: left;">Multi-GPU</td>
<td style="text-align: left;">External GPU interconnects (NVLink)</td>
<td style="text-align: left;">Synchronization overhead, communication bottlenecks</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TPU Pods</td>
<td style="text-align: left;">Distributed accelerator clusters</td>
<td style="text-align: left;">Interconnect congestion, workload partitioning</td>
</tr>
<tr class="even">
<td style="text-align: left;">Wafer-Scale AI</td>
<td style="text-align: left;">Entire wafer as a single processor</td>
<td style="text-align: left;">Thermal dissipation, fault tolerance</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</section><section id="computation-and-memory-scaling-changes" class="level3 page-columns page-full" data-number="11.9.1"><h3 data-number="11.9.1" class="anchored" data-anchor-id="computation-and-memory-scaling-changes">
<span class="header-section-number">11.9.1</span> Computation and Memory Scaling Changes</h3>
<p>As AI systems scale from single-chip accelerators to multi-chip architectures, the fundamental challenges in computation and memory evolve. In a single accelerator, execution is primarily optimized for locality—ensuring that computations are mapped efficiently to available processing elements while minimizing memory access latency. However, as AI systems extend beyond a single chip, the scope of these optimizations expands significantly. Computation must now be distributed across multiple accelerators, and memory access patterns become constrained by interconnect bandwidth and communication overhead.</p>
<section id="multi-chip-execution-mapping" class="level4"><h4 class="anchored" data-anchor-id="multi-chip-execution-mapping">Multi-chip Execution Mapping</h4>
<p>In single-chip AI accelerators, computation placement is concerned with mapping workloads to PEs, vector units, and tensor cores. Mapping strategies aim to maximize data locality, ensuring that computations access nearby memory to reduce costly data movement.</p>
<p>As AI systems scale to multi-chip execution, computation placement must consider several critical factors. Workloads need to be partitioned across multiple accelerators, which requires explicit coordination of execution order and dependencies. This division is essential due to the inherent latency associated with cross-chip communication, which contrasts sharply with single-chip systems that benefit from shared on-chip memory. Accordingly, computation scheduling must be interconnect-aware to manage these delays effectively. Additionally, achieving load balancing across accelerators is vital; an uneven distribution of tasks can result in some accelerators remaining underutilized while others operate at full capacity, ultimately hindering overall system performance.</p>
<p>For example, in multi-GPU training, computation mapping must ensure that each GPU has a balanced portion of the workload while minimizing expensive cross-GPU communication. Similarly, in TPU Pods, mapping strategies must align with the torus interconnect topology, ensuring that computation is placed to minimize long-distance data transfers.</p>
<p>Thus, while computation placement in single-chip systems is a local optimization problem, in multi-chip architectures, it becomes a global optimization challenge where execution efficiency depends on minimizing inter-chip communication and balancing workload distribution.</p>
</section><section id="distributed-access-memory-allocation" class="level4 page-columns page-full"><h4 class="anchored" data-anchor-id="distributed-access-memory-allocation">Distributed Access Memory Allocation</h4>
<p>Memory allocation strategies in single-chip AI accelerators are designed to minimize off-chip memory accesses by leveraging on-chip caches, SRAM, and HBM. Techniques such as tiling, data reuse, and kernel fusion ensure that computations make efficient use of fast local memory.</p>
<p>In multi-chip AI systems, each accelerator manages its own local memory, which necessitates the explicit allocation of model parameters, activations, and intermediate data across the devices. Unlike single-chip execution where data is fetched once and reused, multi-chip setups require deliberate strategies to minimize redundant data transfers, as data must be communicated between accelerators. Additionally, when overlapping data is processed by multiple accelerators, the synchronization of shared data can introduce significant overhead that must be carefully managed to ensure efficient execution.</p>
<p>For instance, in multi-GPU deep learning, gradient synchronization across GPUs is a memory-intensive operation that must be optimized to avoid network congestion <span class="citation" data-cites="Shallue2019measuring">(<a href="../references.html#ref-Shallue2019measuring" role="doc-biblioref">Shallue, Lee, et al. 2019</a>)</span>. In wafer-scale AI, memory allocation must account for fault tolerance and redundancy mechanisms, ensuring that defective regions of the wafer do not disrupt execution.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Shallue2019measuring" class="csl-entry" role="listitem">
Shallue, Christopher J., Jaehoon Lee, et al. 2019. <span>“Measuring the Effects of Data Parallelism on Neural Network Training.”</span> <em>Journal of Machine Learning Research</em> 20: 1–49. <a href="http://jmlr.org/papers/v20/18-789.html">http://jmlr.org/papers/v20/18-789.html</a>.
</div></div><p>Thus, while memory allocation in single-chip accelerators focuses on local cache efficiency, in multi-chip architectures, it must be explicitly coordinated across accelerators to balance memory bandwidth, minimize redundant transfers, and reduce synchronization overhead.</p>
</section><section id="data-movement-constraints" class="level4"><h4 class="anchored" data-anchor-id="data-movement-constraints">Data Movement Constraints</h4>
<p>In single-chip AI accelerators, data movement optimization is largely focused on minimizing on-chip memory access latency. Techniques such as weight stationarity, input stationarity, and tiling ensure that frequently used data remains close to the execution units, reducing off-chip memory traffic.</p>
<p>In multi-chip architectures, data movement transcends being merely an intra-chip issue and becomes a significant system-wide bottleneck. Scaling introduces several critical challenges, foremost among them being inter-chip bandwidth constraints; communication links such as PCIe, NVLink, and TPU interconnects operate at speeds that are considerably slower than those of on-chip memory accesses. Additionally, when accelerators share model parameters or intermediate computations, the resulting data synchronization overhead—including latency and contention—can markedly impede execution. Finally, optimizing collective communication is essential for workloads that require frequent data exchanges, such as gradient updates in deep learning training, where minimizing synchronization penalties is imperative for achieving efficient system performance.</p>
<p>For example, in TPU Pods, systolic execution models ensure that data moves in structured patterns, reducing unnecessary off-chip transfers. In multi-GPU inference, techniques like asynchronous data fetching and overlapping computation with communication help mitigate inter-chip latency.</p>
<p>Thus, while data movement optimization in single-chip systems focuses on cache locality and tiling, in multi-chip architectures, the primary challenge is reducing inter-chip communication overhead to maximize efficiency.</p>
</section><section id="compilers-and-runtimes-adaptation" class="level4"><h4 class="anchored" data-anchor-id="compilers-and-runtimes-adaptation">Compilers and Runtimes Adaptation</h4>
<p>As AI acceleration extends beyond a single chip, compilers and runtimes must adapt to manage computation placement, memory organization, and execution scheduling across multiple accelerators. The fundamental principles of locality, parallelism, and efficient scheduling remain essential, but their implementation requires new strategies for distributed execution.</p>
<p>One of the primary challenges in scaling AI execution is computation placement. In a single-chip accelerator, workloads are mapped to processing elements, vector units, and tensor cores with an emphasis on minimizing on-chip data movement and maximizing parallel execution. However, in a multi-chip system, computation must be partitioned hierarchically, where workloads are distributed not just across cores within a chip, but also across multiple accelerators. Compilers handle this by implementing interconnect-aware scheduling, optimizing workload placement to minimize costly inter-chip communication.</p>
<p>Similarly, memory management evolves as scaling extends beyond a single accelerator. In a single-chip system, local caching, HBM reuse, and efficient tiling strategies ensure that frequently accessed data remains close to computation units. However, in a multi-chip system, each accelerator has its own independent memory, requiring explicit memory partitioning and coordination. Compilers optimize memory layouts for distributed execution, while runtimes introduce data prefetching and caching mechanisms to reduce inter-chip memory access overhead.</p>
<p>Beyond computation and memory, data movement becomes a major bottleneck at scale. In a single-chip accelerator, efficient on-chip caching and minimized DRAM accesses ensure that data is reused efficiently. However, in a multi-chip system, communication-aware execution becomes critical, requiring compilers to generate execution plans that overlap computation with data transfers. Runtimes handle inter-chip synchronization, ensuring that workloads are not stalled by waiting for data to arrive from remote accelerators.</p>
<p>Finally, execution scheduling must be extended for global coordination. In single-chip AI execution, scheduling is primarily concerned with parallelism and maximizing compute occupancy within the accelerator. However, in a multi-chip system, scheduling must balance workload distribution across accelerators while taking interconnect bandwidth and synchronization latency into account. Runtimes manage this complexity by implementing adaptive scheduling strategies that dynamically adjust execution plans based on system state and network congestion.</p>
<p><a href="#tbl-scaling-adaptations" class="quarto-xref">Table&nbsp;<span>11.20</span></a> summarizes these key adaptations, highlighting how compilers and runtimes extend their capabilities to efficiently support multi-chip AI execution.</p>
<p>Thus, while the fundamentals of AI acceleration remain intact, compilers and runtimes must extend their functionality to operate efficiently across distributed systems. The next section will explore how mapping strategies evolve to further optimize multi-chip AI execution.</p>
<div id="tbl-scaling-adaptations" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-scaling-adaptations-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;11.20: Adaptations in computation placement, memory management, and scheduling for multi-chip AI execution.
</figcaption><div aria-describedby="tbl-scaling-adaptations-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 33%">
<col style="width: 45%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Aspect</th>
<th style="text-align: left;">Single-Chip AI Accelerator</th>
<th style="text-align: left;">Multi-Chip AI System &amp; How Compilers/Runtimes Adapt</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Computation Placement</td>
<td style="text-align: left;">Local PEs, tensor cores, vector units</td>
<td style="text-align: left;">Hierarchical mapping, interconnect-aware scheduling</td>
</tr>
<tr class="even">
<td style="text-align: left;">Memory Management</td>
<td style="text-align: left;">Caching, HBM reuse, local tiling</td>
<td style="text-align: left;">Distributed allocation, prefetching, caching</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Data Movement</td>
<td style="text-align: left;">On-chip reuse, minimal DRAM access</td>
<td style="text-align: left;">Communication-aware execution, overlap transfers</td>
</tr>
<tr class="even">
<td style="text-align: left;">Execution Scheduling</td>
<td style="text-align: left;">Parallelism, compute occupancy</td>
<td style="text-align: left;">Global scheduling, interconnect-aware balancing</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</section></section><section id="execution-models-adaptation" class="level3" data-number="11.9.2"><h3 data-number="11.9.2" class="anchored" data-anchor-id="execution-models-adaptation">
<span class="header-section-number">11.9.2</span> Execution Models Adaptation</h3>
<p>As AI accelerators scale beyond a single chip, execution models must evolve to account for the complexities introduced by distributed computation, memory partitioning, and inter-chip communication. In single-chip accelerators, execution is optimized for local processing elements, with scheduling strategies that balance parallelism, locality, and data reuse. However, in multi-chip AI systems, execution must now be coordinated across multiple accelerators, introducing new challenges in workload scheduling, memory coherence, and interconnect-aware execution.</p>
<p>This section explores how execution models change as AI acceleration scales, focusing on scheduling, memory coordination, and runtime management in multi-chip systems.</p>
<section id="cross-accelerator-scheduling" class="level4"><h4 class="anchored" data-anchor-id="cross-accelerator-scheduling">Cross-Accelerator Scheduling</h4>
<p>In single-chip AI accelerators, execution scheduling is primarily aimed at optimizing parallelism within the processor. This involves ensuring that workloads are effectively mapped to tensor cores, vector units, and special function units by employing techniques designed to enhance data locality and resource utilization. For instance, static scheduling uses a predetermined execution order that is carefully optimized for locality and reuse, while dynamic scheduling adapts in real time to variations in workload demands. Additionally, pipeline execution divides computations into stages, thereby maximizing hardware utilization by maintaining a continuous flow of operations.</p>
<p>In contrast, scheduling in multi-chip architectures must address the additional challenges posed by inter-chip dependencies. Workload partitioning in such systems involves distributing tasks across various accelerators such that each receives an optimal share of the workload, all while minimizing the overhead caused by excessive communication. Moreover, interconnect-aware scheduling is essential to align execution timing with the constraints of inter-chip bandwidth, thus preventing performance stalls. Latency hiding techniques also play a critical role, as they enable the overlapping of computation with communication, effectively reducing waiting times.</p>
<p>For example, in multi-GPU inference scenarios, execution scheduling is implemented in a way that allows data to be prefetched concurrently with computation, thereby mitigating memory stalls. Similarly, TPU Pods leverage the systolic array model to tightly couple execution scheduling with data flow, ensuring that each TPU core receives its required data precisely when needed. Therefore, while single-chip execution scheduling is focused largely on maximizing internal parallelism, multi-chip systems require a more holistic approach that explicitly manages communication overhead and synchronizes workload distribution across accelerators.</p>
</section><section id="cross-accelerator-coordination" class="level4"><h4 class="anchored" data-anchor-id="cross-accelerator-coordination">Cross-Accelerator Coordination</h4>
<p>In single-chip AI accelerators, memory coordination is managed through sophisticated local caching strategies that keep frequently used data in close proximity to the execution units. Techniques such as tiling, kernel fusion, and data reuse are employed to reduce the dependency on slower memory hierarchies, thereby enhancing performance and reducing latency.</p>
<p>In contrast, multi-chip architectures present a distributed memory coordination challenge that necessitates more deliberate management. Each accelerator in such a system possesses its own independent memory, which must be organized through explicit memory partitioning to minimize cross-chip data accesses. Additionally, ensuring consistency and synchronization of shared data across accelerators is essential to maintain computational correctness. Efficient communication mechanisms must also be implemented to schedule data transfers in a way that limits overhead associated with synchronization delays.</p>
<p>For instance, in distributed deep learning training, model parameters must be synchronized across multiple GPUs using methods such as all-reduce, where gradients are aggregated across accelerators while reducing communication latency. In wafer-scale AI, memory coordination must further address fault-tolerant execution, ensuring that defective areas do not compromise overall system performance. Consequently, while memory coordination in single-chip systems is primarily concerned with cache optimization, multi-chip architectures require comprehensive management of distributed memory access, synchronization, and communication to achieve efficient execution.</p>
</section><section id="cross-accelerator-execution-management" class="level4"><h4 class="anchored" data-anchor-id="cross-accelerator-execution-management">Cross-Accelerator Execution Management</h4>
<p>Execution in single-chip AI accelerators is managed by AI runtimes that handle workload scheduling, memory allocation, and hardware execution. These runtimes optimize execution at the kernel level, ensuring that computations are executed efficiently within the available resources.</p>
<p>In multi-chip AI systems, runtimes must incorporate a comprehensive strategy for distributed execution orchestration. This approach ensures that both computation and memory access are seamlessly coordinated across multiple accelerators, enabling efficient utilization of hardware resources and minimizing bottlenecks associated with data transfers.</p>
<p>Furthermore, these systems require robust mechanisms for cross-chip workload synchronization. Careful management of dependencies and timely coordination between accelerators are essential to prevent stalls in execution that may arise from delays in inter-chip communication. Such synchronization is critical for maintaining the flow of computation, particularly in environments where latency can significantly impact overall performance.</p>
<p>Finally, adaptive execution models play a pivotal role in contemporary multi-chip architectures. These models dynamically adjust execution plans based on current hardware availability and communication constraints, ensuring that the system can respond to changing conditions and optimize performance in real time. Together, these strategies provide a resilient framework for managing the complexities of distributed AI execution.</p>
<p>For example, in Google’s TPU Pods, the TPU runtime is responsible for scheduling computations across multiple TPU cores, ensuring that workloads are executed in a way that minimizes communication bottlenecks. In multi-GPU frameworks like PyTorch and TensorFlow, runtime execution must synchronize operations across GPUs, ensuring that data is transferred efficiently while maintaining execution order.</p>
<p>Thus, while single-chip runtimes focus on optimizing execution within a single processor, multi-chip runtimes must handle system-wide execution, balancing computation, memory, and interconnect performance.</p>
</section><section id="computation-placement-adaptation" class="level4"><h4 class="anchored" data-anchor-id="computation-placement-adaptation">Computation Placement Adaptation</h4>
<p>As AI systems expand beyond single-chip execution, computation placement must adapt to account for inter-chip workload distribution and interconnect efficiency. In single-chip accelerators, compilers optimize placement by mapping workloads to tensor cores, vector units, and PEs, ensuring maximum parallelism while minimizing on-chip data movement. However, in multi-chip systems, placement strategies must address interconnect bandwidth constraints, synchronization latency, and hierarchical workload partitioning across multiple accelerators.</p>
<p><a href="#tbl-computation-placement" class="quarto-xref">Table&nbsp;<span>11.21</span></a> highlights these adaptations. To reduce expensive cross-chip communication, compilers now implement interconnect-aware workload partitioning, strategically assigning computations to accelerators based on communication cost. For instance, in multi-GPU training, compilers optimize placement to minimize NVLink or PCIe traffic, whereas TPU Pods leverage the torus interconnect topology to enhance data exchanges.</p>
<div id="tbl-computation-placement" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-computation-placement-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;11.21: Adaptations in computation placement strategies for multi-chip AI execution.
</figcaption><div aria-describedby="tbl-computation-placement-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 17%">
<col style="width: 29%">
<col style="width: 52%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Aspect</th>
<th style="text-align: left;">Single-Chip AI Accelerator</th>
<th style="text-align: left;">Multi-Chip AI System &amp; How Compilers/Runtimes Adapt</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Computation Placement</td>
<td style="text-align: left;">Local PEs, tensor cores, vector units</td>
<td style="text-align: left;">Hierarchical mapping, interconnect-aware scheduling</td>
</tr>
<tr class="even">
<td style="text-align: left;">Workload Distribution</td>
<td style="text-align: left;">Optimized within a single chip</td>
<td style="text-align: left;">Partitioning across accelerators, minimizing inter-chip communication</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Synchronization</td>
<td style="text-align: left;">Managed within local execution units</td>
<td style="text-align: left;">Runtimes dynamically balance workloads, adjust execution plans</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Runtimes complement this by dynamically managing execution workloads, adjusting placement in real-time to balance loads across accelerators. Unlike static compilation, which assumes a fixed hardware topology, AI runtimes continuously monitor system conditions and migrate tasks as needed to prevent bottlenecks. This ensures efficient execution even in environments with fluctuating workload demands or varying hardware availability.</p>
<p>By extending local execution strategies to multi-chip environments, computation placement now requires a careful balance between parallel execution, memory locality, and interconnect-aware scheduling. The next section explores how memory hierarchy must evolve to support efficient execution across distributed AI architectures.</p>
<p>Thus, computation placement at scale builds upon local execution optimizations while introducing new challenges in inter-chip coordination, communication-aware execution, and dynamic load balancing. In the next section, we explore how memory hierarchy must adapt to support efficient execution across multi-chip architectures.</p>
</section></section><section id="navigating-multi-chip-ai-complexities" class="level3" data-number="11.9.3"><h3 data-number="11.9.3" class="anchored" data-anchor-id="navigating-multi-chip-ai-complexities">
<span class="header-section-number">11.9.3</span> Navigating Multi-Chip AI Complexities</h3>
<p>The evolution of AI hardware, from single-chip accelerators to multi-chip systems and wafer-scale integration, highlights the increasing complexity of efficiently executing large-scale machine learning workloads. As we’ve explored in this chapter, scaling AI systems introduces new challenges in computation placement, memory management, and data movement. While the fundamental principles of AI acceleration remain consistent, their implementation must adapt to the constraints of distributed execution, interconnect bandwidth limitations, and synchronization overhead.</p>
<p>Multi-chip AI architectures represent a significant step forward in addressing the computational demands of modern machine learning models. By distributing workloads across multiple accelerators, these systems offer increased performance, memory capacity, and scalability. However, realizing these benefits requires careful consideration of how computations are mapped to hardware, how memory is partitioned and accessed, and how execution is scheduled across a distributed system.</p>
<p>While we an overview of the key concepts and challenges in multi-chip AI acceleration as they extend beyond a single system, there is still much more to explore. As AI models continue to grow in size and complexity, new architectural innovations, mapping strategies, and runtime optimizations will be needed to sustain efficient execution. The ongoing development of AI hardware and software reflects a broader trend in computing, where specialization and domain-specific architectures are becoming increasingly important for addressing the unique demands of emerging workloads.</p>
<p>Understanding the principles and trade-offs involved in multi-chip AI acceleration enables machine learning engineers and system designers to make informed decisions about how to best deploy and optimize their models. Whether training large language models on TPU pods or deploying computer vision applications on multi-GPU systems, the ability to efficiently map computations to hardware will continue to be a critical factor in realizing the full potential of AI.</p>
</section></section><section id="conclusion" class="level2" data-number="11.10"><h2 data-number="11.10" class="anchored" data-anchor-id="conclusion">
<span class="header-section-number">11.10</span> Conclusion</h2>
<p>The rapid advancement of machine learning has fundamentally reshaped computer architecture and system design, driving the need for specialized hardware and optimized software to support the increasing computational demands of AI workloads. This chapter has explored the foundational principles of AI acceleration, analyzing how domain-specific architectures, memory hierarchies, and data movement strategies work in concert to maximize performance and mitigate bottlenecks.</p>
<p>We began by examining the historical progression of AI hardware, tracing the shift from general-purpose processors to specialized accelerators tailored for machine learning workloads. This evolution has been driven by the computational intensity of AI models, necessitating vectorized execution, matrix processing, and specialized function units to accelerate key operations.</p>
<p>Memory systems play a pivotal role in AI acceleration, as modern workloads require efficient management of large-scale tensor data across hierarchical memory structures. This chapter detailed the challenges posed by memory bandwidth limitations, irregular access patterns, and off-chip communication, highlighting techniques such as tiling, kernel fusion, and memory-aware data placement that optimize data movement and reuse.</p>
<p>Mapping neural networks to hardware requires balancing computation placement, memory allocation, and execution scheduling. We analyzed key mapping strategies, including weight-stationary, output-stationary, and hybrid approaches, and explored how compilers and runtimes transform high-level models into optimized execution plans that maximize hardware utilization.</p>
<p>As AI workloads scale beyond single-chip accelerators, new challenges emerge in distributed execution, memory coherence, and inter-chip communication. This chapter examined how multi-GPU architectures, TPU pods, and wafer-scale AI systems address these challenges by leveraging hierarchical workload partitioning, distributed memory management, and interconnect-aware scheduling. We also explored how compilers and runtimes must adapt to orchestrate execution across multiple accelerators, ensuring efficient workload distribution and minimizing communication overhead.</p>
<p>The increasing complexity of AI models and the growing scale of machine learning workloads underscore a broader shift in computing—one where specialization and hardware-software co-design are essential for achieving efficiency and scalability. Understanding the fundamental trade-offs in AI acceleration enables system designers, researchers, and engineers to make informed decisions about deploying and optimizing AI models across diverse hardware platforms.</p>
<p>This chapter has provided a comprehensive foundation in AI acceleration, equipping readers with the knowledge to navigate the evolving intersection of machine learning systems, hardware design, and system optimization. As AI continues to advance, the ability to efficiently map computations to hardware will remain a key determinant of performance, scalability, and future innovation in artificial intelligence.</p>
</section><section id="resources" class="level2" data-number="11.11"><h2 data-number="11.11" class="anchored" data-anchor-id="resources">
<span class="header-section-number">11.11</span> Resources</h2>
<p>Here is a curated list of resources to support students and instructors in their learning and teaching journeys. We are continuously working on expanding this collection and will add new exercises soon.</p>
<div class="callout callout-style-default callout-note callout-titled" title="Slides">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Slides
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<ul>
<li><em>Coming soon.</em></li>
</ul>
</div>
</div>
</div>
<div class="callout callout-style-default callout-important callout-titled" title="Videos">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Videos
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<ul>
<li><em>Coming soon.</em></li>
</ul>
</div>
</div>
</div>
<div class="callout callout-style-default callout-caution callout-titled" title="Exercises">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-6-contents" aria-controls="callout-6" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercises
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-6" class="callout-6-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<ul>
<li><em>Coming soon.</em></li>
</ul>
</div>
</div>
</div>



</section></main><!-- /main --><script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    window.setColorSchemeToggle(window.hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
  });
  </script><input type="hidden" id="giscus-base-theme" value="light"><input type="hidden" id="giscus-alt-theme" value="dark"><script>
function loadGiscusWhenReady() {
  // Function to get the theme based on body class
  const getTheme = () => {
    const baseTheme = document.getElementById('giscus-base-theme').value;
    const altTheme = document.getElementById('giscus-alt-theme').value;
    return document.body.classList.contains('quarto-dark') ? altTheme : baseTheme;
  };
  // Create the Giscus script and add it to the desired location
  const loadGiscus = () => {
    const script = document.createElement("script");
    script.src = "https://giscus.app/client.js";
    script.async = true;
    script.dataset.repo = "harvard-edge/cs249r_book";
    script.dataset.repoId = "R_kgDOKQSOaw";
    script.dataset.category = "General";
    script.dataset.categoryId = "DIC_kwDOKQSOa84CZ8Ry";
    script.dataset.mapping = "title";
    script.dataset.reactionsEnabled = "1";
    script.dataset.emitMetadata = "0";
    script.dataset.inputPosition = "top";
    script.dataset.theme = getTheme();
    script.dataset.lang = "en";
    script.crossOrigin = "anonymous";
    // Append the script to the desired div instead of at the end of the body
    document.getElementById("quarto-content").appendChild(script);
  };
  // MutationObserver to detect when the 'quarto-light' or 'quarto-dark' class is added to the body
  const observer = new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type === "attributes" && mutation.attributeName === "class") {
        if (document.body.classList.contains('quarto-light') || document.body.classList.contains('quarto-dark')) {
          loadGiscus();
          observer.disconnect(); // Stop observing once Giscus is loaded
          break;
        }
      }
    }
  });
  // Start observing the body for class attribute changes
  observer.observe(document.body, {
    attributes: true,
    attributeFilter: ["class"],
  });
}
loadGiscusWhenReady();
</script><nav class="page-navigation"><div class="nav-page nav-page-previous">
      <a href="../../../contents/core/optimizations/optimizations.html" class="pagination-link" aria-label="Model Optimizations">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Model Optimizations</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../../contents/core/benchmarking/benchmarking.html" class="pagination-link" aria-label="Benchmarking AI">
        <span class="nav-page-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Benchmarking AI</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer"><div class="nav-footer">
    <div class="nav-footer-left">
<p>Written, edited and curated by Prof.&nbsp;Vijay Janapa Reddi (Harvard University)</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/harvard-edge/cs249r_book/edit/widget_quiz/contents/core/hw_acceleration/hw_acceleration.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/harvard-edge/cs249r_book/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li><li><a href="https://github.com/harvard-edge/cs249r_book/blob/widget_quiz/contents/core/hw_acceleration/hw_acceleration.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>This book was built with <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer><script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>


</body></html>