---
bibliography: benchmarking.bib
---

# Benchmarking AI {#sec-benchmarking_ai}

::: {.content-visible when-format="html"}
Resources: [Slides](#sec-benchmarking-ai-resource), [Videos](#sec-benchmarking-ai-resource), [Exercises](#sec-benchmarking-ai-resource)
:::

![_DALL·E 3 Prompt: Photo of a podium set against a tech-themed backdrop. On each tier of the podium, there are AI chips with intricate designs. The top chip has a gold medal hanging from it, the second one has a silver medal, and the third has a bronze medal. Banners with 'AI Olympics' are displayed prominently in the background._](images/png/cover_ai_benchmarking.png)

## Purpose {.unnumbered}

_How can quantitative evaluation reshape the development of machine learning systems, and what metrics reveal true system capabilities?_

The measurement and analysis of AI system performance represent a critical element in bridging theoretical capabilities with practical outcomes. Systematic evaluation approaches reveal fundamental relationships between model behavior, resource utilization, and operational reliability. These measurements draw out the essential trade-offs across accuracy, efficiency, and scalability, providing insights that guide architectural decisions throughout the development lifecycle. These evaluation frameworks establish core principles for assessing and validating system design choices and enable the creation of robust solutions that meet increasingly complex performance requirements across diverse deployment scenarios.

::: {.callout-tip title="Learning Objectives"}

* Understand the purpose and goals of benchmarking AI systems, including performance assessment, resource evaluation, validation, and more.

* Learn about key model benchmarks, metrics, and trends, including accuracy, fairness, complexity, performance, and energy efficiency.

* Become familiar with the key components of an AI benchmark, including datasets, tasks, metrics, baselines, reproducibility rules, and more.

* Understand the distinction between training and inference and how each phase warrants specialized ML systems benchmarking.

* Learn about system benchmarking concepts like throughput, latency, power, and computational efficiency.

* Appreciate the evolution of model benchmarking from accuracy to more holistic metrics like fairness, robustness, and real-world applicability.

* Recognize the growing role of data benchmarking in evaluating issues like bias, noise, balance, and diversity.

* Understand the limitations of evaluating models, data, and systems in isolation and the emerging need for integrated benchmarking.

:::

## Overview

Computing systems continue to evolve and grow in complexity. Understanding their performance becomes essential to engineer them better. System evaluation measures how computing systems perform relative to specified requirements and goals. Engineers and researchers examine metrics like processing speed, resource usage, and reliability to understand system behavior under different conditions and workloads. These measurements help teams identify bottlenecks, optimize performance, and verify that systems meet design specifications.

Standardized measurement forms the backbone of scientific and engineering progress. The metric system enables precise communication of physical quantities. Organizations like the National Institute of Standards and Technology maintain fundamental measures from the kilogram to the second. This standardization extends to computing, where benchmarks provide uniform methods to quantify system performance. Standard performance tests measure processor operations, memory bandwidth, network throughput, and other computing capabilities. These benchmarks allow meaningful comparison between different hardware and software configurations.

Machine learning systems present distinct measurement challenges. Unlike traditional computing tasks, ML systems integrate hardware performance, algorithmic behavior, and data characteristics. Performance evaluation must account for computational efficiency and statistical effectiveness. Training time, model accuracy, and generalization capabilities all factor into system assessment. The interdependence between computing resources, algorithmic choices, and dataset properties creates new dimensions for measurement and comparison.

These considerations lead us to define machine learning benchmarking as follows:

::: {.callout-note title="Definition of ML Benchmarking"}  

**Machine Learning Benchmarking (ML Benchmarking)** is the _systematic evaluation_ of _compute performance, algorithmic effectiveness, and data quality_ in machine learning systems. It assesses _system capabilities_, _model accuracy and convergence_, and _data scalability and representativeness_ to optimize system performance across diverse workloads. ML benchmarking enables engineers and researchers to _quantify trade-offs_, _improve deployment efficiency_, and _ensure reproducibility_ in both research and production settings. As ML systems evolve, benchmarks also incorporate _fairness, robustness, and energy efficiency_, reflecting the increasing complexity of AI evaluation.  

:::  

This chapter focuses primarily on benchmarking machine learning systems, examining how computational resources affect training and inference performance. While the main emphasis remains on system-level evaluation, understanding the role of algorithms and data proves essential for comprehensive ML benchmarking.

## Historical Context  

The evolution of computing benchmarks mirrors the development of computer systems themselves, progressing from simple performance metrics to increasingly specialized evaluation frameworks. As computing expanded beyond scientific calculations into diverse applications, benchmarks evolved to measure new capabilities, constraints, and use cases. This progression reflects three major shifts in computing: the transition from mainframes to personal computers, the rise of energy efficiency as a critical concern, and the emergence of specialized computing domains such as machine learning.  

Early benchmarks focused primarily on raw computational power, measuring basic operations like floating-point calculations. As computing applications diversified, benchmark development branched into distinct specialized categories, each designed to evaluate specific aspects of system performance. This specialization accelerated with the emergence of graphics processing, mobile computing, and eventually, cloud services and machine learning.

## Performance Benchmarks  

The evolution of benchmarks in computing illustrates how systematic performance measurement has shaped technological progress. During the 1960s and 1970s, when mainframe computers dominated the computing landscape, performance benchmarks focused primarily on fundamental computational tasks. The [Whetstone benchmark](https://en.wikipedia.org/wiki/Whetstone_(benchmark))[^fn-whetstone], introduced in 1964 to measure floating-point arithmetic performance, became a definitive standard that demonstrated how systematic testing could drive improvements in computer architecture.  

[^fn-whetstone]: Introduced in 1964, the Whetstone benchmark was one of the first synthetic benchmarks designed to measure floating-point arithmetic performance, influencing early computer architecture improvements.  

The introduction of the [LINPACK benchmark](https://en.wikipedia.org/wiki/LINPACK_benchmark) in 1979 expanded the focus of performance evaluation, offering a means to assess how efficiently systems solved linear equations. As computing shifted toward personal computers in the 1980s, the need for standardized performance measurement grew. The [Dhrystone benchmark](https://en.wikipedia.org/wiki/Dhrystone), introduced in 1984, provided one of the first integer-based benchmarks, complementing floating-point evaluations.  

The late 1980s and early 1990s saw the emergence of systematic benchmarking frameworks that emphasized real-world workloads. The [SPEC CPU benchmarks](https://www.spec.org/cpu/)[^fn-spec], introduced in 1989 by the [System Performance Evaluation Cooperative (SPEC)](https://www.spec.org/), fundamentally changed hardware evaluation by shifting the focus from synthetic tests to a standardized suite designed to measure performance using practical computing workloads. This approach enabled manufacturers to optimize their systems for real applications, accelerating advances in processor design and software optimization.  

[^fn-spec]: Launched in 1989, the SPEC CPU benchmark suite shifted performance evaluation towards real-world workloads, significantly influencing processor design and optimization.  

The increasing demand for graphics-intensive applications and mobile computing in the 1990s and early 2000s presented new benchmarking challenges. The introduction of [3DMark](https://www.3dmark.com/) in 1998 established an industry standard for evaluating graphics performance, shaping the development of programmable shaders and modern GPU architectures. Mobile computing introduced an additional constraint—power efficiency—necessitating benchmarks that assessed both computational performance and energy consumption. The release of [MobileMark](https://bapco.com/products/mobilemark-2014/) by [BAPCo](https://bapco.com/) provided a means to evaluate power efficiency in laptops and mobile devices, influencing the development of energy-efficient architectures such as [ARM](https://www.arm.com/).  

The focus of benchmarking in the past decade has shifted toward cloud computing, big data, and artificial intelligence. Cloud service providers such as Amazon Web Services and Google Cloud optimize their platforms based on performance, scalability, and cost-effectiveness [@Barroso2022]. Benchmarks like [CloudSuite](http://cloudsuite.ch/) have become critical for evaluating cloud infrastructure, measuring how well systems handle distributed workloads. Machine learning has introduced another dimension of performance evaluation. The introduction of [MLPerf](https://mlcommons.org/) in 2018 established a widely accepted standard for measuring machine learning training and inference efficiency across different hardware architectures.  

## Energy Benchmarks  

As computing scaled from personal devices to massive data centers, energy efficiency emerged as a critical dimension of performance evaluation. The mid-2000s marked a shift in benchmarking methodologies, moving beyond raw computational speed to assess power efficiency across diverse computing platforms. The increasing thermal constraints in processor design, coupled with the scaling demands of large-scale internet services, underscored energy consumption as a fundamental consideration in system evaluation.  

Power benchmarking addresses three interconnected challenges: environmental sustainability, operational efficiency, and device usability. The growing energy demands of the technology sector have intensified concerns about sustainability, while energy costs continue to shape the economics of data center operations. In mobile computing, power efficiency directly determines battery life and user experience, reinforcing the importance of energy-aware performance measurement.  

The industry has responded with several standardized benchmarks that quantify energy efficiency. [SPEC Power](https://www.spec.org/power/) provides a widely accepted methodology for measuring server efficiency across varying workload levels, allowing for direct comparisons of power-performance trade-offs. The [Green500](https://www.top500.org/green500/) ranking[^fn-green500] applies similar principles to high-performance computing, ranking the world's most powerful supercomputers based on their energy efficiency rather than their raw performance. The [ENERGY STAR](https://www.energystar.gov/products/computers) certification program has also established foundational energy standards that have shaped the design of consumer and enterprise computing systems.  

[^fn-green500]: Established in 2007, the Green500 ranks supercomputers based on energy efficiency, highlighting advances in power-efficient high-performance computing.  

Power benchmarking faces distinct challenges, particularly in accounting for the diverse workload patterns and system configurations encountered across different computing environments. Recent advancements, such as the [MLPerf Power](https://mlcommons.org/) benchmark, have introduced specialized methodologies for measuring the energy impact of machine learning workloads, addressing the growing importance of energy efficiency in AI-driven computing. As artificial intelligence and edge computing continue to evolve, power benchmarking will play an increasingly crucial role in driving energy-efficient hardware and software innovations.  

## Domain-Specific Benchmarks  

The evolution of computing applications, particularly in artificial intelligence, has highlighted the limitations of general-purpose benchmarks and led to the development of domain-specific evaluation frameworks. Standardized benchmarks, while effective for assessing broad system performance, often fail to capture the unique constraints and operational requirements of specialized workloads. This gap has resulted in the emergence of tailored benchmarking methodologies designed to evaluate performance in specific computing domains.  

Machine learning presents one of the most prominent examples of this transition. Traditional CPU and GPU benchmarks are insufficient for assessing workloads, which involve complex interactions between computation, memory bandwidth, and data movement. The introduction of MLPerf has standardized performance measurement for machine learning models, providing detailed insights into training and inference efficiency.  

Beyond AI, domain-specific benchmarks have been adopted across various industries. Healthcare organizations have developed benchmarking frameworks to evaluate machine learning models used in medical diagnostics, ensuring that performance assessments align with real-world patient data. In financial computing, specialized benchmarking methodologies assess transaction latency and fraud detection accuracy, ensuring that high-frequency trading systems meet stringent timing requirements. Autonomous vehicle developers implement evaluation frameworks that test AI models under varying environmental conditions and traffic scenarios, ensuring the reliability of self-driving systems.  

The strength of domain-specific benchmarks lies in their ability to capture workload-specific performance characteristics that general benchmarks may overlook. By tailoring performance evaluation to sector-specific requirements, these benchmarks provide insights that drive targeted optimizations in both hardware and software. As computing continues to expand into new domains, specialized benchmarking will remain a key tool for assessing and improving performance in emerging fields.  

## AI Benchmarks: System, Model, and Data  

The evolution of benchmarks reaches its apex in machine learning, reflecting a journey that parallels the field's development towards domain-specific applications. Early machine learning benchmarks focused primarily on algorithmic performance, measuring how well models could perform specific tasks [@lecun1998gradient]. As machine learning applications scaled and computational demands grew, the focus expanded to include system performance and hardware efficiency [@jouppi2017datacenter]. Most recently, the critical role of data quality has emerged as the third essential dimension of evaluation [@gebru2018datasheets].  

What sets AI benchmarks apart from traditional performance metrics is their inherent variability---introducing accuracy as a fundamental dimension of evaluation. Unlike conventional benchmarks, which measure fixed, deterministic characteristics like computational speed or energy consumption, AI benchmarks must account for the probabilistic nature of machine learning models. The same system can produce different results depending on the data it encounters, making accuracy a defining factor in performance assessment. This distinction adds complexity, as benchmarking AI systems requires not only measuring raw computational efficiency but also understanding trade-offs between accuracy, generalization, and resource constraints.  

The growing complexity and ubiquity of machine learning systems demand comprehensive benchmarking across all three dimensions: algorithmic models, hardware systems, and training data. This multifaceted evaluation approach represents a significant departure from earlier benchmarks that could focus on isolated aspects like computational speed or energy efficiency [@hernandez2020measuring]. Modern machine learning benchmarks must address the sophisticated interplay between these dimensions, as limitations in any one area can fundamentally constrain overall system performance.  

This evolution in benchmark complexity mirrors the field's deepening understanding of what drives machine learning system success. While algorithmic innovations initially dominated progress metrics, the challenges of deploying models at scale revealed the critical importance of hardware efficiency [@jouppi2021ten]. Subsequently, high-profile failures of machine learning systems in real-world deployments highlighted how data quality and representation fundamentally determine system reliability and fairness [@bender2021stochastic]. Understanding how these dimensions interact has become essential for accurately assessing machine learning system performance, informing development decisions, and measuring technological progress in the field.  

### Algorithmic Benchmarks

AI algorithms must balance multiple interconnected performance objectives, including accuracy, speed, resource efficiency, and generalization capability. As machine learning applications span diverse domains—such as computer vision, natural language processing, speech recognition, and reinforcement learning—evaluating these objectives requires standardized methodologies tailored to each domain's unique challenges. Algorithmic benchmarks, such as ImageNet [@deng2009imagenet], establish these evaluation frameworks, providing a consistent basis for comparing different machine learning approaches.  

::: {.callout-note title="Definition of Machine Learning  Algorithmic Benchmarks"}

**ML Algorithmic benchmarks** refer to the evaluation of machine learning models on _standardized tasks_ using _predefined datasets and metrics_. These benchmarks measure _accuracy, efficiency, and generalization_ to ensure _objective comparisons_ across different models. Algorithmic benchmarks provide _performance baselines_, enabling systematic assessment of _trade-offs between model complexity and computational cost_. They drive _technological progress_ by tracking improvements over time and identifying _limitations_ in existing approaches.

:::

Algorithmic benchmarks serve several critical functions in advancing AI. They establish clear performance baselines, enabling objective comparisons between competing approaches. By systematically evaluating trade-offs between model complexity, computational requirements, and task performance, they help researchers and practitioners identify optimal design choices. Moreover, they track technological progress by documenting improvements over time, guiding the development of new techniques while exposing limitations in existing methodologies. Through these roles, algorithmic benchmarks shape the trajectory of AI research and development, ensuring that innovations translate into measurable, real-world improvements.

### System Benchmarks

AI computations, particularly in machine learning, place extraordinary demands on computational resources. The underlying hardware infrastructure, encompassing CPUs, GPUs, TPUs, and specialized accelerators, fundamentally determines the speed, efficiency, and scalability of AI solutions. System benchmarks establish standardized methodologies for evaluating hardware performance across diverse AI workloads, measuring critical metrics including computational throughput, memory bandwidth, power efficiency, and scaling characteristics [@reddi2020mlperf; Mattson2020].  

::: {.callout-note title="Definition of Machine Learning System Benchmarks"}  

**ML System benchmarks** refer to the evaluation of _computational infrastructure_ used to execute AI workloads, assessing _performance, efficiency, and scalability_ under standardized conditions. These benchmarks measure _throughput, latency, and resource utilization_ to ensure _objective comparisons_ across different system configurations. System benchmarks provide _insights into workload efficiency_, guiding _infrastructure selection, system optimization,_ and _advancements in computational architectures_.  

:::  

These benchmarks fulfill two essential functions in the AI ecosystem. First, they enable developers and organizations to make informed decisions when selecting hardware platforms for their AI applications by providing comprehensive comparative performance data across system configurations. Critical evaluation factors include training speed, inference latency, energy efficiency, and cost-effectiveness. Second, hardware manufacturers rely on these benchmarks to quantify generational improvements and guide the development of specialized AI accelerators, driving continuous advancement in computational capabilities.  

System benchmarks evaluate performance across multiple scales, ranging from single-chip configurations to large distributed systems, and diverse AI workloads including both training and inference tasks. This comprehensive evaluation approach ensures that benchmarks accurately reflect real-world deployment scenarios and deliver actionable insights that inform both hardware selection decisions and system architecture design.  

### Data Benchmarks  

Data quality, scale, and diversity fundamentally shape machine learning system performance, directly influencing how effectively algorithms learn and generalize to new situations. Data benchmarks establish standardized datasets and evaluation methodologies that enable consistent comparison of different approaches. These frameworks assess critical aspects of data quality, including domain coverage, potential biases, and resilience to real-world variations in input data [@gebru2021datasheets].  

::: {.callout-note title="Definition of Machine Learning Data Benchmarks"}  

**ML Data benchmarks** refer to the evaluation of _datasets and data quality_ in machine learning, assessing _coverage, bias, and robustness_ under standardized conditions. These benchmarks measure _data representativeness, consistency, and impact on model performance_ to ensure _objective comparisons_ across different AI approaches. Data benchmarks provide _insights into data reliability_, guiding _dataset selection, bias mitigation,_ and _improvements in data-driven AI systems_.  

:::  

Data benchmarks serve an essential function in understanding AI system behavior under diverse data conditions. Through systematic evaluation, they help identify common failure modes, expose gaps in data coverage, and reveal underlying biases that could impact model behavior in deployment. By providing common frameworks for data evaluation, these benchmarks enable the AI community to systematically improve data quality and address potential issues before deploying systems in production environments. This proactive approach to data quality assessment has become increasingly critical as AI systems take on more complex and consequential tasks across different domains.  

### Community Consensus

The proliferation of benchmarks spanning performance, energy efficiency, and domain-specific applications creates a fundamental challenge: establishing industry-wide standards. While early computing benchmarks primarily measured processor speed and memory bandwidth, modern benchmarks evaluate sophisticated aspects of system performance, from power consumption profiles to application-specific capabilities. This evolution in scope and complexity necessitates comprehensive validation and consensus from the computing community, particularly in rapidly evolving fields like machine learning where performance must be evaluated across multiple interdependent dimensions.

The lasting impact of a benchmark depends fundamentally on its acceptance by the research community, where technical excellence alone proves insufficient. Benchmarks developed without broad community input often fail to gain traction, frequently missing metrics that leading research groups consider essential. Successful benchmarks emerge through collaborative development involving academic institutions, industry partners, and domain experts. This inclusive approach ensures benchmarks evaluate capabilities most crucial for advancing the field, while balancing theoretical and practical considerations.

Benchmarks developed through extensive collaboration among respected institutions carry the authority necessary to drive widespread adoption, while those perceived as advancing particular corporate interests face skepticism and limited acceptance. The success of ImageNet demonstrates how sustained community engagement through workshops and challenges establishes long-term viability. This community-driven development creates a foundation for formal standardization, where organizations like IEEE and ISO transform these benchmarks into official standards.

The standardization process provides crucial infrastructure for benchmark formalization and adoption. [IEEE working groups](https://standards.ieee.org/develop/wg/) transform community-developed benchmarking methodologies into formal industry standards, establishing precise specifications for measurement and reporting. The [IEEE 2416-2019](https://standards.ieee.org/ieee/2416/7065/) standard for system power modeling[^fn-ieee-2416] exemplifies this process, codifying best practices developed through community consensus. Similarly, [ISO/IEC technical committees](https://www.iso.org/committee/45020.html) develop international standards for benchmark validation and certification, ensuring consistent evaluation across global research and industry communities. These organizations bridge the gap between community-driven innovation and formal standardization, providing frameworks that enable reliable comparison of results across different institutions and geographic regions.  

[^fn-ieee-2416]: **IEEE 2416-2019:** A standard defining methodologies for parameterized power modeling, enabling system-level power analysis and optimization in electronic design, including AI hardware.  

Successful community benchmarks establish clear governance structures for managing their evolution. Through rigorous version control systems and detailed change documentation, benchmarks maintain backward compatibility while incorporating new advances. This governance includes formal processes for proposing, reviewing, and implementing changes, ensuring that benchmarks remain relevant while maintaining stability. Modern benchmarks increasingly emphasize reproducibility requirements, incorporating automated verification systems and standardized evaluation environments.

Open access accelerates benchmark adoption and ensures consistent implementation. Projects that provide open-source reference implementations, comprehensive documentation, validation suites, and containerized evaluation environments reduce barriers to entry. This standardization enables research groups to evaluate solutions using uniform methods and metrics. Without such coordinated implementation frameworks, organizations might interpret benchmarks inconsistently, compromising result reproducibility and meaningful comparison across studies.

The most successful benchmarks strike a careful balance between academic rigor and industry practicality. Academic involvement ensures theoretical soundness and comprehensive evaluation methodology, while industry participation grounds benchmarks in practical constraints and real-world applications. This balance proves particularly crucial in machine learning benchmarks, where theoretical advances must translate to practical improvements in deployed systems [@patterson2021carbon].

Community consensus establishes enduring benchmark relevance, while fragmentation impedes scientific progress. Through collaborative development and transparent operation, benchmarks evolve into authoritative standards for measuring advancement. The most successful benchmarks in energy efficiency and domain-specific applications share this foundation of community development and governance, demonstrating how collective expertise and shared purpose create lasting impact in rapidly advancing fields.

## Benchmark Components

An AI benchmark is more than just a test or a score; it is a comprehensive evaluation framework designed to assess the performance and capabilities of artificial intelligence systems. To understand this in-depth, it is essential to break down the typical components that constitute an AI benchmark.

### Standardized Datasets

Standardized datasets form the cornerstone of AI benchmarks, providing a consistent foundation for training and evaluating models. These datasets are meticulously curated to ensure that all models are tested on equal footing, allowing for meaningful comparisons across different approaches and architectures. In the field of computer vision, datasets such as [ImageNet](http://www.image-net.org/) [@deng2009imagenet], [COCO](https://cocodataset.org/) [@lin2014microsoft], and [CIFAR-10](https://www.cs.toronto.edu/~kriz/cifar.html) [@krizhevsky2009learning] have become gold standards. For natural language processing, corpora such as [SQuAD](https://rajpurkar.github.io/SQuAD-explorer/) [@rajpurkar2016squad], [GLUE](https://gluebenchmark.com/) [@wang2018glue], and [WikiText](https://blog.einstein.ai/the-wikitext-long-term-dependency-language-modeling-dataset/) [@merity2016pointer] serve similar roles. These datasets often encompass a wide range of complexities and edge cases, pushing machine learning systems to their limits and revealing their true capabilities.

The choice of dataset significantly influences benchmark results, making it crucial to select datasets that accurately represent real-world challenges. Moreover, as machine learning systems evolve, so too must these datasets to continue providing relevant and challenging evaluation scenarios.

### Pre-defined Tasks

Pre-defined tasks are essential components of machine learning benchmarks, providing clear objectives against which models can be evaluated. These tasks simulate real-world problems and challenges, allowing researchers and practitioners to assess a model's practical capabilities.

Tasks are typically designed to test specific aspects of machine learning systems, such as classification, regression, generation, or reasoning. For instance, in natural language processing, common tasks include sentiment analysis, machine translation, and question answering [@hirschberg2015advances]. In computer vision, object detection, image segmentation, and facial recognition are frequently used benchmark tasks [@everingham2010pascal].

The complexity and diversity of these tasks play a crucial role in the benchmark's effectiveness. Well-designed tasks should:

1. Reflect real-world applications
2. Cover a range of difficulties
3. Test multiple aspects of model performance
4. Be clearly defined and unambiguous

As machine learning advances, benchmark tasks must evolve to keep pace with emerging capabilities and challenges, ensuring they remain relevant and informative.

### Evaluation Metrics

Evaluation metrics are quantitative measures used to assess the performance of machine learning models on specific tasks. These metrics provide objective standards for comparing different models and approaches, enabling researchers and practitioners to gauge the effectiveness of their solutions. The selection of appropriate evaluation metrics is a critical aspect of benchmark design. Metrics must align closely with the task objectives and provide meaningful insights into model performance. For classification tasks, common metrics include accuracy, precision, recall, and F1 score [@sokolova2009systematic]. These metrics offer different perspectives on a model's ability to correctly identify and categorize data points.

In regression tasks, where the goal is to predict continuous values, error-based metrics are typically employed. Mean Squared Error (MSE) and Mean Absolute Error (MAE) quantify the discrepancy between predicted and actual values, providing a measure of the model's predictive accuracy. Certain domains require specialized metrics to capture task-specific nuances. In natural language processing, for instance, the BLEU score[^fn-bleu] is frequently used to evaluate machine translation quality, assessing the similarity between machine-generated translations and those produced by human experts [@papineni2002bleu].  

[^fn-bleu]: **BLEU Score:** A metric used in machine translation to measure the similarity between a machine-generated translation and human reference translations by comparing n-gram overlap.  

It is important to note that commonly used metrics may not always capture the full complexity of model performance. For example, in imbalanced datasets, accuracy can be misleading. Researchers must consider the limitations of each metric and select those most appropriate for their specific task and data distribution. As machine learning models become more sophisticated and are increasingly deployed in real-world applications, additional performance aspects have gained prominence. Metrics related to inference time, model size, and energy efficiency are now often incorporated into benchmarks. These metrics address practical considerations of model deployment, reflecting the growing need for solutions that balance accuracy with computational efficiency.

No single metric can fully capture all aspects of model performance. Consequently, comprehensive benchmarks often employ a combination of metrics to provide a more holistic evaluation. This multi-faceted approach allows for a nuanced understanding of a model's strengths and limitations across various performance dimensions.

### Baselines and Baseline Models

Baselines and baseline models serve as fundamental reference points in AI benchmarks. These standard models or methods provide a basis for comparison, allowing researchers to contextualize the performance of more advanced techniques. In benchmark design, the selection of appropriate baselines is crucial. Simple models, such as linear regression for continuous predictions or logistic regression for classification tasks, often serve as initial baselines. These straightforward approaches establish a minimum performance threshold that more complex models should surpass. More sophisticated baselines may include established machine learning algorithms or architectures that have demonstrated strong performance on similar tasks. For instance, in natural language processing tasks, models like BERT[^fn-bert] or GPT might serve as baselines against which newer models are compared.  

[^fn-bert]: **BERT (Bidirectional Encoder Representations from Transformers):** A pre-trained transformer-based language model introduced by Google in 2018 that revolutionized NLP tasks by enabling bidirectional contextual understanding.  

The inclusion of multiple baselines in a benchmark offers several advantages. Baselines provide a frame of reference for interpreting the results of more advanced models. By comparing new models to established baselines, researchers can quantify improvements in the field over time. Simple baselines can highlight cases where complex models may be unnecessarily sophisticated for a given task. Additionally, comparing advanced models to baselines across various datasets can reveal potential overfitting or task-specific optimizations.

It is important to note that as the field progresses, baselines that were once considered state-of-the-art may become outdated. Consequently, benchmark designers must periodically reassess and update their baseline models to ensure they remain relevant and challenging. By providing these points of comparison, baselines and baseline models play a critical role in the rigorous evaluation of machine learning techniques, contributing to the overall advancement of the field.

### Hardware and Software Specifications

Hardware and software specifications are critical components of machine learning benchmarks, as they significantly influence model performance, training time, and reproducibility of results. These specifications provide a detailed description of the computational environment in which experiments are conducted.

Hardware specifications typically include:

1. Processor type and speed (e.g., CPU model, clock rate)
2. Graphics Processing Units (GPUs) or Tensor Processing Units (TPUs), if used
3. Memory capacity and type (e.g., RAM size, DDR4)
4. Storage type and capacity (e.g., SSD, HDD)
5. Network configuration, if relevant for distributed computing

Software specifications generally encompass:

1. Operating system and version
2. Programming language and version
3. Machine learning frameworks and libraries (e.g., TensorFlow, PyTorch) with version numbers
4. Compiler information and optimization flags
5. Custom software or scripts used in the benchmark process

The precise documentation of these specifications is crucial for several reasons. Firstly, it ensures reproducibility, allowing other researchers to replicate the benchmark environment as closely as possible. Secondly, it provides context for interpreting performance metrics, as hardware capabilities can significantly impact training and inference times. Lastly, it helps in understanding the scalability and resource requirements of different models.

In many cases, benchmarks may include results from multiple hardware configurations to provide a more comprehensive view of model performance across different computational environments. This approach is particularly valuable as it highlights the trade-offs between model complexity, computational resources, and performance.

As the field evolves, hardware and software specifications in benchmarks are increasingly including information about energy consumption and computational efficiency. This trend reflects growing concerns about the environmental impact of large-scale machine learning models and the need for sustainable AI practices.

By clearly defining hardware and software specifications, benchmarks contribute to the transparency and reliability of machine learning research, facilitating fair comparisons and fostering progress in the field.

### Environmental Conditions

Environmental conditions in AI benchmarking refer to the physical and operational circumstances under which experiments are conducted. These conditions, while often overlooked, can significantly influence benchmark results and impact the reproducibility of experiments. Physical environmental factors include ambient temperature, humidity, air quality, and altitude. These elements can affect hardware performance in subtle but measurable ways. For instance, elevated temperatures may lead to thermal throttling[^fn-throttling] in processors, potentially reducing computational speed and affecting benchmark outcomes. Similarly, variations in altitude can impact cooling system efficiency and hard drive performance due to changes in air pressure.  

[^fn-throttling]: **Thermal Throttling:** A mechanism in computer processors that reduces performance to prevent overheating, often triggered by excessive computational load or inadequate cooling.  

Operational environmental factors encompass the broader system context in which benchmarks are executed. This includes background processes running on the system, network conditions, and power supply stability. The presence of other active programs or services can compete for computational resources, potentially altering the performance characteristics of the model under evaluation. To ensure the validity and reproducibility of benchmark results, it is crucial to document and control these environmental conditions to the extent possible. This may involve conducting experiments in temperature-controlled environments, monitoring and reporting ambient conditions, standardizing the operational state of benchmark systems, and documenting any background processes or system loads.

In scenarios where controlling all environmental variables is impractical, such as in distributed or cloud-based benchmarking, it becomes essential to report these conditions in detail. This information allows other researchers to account for potential variations when interpreting or attempting to reproduce results. As machine learning models are increasingly deployed in diverse real-world environments, understanding the impact of environmental conditions on model performance becomes even more critical. This knowledge not only ensures more accurate benchmarking but also informs the development of robust models capable of consistent performance across varying operational conditions.

### Reproducibility Rules

Reproducibility is a cornerstone of scientific research, and AI benchmarks are no exception. Reproducibility rules are guidelines and practices that ensure benchmark results can be reliably replicated by other researchers or practitioners. These rules are crucial for validating claims, building upon existing work, and advancing the field of machine learning. At the heart of reproducibility in AI benchmarks is the concept of controlled randomness. Many machine learning algorithms involve stochastic processes, such as random weight initialization or data shuffling. To address this, benchmarks often specify seed values for random number generators. By using the same seed, researchers can ensure that the "random" elements of their experiments are consistent across different runs and environments.

Another key aspect of reproducibility is the complete documentation of hyperparameters. These are the settings that control the learning process but are not learned from the data itself. Examples include learning rates, batch sizes, and network architectures. Even small changes in hyperparameters can lead to significant differences in model performance, making their precise documentation essential. Benchmarks also typically require the preservation and sharing of training and evaluation datasets. In cases where data cannot be directly shared due to privacy or licensing concerns, benchmarks may provide detailed descriptions of data preprocessing steps and selection criteria. This allows other researchers to assemble comparable datasets or understand the characteristics of the data used in the original experiments.

Code availability is another critical component of reproducibility rules. Many benchmarks now require the publication of implementation code, preferably in a version-controlled repository. This code should include not only the model implementation but also scripts for data preprocessing, training, and evaluation. Some benchmarks go a step further, providing containerized environments that encapsulate all necessary dependencies and configurations. Detailed logging of the training process and intermediate results is also often mandated. This includes recording metrics at regular intervals during training, saving model checkpoints, and documenting any manual interventions or adjustments made during the experiment.

By adhering to these reproducibility rules, AI benchmarks foster transparency, facilitate peer review, and accelerate scientific progress. They allow the community to verify results, build upon successful approaches, and identify potential issues or limitations in proposed methods. As the field of machine learning continues to evolve rapidly, the importance of robust reproducibility practices in benchmarking cannot be overstated.

### Result Interpretation Guidelines

Result interpretation guidelines are an essential component of AI benchmarks, providing a framework for understanding and contextualizing benchmark outcomes. These guidelines help researchers and practitioners draw meaningful conclusions from benchmark results, ensuring fair and informative comparisons between different models or approaches. A key aspect of result interpretation is understanding the statistical significance of performance differences. Benchmarks often specify guidelines for conducting appropriate statistical tests and reporting confidence intervals. This approach helps distinguish between meaningful improvements and variations that may be due to random chance or noise in the data.

Benchmarks typically provide context for interpreting metrics in light of real-world applications. For instance, a small improvement in accuracy might be considered significant for certain high-stakes applications, while in other contexts, factors like inference speed or model size might take precedence over marginal accuracy gains. It is crucial for users to understand the limitations of the benchmark itself. No benchmark can cover all possible use cases or scenarios. Guidelines often address where benchmark results are most applicable and where they might not generalize well, including discussions of dataset biases, task-specific quirks, or limitations in the evaluation metrics.

Many benchmarks now include guidelines for interpreting results across different performance axes. For example, a model might excel in accuracy but perform poorly in terms of computational efficiency. Interpretation guidelines help users navigate these trade-offs and select models that best fit their specific requirements and constraints. The issue of overfitting to the benchmark is frequently addressed in these guidelines. As benchmarks become widely used, there's a risk that researchers might optimize their models specifically for the benchmark tasks, potentially at the expense of generalizability. Guidelines may suggest ways to assess a model's performance beyond the specific benchmark tasks or caution against over-interpreting small performance gains.

Cross-validation[^fn-cross-validation] techniques play a crucial role in result interpretation. By evaluating models on multiple subsets of the data, researchers can gain a more robust understanding of model performance and reduce the risk of overfitting to a particular dataset split. Benchmark guidelines often specify cross-validation procedures to ensure consistent and reliable performance estimates. Result interpretation guidelines often encourage a holistic view of model performance. This may include considering factors beyond the primary metrics, such as model robustness, fairness across different demographic groups, or performance degradation over time.

[^fn-cross-validation]: **Cross-Validation:** A statistical technique used in machine learning to evaluate model performance by partitioning data into multiple subsets, training on some and testing on others, to reduce overfitting.  

By providing these interpretation guidelines, benchmarks not only offer a standardized way to measure performance but also promote a nuanced and contextualized understanding of machine learning model capabilities. This approach supports more informed decision-making in both research and practical applications of machine learning technologies.

Standardized datasets are the cornerstone of machine learning benchmarks, providing a consistent foundation for training and evaluation. These carefully curated collections of data ensure that all models are tested on equal footing, allowing for meaningful comparisons across different approaches and architectures.

In the field of computer vision, datasets like [ImageNet](http://www.image-net.org/), [COCO](https://cocodataset.org/), and [CIFAR-10](https://www.cs.toronto.edu/~kriz/cifar.html) have become gold standards. For natural language processing, corpora such as [SQuAD](https://rajpurkar.github.io/SQuAD-explorer/), [GLUE](https://gluebenchmark.com/), and [WikiText](https://blog.einstein.ai/the-wikitext-long-term-dependency-language-modeling-dataset/) serve similar roles. These datasets often encompass a wide range of complexities and edge cases, pushing machine learning systems to their limits and revealing their true capabilities.

The choice of dataset significantly influences benchmark results, making it crucial to select datasets that accurately represent real-world challenges. Moreover, as machine learning systems evolve, so too must these datasets to continue providing relevant and challenging evaluation scenarios.

## Benchmarking Granularity

Machine learning system benchmarking provides a structured and systematic approach to assessing a system's performance across various dimensions. Given the complexity of ML systems, we can dissect their performance through different levels of granularity and obtain a comprehensive view of the system's efficiency, identify potential bottlenecks, and pinpoint areas for improvement. To this end, various types of benchmarks have evolved over the years and continue to persist.

@fig-granularity shows the different layers of granularity of an ML system. At the application level, end-to-end benchmarks assess the overall system performance, considering factors like data preprocessing, model training, and inference. While at the model layer, benchmarks focus on assessing the efficiency and accuracy of specific models. This includes evaluating how well models generalize to new data and their computational efficiency during training and inference. Furthermore, benchmarking can extend to hardware and software infrastructure, examining the performance of individual components like GPUs or TPUs.

![ML system granularity.](images/png/end2end.png){#fig-granularity}

### Micro Benchmarks

Micro-benchmarks are specialized evaluation tools that assess distinct components or specific operations within a broader machine learning process. These benchmarks isolate individual tasks to provide detailed insights into the computational demands of particular system elements, from neural network layers to optimization techniques to activation functions. For example, micro-benchmarks might measure the time required to execute a convolutional layer in a deep learning model or evaluate the speed of data preprocessing operations that prepare training data.

A key area of micro-benchmarking focuses on tensor operations, which are the computational foundation of deep learning. Libraries like [cuDNN](https://developer.nvidia.com/cudnn) by NVIDIA provide benchmarks for measuring fundamental computations such as convolutions and matrix multiplications across different hardware configurations. These measurements help developers understand how their hardware handles the core mathematical operations that dominate ML workloads.

Micro-benchmarks also examine activation functions and neural network layers in isolation. This includes measuring the performance of various activation functions like ReLU, Sigmoid, and Tanh under controlled conditions, as well as evaluating the computational efficiency of distinct neural network components such as LSTM cells or Transformer blocks when processing standardized inputs.

[DeepBench](https://github.com/baidu-research/DeepBench), developed by Baidu, was one of the first to demonstrate the value of comprehensive micro-benchmarking. It evaluates these fundamental operations across different hardware platforms, providing detailed performance data that helps developers optimize their deep learning implementations. By isolating and measuring individual operations, DeepBench enables precise comparison of hardware platforms and identification of potential performance bottlenecks.

:::{#exr-cuda .callout-caution collapse="true" title="Benchmarking Tensor Operations"}

Ever wonder how your image filters get so fast? Special libraries like cuDNN supercharge those calculations on certain hardware. In this Colab, we'll use cuDNN with PyTorch to speed up image filtering. Think of it as a tiny benchmark, showing how the right software can unlock your GPU's power!  
  
[![](https://colab.research.google.com/assets/colab-badge.png)](https://colab.research.google.com/github/RyanHartzell/cudnn-image-filtering/blob/master/notebooks/CuDNN%20Image%20Filtering%20Tutorial%20Using%20PyTorch.ipynb#scrollTo=1sWeXdYsATrr)

:::

### Macro Benchmarks

While micro-benchmarks examine individual operations like tensor computations and layer performance, macro benchmarks evaluate complete machine learning models. This shift from component-level to model-level assessment provides insights into how architectural choices and component interactions affect overall model behavior. For instance, while micro-benchmarks might show optimal performance for individual convolutional layers, macro-benchmarks reveal how these layers work together within a complete convolutional neural network.

Macro-benchmarks measure multiple performance dimensions that emerge only at the model level. These include prediction accuracy, which shows how well the model generalizes to new data; memory consumption patterns across different batch sizes and sequence lengths; throughput under varying computational loads; and latency across different hardware configurations. Understanding these metrics helps developers make informed decisions about model architecture, optimization strategies, and deployment configurations.

The assessment of complete models occurs under standardized conditions using established datasets and tasks. For example, computer vision models might be evaluated on [ImageNet](https://www.image-net.org/), measuring both computational efficiency and prediction accuracy. Natural language processing models might be assessed on translation tasks, examining how they balance quality and speed across different language pairs.

Several industry-standard benchmarks enable consistent model evaluation across platforms. [MLPerf Inference](https://github.com/mlcommons/inference) provides comprehensive testing suites adapted for different computational environments [@reddi2020mlperf]. [MLPerf Mobile](https://github.com/mlcommons/mobile_app_open) focuses on mobile device constraints [@janapa2022mlperf], while [MLPerf Tiny](https://github.com/mlcommons/tiny) addresses microcontroller deployments [@banbury2021mlperf]. For embedded systems, [EEMBC's MLMark](https://github.com/eembc/mlmark)[^fn-eembc] emphasizes both performance and power efficiency. The [AI-Benchmark](https://ai-benchmark.com/) suite specializes in mobile platforms, evaluating models across diverse tasks from image recognition to face parsing.  

[^fn-eembc]: **EEMBC (Embedded Microprocessor Benchmark Consortium):** A nonprofit industry group that develops benchmarks for embedded systems, including MLMark for evaluating machine learning workloads.

### End-to-end Benchmarks

End-to-end benchmarks provide an all-inclusive evaluation that extends beyond the boundaries of the ML model itself. Rather than focusing solely on a machine learning model's computational efficiency or accuracy, these benchmarks encompass the entire pipeline of an AI system. This includes initial ETL (Extract-Transform-Load) or ELT (Extract-Load-Transform) data processing, the core model's performance, post-processing of results, and critical infrastructure components like storage and network systems.

Data processing is the foundation of all AI systems, transforming raw data into a format suitable for model training or inference. In ETL pipelines, data undergoes extraction from source systems, transformation through cleaning and feature engineering, and loading into model-ready formats. These preprocessing steps' efficiency, scalability, and accuracy significantly impact overall system performance. End-to-end benchmarks must assess standardized datasets through these pipelines to ensure data preparation doesn't become a bottleneck.

The post-processing phase plays an equally important role. This involves interpreting the model's raw outputs, converting scores into meaningful categories, filtering results based on predefined tasks, or integrating with other systems. For instance, a computer vision system might need to post-process detection boundaries, apply confidence thresholds, and format results for downstream applications. In real-world deployments, this phase proves crucial for delivering actionable insights.

Beyond core AI operations, infrastructure components heavily influence overall performance and user experience. Storage solutions, whether cloud-based, on-premises, or hybrid, can significantly impact data retrieval and storage times, especially with vast AI datasets. Network interactions, vital for distributed systems, can become performance bottlenecks if not optimized. End-to-end benchmarks must evaluate these components under specified environmental conditions to ensure reproducible measurements of the entire system.

To date, there are no public, end-to-end benchmarks that fully account for data storage, network, and compute performance. While MLPerf Training and Inference approach end-to-end evaluation, they primarily focus on model performance rather than real-world deployment scenarios. Nonetheless, they provide valuable baseline metrics for assessing AI system capabilities.

Given the inherent specificity of end-to-end benchmarking, organizations typically perform these evaluations internally by instrumenting production deployments. This allows engineers to develop result interpretation guidelines based on realistic workloads, but given the sensitivity and specificity of the information, these benchmarks rarely appear in public settings.

### The Trade-offs

As shown in @tbl-benchmark-comparison, different challenges emerge at different stages of an AI system's lifecycle. Each benchmarking approach provides unique insights: micro-benchmarks help engineers optimize specific components like GPU kernel implementations or data loading operations, macro-benchmarks guide model architecture decisions and algorithm selection, while end-to-end benchmarks reveal system-level bottlenecks in production environments.

+-------------+-----------------------------------------------------------+--------------------------------------------------------+--------------------------------------------------------+
| Component   | Micro Benchmarks                                          | Macro Benchmarks                                       | End-to-End Benchmarks                                  |
+:============+:==========================================================+:=======================================================+:=======================================================+
| Focus       | Individual operations                                     | Complete models                                        | Full system pipeline                                   |
+-------------+-----------------------------------------------------------+--------------------------------------------------------+--------------------------------------------------------+
| Scope       | Tensor ops, layers, activations                           | Model architecture, training, inference                | ETL, model, infrastructure                             |
+-------------+-----------------------------------------------------------+--------------------------------------------------------+--------------------------------------------------------+
| Example     | Conv layer performance on cuDNN                           | ResNet-50 on ImageNet                                  | Production recommendation system                       |
+-------------+-----------------------------------------------------------+--------------------------------------------------------+--------------------------------------------------------+
| Advantages  | Precise bottleneck identification, Component optimization | Model architecture comparison, Standardized evaluation | Realistic performance assessment, System-wide insights |
+-------------+-----------------------------------------------------------+--------------------------------------------------------+--------------------------------------------------------+
| Challenges  | May miss interaction effects                              | Limited infrastructure insights                        | Complex to standardize, Often proprietary              |
+-------------+-----------------------------------------------------------+--------------------------------------------------------+--------------------------------------------------------+
| Typical Use | Hardware selection, Operation optimization                | Model selection, Research comparison                   | Production system evaluation                           |
+-------------+-----------------------------------------------------------+--------------------------------------------------------+--------------------------------------------------------+

: Comparison of benchmarking approaches across different dimensions. Each approach offers distinct advantages and focuses on different aspects of ML system evaluation. {#tbl-benchmark-comparison .striped .hover}

Component interaction often produces unexpected behaviors. For example, while micro-benchmarks might show excellent performance for individual convolutional layers, and macro-benchmarks might demonstrate strong accuracy for the complete model, end-to-end evaluation could reveal that data preprocessing creates unexpected bottlenecks during high-traffic periods. These system-level insights often remain hidden when components undergo isolated testing.

Component interaction often produces unexpected behaviors. For example, while micro-benchmarks might show excellent performance for individual convolutional layers, and macro-benchmarks might demonstrate strong accuracy for the complete model, end-to-end evaluation could reveal that data preprocessing creates unexpected bottlenecks during high-traffic periods. These system-level insights often remain hidden when components undergo isolated testing.

## Training Benchmarks  

Training benchmarks provide a systematic approach to evaluating the efficiency, scalability, and resource demands of the training phase. They allow practitioners to assess how different design choices—such as model architectures, data loading mechanisms, hardware configurations, and distributed training strategies—impact performance. These benchmarks are particularly vital as machine learning systems grow in scale, requiring billions of parameters, terabytes of data, and distributed computing environments.  

For instance, large-scale models like [OpenAI's GPT-3](https://arxiv.org/abs/2005.14165) [@brown2020language], which consists of 175 billion parameters trained on 45 terabytes of data, highlight the immense computational demands of training. Benchmarks enable systematic evaluation of the underlying systems to ensure that hardware and software configurations can meet these demands efficiently.  

::: {.callout-note title="Definition of ML Training Benchmarks"}  

**ML Training Benchmarks** are standardized tools used to evaluate the _performance_, _efficiency_, and _scalability_ of machine learning systems during the _training phase_. These benchmarks measure key _system-level metrics_, such as _time-to-accuracy_, _throughput_, _resource utilization_, and _energy consumption_. By providing a structured evaluation framework, training benchmarks enable _fair comparisons_ across _hardware platforms_, _software frameworks_, and _distributed computing setups_. They help identify _bottlenecks_ and optimize _training processes_ for _large-scale machine learning models_, ensuring that computational resources are used effectively.  

:::  

Efficient data storage and delivery during training also play a major role in the training process. For instance, in a machine learning model that predicts bounding boxes around objects in an image, thousands of images may be required. However, loading an entire image dataset into memory is typically infeasible, so practitioners rely on data loaders from ML frameworks. Successful model training depends on timely and efficient data delivery, making it essential to benchmark tools like data pipelines, preprocessing speed, and storage retrieval times to understand their impact on training performance.

Hardware selection is another key factor in training machine learning systems, as it can significantly impact training time. Training benchmarks evaluate CPU, GPU, memory, and network utilization during the training phase to guide system optimizations. Understanding how resources are used is essential: Are GPUs being fully leveraged? Is there unnecessary memory overhead? Benchmarks can uncover bottlenecks or inefficiencies in resource utilization, leading to cost savings and performance improvements.

In many cases, using a single hardware accelerator, such as a single GPU, is insufficient to meet the computational demands of large-scale model training. Machine learning models are often trained in data centers with multiple GPUs or TPUs, where distributed computing enables parallel processing across nodes. Training benchmarks assess how efficiently the system scales across multiple nodes, manages data sharding, and handles challenges like node failures or drop-offs during training.  

To illustrate these benchmarking principles, we will reference [MLPerf Training](https://mlcommons.org/benchmarks/training/) throughout this section. Briefly, MLPerf is an industry-standard benchmark suite designed to evaluate machine learning system performance. It provides standardized tests for training and inference across a range of deep learning workloads, including image classification, language modeling, object detection, and recommendation systems.

### Purpose  

From a systems perspective, training machine learning models is a computationally intensive process that requires careful optimization of resources. Training benchmarks serve as essential tools for evaluating system efficiency, identifying bottlenecks, and ensuring that machine learning systems can scale effectively. They provide a standardized approach to measuring how various system components—such as hardware accelerators, memory, storage, and network infrastructure—affect training performance.

By systematically evaluating these factors, training benchmarks enable researchers and engineers to push the state-of-the-art, optimize configurations, improve scalability, and reduce overall resource consumption. As shown in @fig-mlperf-training-improve, the performance improvements in progressive versions of MLPerf Training benchmarks have consistently outpaced Moore's Law---demonstrating that what gets measured gets improved. Using standardized benchmarking trends allows us to rigorously showcase the rapid evolution of ML computing.

![MLPerf Training performance trends. Source: @tschand2024mlperf.](images/png/mlperf_training_06-12-2024.png){#fig-mlperf-training-improve}

#### Why Training Benchmarks Matter for ML Systems

As machine learning models grow in complexity, training becomes increasingly demanding in terms of compute power, memory, and data storage. The ability to measure and compare training efficiency is critical to ensuring that systems can effectively handle large-scale workloads. Training benchmarks provide a structured methodology for assessing performance across different hardware platforms, software frameworks, and optimization techniques.  

One of the fundamental challenges in training machine learning models is the efficient allocation of computational resources. Training a transformer-based model such as GPT-3, which consists of 175 billion parameters and requires processing terabytes of data, places an enormous burden on modern computing infrastructure. Without standardized benchmarks, it becomes difficult to determine whether a system is fully utilizing its resources or whether inefficiencies—such as slow data loading, underutilized accelerators, or excessive memory overhead—are limiting performance.  

Training benchmarks help uncover such inefficiencies by measuring key performance indicators, including system throughput, time-to-accuracy, and hardware utilization. These benchmarks allow practitioners to analyze whether GPUs, TPUs, and CPUs are being leveraged effectively or whether specific bottlenecks, such as memory bandwidth constraints or inefficient data pipelines, are reducing overall system performance. For example, a system using TF32[^fn-tf32] precision1 may achieve higher throughput than one using FP32, but if TF32 introduces numerical instability that increases the number of iterations required to reach the target accuracy, the overall training time may be longer. By providing insights into these factors, benchmarks support the design of more efficient training workflows that maximize hardware potential while minimizing unnecessary computation.

[^fn-tf32]: **TensorFloat-32 (TF32):** Introduced in NVIDIA Ampere GPUs, provides higher throughput than FP32 but may introduce numerical stability issues affecting model convergence.

#### Optimizing Hardware & Software Configurations

The performance of machine learning training is heavily influenced by the choice of hardware and software. Training benchmarks guide system designers in selecting optimal configurations by measuring how different architectures—such as GPUs, TPUs, and emerging AI accelerators—handle computational workloads. These benchmarks also evaluate how well deep learning frameworks, such as TensorFlow and PyTorch, optimize performance across different hardware setups.  

For example, the MLPerf Training benchmark suite is widely used to compare the performance of different accelerator architectures on tasks such as image classification, natural language processing, and recommendation systems. By running standardized benchmarks across multiple hardware configurations, engineers can determine whether certain accelerators are better suited for specific training workloads. This information is particularly valuable in large-scale data centers and cloud computing environments, where selecting the right combination of hardware and software can lead to significant performance gains and cost savings.  

Beyond hardware selection, training benchmarks also inform software optimizations. Machine learning frameworks implement various low-level optimizations—such as mixed-precision training, memory-efficient data loading, and distributed training strategies—that can significantly impact system performance. Benchmarks help quantify the impact of these optimizations, ensuring that training systems are configured for maximum efficiency.  

#### Scalability & Efficiency

As machine learning workloads continue to grow, efficient scaling across distributed computing environments has become a key concern. Many modern deep learning models are trained across multiple GPUs or TPUs, requiring efficient parallelization strategies to ensure that additional computing resources lead to meaningful performance improvements. Training benchmarks measure how well a system scales by evaluating system throughput, memory efficiency, and overall training time as additional computational resources are introduced.  

Effective scaling is not always guaranteed. While adding more GPUs or TPUs should, in theory, reduce training time, issues such as communication overhead, data synchronization latency, and memory bottlenecks can limit scaling efficiency. Training benchmarks help identify these challenges by quantifying how performance scales with increasing hardware resources. A well-designed system should exhibit near-linear scaling, where doubling the number of GPUs results in a near-halving of training time. However, real-world inefficiencies often prevent perfect scaling, and benchmarks provide the necessary insights to optimize system design accordingly.  

Another crucial factor in training efficiency is time-to-accuracy, which measures how quickly a model reaches a target accuracy level. Achieving faster convergence with fewer computational resources is a key goal in training optimization, and benchmarks help compare different training methodologies to determine which approaches strike the best balance between speed and accuracy. By leveraging training benchmarks, system designers can assess whether their infrastructure is capable of handling large-scale workloads efficiently while maintaining training stability and accuracy.  

#### Cost & Energy Considerations

The computational cost of training large-scale models has risen sharply in recent years, making cost-efficiency a critical consideration. Training a model such as GPT-3 can require millions of dollars in cloud computing resources, making it imperative to evaluate cost-effectiveness across different hardware and software configurations. Training benchmarks provide a means to quantify the cost per training run by analyzing computational expenses, cloud pricing models, and energy consumption.  

Beyond financial cost, energy efficiency has become an increasingly important metric. Large-scale training runs consume vast amounts of electricity, contributing to significant carbon emissions. Benchmarks help evaluate energy efficiency by measuring power consumption per unit of training progress, allowing organizations to identify sustainable approaches to AI development.  

For example, MLPerf includes an energy benchmarking component that tracks the power consumption of various hardware accelerators during training. This allows researchers to compare different computing platforms not only in terms of raw performance but also in terms of their environmental impact. By integrating energy efficiency metrics into benchmarking studies, organizations can design AI systems that balance computational power with sustainability goals.  

#### Fair Comparisons Across ML Systems  

One of the primary functions of training benchmarks is to establish a standardized framework for comparing ML systems. Given the wide variety of hardware architectures, deep learning frameworks, and optimization techniques available today, ensuring fair and reproducible comparisons is essential.  

Standardized benchmarks provide a common evaluation methodology, allowing researchers and practitioners to assess how different training systems perform under identical conditions. For example, MLPerf Training benchmarks enable vendor-neutral comparisons by defining strict evaluation criteria for deep learning tasks such as image classification, language modeling, and recommendation systems. This ensures that performance results are meaningful and not skewed by differences in dataset preprocessing, hyperparameter tuning, or implementation details.  

Furthermore, reproducibility is a major concern in machine learning research. Training benchmarks help address this challenge by providing clearly defined methodologies for performance evaluation, ensuring that results can be consistently reproduced across different computing environments. By adhering to standardized benchmarks, researchers can make informed decisions when selecting hardware, software, and training methodologies, ultimately driving progress in AI systems development.  

### Metrics

Evaluating the performance of machine learning training requires a set of well-defined metrics that go beyond conventional algorithmic measures. From a systems perspective, training benchmarks assess how efficiently and effectively a machine learning model can be trained to a predefined accuracy threshold. Metrics such as throughput, scalability, and energy efficiency are only meaningful in relation to whether the model successfully reaches its target accuracy. Without this constraint, optimizing for raw speed or resource utilization may lead to misleading conclusions.  

Training benchmarks, such as MLPerf Training, define specific accuracy targets for different machine learning tasks, ensuring that performance measurements are made in a fair and reproducible manner. A system that trains a model quickly but fails to reach the required accuracy is not considered a valid benchmark result. Conversely, a system that achieves the best possible accuracy but takes an excessive amount of time or resources may not be practically useful. Effective benchmarking requires balancing speed, efficiency, and accuracy convergence.  

#### Training Time and Throughput

One of the fundamental metrics for evaluating training efficiency is the time required to reach a predefined accuracy threshold. Training time ($T_{\text{train}}$) measures how long a model takes to converge to an acceptable performance level, reflecting the overall computational efficiency of the system. It is formally defined as:

$$
T_{\text{train}} = \arg\min_{t} \{ \text{accuracy}(t) \geq \text{target accuracy} \}
$$

This metric ensures that benchmarking focuses on how quickly and effectively a system can achieve meaningful results.

Throughput, often expressed as the number of training samples processed per second, provides an additional measure of system performance:

$$
T = \frac{N_{\text{samples}}}{T_{\text{train}}}
$$

where $N_{\text{samples}}$ is the total number of training samples processed. However, throughput alone does not guarantee meaningful results, as a model may process a large number of samples quickly without necessarily reaching the desired accuracy.

For example, in MLPerf Training, the benchmark for ResNet-50 may require reaching an accuracy target like 75.9% top-1 on the ImageNet dataset. A system that processes 10,000 images per second but fails to achieve this accuracy is not considered a valid benchmark result, while a system that processes fewer images per second but converges efficiently is preferable. This highlights why throughput must always be evaluated in relation to time-to-accuracy rather than as an independent performance measure.

#### Scalability and Parallelism

As machine learning models increase in size, training workloads often require distributed computing across multiple processors or accelerators. Scalability measures how effectively training performance improves as more computational resources are added. An ideal system should exhibit near-linear scaling, where doubling the number of GPUs or TPUs leads to a proportional reduction in training time. However, real-world performance is often constrained by factors such as communication overhead, memory bandwidth limitations, and inefficiencies in parallelization strategies.  

When training large-scale models such as GPT-3, OpenAI employed thousands of GPUs in a distributed training setup. While increasing the number of GPUs provided more raw computational power, the performance improvements were not perfectly linear due to network communication overhead between nodes. Benchmarks such as MLPerf quantify how well a system scales across multiple GPUs, providing insights into where inefficiencies arise in distributed training.  

Parallelism in training is categorized into data parallelism, model parallelism, and pipeline parallelism, each presenting distinct challenges. Data parallelism, the most commonly used strategy, involves splitting the training dataset across multiple compute nodes. The efficiency of this approach depends on synchronization mechanisms and gradient communication overhead. In contrast, model parallelism partitions the neural network itself, requiring efficient coordination between processors. Benchmarks evaluate how well a system manages these parallelism strategies without degrading accuracy convergence.  

#### Resource Utilization

The efficiency of machine learning training depends not only on speed and scalability but also on how well available hardware resources are utilized. Compute utilization measures the extent to which processing units, such as GPUs or TPUs, are actively engaged during training. Low utilization may indicate bottlenecks in data movement, memory access, or inefficient workload scheduling.  

For instance, when training BERT on a TPU cluster, researchers observed that input pipeline inefficiencies were limiting overall throughput. Although the TPUs had high raw compute power, the system was not keeping them fully utilized due to slow data retrieval from storage. By profiling the resource utilization, engineers identified the bottleneck and optimized the input pipeline using TFRecord and data prefetching, leading to improved performance.  

Memory bandwidth is another critical factor, as deep learning models require frequent access to large volumes of data during training. If memory bandwidth becomes a limiting factor, increasing compute power alone will not improve training speed. Benchmarks assess how well models leverage available memory, ensuring that data transfer rates between storage, main memory, and processing units do not become performance bottlenecks.  

I/O performance also plays a significant role in training efficiency, particularly when working with large datasets that cannot fit entirely in memory. Benchmarks evaluate the efficiency of data loading pipelines, including preprocessing operations, caching mechanisms, and storage retrieval speeds. Systems that fail to optimize data loading can experience significant slowdowns, regardless of computational power.  

#### Energy Efficiency and Cost

Training large-scale machine learning models requires substantial computational resources, leading to significant energy consumption and financial costs. Energy efficiency metrics quantify the power usage of training workloads, helping identify systems that optimize computational efficiency while minimizing energy waste. The increasing focus on sustainability has led to the inclusion of energy-based benchmarks, such as those in MLPerf Training, which measure power consumption per training run.  

Training GPT-3 was estimated to consume 1,287 MWh of electricity, which is comparable to the yearly energy usage of 100 US households. If a system can achieve the same accuracy with fewer training iterations, it directly reduces energy consumption. Energy-aware benchmarks help guide the development of hardware and training strategies that optimize power efficiency while maintaining accuracy targets.  

Cost considerations extend beyond electricity usage to include hardware expenses, cloud computing costs, and infrastructure maintenance. Training benchmarks provide insights into the cost-effectiveness of different hardware and software configurations by measuring training time in relation to resource expenditure. Organizations can use these benchmarks to balance performance and budget constraints when selecting training infrastructure.  

#### Fault Tolerance and Robustness

Training workloads often run for extended periods, sometimes spanning days or weeks, making fault tolerance an essential consideration. A robust system must be capable of handling unexpected failures, including hardware malfunctions, network disruptions, and memory errors, without compromising accuracy convergence.  

In large-scale cloud-based training, node failures are common due to hardware instability. If a GPU node in a distributed cluster fails, training must continue without corrupting the model. MLPerf Training includes evaluations of fault-tolerant training strategies, such as checkpointing, where models periodically save their progress. This ensures that failures do not require restarting the entire training process.  

#### Reproducibility and Standardization

For benchmarks to be meaningful, results must be reproducible across different runs, hardware platforms, and software frameworks. Variability in training results can arise due to stochastic processes, hardware differences, and software optimizations. Ensuring reproducibility requires standardizing evaluation protocols, controlling for randomness in model initialization, and enforcing consistency in dataset processing.  

MLPerf Training enforces strict reproducibility requirements, ensuring that accuracy results remain stable across multiple training runs. When NVIDIA submitted benchmark results for MLPerf, they had to demonstrate that their ResNet-50 ImageNet training time remained consistent across different GPUs. This ensures that benchmarks measure true system performance rather than noise from randomness.  

### Evaluating Training Performance  

There are many different ways to analyze and evaluate system performance in machine learning training. The choice of benchmarking metrics depends on the specific goals of the evaluation—whether the focus is on optimizing speed, improving resource utilization, enhancing energy efficiency, or ensuring fault tolerance. A well-rounded benchmarking approach must take all these factors into account while ensuring that models reach their intended accuracy targets in a reproducible and scalable manner.  

@tbl-training-metrics provides a structured overview of key system-level training metrics, highlighting different evaluation dimensions and their relevance to training benchmarks. This table serves as a reference for how system performance can be analyzed in the context of machine learning training.  

+-------------------------------------+------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------+
| Category                            | Key Metrics                                                                                                            | Example Benchmark Use                                       |
+:====================================+:=======================================================================================================================+:============================================================+
| Training Time and Throughput        | Time-to-accuracy (seconds, minutes, hours); Throughput (samples/sec)                                                   | Comparing training speed across different GPU architectures |
+-------------------------------------+------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------+
| Scalability and Parallelism         | Scaling efficiency (% of ideal speedup); Communication overhead (latency, bandwidth)                                   | Analyzing distributed training performance for large models |
+-------------------------------------+------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------+
| Resource Utilization                | Compute utilization (% GPU/TPU usage); Memory bandwidth (GB/s); I/O efficiency (data loading speed)                    | Optimizing data pipelines to improve GPU utilization        |
+-------------------------------------+------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------+
| Energy Efficiency and Cost          | Energy consumption per run (MWh, kWh); Performance per watt (TOPS/W)                                                   | Evaluating energy-efficient training strategies             |
+-------------------------------------+------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------+
| Fault Tolerance and Robustness      | Checkpoint overhead (time per save); Recovery success rate (%)                                                         | Assessing failure recovery in cloud-based training systems  |
+-------------------------------------+------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------+
| Reproducibility and Standardization | Variance across runs (% difference in accuracy, training time); Framework consistency (TensorFlow vs. PyTorch vs. JAX) | Ensuring consistency in benchmark results across hardware   |
+-------------------------------------+------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------+

: Training benchmark metrics and evaluation dimensions. {#tbl-training-metrics .striped .hover}

#### Common Pitfalls in Training Benchmarks  

Despite the availability of well-defined benchmarking methodologies, certain misconceptions and flawed evaluation practices often lead to misleading conclusions. Understanding these pitfalls is important for interpreting benchmark results correctly.  

##### Focusing only on raw throughput  

A common mistake in training benchmarks is assuming that higher throughput always translates to better training performance. It is possible to artificially increase throughput by using lower numerical precision, reducing synchronization, or even bypassing certain computations. However, these optimizations do not necessarily lead to faster convergence.

For example, a system using TF32 precision may achieve higher throughput than one using FP32, but if TF32 introduces numerical instability that increases the number of iterations required to reach the target accuracy, the overall training time may be longer. The correct way to evaluate throughput is in relation to time-to-accuracy, ensuring that speed optimizations do not come at the expense of convergence efficiency.  

##### Evaluating single-node performance in isolation  

Benchmarking training performance on a single node without considering how well it scales in a distributed setting can lead to misleading conclusions. A GPU may demonstrate excellent throughput when used independently, but when deployed across hundreds of nodes, communication overhead and synchronization constraints may diminish these efficiency gains.  

For instance, a system optimized for single-node performance may employ memory optimizations that do not generalize well to multi-node environments. Large-scale models such as GPT-3 require efficient gradient synchronization across multiple nodes, making it essential to assess scalability rather than relying solely on single-node performance metrics.  

##### Ignoring mid-training failures, fault tolerance, and interference

Many benchmarks assume an idealized training environment where hardware failures, memory corruption, network instability, or interference from other processes do not occur. However, real-world training jobs often experience unexpected failures and workload interference that require checkpointing, recovery mechanisms, and resource management.

A system optimized for ideal-case performance but lacking fault tolerance and interference handling may achieve impressive benchmark results under controlled conditions, but frequent failures, inefficient recovery, and resource contention could make it impractical for large-scale deployment. Effective benchmarking should consider checkpointing overhead, failure recovery efficiency, and the impact of interference from other processes rather than assuming perfect execution conditions.

##### Assuming that scaling efficiency is always linear  

When evaluating distributed training, it is often assumed that increasing the number of GPUs or TPUs will result in proportional speedups. In practice, communication bottlenecks, memory contention, and synchronization overheads lead to diminishing returns as more compute nodes are added.  

For example, training a model across 1,000 GPUs does not necessarily provide 100 times the speed of training on 10 GPUs. At a certain scale, gradient communication costs become a limiting factor, offsetting the benefits of additional parallelism. Proper benchmarking should assess scalability efficiency rather than assuming idealized linear improvements.  

##### Failing to consider reproducibility across frameworks and hardware  

Benchmark results are often reported without verifying their reproducibility across different hardware and software frameworks. Even minor variations in floating-point arithmetic, memory layouts, or optimization strategies can introduce statistical differences in training time and accuracy.  

For example, a benchmark run on TensorFlow with XLA optimizations may exhibit different convergence characteristics compared to the same model trained using PyTorch with Automatic Mixed Precision (AMP). Proper benchmarking requires evaluating results across multiple frameworks to ensure that software-specific optimizations do not distort performance comparisons.  

#### Final Thoughts  

Training benchmarks provide valuable insights into machine learning system performance, but their interpretation requires careful consideration of real-world constraints. High throughput does not necessarily mean faster training if it compromises accuracy convergence. Similarly, scaling efficiency must be evaluated holistically, taking into account both computational efficiency and communication overhead.

By avoiding common benchmarking pitfalls and employing structured evaluation methodologies, machine learning practitioners can gain a deeper understanding of how to optimize training workflows, design efficient AI systems, and develop scalable machine learning infrastructure. As models continue to increase in complexity, benchmarking methodologies must evolve to reflect real-world challenges, ensuring that benchmarks remain meaningful and actionable in guiding AI system development.

## Inference Benchmarks  

Inference benchmarks provide a systematic approach to evaluating the efficiency, latency, and resource demands of the inference phase in machine learning systems. Unlike training, where the focus is on optimizing large-scale computations over extensive datasets, inference involves deploying trained models to make real-time or batch predictions efficiently. These benchmarks help assess how various factors—such as model architectures, hardware configurations, quantization techniques, and runtime optimizations—impact inference performance.  

As deep learning models grow in complexity and size, efficient inference becomes a key challenge, particularly for applications requiring real-time decision-making, such as autonomous driving, healthcare diagnostics, and conversational AI. For example, serving large-scale models like [OpenAI's GPT-4](https://arxiv.org/abs/2303.08774) involves handling billions of parameters while maintaining low latency. Inference benchmarks enable systematic evaluation of the underlying hardware and software stacks to ensure that models can be deployed efficiently across different environments, from cloud data centers to edge devices.  

::: {.callout-note title="Definition of ML Inference Benchmarks"}  

**ML Inference Benchmarks** are standardized tools used to evaluate the _performance_, _efficiency_, and _scalability_ of machine learning systems during the _inference phase_. These benchmarks measure key _system-level metrics_, such as _latency_, _throughput_, _energy consumption_, and _memory footprint_. By providing a structured evaluation framework, inference benchmarks enable _fair comparisons_ across _hardware platforms_, _software runtimes_, and _deployment configurations_. They help identify _bottlenecks_ and optimize _inference pipelines_ for _real-time and large-scale machine learning applications_, ensuring that computational resources are utilized effectively.  

:::  

Unlike training, which is often conducted in large-scale data centers with ample computational resources, inference must be optimized for diverse deployment scenarios, including mobile devices, IoT systems, and embedded processors. Efficient inference depends on multiple factors, such as optimized data pipelines, quantization, pruning, and hardware acceleration. Benchmarks help evaluate how well these optimizations improve real-world deployment performance.  

Hardware selection plays an important role in inference efficiency. While GPUs and TPUs are widely used for training, inference workloads often require specialized accelerators like NPUs (Neural Processing Units), FPGAs, and dedicated inference chips such as Google's Edge TPU. Inference benchmarks evaluate the utilization and performance of these hardware components, helping practitioners choose the right configurations for their deployment needs.  

Scaling inference workloads across cloud servers, edge platforms, mobile devices and tinyML systems introduces additional challenges. Inference benchmarks assess the trade-offs between latency, cost, and energy efficiency, helping organizations make informed deployment decisions. As with training, we will reference MLPerf Inference throughout this section to illustrate benchmarking principles. MLPerf provides standardized inference tests across different workloads, including image classification, object detection, speech recognition, and language processing. A full discussion of MLPerf's methodology and structure is presented later in this chapter.  

### Purpose

Deploying machine learning models for inference introduces a unique set of challenges distinct from training. While training optimizes large-scale computation over extensive datasets, inference must deliver predictions efficiently and at scale in real-world environments. Inference benchmarks provide a systematic approach to evaluating system performance, identifying bottlenecks, and ensuring that models can operate effectively across diverse deployment scenarios.  

Unlike training, which typically runs on dedicated high-performance hardware, inference must adapt to varying constraints. A model deployed in a cloud server might prioritize high-throughput batch processing, while the same model running on a mobile device must operate under strict latency and power constraints. On edge devices with limited compute and memory, optimizations such as quantization and pruning become critical. Benchmarks help assess these trade-offs, ensuring that inference systems maintain the right balance between accuracy, speed, and efficiency across different platforms.  

Inference benchmarks help answer fundamental questions about model deployment. How quickly can a model generate predictions in real-world conditions? What are the trade-offs between inference speed and accuracy? Can an inference system handle increasing demand while maintaining low latency? By evaluating these factors, benchmarks guide optimizations in both hardware and software to improve overall efficiency [@reddi2020mlperf].  

#### Why Inference Benchmarks Matter for ML Systems  

Inference plays a critical role in AI applications, where performance directly affects usability and cost. Unlike training, which is often performed offline, inference typically operates in real-time or near real-time, making latency a primary concern. A self-driving car processing camera feeds must react within milliseconds, while a voice assistant generating responses should feel instantaneous to users.  

Different applications impose varying constraints on inference. Some workloads require single-instance inference, where predictions must be made as quickly as possible for each individual input. This is crucial in real-time systems such as robotics, augmented reality, and conversational AI, where even small delays can impact responsiveness. Other workloads, such as large-scale recommendation systems or search engines, process massive batches of queries simultaneously, prioritizing throughput over per-query latency. Benchmarks allow engineers to evaluate both scenarios and ensure models are optimized for their intended use case.  

A key difference between training and inference is that inference workloads often run continuously in production, meaning that small inefficiencies can compound over time. Unlike a training job that runs once and completes, an inference system deployed in the cloud may serve millions of queries daily, and a model running on a smartphone must manage battery consumption over extended use. Benchmarks provide a structured way to measure inference efficiency under these real-world constraints, helping developers make informed choices about model optimization, hardware selection, and deployment strategies.  

#### Optimizing Hardware & Software Configurations  

Efficient inference depends on both hardware acceleration and software optimizations. While GPUs and TPUs dominate training, inference is more diverse in its hardware needs. A cloud-based AI service might leverage powerful accelerators for large-scale workloads, whereas mobile devices rely on specialized inference chips like NPUs or optimized CPU execution. On embedded systems, where resources are constrained, achieving high performance requires careful memory and compute efficiency. Benchmarks help evaluate how well different hardware platforms handle inference workloads, guiding deployment decisions.  

Software optimizations are just as important. Frameworks like TensorRT, ONNX Runtime, and TVM apply optimizations such as operator fusion, quantization, and kernel tuning to improve inference speed and reduce computational overhead. These optimizations can make a significant difference, especially in environments with limited resources. Benchmarks allow developers to measure the impact of such techniques on latency, throughput, and power efficiency, ensuring that optimizations translate into real-world improvements without degrading model accuracy.  

#### Scalability & Efficiency  

Inference workloads vary significantly in their scaling requirements. A cloud-based AI system handling millions of queries per second must ensure that increasing demand does not cause delays, while a mobile application running a model locally must execute quickly even under power constraints. Unlike training, which is typically performed on a fixed set of high-performance machines, inference must scale dynamically based on usage patterns and available computational resources.  

Benchmarks evaluate how inference systems scale under different conditions. They measure how well performance holds up under increasing query loads, whether additional compute resources improve inference speed, and how efficiently models run across different deployment environments. Large-scale inference deployments often involve distributed inference servers, where multiple copies of a model process incoming requests in parallel. Benchmarks assess how efficiently this scaling occurs and whether additional resources lead to meaningful improvements in latency and throughput.  

Another key factor in inference efficiency is cold-start performance—the time it takes for a model to load and begin processing queries. This is especially relevant for applications that do not run inference continuously but instead load models on demand. Benchmarks help determine whether a system can quickly transition from idle to active execution without significant overhead.  

#### Cost & Energy Considerations  

Because inference workloads run continuously, operational cost and energy efficiency are critical factors. Unlike training, where compute costs are incurred once, inference costs accumulate over time as models are deployed in production. Running an inefficient model at scale can significantly increase cloud compute expenses, while an inefficient mobile inference system can drain battery life quickly. Benchmarks provide insights into cost per inference request, helping organizations optimize for both performance and affordability.  

Energy efficiency is also a growing concern, particularly for mobile and edge AI applications. Many inference workloads run on battery-powered devices, where excessive computation can impact usability. A model running on a smartphone, for example, must be optimized to minimize power consumption while maintaining responsiveness. Benchmarks help evaluate inference efficiency per watt, ensuring that models can operate sustainably across different platforms.  

#### Fair Comparisons Across ML Systems  

With many different hardware platforms and optimization techniques available, standardized benchmarking is essential for fair comparisons. Without well-defined benchmarks, it becomes difficult to determine whether performance gains come from genuine improvements or from optimizations that exploit specific hardware features. Inference benchmarks provide a consistent evaluation methodology, ensuring that comparisons are meaningful and reproducible.  

For example, MLPerf Inference defines rigorous evaluation criteria for tasks such as image classification, object detection, and speech recognition, making it possible to compare different systems under controlled conditions. These standardized tests prevent misleading results caused by differences in dataset preprocessing, proprietary optimizations, or vendor-specific tuning. By enforcing reproducibility, benchmarks allow researchers and engineers to make informed decisions when selecting inference frameworks, hardware accelerators, and optimization techniques.  

### Metrics

Evaluating the performance of inference systems requires a distinct set of metrics from those used for training. While training benchmarks emphasize throughput, scalability, and time-to-accuracy, inference benchmarks must focus on latency, efficiency, and resource utilization in practical deployment settings. These metrics ensure that machine learning models perform well across different environments, from cloud data centers handling millions of requests to mobile and edge devices operating under strict power and memory constraints.  

Unlike training, where the primary goal is to optimize learning speed, inference benchmarks evaluate how efficiently a trained model can process inputs and generate predictions at scale. The following sections describe the most important inference benchmarking metrics, explaining their relevance and how they are used to compare different systems.  

#### Latency and Tail Latency  

Latency is one of the most critical performance metrics for inference, particularly in real-time applications where delays can negatively impact user experience or system safety. Latency refers to the time taken for an inference system to process an input and produce a prediction. While the average latency of a system is useful, it does not capture performance in high-demand scenarios where occasional delays can degrade reliability.  

To account for this, benchmarks often measure tail latency, which reflects the worst-case delays in a system. These are typically reported as the 95th percentile (p95) or 99th percentile (p99) latency, meaning that 95% or 99% of inferences are completed within a given time. For applications such as autonomous driving or real-time trading, maintaining low tail latency is essential to avoid unpredictable delays that could lead to catastrophic outcomes.  

#### Throughput and Batch Processing Efficiency  

While latency measures the speed of individual inference requests, throughput measures how many inference requests a system can process per second. It is typically expressed in queries per second (QPS) or frames per second (FPS) for vision tasks. Some inference systems operate on a single-instance basis, where each input is processed independently as soon as it arrives. Other systems process multiple inputs in parallel using batch inference, which can significantly improve efficiency by leveraging hardware optimizations.  

For example, cloud-based services handling millions of queries per second benefit from batch inference, where large groups of inputs are processed together to maximize computational efficiency. In contrast, applications like robotics, interactive AI, and augmented reality require low-latency single-instance inference, where the system must respond immediately to each new input.  

Benchmarks must consider both single-instance and batch throughput to provide a comprehensive understanding of inference performance across different deployment scenarios.  

#### Numerical Precision and Accuracy Trade-offs  

Optimizing inference performance often involves reducing numerical precision, which can significantly accelerate computation while reducing memory and energy consumption. However, lower-precision calculations can introduce accuracy degradation, making it essential to benchmark the trade-offs between speed and predictive quality.  

Inference benchmarks evaluate how well models perform under different numerical settings, such as FP32, FP16, and INT8. Many modern AI accelerators support mixed-precision inference, allowing systems to dynamically adjust numerical representation based on workload requirements. Quantization and pruning techniques further improve efficiency, but their impact on model accuracy varies depending on the task and dataset. Benchmarks help determine whether these optimizations are viable for deployment, ensuring that improvements in efficiency do not come at the cost of unacceptable accuracy loss.  

#### Memory Footprint and Model Size  

Beyond computational optimizations, memory footprint is another critical consideration for inference systems, particularly for devices with limited resources. Efficient inference depends not only on speed but also on memory usage. Unlike training, where large models can be distributed across powerful GPUs or TPUs, inference often requires models to run within strict memory budgets. The total model size determines how much storage is required for deployment, while RAM usage reflects the working memory needed during execution. Some models require large memory bandwidth to efficiently transfer data between processing units, which can become a bottleneck if the hardware lacks sufficient capacity.  

Inference benchmarks evaluate these factors to ensure that models can be deployed effectively across a range of devices. A model that achieves high accuracy but exceeds memory constraints may be impractical for real-world use. To address this, compression techniques such as quantization, pruning, and knowledge distillation are often applied to reduce model size while maintaining accuracy. Benchmarks help assess whether these optimizations strike the right balance between memory efficiency and predictive performance.  

#### Cold-Start Time and Model Load Time  

Once memory requirements are optimized, cold-start performance[^fn-cold-start] becomes critical for ensuring inference systems are ready to respond quickly upon deployment. In many deployment scenarios, models are not always kept in memory but instead loaded on demand when needed. This can introduce significant delays, particularly in serverless AI[^fn-serverless-ai] environments, where resources are allocated dynamically based on incoming requests. Cold-start performance measures how quickly a system can transition from idle to active execution, ensuring that inference is available without excessive wait times.  

[^fn-cold-start]: **Cold-Start Time:** The time required for a model to initialize and become ready to process the first inference request after being loaded from disk or a low-power state.  

[^fn-serverless-ai]: **Serverless AI:** A deployment model where inference workloads are executed on demand, eliminating the need for dedicated compute resources but introducing cold-start latency challenges.  

Model load time refers to the duration required to load a trained model into memory before it can process inputs. In some cases, particularly on resource-limited devices, models must be reloaded frequently to free up memory for other applications. The time taken for the first inference request is also an important consideration, as it reflects the total delay users experience when interacting with an AI-powered service. Benchmarks help quantify these delays, ensuring that inference systems can meet real-world responsiveness requirements.  

#### Scalability and Dynamic Workload Handling  

While cold-start latency addresses initial responsiveness, scalability ensures that inference systems can handle fluctuating workloads and concurrent demands over time Inference workloads must scale effectively across different usage patterns. In cloud-based AI services, this means efficiently handling millions of concurrent users, while on mobile or embedded devices, it involves managing multiple AI models running simultaneously without overloading the system.  

Scalability measures how well inference performance improves when additional computational resources are allocated. In some cases, adding more GPUs or TPUs increases throughput significantly, but in other scenarios, bottlenecks such as memory bandwidth limitations or network latency may limit scaling efficiency. Benchmarks also assess how well a system balances multiple concurrent models in real-world deployment, where different AI-powered features may need to run at the same time without interference.  

For cloud-based AI, benchmarks evaluate how efficiently a system handles fluctuating demand, ensuring that inference servers can dynamically allocate resources without compromising latency. In mobile and embedded AI, efficient multi-model execution is essential for running multiple AI-powered features simultaneously without degrading system performance.  

#### Power Consumption and Energy Efficiency  

Since inference workloads run continuously in production, power consumption and energy efficiency are critical considerations. This is particularly important for mobile and edge devices, where battery life and thermal constraints limit available computational resources. Even in large-scale cloud environments, power efficiency directly impacts operational costs and sustainability goals.  

The energy required for a single inference is often measured in joules per inference, reflecting how efficiently a system processes inputs while minimizing power draw. In cloud-based inference, efficiency is commonly expressed as queries per second per watt (QPS/W) to quantify how well a system balances performance and energy consumption. For mobile AI applications, optimizing inference power consumption extends battery life and allows models to run efficiently on resource-constrained devices. Reducing energy use also plays a key role in making large-scale AI systems more environmentally sustainable, ensuring that computational advancements align with energy-conscious deployment strategies. By balancing power consumption with performance, energy-efficient inference systems enable AI to scale sustainably across diverse applications, from data centers to edge devices.

### Evaluating Inference Performance  

Evaluating inference performance is a critical step in understanding how well machine learning systems meet the demands of real-world applications. Unlike training, which is typically conducted offline, inference systems must process inputs and generate predictions efficiently across a wide range of deployment scenarios. Metrics such as latency, throughput, memory usage, and energy efficiency provide a structured way to measure system performance and identify areas for improvement.

@tbl-inference-metrics below summarizes the key metrics used to evaluate inference systems, highlighting their relevance to different contexts. While each metric offers unique insights, it is important to approach inference benchmarking holistically. Trade-offs between metrics—such as speed versus accuracy or throughput versus power consumption—are common, and understanding these trade-offs is essential for effective system design.  

+-----------------------------+----------------------------------------------------------------------+----------------------------------------------------------+
| Category                    | Key Metrics                                                          | Example Benchmark Use                                    |
+=============================+======================================================================+==========================================================+
| Latency and Tail Latency    | Mean latency (ms/request); Tail latency (p95, p99, p99.9)            | Evaluating real-time performance for safety-critical AI  |
+-----------------------------+----------------------------------------------------------------------+----------------------------------------------------------+
| Throughput and Efficiency   | Queries per second (QPS); Frames per second (FPS); Batch throughput  | Comparing large-scale cloud inference systems            |
+-----------------------------+----------------------------------------------------------------------+----------------------------------------------------------+
| Numerical Precision Impact  | Accuracy degradation (FP32 vs. INT8); Speedup from reduced precision | Balancing accuracy vs. efficiency in optimized inference |
+-----------------------------+----------------------------------------------------------------------+----------------------------------------------------------+
| Memory Footprint            | Model size (MB/GB); RAM usage (MB); Memory bandwidth utilization     | Assessing feasibility for edge and mobile deployments    |
+-----------------------------+----------------------------------------------------------------------+----------------------------------------------------------+
| Cold-Start and Load Time    | Model load time (s); First inference latency (s)                     | Evaluating responsiveness in serverless AI               |
+-----------------------------+----------------------------------------------------------------------+----------------------------------------------------------+
| Scalability                 | Efficiency under load; Multi-model serving performance               | Measuring robustness for dynamic, high-demand systems    |
+-----------------------------+----------------------------------------------------------------------+----------------------------------------------------------+
| Power and Energy Efficiency | Power consumption (Watts); Performance per Watt (QPS/W)              | Optimizing energy use for mobile and sustainable AI      |
+-----------------------------+----------------------------------------------------------------------+----------------------------------------------------------+

: Inference benchmark metrics and evaluation dimensions. {#tbl-inference-metrics .striped .hover} 

#### Key Considerations for Inference Systems  

Inference systems face unique challenges depending on where and how they are deployed. Real-time applications, such as self-driving cars or voice assistants, require low latency to ensure timely responses, while large-scale cloud deployments focus on maximizing throughput to handle millions of queries. Edge devices, on the other hand, are constrained by memory and power, making efficiency critical.

One of the most important aspects of evaluating inference performance is understanding the trade-offs between metrics. For example, optimizing for high throughput might increase latency, making a system unsuitable for real-time applications. Similarly, reducing numerical precision improves power efficiency and speed but may lead to minor accuracy degradation. A thoughtful evaluation must balance these trade-offs to align with the intended application.

The deployment environment also plays a significant role in determining evaluation priorities. Cloud-based systems often prioritize scalability and adaptability to dynamic workloads, while mobile and edge systems require careful attention to memory usage and energy efficiency. These differing priorities mean that benchmarks must be tailored to the context of the system's use, rather than relying on one-size-fits-all evaluations.

Ultimately, evaluating inference performance requires a holistic approach. Focusing on a single metric, such as latency or energy efficiency, provides an incomplete picture. Instead, all relevant dimensions must be considered together to ensure that the system meets its functional, resource, and performance goals in a balanced way.

#### Common Pitfalls in Inference Benchmarks  

Even with well-defined metrics, benchmarking inference systems can be challenging. Missteps during the evaluation process often lead to misleading conclusions. Below are common pitfalls that students and practitioners should be aware of when analyzing inference performance.  

##### Focusing Only on Average Latency

While average latency provides a baseline measure of response time, it fails to capture how a system performs under peak load. In real-world scenarios, worst-case latency—captured through metrics like p95 or p99 tail latency—can significantly impact system reliability. For instance, a conversational AI system may fail to provide timely responses if occasional latency spikes exceed acceptable thresholds.

##### Neglecting Memory and Energy Constraints  

A model with excellent throughput or latency may be unsuitable for mobile or edge deployments if it requires excessive memory or power. For example, an inference system designed for cloud environments might fail to operate efficiently on a battery-powered device. Proper benchmarks must consider memory footprint and energy consumption to ensure practicality across deployment contexts.

##### Overlooking Cold-Start Performance  

In serverless environments, where models are loaded on demand, cold-start latency is a critical factor. Ignoring the time it takes to initialize a model and process the first request can result in unrealistic expectations for responsiveness. Evaluating both model load time and first-inference latency ensures that systems are designed to meet real-world responsiveness requirements.

##### Evaluating Metrics in Isolation 

Benchmarking inference systems often involves balancing competing metrics. For example, maximizing batch throughput might degrade latency, while aggressive quantization could reduce accuracy. Focusing on a single metric without considering its impact on others can lead to incomplete or misleading evaluations. Comprehensive benchmarks must account for these interactions.

##### Assuming Linear Scalability  

Inference performance does not always scale proportionally with additional resources. Bottlenecks such as memory bandwidth, thermal limits, or communication overhead can limit the benefits of adding more GPUs or TPUs. Benchmarks that assume linear scaling behavior may overestimate system performance, particularly in distributed deployments.

##### Ignoring Application-Specific Requirements

Generic benchmarking results may fail to account for the specific needs of an application. For instance, a benchmark optimized for cloud inference might be irrelevant for edge devices, where energy and memory constraints dominate. Tailoring benchmarks to the deployment context ensures that results are meaningful and actionable.

#### Final Thoughts  

Inference benchmarks are essential tools for understanding system performance, but their utility depends on careful and holistic evaluation. Metrics like latency, throughput, memory usage, and energy efficiency provide valuable insights, but their importance varies depending on the application and deployment context. Students should approach benchmarking as a process of balancing multiple priorities, rather than optimizing for a single metric.  

By avoiding common pitfalls and considering the trade-offs between different metrics, practitioners can design inference systems that are reliable, efficient, and suitable for real-world deployment. The ultimate goal of benchmarking is to guide system improvements that align with the demands of the intended application.  

### MLPerf Inference Benchmarks

The MLPerf Inference benchmark, developed by [MLCommons](https://mlcommons.org/en/), provides a standardized framework for evaluating machine learning inference performance across a range of deployment environments. Initially, MLPerf started with a single inference benchmark, but as machine learning systems expanded into diverse applications, it became clear that a one-size-fits-all benchmark was insufficient. Different inference scenarios—ranging from cloud-based AI services to resource-constrained embedded devices—demanded tailored evaluations. This realization led to the development of a family of MLPerf inference benchmarks, each designed to assess performance within a specific deployment setting.  

#### MLPerf Inference  

[MLPerf Inference](https://mlcommons.org/en/inference-datacenter/) serves as the baseline benchmark, originally designed to evaluate large-scale inference systems. It primarily focuses on data center and cloud-based inference workloads, where high throughput, low latency, and efficient resource utilization are essential. The benchmark assesses performance across a range of deep learning models, including image classification, object detection, natural language processing, and recommendation systems. This version of MLPerf remains the gold standard for comparing AI accelerators, GPUs, TPUs, and CPUs in high-performance computing environments.  

#### MLPerf Mobile  

[MLPerf Mobile](https://mlcommons.org/en/mlperf-mobile/) extends MLPerf's evaluation framework to smartphones and other mobile devices. Unlike cloud-based inference, mobile inference operates under strict power and memory constraints, requiring models to be optimized for efficiency without sacrificing responsiveness. The benchmark measures latency and responsiveness for real-time AI tasks, such as camera-based scene detection, speech recognition, and augmented reality applications. MLPerf Mobile has become an industry standard for assessing AI performance on flagship smartphones and mobile AI chips, helping developers optimize models for on-device AI workloads.  

#### MLPerf Client  

[MLPerf Client](https://mlcommons.org/en/inference-edge/) focuses on inference performance on consumer computing devices, such as laptops, desktops, and workstations. This benchmark addresses local AI workloads that run directly on personal devices, eliminating reliance on cloud inference. Tasks such as real-time video editing, speech-to-text transcription, and AI-enhanced productivity applications fall under this category. Unlike cloud-based benchmarks, MLPerf Client evaluates how AI workloads interact with general-purpose hardware, such as CPUs, discrete GPUs, and integrated neural processing units (NPUs), making it relevant for consumer and enterprise AI applications.  

#### MLPerf Tiny  

[MLPerf Tiny](https://mlcommons.org/en/inference-tiny/) was created to benchmark embedded and ultra-low-power AI systems, such as IoT devices, wearables, and microcontrollers. Unlike other MLPerf benchmarks, which assess performance on powerful accelerators, MLPerf Tiny evaluates inference on devices with limited compute, memory, and power resources. This benchmark is particularly relevant for applications such as smart sensors, AI-driven automation, and real-time industrial monitoring, where models must run efficiently on hardware with minimal processing capabilities. MLPerf Tiny plays a crucial role in the advancement of AI at the edge, helping developers optimize models for constrained environments.  

#### Why MLPerf Inference Benchmarks Matter  

The evolution of MLPerf Inference from a single benchmark to a spectrum of benchmarks reflects the diversity of AI deployment scenarios. Different environments—whether cloud, mobile, desktop, or embedded—have unique constraints and requirements, and MLPerf provides a structured way to evaluate AI models accordingly.  

MLPerf serves as an essential tool for:  

- Understanding how inference performance varies across deployment settings.  
- Learning which performance metrics are most relevant for different AI applications.  
- Optimizing models and hardware choices based on real-world usage constraints.  

By recognizing why tailored inference benchmarks are necessary, we gain a deeper appreciation for the challenges of AI deployment and the role of benchmarking in shaping efficient, scalable, and practical machine learning systems.  

## Measuring Energy Efficiency

As machine learning expands into diverse applications, concerns about its growing power consumption and ecological footprint have intensified. While performance benchmarks help optimize speed and accuracy, they do not always account for energy efficiency, which is an increasingly critical factor in real-world deployment. Efficient inference is particularly important in scenarios where power is a limited resource, such as mobile devices, embedded AI, and cloud-scale inference workloads. The need to optimize both performance and power consumption has led to the development of standardized energy efficiency benchmarks.  

However, measuring power consumption in machine learning systems presents unique challenges. The energy demands of ML models vary dramatically across deployment environments—from TinyML devices consuming microwatts to data centers requiring megawatts of power. Creating a single standardized methodology for benchmarking energy efficiency requires accommodating these vastly different scales while ensuring that measurements are consistent, fair, and reproducible across diverse hardware configurations [@henderson2020towards].

### MLPerf Power: A Standard for Measuring AI Energy Consumption  

One of the most widely used methodologies for measuring energy efficiency is MLPerf Power [@tschand2024mlperf], a benchmarking framework designed to accurately assess power consumption across different ML systems. This methodology extends across:  

- Datacenter Inference: Measuring power usage in large-scale AI workloads where optimizing energy consumption is crucial for reducing operational costs.  
- Edge Inference: Evaluating power efficiency in devices like smartphones, laptops, and AI-enabled edge hardware, where battery life is a key constraint.  
- Tiny Inference: Assessing energy consumption in ultra-low-power AI systems, such as IoT sensors and microcontrollers, where every milliwatt counts.  

The MLPerf Power methodology adapts to different hardware architectures, ranging from general-purpose CPUs to specialized AI accelerators, while maintaining a uniform measurement standard. This ensures that comparisons across platforms are meaningful and unbiased.  

### Understanding Power Measurement Boundaries  

@fig-power-diagram illustrates how power consumption is measured at different system scales, from TinyML devices to full-scale data center inference nodes. Each scenario highlights the components included within the measurement boundary and those excluded from direct measurement. This approach ensures that benchmarks reflect the true energy costs of running ML workloads in real-world settings.  

![MLPerf Power system measurement diagram. Source: @tschand2024mlperf.](images/png/power_component_diagram.png){#fig-power-diagram}  

By defining clear measurement boundaries, MLPerf Power ensures that power consumption metrics are comparable across different AI systems, helping researchers and engineers make informed decisions about energy-efficient AI deployment.  

### The Trade-off Between Performance and Energy Efficiency  

It is important to recognize that optimizing a system purely for performance does not always result in the most energy-efficient execution. In many cases, sacrificing a small amount of accuracy or processing speed can lead to significant improvements in energy efficiency. This is particularly relevant for inference workloads running in battery-powered environments, where maximizing efficiency extends operational lifetime.  

As benchmarking methodologies continue to evolve, energy efficiency metrics will play an increasingly central role in AI optimization. Future advancements in sustainable AI benchmarking[^fn-sustainable-ai] will help researchers and engineers design systems that balance performance, power consumption, and environmental impact, ensuring that ML systems operate efficiently without unnecessary energy waste.  

[^fn-sustainable-ai]: Reducing the environmental impact of machine learning by improving energy efficiency, using renewable energy sources, and designing models that require fewer computational resources.

## Challenges and Limitations

Benchmarking provides a structured framework for evaluating the performance of AI systems, but it comes with significant challenges. If these challenges are not properly addressed, they can undermine the credibility and usefulness of benchmarking results. One of the most fundamental issues is incomplete problem coverage. Many benchmarks, while useful for controlled comparisons, fail to capture the full diversity of real-world applications. For instance, common image classification datasets, such as [CIFAR-10](https://www.cs.toronto.edu/kriz/cifar.html), contain a limited variety of images. As a result, models that perform well on these datasets may struggle when applied to more complex, real-world scenarios with greater variability in lighting, perspective, and object composition.  

Another challenge is statistical insignificance, which arises when benchmark evaluations are conducted on too few data samples or trials. For example, testing an optical character recognition (OCR) system on a small dataset may not accurately reflect its performance on large-scale, noisy text documents. Without sufficient trials and diverse input distributions, benchmarking results may be misleading or fail to capture true system reliability.  

Reproducibility is also a major concern. Benchmark results can vary significantly depending on factors such as hardware configurations, software versions, and system dependencies. Small differences in compilers, numerical precision, or library updates can lead to inconsistent performance measurements across different environments. To mitigate this issue, MLPerf addresses reproducibility by providing reference implementations, standardized test environments, and strict submission guidelines. Even with these efforts, achieving true consistency across diverse hardware platforms remains an ongoing challenge.  

A more fundamental limitation of benchmarking is the risk of misalignment with real-world goals. Many benchmarks emphasize metrics such as speed, accuracy, and throughput, but practical AI deployments often require balancing multiple objectives, including power efficiency, cost, and robustness. A model that achieves state-of-the-art accuracy on a benchmark may be impractical for deployment if it consumes excessive energy or requires expensive hardware. Furthermore, benchmarks can quickly become outdated due to the rapid evolution of AI models and hardware. New techniques may emerge that render existing benchmarks less relevant, necessitating continuous updates to keep benchmarking methodologies aligned with state-of-the-art developments.  

While these challenges affect all benchmarking efforts, the most pressing concern is the role of benchmark engineering, which introduces the risk of over-optimization for specific benchmark tasks rather than meaningful improvements in real-world performance.  

### The Hardware Lottery

A critical issue in benchmarking is what has been described as the hardware lottery, a concept introduced by [@hooker2021hardware]. The success of a machine learning model is often dictated not only by its architecture and training data but also by how well it aligns with the underlying hardware used for inference. Some models perform exceptionally well, not because they are inherently better, but because they are optimized for the parallel processing capabilities of GPUs or TPUs. Meanwhile, other promising architectures may be overlooked because they do not map efficiently to dominant hardware platforms.  

This dependence on hardware compatibility introduces biases into benchmarking. A model that is highly efficient on a specific GPU may perform poorly on a CPU or a custom AI accelerator. For instance, @fig-hw-lottery compares the performance of models across different hardware platforms. The multi-hardware models show comparable results to "MobileNetV3 Large min" on both the CPU `uint8` and GPU configurations. However, these multi-hardware models demonstrate significant performance improvements over the MobileNetV3 Large baseline when run on the EdgeTPU and DSP hardware. This emphasizes the variable efficiency of multi-hardware models in specialized computing environments.

![Accuracy-latency trade-offs of multiple ML models and how they perform on various hardware. Source: @chu2021discovering.](images/png/hardware_lottery.png){#fig-hw-lottery}

Without careful benchmarking across diverse hardware configurations, the field risks favoring architectures that "win" the hardware lottery rather than selecting models based on their intrinsic strengths. This bias can shape research directions, influence funding allocation, and impact the design of next-generation AI systems. In extreme cases, it may even stifle innovation by discouraging exploration of alternative architectures that do not align with current hardware trends.  

### Benchmark Engineering

While the hardware lottery is an unintended consequence of hardware trends, benchmark engineering is an intentional practice where models or systems are explicitly optimized to excel on specific benchmark tests. This practice can lead to misleading performance claims and results that do not generalize beyond the benchmarking environment.  

Benchmark engineering occurs when AI developers fine-tune hyperparameters, preprocessing techniques, or model architectures specifically to maximize benchmark scores rather than improve real-world performance. For example, an object detection model might be carefully optimized to achieve record-low latency on a benchmark but fail when deployed in dynamic, real-world environments with varying lighting, motion blur, and occlusions. Similarly, a language model might be tuned to excel on benchmark datasets but struggle when processing conversational speech with informal phrasing and code-switching.  

The pressure to achieve high benchmark scores is often driven by competition, marketing, and research recognition. Benchmarks are frequently used to rank AI models and systems, creating an incentive to optimize specifically for them. While this can drive technical advancements, it also risks prioritizing benchmark-specific optimizations at the expense of broader generalization.  

### Bias and Over-Optimization  

To ensure that benchmarks remain useful and fair, several strategies can be employed. Transparency is one of the most important factors in maintaining benchmarking integrity. Benchmark submissions should include detailed documentation on any optimizations applied, ensuring that improvements are clearly distinguished from benchmark-specific tuning. Researchers and developers should report both benchmark performance and real-world deployment results to provide a complete picture of a system's capabilities.  

Another approach is to diversify and evolve benchmarking methodologies. Instead of relying on a single static benchmark, AI systems should be evaluated across multiple, continuously updated benchmarks that reflect real-world complexity. This reduces the risk of models being overfitted to a single test set and encourages general-purpose improvements rather than narrow optimizations.  

Standardization and third-party verification can also help mitigate bias. By establishing industry-wide benchmarking standards and requiring independent third-party audits of results, the AI community can improve the reliability and credibility of benchmarking outcomes. Third-party verification ensures that reported results are reproducible across different settings and helps prevent unintentional benchmark gaming.  

Another important strategy is application-specific testing. While benchmarks provide controlled evaluations, real-world deployment testing remains essential. AI models should be assessed not only on benchmark datasets but also in practical deployment environments. For instance, an autonomous driving model should be tested in a variety of weather conditions and urban settings rather than being judged solely on controlled benchmark datasets.  

Finally, fairness across hardware platforms must be considered. Benchmarks should test AI models on multiple hardware configurations to ensure that performance is not being driven solely by compatibility with a specific platform. This helps reduce the risk of the hardware lottery and provides a more balanced evaluation of AI system efficiency. 

### Evolving Benchmarks

One of the greatest challenges in benchmarking is that benchmarks are never static. As AI systems evolve, so must the benchmarks that evaluate them. What defines "good performance" today may be irrelevant tomorrow as models, hardware, and application requirements change. While benchmarks are essential for tracking progress, they can also quickly become outdated, leading to over-optimization for old metrics rather than real-world performance improvements.  

This has already been evident in the evolution of AI benchmarks. Early benchmarks focused heavily on image classification and object detection, as these were some of the first widely studied deep learning tasks. However, as AI expanded into natural language processing, recommendation systems, and generative AI, it became clear that these early benchmarks no longer reflected the most important challenges in the field. In response, new benchmarks emerged to measure language understanding (GLUE, SuperGLUE), generative AI (HELM, OpenAI's evals), and energy efficiency (MLPerf Power).  

Benchmark evolution is not just about adding new tasks—it's also about capturing new dimensions of performance. Traditional AI benchmarks emphasized accuracy and throughput, but modern AI applications require evaluation across fairness, robustness, scalability, and energy efficiency. For instance, AI deployed in edge environments must balance performance with power consumption, leading to benchmarks such as MLPerf Tiny that focus on resource-constrained inference. Similarly, cloud-based AI models must optimize not just for latency and accuracy, but also for cost efficiency and environmental impact, driving the need for new benchmarking methodologies.  

The need for evolving benchmarks also presents a challenge: stability versus adaptability. On the one hand, benchmarks must remain stable for long enough to allow meaningful comparisons over time. If benchmarks change too frequently, it becomes difficult to track long-term progress and compare new results with historical performance. On the other hand, failing to update benchmarks leads to stagnation, where models are optimized for outdated tasks rather than advancing the field. Striking the right balance between benchmark longevity and adaptation is an ongoing challenge for the AI community.  

Despite these difficulties, evolving benchmarks is essential for ensuring that AI progress remains meaningful. Without updates, benchmarks risk becoming detached from real-world needs, leading researchers and engineers to focus on optimizing models for artificial test cases rather than solving practical challenges. As AI continues to expand into new domains, benchmarking must keep pace, ensuring that performance evaluations remain relevant, fair, and aligned with real-world deployment scenarios.  

### The Role of MLPerf

MLPerf has played a crucial role in improving benchmarking by reducing bias, increasing generalizability, and ensuring benchmarks evolve alongside AI advancements. One of its key contributions is the standardization of benchmarking environments. By providing reference implementations, clearly defined rules, and reproducible test environments, MLPerf ensures that performance results are consistent across different hardware and software platforms, reducing variability in benchmarking outcomes.  

Recognizing that AI is deployed in a variety of real-world settings, MLPerf has also introduced different categories of inference benchmarks. The inclusion of MLPerf Inference, MLPerf Mobile, MLPerf Client, and MLPerf Tiny reflects an effort to evaluate models in the contexts where they will actually be deployed. This approach mitigates issues such as the hardware lottery by ensuring that AI systems are tested across diverse computational environments, rather than being over-optimized for a single hardware type.  

Beyond providing a structured benchmarking framework, MLPerf is continuously evolving to keep pace with the rapid progress in AI. New tasks are incorporated into benchmarks to reflect emerging challenges, such as generative AI models and energy-efficient computing, ensuring that evaluations remain relevant and forward-looking. By regularly updating its benchmarking methodologies, MLPerf helps prevent benchmarks from becoming outdated or encouraging overfitting to legacy performance metrics.  

By prioritizing fairness, transparency, and adaptability, MLPerf ensures that benchmarking remains a meaningful tool for guiding AI research and deployment. Instead of simply measuring raw speed or accuracy, MLPerf's evolving benchmarks aim to capture the complexities of real-world AI performance, ultimately fostering more reliable, efficient, and impactful AI systems.  

## Beyond ML System Benchmarking

While this chapter has primarily focused on system benchmarking, AI performance is not determined by system efficiency alone. Machine learning models and datasets play an equally crucial role in shaping AI capabilities. Model benchmarking evaluates algorithmic performance, while data benchmarking ensures that training datasets are high-quality, unbiased, and representative of real-world distributions. Understanding these aspects is vital because AI systems are not just computational pipelines—they are deeply dependent on the models they execute and the data they are trained on.  

### Model Benchmarking

Model benchmarks measure how well different machine learning algorithms perform on specific tasks. Historically, benchmarks focused almost exclusively on accuracy, but as models have grown more complex, additional factors—such as fairness, robustness, efficiency, and generalizability—have become equally important.  

Over the years, datasets have driven model innovation. The [MNIST dataset](https://www.tensorflow.org/datasets/catalog/mnist) [@lecun1998gradient] was one of the earliest used for handwritten digit recognition, while the [ImageNet dataset](https://www.image-net.org/) [@deng2009imagenet] led to breakthroughs in deep learning for image classification. More recently, datasets like [COCO](https://cocodataset.org/) [@lin2014microsoft] for object detection and [GPT-3's training corpus](https://arxiv.org/abs/2005.14165) [@brown2020language] have pushed model capabilities further.  

However, model benchmarks have limitations. Many models optimized for benchmarks fail in real-world conditions, a challenge known as the Sim2Real gap. For instance, high-performance models may be overfit to benchmark datasets, leading to poor generalization in real-world environments. Similarly, bias remains a significant issue. The [Gender Shades project](http://gendershades.org/) [@buolamwini2018gender] showed that commercial facial recognition models performed far worse on darker-skinned individuals, underscoring the importance of evaluating fairness alongside accuracy. These challenges highlight the need to go beyond isolated accuracy metrics and develop benchmarks that test generalization, fairness, and efficiency under diverse conditions.  

Emerging model benchmarks now evaluate:  

- Computational efficiency, measured by floating-point operations (FLOPs) [@bianco2018benchmark].  
- Adversarial robustness, as seen in ImageNet-A [@hendrycks2021natural] and ImageNet-C [@xie2020adversarial].  
- Generalization to unseen data, studied in benchmarks like [WILDS](https://wilds.stanford.edu/) [@koh2021wilds].  
- Fairness and bias, measured by tools like [AI Fairness 360](https://ai-fairness-360.org/).  

### Data Benchmarking

The evolution of artificial intelligence has traditionally focused on model-centric approaches, emphasizing architectural improvements and optimization techniques. However, contemporary AI development reveals that data quality, rather than model design alone, often determines performance boundaries. This recognition has elevated data benchmarking to a critical field that ensures AI models learn from datasets that are high-quality, diverse, and free from bias.

This shift toward data-centric AI development reflects a fundamental understanding: superior data quality, not just sophisticated models, produces more reliable and robust AI systems. Initiatives like DataPerf and DataComp have emerged to systematically evaluate how dataset improvements affect model performance. DataComp [@gadre2024datacomp] notably demonstrated that models trained on a carefully curated 30% subset of data achieved better results than those trained on the complete dataset, emphasizing that thoughtful data selection surpasses mere volume in importance [@northcutt2021pervasive].

Dataset saturation presents a significant challenge in data benchmarking. With models achieving near-perfect accuracy on benchmarks like ImageNet, researchers must question whether these improvements represent genuine advances in AI capability or merely optimization to existing test sets. @fig-dataset-saturation illustrates this trend, showing AI systems surpassing human performance (marked by the horizontal line at 0) across various applications including handwriting recognition, speech recognition, image recognition, reading comprehension, and language understanding over the past decade.

![AI vs human performane. Source: @kiela2021dynabench](images/png/dynabench.png){#fig-dataset-saturation}

The saturation of popular evaluation datasets raises important methodological questions [@kiela2021dynabench]. Consider the MNIST handwritten digit dataset: some test images that appear illegible to human observers were assigned specific labels during the dataset's creation in 1994. When models correctly predict these labels, they may appear to demonstrate superhuman performance, but in reality, they might simply be learning dataset-specific patterns rather than developing genuine digit recognition capabilities.

This phenomenon extends beyond computer vision. The question "Are we done with ImageNet?" [@beyer2020we] reflects broader concerns about the limitations of optimizing model architecture for fixed datasets. More critically, models trained on static datasets often struggle with distribution shifts—real-world changes that occur after the training data was collected. This challenge has prompted the development of dynamic benchmarking approaches, such as Dynabench [@kiela2021dynabench], which continuously updates test data based on model performance to prevent overfitting.

Current data benchmarking efforts focus on:  

- Label quality, as explored in [DataPerf's debugging challenge](https://www.dataperf.org/).  
- Bias and representation, studied in datasets like [MSWC](https://arxiv.org/pdf/1804.03209.pdf) for speech recognition.  
- Out-of-distribution generalization, tested in benchmarks like RxRx and WILDS [@koh2021wilds].  

### The Benchmarking Trifecta

AI benchmarking has traditionally evaluated systems, models, and data separately, but real-world AI performance emerges from the interplay between these three components. A fast system cannot compensate for a poorly trained model, and a powerful model is only as good as the data it learns from.  

The future of benchmarking lies in an integrated approach that evaluates how system efficiency, model performance, and data quality interact. This trifecta of benchmarking will allow researchers to uncover new optimization opportunities that are invisible when these components are analyzed in isolation. For instance, co-designing efficient AI models with optimized hardware and curated datasets can lead to better performance with lower computational cost.  

As AI continues to evolve, benchmarking must evolve with it. Understanding AI performance requires evaluating systems, models, and data together, ensuring that benchmarks drive not just higher accuracy, but also efficiency, fairness, and robustness. This holistic perspective will be critical for building AI that is not only powerful, but also practical and ethical.  

![Benchmarking trifecta.](images/png/benchmarking_trifecta.png){#fig-benchmarking-trifecta}

## Conclusion  

*"What gets measured gets improved."* Benchmarking plays a foundational role in the advancement of AI, providing the essential measurements needed to track progress, identify limitations, and drive innovation. This chapter has explored the multifaceted nature of benchmarking, spanning systems, models, and data, and has highlighted its critical role in optimizing AI performance across different dimensions.  

ML system benchmarks enable optimizations in speed, efficiency, and scalability, ensuring that hardware and infrastructure can support increasingly complex AI workloads. Model benchmarks provide standardized tasks and evaluation metrics beyond accuracy, driving progress in algorithmic innovation. Data benchmarks, meanwhile, reveal key issues related to data quality, bias, and representation, ensuring that AI models are built on fair and diverse datasets.  

While these components---systems, models, and data---are often evaluated in isolation, future benchmarking efforts will likely adopt a more integrated approach. By measuring the interplay between system, model, and data benchmarks, AI researchers and engineers can uncover new insights into the co-design of data, algorithms, and infrastructure. This holistic perspective will be essential as AI applications grow more sophisticated and are deployed across increasingly diverse environments.  

Benchmarking is not static—it must continuously evolve to capture new AI capabilities, address emerging challenges, and refine evaluation methodologies. As AI systems become more complex and influential, the need for rigorous, transparent, and socially beneficial benchmarking standards becomes even more pressing. Achieving this requires close collaboration between industry, academia, and standardization bodies to ensure that benchmarks remain relevant, unbiased, and aligned with real-world needs.  

Ultimately, benchmarking serves as the compass that guides AI progress. By persistently measuring and openly sharing results, we can navigate toward AI systems that are performant, robust, and trustworthy. However, benchmarking must also be aligned with human-centered principles, ensuring that AI serves society in a fair and ethical manner. The future of benchmarking is already expanding into new frontiers, including the evaluation of AI safety, fairness, and generative AI models, which will shape the next generation of AI benchmarks. These topics, while beyond the scope of this chapter, will be explored further in the discussion on Generative AI.  

For those interested in emerging trends in AI benchmarking, the article *[The Olympics of AI: Benchmarking Machine Learning Systems](https://towardsdatascience.com/the-olympics-of-ai-benchmarking-machine-learning-systems-c4b2051fbd2b)* provides a broader look at benchmarking efforts in robotics, extended reality, and neuromorphic computing. As benchmarking continues to evolve, it remains an essential tool for understanding, improving, and shaping the future of AI.  

## Resources {#sec-benchmarking-ai-resource}

Here is a curated list of resources to support students and instructors in their learning and teaching journeys. We are continuously working on expanding this collection and will add new exercises soon.

:::{.callout-note collapse="false"}

#### Slides

These slides are a valuable tool for instructors to deliver lectures and for students to review the material at their own pace. We encourage students and instructors to leverage these slides to improve their understanding and facilitate effective knowledge transfer.

* [Why is benchmarking important?](https://docs.google.com/presentation/d/17udz3gxeYF3r3X1r4ePwu1I9H8ljb53W3ktFSmuDlGs/edit?usp=drive_link&resourcekey=0-Espn0a0x81kl2txL_jIWjw)

* [Embedded inference benchmarking.](https://docs.google.com/presentation/d/18PI_0xmcW1xwwfcjmj25PikqBM_92vQfOXFV4hah-6I/edit?resourcekey=0-KO3HQcDAsR--jgbKd5cp4w#slide=id.g94db9f9f78_0_2)

:::

:::{.callout-important collapse="false"}

#### Videos

* _Coming soon._
:::

:::{.callout-caution collapse="false"}

#### Exercises

To reinforce the concepts covered in this chapter, we have curated a set of exercises that challenge students to apply their knowledge and deepen their understanding.

* @exr-cuda

<!-- * @exr-perf -->
:::
