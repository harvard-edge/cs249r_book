<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.13">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>12&nbsp; Benchmarking AI ‚Äì Machine Learning Systems</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../contents/core/ops/ops.html" rel="next">
<link href="../../../contents/core/hw_acceleration/hw_acceleration.html" rel="prev">
<link href="../../../favicon.png" rel="icon" type="image/png">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-8d568fb58c33a0b3232b1f9968c626e4.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-dark-ef4e90ae6c3d09b51a45eb7507f66832.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-dd7fbd3b0b449e893f0b297859ce1026.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/bootstrap/bootstrap-dark-7aa23e573988fad121bab2eab864bba7.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script src="../../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "~",
    "/"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-M21L0CBCVN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-M21L0CBCVN', { 'anonymize_ip': true});
</script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-M21L0CBCVN"></script>
<script type="module" src="../../../scripts/ai_menu/dist/bundle.js" defer=""></script>
<script type="module" src="../../../scripts/ai_menu/dist/sqlite3-opfs-async-proxy-B_ImRJXp.js"></script>
<script type="module" src="../../../scripts/ai_menu/dist/sqlite3-worker1-bundler-friendly-CbDNa4by.js"></script>
<script type="module" src="../../../scripts/ai_menu/dist/worker-voUF5YDa.js"></script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating nav-fixed slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Machine Learning Systems</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-wide tools-end">
    <a href="https://github.com/harvard-edge/cs249r_book" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="../../../Machine-Learning-Systems.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
    <div class="dropdown">
      <a href="" title="Share" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" role="link" aria-label="Share"><i class="bi bi-share"></i></a>
      <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item quarto-navbar-tools-item" href="https://twitter.com/intent/tweet?url=|url|">
              <i class="bi bi-twitter pe-1"></i>
            Twitter
            </a>
          </li>
          <li>
            <a class="dropdown-item quarto-navbar-tools-item" href="https://www.facebook.com/sharer/sharer.php?u=|url|">
              <i class="bi bi-facebook pe-1"></i>
            Facebook
            </a>
          </li>
      </ul>
    </div>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../contents/core/benchmarking/benchmarking.html"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Benchmarking AI</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
  <div id="quarto-announcement" data-announcement-id="1e80f3b3ab42accd40c310b55c416a9a" class="alert alert-primary hidden"><i class="bi bi-book quarto-announcement-icon"></i><div class="quarto-announcement-content">
üîî <b>What‚Äôs New?</b><br>
üìÖ <b>[02 Feb 2025]</b> Updated Chapter 12 (Benchmarking AI).<br> üìÖ <b>[28 Jan 2025]</b> Updated Chapter 8 &amp; 9 (AI Training &amp; Efficient AI).<br> üìÖ <b>[16 Jan 2025]</b> Updated Chapter 6 &amp; 7 (AI Frameworks &amp; Data Engineering).<br> üìÖ <b>[03 Jan 2025]</b> Happy New Year 2025! Chapters 1-5 have been expanded and improved, in addition to a brand-new Chapter 4!<br>
<div style="height: 1px; background-color: #ccc; margin: 10px 0;">

</div>
<p>üöÄ <b>[Our Mission]</b> 1 ‚≠ê = 1 üë©‚Äçüéì | Every GitHub ‚≠ê supports learners, reflects their engagement, and signals this subject matters.<br> üôè <b>Thank You for Your Support!</b> Help us empower more learners by reaching 10,000 GitHub ‚≠ê <a href="https://github.com/harvard-edge/cs249r_book">Star us on GitHub</a>.</p>
</div><i class="bi bi-x-lg quarto-announcement-action"></i></div>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/foreword.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Author‚Äôs Note</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/about/about.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About the Book</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/acknowledgements/acknowledgements.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Acknowledgements</span></a>
  </div>
</li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/ai/socratiq.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">SocratiQ AI</span></a>
  </div>
</li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text"><div class="part">AI Essentials</div></span></span>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/introduction/introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ml_systems/ml_systems.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">ML Systems</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/dl_primer/dl_primer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">DL Primer</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/dnn_architectures/dnn_architectures.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">DNN Architectures</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text"><div class="part">AI Engineering Principles</div></span></span>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/workflow/workflow.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">AI Workflow</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/data_engineering/data_engineering.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Data Engineering</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/frameworks/frameworks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">AI Frameworks</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/training/training.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">AI Training</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/efficient_ai/efficient_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Efficient AI</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/optimizations/optimizations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Model Optimizations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/hw_acceleration/hw_acceleration.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">AI Acceleration</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/benchmarking/benchmarking.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Benchmarking AI</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ops/ops.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">ML Operations</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text"><div class="part">AI Best Practices</div></span></span>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ondevice_learning/ondevice_learning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">On-Device Learning</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/privacy_security/privacy_security.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Security &amp; Privacy</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/responsible_ai/responsible_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Responsible AI</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/sustainable_ai/sustainable_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Sustainable AI</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/robust_ai/robust_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Robust AI</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text"><div class="part">AI Perspectives</div></span></span>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ai_for_good/ai_for_good.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">AI for Good</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/conclusion/conclusion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Conclusion</span></span></a>
  </div>
</li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text">LABS</span></span>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/overview.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/getting_started.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Getting Started</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../contents/labs/arduino/nicla_vision/nicla_vision.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Nicla Vision</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/setup/setup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Setup</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/image_classification/image_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Image Classification</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/object_detection/object_detection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Object Detection</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/kws/kws.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Keyword Spotting (KWS)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/motion_classification/motion_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Motion Classification and Anomaly Detection</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../contents/labs/seeed/xiao_esp32s3/xiao_esp32s3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">XIAO ESP32S3</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/setup/setup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Setup</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/image_classification/image_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Image Classification</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/object_detection/object_detection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Object Detection</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/kws/kws.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Keyword Spotting (KWS)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/motion_classification/motion_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Motion Classification and Anomaly Detection</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../contents/labs/raspi/raspi.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Raspberry Pi</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-8" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/setup/setup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Setup</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/image_classification/image_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Image Classification</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/object_detection/object_detection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Object Detection</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/llm/llm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Small Language Models (SLM)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/vlm/vlm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Vision-Language Models (VLM)</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../contents/labs/shared/shared.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Shared Labs</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-9" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/shared/kws_feature_eng/kws_feature_eng.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">KWS Feature Engineering</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/shared/dsp_spectral_features_block/dsp_spectral_features_block.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">DSP Spectral Features</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-10" role="navigation" aria-expanded="false">
 <span class="menu-text">Appendix</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-10" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-10" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/appendix/phd_survival_guide.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">PhD Survival Guide</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text">REFERENCES</span></span>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#purpose" id="toc-purpose" class="nav-link active" data-scroll-target="#purpose">Purpose</a></li>
  <li><a href="#overview" id="toc-overview" class="nav-link" data-scroll-target="#overview"><span class="header-section-number">12.1</span> Overview</a></li>
  <li><a href="#historical-context" id="toc-historical-context" class="nav-link" data-scroll-target="#historical-context"><span class="header-section-number">12.2</span> Historical Context</a>
  <ul>
  <li><a href="#performance-benchmarks" id="toc-performance-benchmarks" class="nav-link" data-scroll-target="#performance-benchmarks"><span class="header-section-number">12.2.1</span> Performance Benchmarks</a></li>
  <li><a href="#energy-benchmarks" id="toc-energy-benchmarks" class="nav-link" data-scroll-target="#energy-benchmarks"><span class="header-section-number">12.2.2</span> Energy Benchmarks</a></li>
  <li><a href="#domain-specific-benchmarks" id="toc-domain-specific-benchmarks" class="nav-link" data-scroll-target="#domain-specific-benchmarks"><span class="header-section-number">12.2.3</span> Domain-Specific Benchmarks</a></li>
  </ul></li>
  <li><a href="#ai-benchmarks-system-model-and-data" id="toc-ai-benchmarks-system-model-and-data" class="nav-link" data-scroll-target="#ai-benchmarks-system-model-and-data"><span class="header-section-number">12.3</span> AI Benchmarks: System, Model, and Data</a>
  <ul>
  <li><a href="#algorithmic-benchmarks" id="toc-algorithmic-benchmarks" class="nav-link" data-scroll-target="#algorithmic-benchmarks"><span class="header-section-number">12.3.1</span> Algorithmic Benchmarks</a></li>
  <li><a href="#system-benchmarks" id="toc-system-benchmarks" class="nav-link" data-scroll-target="#system-benchmarks"><span class="header-section-number">12.3.2</span> System Benchmarks</a></li>
  <li><a href="#data-benchmarks" id="toc-data-benchmarks" class="nav-link" data-scroll-target="#data-benchmarks"><span class="header-section-number">12.3.3</span> Data Benchmarks</a></li>
  <li><a href="#community-consensus" id="toc-community-consensus" class="nav-link" data-scroll-target="#community-consensus"><span class="header-section-number">12.3.4</span> Community Consensus</a></li>
  </ul></li>
  <li><a href="#benchmark-components" id="toc-benchmark-components" class="nav-link" data-scroll-target="#benchmark-components"><span class="header-section-number">12.4</span> Benchmark Components</a>
  <ul>
  <li><a href="#standardized-datasets" id="toc-standardized-datasets" class="nav-link" data-scroll-target="#standardized-datasets"><span class="header-section-number">12.4.1</span> Standardized Datasets</a></li>
  <li><a href="#pre-defined-tasks" id="toc-pre-defined-tasks" class="nav-link" data-scroll-target="#pre-defined-tasks"><span class="header-section-number">12.4.2</span> Pre-defined Tasks</a></li>
  <li><a href="#evaluation-metrics" id="toc-evaluation-metrics" class="nav-link" data-scroll-target="#evaluation-metrics"><span class="header-section-number">12.4.3</span> Evaluation Metrics</a></li>
  <li><a href="#baselines-and-baseline-models" id="toc-baselines-and-baseline-models" class="nav-link" data-scroll-target="#baselines-and-baseline-models"><span class="header-section-number">12.4.4</span> Baselines and Baseline Models</a></li>
  <li><a href="#hardware-and-software-specifications" id="toc-hardware-and-software-specifications" class="nav-link" data-scroll-target="#hardware-and-software-specifications"><span class="header-section-number">12.4.5</span> Hardware and Software Specifications</a></li>
  <li><a href="#environmental-conditions" id="toc-environmental-conditions" class="nav-link" data-scroll-target="#environmental-conditions"><span class="header-section-number">12.4.6</span> Environmental Conditions</a></li>
  <li><a href="#reproducibility-rules" id="toc-reproducibility-rules" class="nav-link" data-scroll-target="#reproducibility-rules"><span class="header-section-number">12.4.7</span> Reproducibility Rules</a></li>
  <li><a href="#result-interpretation-guidelines" id="toc-result-interpretation-guidelines" class="nav-link" data-scroll-target="#result-interpretation-guidelines"><span class="header-section-number">12.4.8</span> Result Interpretation Guidelines</a></li>
  </ul></li>
  <li><a href="#benchmarking-granularity" id="toc-benchmarking-granularity" class="nav-link" data-scroll-target="#benchmarking-granularity"><span class="header-section-number">12.5</span> Benchmarking Granularity</a>
  <ul>
  <li><a href="#micro-benchmarks" id="toc-micro-benchmarks" class="nav-link" data-scroll-target="#micro-benchmarks"><span class="header-section-number">12.5.1</span> Micro Benchmarks</a></li>
  <li><a href="#macro-benchmarks" id="toc-macro-benchmarks" class="nav-link" data-scroll-target="#macro-benchmarks"><span class="header-section-number">12.5.2</span> Macro Benchmarks</a></li>
  <li><a href="#end-to-end-benchmarks" id="toc-end-to-end-benchmarks" class="nav-link" data-scroll-target="#end-to-end-benchmarks"><span class="header-section-number">12.5.3</span> End-to-end Benchmarks</a></li>
  <li><a href="#the-trade-offs" id="toc-the-trade-offs" class="nav-link" data-scroll-target="#the-trade-offs"><span class="header-section-number">12.5.4</span> The Trade-offs</a></li>
  </ul></li>
  <li><a href="#training-benchmarks" id="toc-training-benchmarks" class="nav-link" data-scroll-target="#training-benchmarks"><span class="header-section-number">12.6</span> Training Benchmarks</a>
  <ul>
  <li><a href="#purpose-1" id="toc-purpose-1" class="nav-link" data-scroll-target="#purpose-1"><span class="header-section-number">12.6.1</span> Purpose</a>
  <ul class="collapse">
  <li><a href="#why-training-benchmarks-matter-for-ml-systems" id="toc-why-training-benchmarks-matter-for-ml-systems" class="nav-link" data-scroll-target="#why-training-benchmarks-matter-for-ml-systems">Why Training Benchmarks Matter for ML Systems</a></li>
  <li><a href="#optimizing-hardware-software-configurations" id="toc-optimizing-hardware-software-configurations" class="nav-link" data-scroll-target="#optimizing-hardware-software-configurations">Optimizing Hardware &amp; Software Configurations</a></li>
  <li><a href="#scalability-efficiency" id="toc-scalability-efficiency" class="nav-link" data-scroll-target="#scalability-efficiency">Scalability &amp; Efficiency</a></li>
  <li><a href="#cost-energy-considerations" id="toc-cost-energy-considerations" class="nav-link" data-scroll-target="#cost-energy-considerations">Cost &amp; Energy Considerations</a></li>
  <li><a href="#fair-comparisons-across-ml-systems" id="toc-fair-comparisons-across-ml-systems" class="nav-link" data-scroll-target="#fair-comparisons-across-ml-systems">Fair Comparisons Across ML Systems</a></li>
  </ul></li>
  <li><a href="#metrics" id="toc-metrics" class="nav-link" data-scroll-target="#metrics"><span class="header-section-number">12.6.2</span> Metrics</a>
  <ul class="collapse">
  <li><a href="#training-time-and-throughput" id="toc-training-time-and-throughput" class="nav-link" data-scroll-target="#training-time-and-throughput">Training Time and Throughput</a></li>
  <li><a href="#scalability-and-parallelism" id="toc-scalability-and-parallelism" class="nav-link" data-scroll-target="#scalability-and-parallelism">Scalability and Parallelism</a></li>
  <li><a href="#resource-utilization" id="toc-resource-utilization" class="nav-link" data-scroll-target="#resource-utilization">Resource Utilization</a></li>
  <li><a href="#energy-efficiency-and-cost" id="toc-energy-efficiency-and-cost" class="nav-link" data-scroll-target="#energy-efficiency-and-cost">Energy Efficiency and Cost</a></li>
  <li><a href="#fault-tolerance-and-robustness" id="toc-fault-tolerance-and-robustness" class="nav-link" data-scroll-target="#fault-tolerance-and-robustness">Fault Tolerance and Robustness</a></li>
  <li><a href="#reproducibility-and-standardization" id="toc-reproducibility-and-standardization" class="nav-link" data-scroll-target="#reproducibility-and-standardization">Reproducibility and Standardization</a></li>
  </ul></li>
  <li><a href="#evaluating-training-performance" id="toc-evaluating-training-performance" class="nav-link" data-scroll-target="#evaluating-training-performance"><span class="header-section-number">12.6.3</span> Evaluating Training Performance</a>
  <ul class="collapse">
  <li><a href="#common-pitfalls-in-training-benchmarks" id="toc-common-pitfalls-in-training-benchmarks" class="nav-link" data-scroll-target="#common-pitfalls-in-training-benchmarks">Common Pitfalls in Training Benchmarks</a></li>
  <li><a href="#final-thoughts" id="toc-final-thoughts" class="nav-link" data-scroll-target="#final-thoughts">Final Thoughts</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#inference-benchmarks" id="toc-inference-benchmarks" class="nav-link" data-scroll-target="#inference-benchmarks"><span class="header-section-number">12.7</span> Inference Benchmarks</a>
  <ul>
  <li><a href="#purpose-2" id="toc-purpose-2" class="nav-link" data-scroll-target="#purpose-2"><span class="header-section-number">12.7.1</span> Purpose</a>
  <ul class="collapse">
  <li><a href="#why-inference-benchmarks-matter-for-ml-systems" id="toc-why-inference-benchmarks-matter-for-ml-systems" class="nav-link" data-scroll-target="#why-inference-benchmarks-matter-for-ml-systems">Why Inference Benchmarks Matter for ML Systems</a></li>
  <li><a href="#optimizing-hardware-software-configurations-1" id="toc-optimizing-hardware-software-configurations-1" class="nav-link" data-scroll-target="#optimizing-hardware-software-configurations-1">Optimizing Hardware &amp; Software Configurations</a></li>
  <li><a href="#scalability-efficiency-1" id="toc-scalability-efficiency-1" class="nav-link" data-scroll-target="#scalability-efficiency-1">Scalability &amp; Efficiency</a></li>
  <li><a href="#cost-energy-considerations-1" id="toc-cost-energy-considerations-1" class="nav-link" data-scroll-target="#cost-energy-considerations-1">Cost &amp; Energy Considerations</a></li>
  <li><a href="#fair-comparisons-across-ml-systems-1" id="toc-fair-comparisons-across-ml-systems-1" class="nav-link" data-scroll-target="#fair-comparisons-across-ml-systems-1">Fair Comparisons Across ML Systems</a></li>
  </ul></li>
  <li><a href="#metrics-1" id="toc-metrics-1" class="nav-link" data-scroll-target="#metrics-1"><span class="header-section-number">12.7.2</span> Metrics</a>
  <ul class="collapse">
  <li><a href="#latency-and-tail-latency" id="toc-latency-and-tail-latency" class="nav-link" data-scroll-target="#latency-and-tail-latency">Latency and Tail Latency</a></li>
  <li><a href="#throughput-and-batch-processing-efficiency" id="toc-throughput-and-batch-processing-efficiency" class="nav-link" data-scroll-target="#throughput-and-batch-processing-efficiency">Throughput and Batch Processing Efficiency</a></li>
  <li><a href="#numerical-precision-and-accuracy-trade-offs" id="toc-numerical-precision-and-accuracy-trade-offs" class="nav-link" data-scroll-target="#numerical-precision-and-accuracy-trade-offs">Numerical Precision and Accuracy Trade-offs</a></li>
  <li><a href="#memory-footprint-and-model-size" id="toc-memory-footprint-and-model-size" class="nav-link" data-scroll-target="#memory-footprint-and-model-size">Memory Footprint and Model Size</a></li>
  <li><a href="#cold-start-time-and-model-load-time" id="toc-cold-start-time-and-model-load-time" class="nav-link" data-scroll-target="#cold-start-time-and-model-load-time">Cold-Start Time and Model Load Time</a></li>
  <li><a href="#scalability-and-dynamic-workload-handling" id="toc-scalability-and-dynamic-workload-handling" class="nav-link" data-scroll-target="#scalability-and-dynamic-workload-handling">Scalability and Dynamic Workload Handling</a></li>
  <li><a href="#power-consumption-and-energy-efficiency" id="toc-power-consumption-and-energy-efficiency" class="nav-link" data-scroll-target="#power-consumption-and-energy-efficiency">Power Consumption and Energy Efficiency</a></li>
  </ul></li>
  <li><a href="#evaluating-inference-performance" id="toc-evaluating-inference-performance" class="nav-link" data-scroll-target="#evaluating-inference-performance"><span class="header-section-number">12.7.3</span> Evaluating Inference Performance</a>
  <ul class="collapse">
  <li><a href="#key-considerations-for-inference-systems" id="toc-key-considerations-for-inference-systems" class="nav-link" data-scroll-target="#key-considerations-for-inference-systems">Key Considerations for Inference Systems</a></li>
  <li><a href="#common-pitfalls-in-inference-benchmarks" id="toc-common-pitfalls-in-inference-benchmarks" class="nav-link" data-scroll-target="#common-pitfalls-in-inference-benchmarks">Common Pitfalls in Inference Benchmarks</a></li>
  <li><a href="#final-thoughts-1" id="toc-final-thoughts-1" class="nav-link" data-scroll-target="#final-thoughts-1">Final Thoughts</a></li>
  </ul></li>
  <li><a href="#mlperf-inference-benchmarks" id="toc-mlperf-inference-benchmarks" class="nav-link" data-scroll-target="#mlperf-inference-benchmarks"><span class="header-section-number">12.7.4</span> MLPerf Inference Benchmarks</a>
  <ul class="collapse">
  <li><a href="#mlperf-inference" id="toc-mlperf-inference" class="nav-link" data-scroll-target="#mlperf-inference">MLPerf Inference</a></li>
  <li><a href="#mlperf-mobile" id="toc-mlperf-mobile" class="nav-link" data-scroll-target="#mlperf-mobile">MLPerf Mobile</a></li>
  <li><a href="#mlperf-client" id="toc-mlperf-client" class="nav-link" data-scroll-target="#mlperf-client">MLPerf Client</a></li>
  <li><a href="#mlperf-tiny" id="toc-mlperf-tiny" class="nav-link" data-scroll-target="#mlperf-tiny">MLPerf Tiny</a></li>
  <li><a href="#why-mlperf-inference-benchmarks-matter" id="toc-why-mlperf-inference-benchmarks-matter" class="nav-link" data-scroll-target="#why-mlperf-inference-benchmarks-matter">Why MLPerf Inference Benchmarks Matter</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#measuring-energy-efficiency" id="toc-measuring-energy-efficiency" class="nav-link" data-scroll-target="#measuring-energy-efficiency"><span class="header-section-number">12.8</span> Measuring Energy Efficiency</a>
  <ul>
  <li><a href="#mlperf-power-a-standard-for-measuring-ai-energy-consumption" id="toc-mlperf-power-a-standard-for-measuring-ai-energy-consumption" class="nav-link" data-scroll-target="#mlperf-power-a-standard-for-measuring-ai-energy-consumption"><span class="header-section-number">12.8.1</span> MLPerf Power: A Standard for Measuring AI Energy Consumption</a></li>
  <li><a href="#understanding-power-measurement-boundaries" id="toc-understanding-power-measurement-boundaries" class="nav-link" data-scroll-target="#understanding-power-measurement-boundaries"><span class="header-section-number">12.8.2</span> Understanding Power Measurement Boundaries</a></li>
  <li><a href="#the-trade-off-between-performance-and-energy-efficiency" id="toc-the-trade-off-between-performance-and-energy-efficiency" class="nav-link" data-scroll-target="#the-trade-off-between-performance-and-energy-efficiency"><span class="header-section-number">12.8.3</span> The Trade-off Between Performance and Energy Efficiency</a></li>
  </ul></li>
  <li><a href="#challenges-and-limitations" id="toc-challenges-and-limitations" class="nav-link" data-scroll-target="#challenges-and-limitations"><span class="header-section-number">12.9</span> Challenges and Limitations</a>
  <ul>
  <li><a href="#the-hardware-lottery" id="toc-the-hardware-lottery" class="nav-link" data-scroll-target="#the-hardware-lottery"><span class="header-section-number">12.9.1</span> The Hardware Lottery</a></li>
  <li><a href="#benchmark-engineering" id="toc-benchmark-engineering" class="nav-link" data-scroll-target="#benchmark-engineering"><span class="header-section-number">12.9.2</span> Benchmark Engineering</a></li>
  <li><a href="#bias-and-over-optimization" id="toc-bias-and-over-optimization" class="nav-link" data-scroll-target="#bias-and-over-optimization"><span class="header-section-number">12.9.3</span> Bias and Over-Optimization</a></li>
  <li><a href="#evolving-benchmarks" id="toc-evolving-benchmarks" class="nav-link" data-scroll-target="#evolving-benchmarks"><span class="header-section-number">12.9.4</span> Evolving Benchmarks</a></li>
  <li><a href="#the-role-of-mlperf" id="toc-the-role-of-mlperf" class="nav-link" data-scroll-target="#the-role-of-mlperf"><span class="header-section-number">12.9.5</span> The Role of MLPerf</a></li>
  </ul></li>
  <li><a href="#beyond-ml-system-benchmarking" id="toc-beyond-ml-system-benchmarking" class="nav-link" data-scroll-target="#beyond-ml-system-benchmarking"><span class="header-section-number">12.10</span> Beyond ML System Benchmarking</a>
  <ul>
  <li><a href="#model-benchmarking" id="toc-model-benchmarking" class="nav-link" data-scroll-target="#model-benchmarking"><span class="header-section-number">12.10.1</span> Model Benchmarking</a></li>
  <li><a href="#data-benchmarking" id="toc-data-benchmarking" class="nav-link" data-scroll-target="#data-benchmarking"><span class="header-section-number">12.10.2</span> Data Benchmarking</a></li>
  <li><a href="#the-benchmarking-trifecta" id="toc-the-benchmarking-trifecta" class="nav-link" data-scroll-target="#the-benchmarking-trifecta"><span class="header-section-number">12.10.3</span> The Benchmarking Trifecta</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">12.11</span> Conclusion</a></li>
  <li><a href="#sec-benchmarking-ai-resource" id="toc-sec-benchmarking-ai-resource" class="nav-link" data-scroll-target="#sec-benchmarking-ai-resource"><span class="header-section-number">12.12</span> Resources</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/harvard-edge/cs249r_book/edit/dev/contents/core/benchmarking/benchmarking.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/harvard-edge/cs249r_book/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li><li><a href="https://github.com/harvard-edge/cs249r_book/blob/dev/contents/core/benchmarking/benchmarking.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-benchmarking_ai" class="quarto-section-identifier"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Benchmarking AI</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Resources: <a href="#sec-benchmarking-ai-resource">Slides</a>, <a href="#sec-benchmarking-ai-resource">Videos</a>, <a href="#sec-benchmarking-ai-resource">Exercises</a></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="images/png/cover_ai_benchmarking.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="DALL¬∑E 3 Prompt: Photo of a podium set against a tech-themed backdrop. On each tier of the podium, there are AI chips with intricate designs. The top chip has a gold medal hanging from it, the second one has a silver medal, and the third has a bronze medal. Banners with ‚ÄòAI Olympics‚Äô are displayed prominently in the background."><img src="images/png/cover_ai_benchmarking.png" class="img-fluid figure-img" alt="DALL¬∑E 3 Prompt: Photo of a podium set against a tech-themed backdrop. On each tier of the podium, there are AI chips with intricate designs. The top chip has a gold medal hanging from it, the second one has a silver medal, and the third has a bronze medal. Banners with ‚ÄòAI Olympics‚Äô are displayed prominently in the background."></a></p>
<figcaption><em>DALL¬∑E 3 Prompt: Photo of a podium set against a tech-themed backdrop. On each tier of the podium, there are AI chips with intricate designs. The top chip has a gold medal hanging from it, the second one has a silver medal, and the third has a bronze medal. Banners with ‚ÄòAI Olympics‚Äô are displayed prominently in the background.</em></figcaption>
</figure>
</div>
<section id="purpose" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="purpose">Purpose</h2>
<p><em>How can quantitative evaluation reshape the development of machine learning systems, and what metrics reveal true system capabilities?</em></p>
<p>The measurement and analysis of AI system performance represent a critical element in bridging theoretical capabilities with practical outcomes. Systematic evaluation approaches reveal fundamental relationships between model behavior, resource utilization, and operational reliability. These measurements draw out the essential trade-offs across accuracy, efficiency, and scalability, providing insights that guide architectural decisions throughout the development lifecycle. These evaluation frameworks establish core principles for assessing and validating system design choices and enable the creation of robust solutions that meet increasingly complex performance requirements across diverse deployment scenarios.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Learning Objectives">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Learning Objectives
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><p>Understand the objectives of AI benchmarking, including performance evaluation, resource assessment, and validation.</p></li>
<li><p>Differentiate between training and inference benchmarking and their respective evaluation methodologies.</p></li>
<li><p>Identify key benchmarking metrics and trends, including accuracy, fairness, complexity, and efficiency.</p></li>
<li><p>Recognize system benchmarking concepts, including throughput, latency, power consumption, and computational efficiency.</p></li>
<li><p>Understand the limitations of isolated evaluations and the necessity of integrated benchmarking frameworks.</p></li>
</ul>
</div>
</div>
</section>
<section id="overview" class="level2" data-number="12.1">
<h2 data-number="12.1" class="anchored" data-anchor-id="overview"><span class="header-section-number">12.1</span> Overview</h2>
<p>Computing systems continue to evolve and grow in complexity. Understanding their performance becomes essential to engineer them better. System evaluation measures how computing systems perform relative to specified requirements and goals. Engineers and researchers examine metrics like processing speed, resource usage, and reliability to understand system behavior under different conditions and workloads. These measurements help teams identify bottlenecks, optimize performance, and verify that systems meet design specifications.</p>
<p>Standardized measurement forms the backbone of scientific and engineering progress. The metric system enables precise communication of physical quantities. Organizations like the National Institute of Standards and Technology maintain fundamental measures from the kilogram to the second. This standardization extends to computing, where benchmarks provide uniform methods to quantify system performance. Standard performance tests measure processor operations, memory bandwidth, network throughput, and other computing capabilities. These benchmarks allow meaningful comparison between different hardware and software configurations.</p>
<p>Machine learning systems present distinct measurement challenges. Unlike traditional computing tasks, ML systems integrate hardware performance, algorithmic behavior, and data characteristics. Performance evaluation must account for computational efficiency and statistical effectiveness. Training time, model accuracy, and generalization capabilities all factor into system assessment. The interdependence between computing resources, algorithmic choices, and dataset properties creates new dimensions for measurement and comparison.</p>
<p>These considerations lead us to define machine learning benchmarking as follows:</p>
<div class="callout callout-style-default callout-note callout-titled" title="Definition of ML Benchmarking">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition of ML Benchmarking
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Machine Learning Benchmarking (ML Benchmarking)</strong> is the <em>systematic evaluation</em> of <em>compute performance, algorithmic effectiveness, and data quality</em> in machine learning systems. It assesses <em>system capabilities</em>, <em>model accuracy and convergence</em>, and <em>data scalability and representativeness</em> to optimize system performance across diverse workloads. ML benchmarking enables engineers and researchers to <em>quantify trade-offs</em>, <em>improve deployment efficiency</em>, and <em>ensure reproducibility</em> in both research and production settings. As ML systems evolve, benchmarks also incorporate <em>fairness, robustness, and energy efficiency</em>, reflecting the increasing complexity of AI evaluation.</p>
</div>
</div>
<p>This chapter focuses primarily on benchmarking machine learning systems, examining how computational resources affect training and inference performance. While the main emphasis remains on system-level evaluation, understanding the role of algorithms and data proves essential for comprehensive ML benchmarking.</p>
</section>
<section id="historical-context" class="level2 page-columns page-full" data-number="12.2">
<h2 data-number="12.2" class="anchored" data-anchor-id="historical-context"><span class="header-section-number">12.2</span> Historical Context</h2>
<p>The evolution of computing benchmarks mirrors the development of computer systems themselves, progressing from simple performance metrics to increasingly specialized evaluation frameworks. As computing expanded beyond scientific calculations into diverse applications, benchmarks evolved to measure new capabilities, constraints, and use cases. This progression reflects three major shifts in computing: the transition from mainframes to personal computers, the rise of energy efficiency as a critical concern, and the emergence of specialized computing domains such as machine learning.</p>
<p>Early benchmarks focused primarily on raw computational power, measuring basic operations like floating-point calculations. As computing applications diversified, benchmark development branched into distinct specialized categories, each designed to evaluate specific aspects of system performance. This specialization accelerated with the emergence of graphics processing, mobile computing, and eventually, cloud services and machine learning.</p>
<section id="performance-benchmarks" class="level3 page-columns page-full" data-number="12.2.1">
<h3 data-number="12.2.1" class="anchored" data-anchor-id="performance-benchmarks"><span class="header-section-number">12.2.1</span> Performance Benchmarks</h3>
<p>The evolution of benchmarks in computing illustrates how systematic performance measurement has shaped technological progress. During the 1960s and 1970s, when mainframe computers dominated the computing landscape, performance benchmarks focused primarily on fundamental computational tasks. The <a href="https://en.wikipedia.org/wiki/Whetstone_(benchmark)">Whetstone benchmark</a><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, introduced in 1964 to measure floating-point arithmetic performance, became a definitive standard that demonstrated how systematic testing could drive improvements in computer architecture.</p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;Introduced in 1964, the Whetstone benchmark was one of the first synthetic benchmarks designed to measure floating-point arithmetic performance, influencing early computer architecture improvements.</p></div></div><p>The introduction of the <a href="https://en.wikipedia.org/wiki/LINPACK_benchmark">LINPACK benchmark</a> in 1979 expanded the focus of performance evaluation, offering a means to assess how efficiently systems solved linear equations. As computing shifted toward personal computers in the 1980s, the need for standardized performance measurement grew. The <a href="https://en.wikipedia.org/wiki/Dhrystone">Dhrystone benchmark</a>, introduced in 1984, provided one of the first integer-based benchmarks, complementing floating-point evaluations.</p>
<p>The late 1980s and early 1990s saw the emergence of systematic benchmarking frameworks that emphasized real-world workloads. The <a href="https://www.spec.org/cpu/">SPEC CPU benchmarks</a><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, introduced in 1989 by the <a href="https://www.spec.org/">System Performance Evaluation Cooperative (SPEC)</a>, fundamentally changed hardware evaluation by shifting the focus from synthetic tests to a standardized suite designed to measure performance using practical computing workloads. This approach enabled manufacturers to optimize their systems for real applications, accelerating advances in processor design and software optimization.</p>
<div class="no-row-height column-margin column-container"><div id="fn2"><p><sup>2</sup>&nbsp;Launched in 1989, the SPEC CPU benchmark suite shifted performance evaluation towards real-world workloads, significantly influencing processor design and optimization.</p></div></div><p>The increasing demand for graphics-intensive applications and mobile computing in the 1990s and early 2000s presented new benchmarking challenges. The introduction of <a href="https://www.3dmark.com/">3DMark</a> in 1998 established an industry standard for evaluating graphics performance, shaping the development of programmable shaders and modern GPU architectures. Mobile computing introduced an additional constraint‚Äîpower efficiency‚Äînecessitating benchmarks that assessed both computational performance and energy consumption. The release of <a href="https://bapco.com/products/mobilemark-2014/">MobileMark</a> by <a href="https://bapco.com/">BAPCo</a> provided a means to evaluate power efficiency in laptops and mobile devices, influencing the development of energy-efficient architectures such as <a href="https://www.arm.com/">ARM</a>.</p>
<p>The focus of benchmarking in the past decade has shifted toward cloud computing, big data, and artificial intelligence. Cloud service providers such as Amazon Web Services and Google Cloud optimize their platforms based on performance, scalability, and cost-effectiveness <span class="citation" data-cites="Barroso2022">(<a href="../references.html#ref-Barroso2022" role="doc-biblioref">Barroso, H√∂lzle, and Ranganathan 2019</a>)</span>. Benchmarks like <a href="http://cloudsuite.ch/">CloudSuite</a> have become critical for evaluating cloud infrastructure, measuring how well systems handle distributed workloads. Machine learning has introduced another dimension of performance evaluation. The introduction of <a href="https://mlcommons.org/">MLPerf</a> in 2018 established a widely accepted standard for measuring machine learning training and inference efficiency across different hardware architectures.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Barroso2022" class="csl-entry" role="listitem">
Barroso, Luiz Andr√©, Urs H√∂lzle, and Parthasarathy Ranganathan. 2019. <span>‚ÄúThe Datacenter as a Computer: An Introduction to the Design of Warehouse-Scale Machines.‚Äù</span> In <em>The Datacenter as a Computer</em>, 3rd ed., 1‚Äì15. Springer International Publishing. <a href="https://doi.org/10.1007/978-3-031-01761-2\_1">https://doi.org/10.1007/978-3-031-01761-2\_1</a>.
</div></div></section>
<section id="energy-benchmarks" class="level3 page-columns page-full" data-number="12.2.2">
<h3 data-number="12.2.2" class="anchored" data-anchor-id="energy-benchmarks"><span class="header-section-number">12.2.2</span> Energy Benchmarks</h3>
<p>As computing scaled from personal devices to massive data centers, energy efficiency emerged as a critical dimension of performance evaluation. The mid-2000s marked a shift in benchmarking methodologies, moving beyond raw computational speed to assess power efficiency across diverse computing platforms. The increasing thermal constraints in processor design, coupled with the scaling demands of large-scale internet services, underscored energy consumption as a fundamental consideration in system evaluation.</p>
<p>Power benchmarking addresses three interconnected challenges: environmental sustainability, operational efficiency, and device usability. The growing energy demands of the technology sector have intensified concerns about sustainability, while energy costs continue to shape the economics of data center operations. In mobile computing, power efficiency directly determines battery life and user experience, reinforcing the importance of energy-aware performance measurement.</p>
<p>The industry has responded with several standardized benchmarks that quantify energy efficiency. <a href="https://www.spec.org/power/">SPEC Power</a> provides a widely accepted methodology for measuring server efficiency across varying workload levels, allowing for direct comparisons of power-performance trade-offs. The <a href="https://www.top500.org/green500/">Green500</a> ranking<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> applies similar principles to high-performance computing, ranking the world‚Äôs most powerful supercomputers based on their energy efficiency rather than their raw performance. The <a href="https://www.energystar.gov/products/computers">ENERGY STAR</a> certification program has also established foundational energy standards that have shaped the design of consumer and enterprise computing systems.</p>
<div class="no-row-height column-margin column-container"><div id="fn3"><p><sup>3</sup>&nbsp;Established in 2007, the Green500 ranks supercomputers based on energy efficiency, highlighting advances in power-efficient high-performance computing.</p></div></div><p>Power benchmarking faces distinct challenges, particularly in accounting for the diverse workload patterns and system configurations encountered across different computing environments. Recent advancements, such as the <a href="https://mlcommons.org/">MLPerf Power</a> benchmark, have introduced specialized methodologies for measuring the energy impact of machine learning workloads, addressing the growing importance of energy efficiency in AI-driven computing. As artificial intelligence and edge computing continue to evolve, power benchmarking will play an increasingly crucial role in driving energy-efficient hardware and software innovations.</p>
</section>
<section id="domain-specific-benchmarks" class="level3" data-number="12.2.3">
<h3 data-number="12.2.3" class="anchored" data-anchor-id="domain-specific-benchmarks"><span class="header-section-number">12.2.3</span> Domain-Specific Benchmarks</h3>
<p>The evolution of computing applications, particularly in artificial intelligence, has highlighted the limitations of general-purpose benchmarks and led to the development of domain-specific evaluation frameworks. Standardized benchmarks, while effective for assessing broad system performance, often fail to capture the unique constraints and operational requirements of specialized workloads. This gap has resulted in the emergence of tailored benchmarking methodologies designed to evaluate performance in specific computing domains.</p>
<p>Machine learning presents one of the most prominent examples of this transition. Traditional CPU and GPU benchmarks are insufficient for assessing workloads, which involve complex interactions between computation, memory bandwidth, and data movement. The introduction of MLPerf has standardized performance measurement for machine learning models, providing detailed insights into training and inference efficiency.</p>
<p>Beyond AI, domain-specific benchmarks have been adopted across various industries. Healthcare organizations have developed benchmarking frameworks to evaluate machine learning models used in medical diagnostics, ensuring that performance assessments align with real-world patient data. In financial computing, specialized benchmarking methodologies assess transaction latency and fraud detection accuracy, ensuring that high-frequency trading systems meet stringent timing requirements. Autonomous vehicle developers implement evaluation frameworks that test AI models under varying environmental conditions and traffic scenarios, ensuring the reliability of self-driving systems.</p>
<p>The strength of domain-specific benchmarks lies in their ability to capture workload-specific performance characteristics that general benchmarks may overlook. By tailoring performance evaluation to sector-specific requirements, these benchmarks provide insights that drive targeted optimizations in both hardware and software. As computing continues to expand into new domains, specialized benchmarking will remain a key tool for assessing and improving performance in emerging fields.</p>
</section>
</section>
<section id="ai-benchmarks-system-model-and-data" class="level2 page-columns page-full" data-number="12.3">
<h2 data-number="12.3" class="anchored" data-anchor-id="ai-benchmarks-system-model-and-data"><span class="header-section-number">12.3</span> AI Benchmarks: System, Model, and Data</h2>
<p>The evolution of benchmarks reaches its apex in machine learning, reflecting a journey that parallels the field‚Äôs development towards domain-specific applications. Early machine learning benchmarks focused primarily on algorithmic performance, measuring how well models could perform specific tasks <span class="citation" data-cites="lecun1998gradient">(<a href="../references.html#ref-lecun1998gradient" role="doc-biblioref">Lecun et al. 1998</a>)</span>. As machine learning applications scaled and computational demands grew, the focus expanded to include system performance and hardware efficiency <span class="citation" data-cites="jouppi2017datacenter">(<a href="../references.html#ref-jouppi2017datacenter" role="doc-biblioref">Jouppi et al. 2017</a>)</span>. Most recently, the critical role of data quality has emerged as the third essential dimension of evaluation <span class="citation" data-cites="gebru2021datasheets">(<a href="../references.html#ref-gebru2021datasheets" role="doc-biblioref">Gebru et al. 2021</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-jouppi2017datacenter" class="csl-entry" role="listitem">
Jouppi, Norman P., Cliff Young, Nishant Patil, David Patterson, Gaurav Agrawal, Raminder Bajwa, Sarah Bates, et al. 2017. <span>‚ÄúIn-Datacenter Performance Analysis of a Tensor Processing Unit.‚Äù</span> <em>ACM SIGARCH Computer Architecture News</em> 45 (2): 1‚Äì12. <a href="https://doi.org/10.1145/3140659.3080246">https://doi.org/10.1145/3140659.3080246</a>.
</div></div><p>What sets AI benchmarks apart from traditional performance metrics is their inherent variability‚Äîintroducing accuracy as a fundamental dimension of evaluation. Unlike conventional benchmarks, which measure fixed, deterministic characteristics like computational speed or energy consumption, AI benchmarks must account for the probabilistic nature of machine learning models. The same system can produce different results depending on the data it encounters, making accuracy a defining factor in performance assessment. This distinction adds complexity, as benchmarking AI systems requires not only measuring raw computational efficiency but also understanding trade-offs between accuracy, generalization, and resource constraints.</p>
<p>The growing complexity and ubiquity of machine learning systems demand comprehensive benchmarking across all three dimensions: algorithmic models, hardware systems, and training data. This multifaceted evaluation approach represents a significant departure from earlier benchmarks that could focus on isolated aspects like computational speed or energy efficiency <span class="citation" data-cites="hernandez2020measuring">(<a href="../references.html#ref-hernandez2020measuring" role="doc-biblioref">Hernandez and Brown 2020</a>)</span>. Modern machine learning benchmarks must address the sophisticated interplay between these dimensions, as limitations in any one area can fundamentally constrain overall system performance.</p>
<div class="no-row-height column-margin column-container"><div id="ref-hernandez2020measuring" class="csl-entry" role="listitem">
Hernandez, Danny, and Tom B. Brown. 2020. <span>‚ÄúMeasuring the Algorithmic Efficiency of Neural Networks.‚Äù</span> <em>arXiv Preprint arXiv:2005.04305</em>, May. <a href="https://doi.org/10.48550/arxiv.2005.04305">https://doi.org/10.48550/arxiv.2005.04305</a>.
</div><div id="ref-jouppi2021ten" class="csl-entry" role="listitem">
Jouppi, Norman P., Doe Hyun Yoon, Matthew Ashcraft, Mark Gottscho, Thomas B. Jablin, George Kurian, James Laudon, et al. 2021. <span>‚ÄúTen Lessons from Three Generations Shaped Google‚Äôs TPUv4i : Industrial Product.‚Äù</span> In <em>2021 ACM/IEEE 48th Annual International Symposium on Computer Architecture (ISCA)</em>, 1‚Äì14. IEEE. <a href="https://doi.org/10.1109/isca52012.2021.00010">https://doi.org/10.1109/isca52012.2021.00010</a>.
</div><div id="ref-bender2021stochastic" class="csl-entry" role="listitem">
Bender, Emily M., Timnit Gebru, Angelina McMillan-Major, and Shmargaret Shmitchell. 2021. <span>‚ÄúOn the Dangers of Stochastic Parrots: Can Language Models Be Too Big? ü¶ú.‚Äù</span> In <em>Proceedings of the 2021 ACM Conference on Fairness, Accountability, and Transparency</em>, 610‚Äì23. ACM. <a href="https://doi.org/10.1145/3442188.3445922">https://doi.org/10.1145/3442188.3445922</a>.
</div></div><p>This evolution in benchmark complexity mirrors the field‚Äôs deepening understanding of what drives machine learning system success. While algorithmic innovations initially dominated progress metrics, the challenges of deploying models at scale revealed the critical importance of hardware efficiency <span class="citation" data-cites="jouppi2021ten">(<a href="../references.html#ref-jouppi2021ten" role="doc-biblioref">Jouppi et al. 2021</a>)</span>. Subsequently, high-profile failures of machine learning systems in real-world deployments highlighted how data quality and representation fundamentally determine system reliability and fairness <span class="citation" data-cites="bender2021stochastic">(<a href="../references.html#ref-bender2021stochastic" role="doc-biblioref">Bender et al. 2021</a>)</span>. Understanding how these dimensions interact has become essential for accurately assessing machine learning system performance, informing development decisions, and measuring technological progress in the field.</p>
<section id="algorithmic-benchmarks" class="level3 page-columns page-full" data-number="12.3.1">
<h3 data-number="12.3.1" class="anchored" data-anchor-id="algorithmic-benchmarks"><span class="header-section-number">12.3.1</span> Algorithmic Benchmarks</h3>
<p>AI algorithms must balance multiple interconnected performance objectives, including accuracy, speed, resource efficiency, and generalization capability. As machine learning applications span diverse domains‚Äîsuch as computer vision, natural language processing, speech recognition, and reinforcement learning‚Äîevaluating these objectives requires standardized methodologies tailored to each domain‚Äôs unique challenges. Algorithmic benchmarks, such as ImageNet <span class="citation" data-cites="deng2009imagenet">(<a href="../references.html#ref-deng2009imagenet" role="doc-biblioref">Deng et al. 2009</a>)</span>, establish these evaluation frameworks, providing a consistent basis for comparing different machine learning approaches.</p>
<div class="no-row-height column-margin column-container"></div><div class="callout callout-style-default callout-note callout-titled" title="Definition of Machine Learning  Algorithmic Benchmarks">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition of Machine Learning Algorithmic Benchmarks
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>ML Algorithmic benchmarks</strong> refer to the evaluation of machine learning models on <em>standardized tasks</em> using <em>predefined datasets and metrics</em>. These benchmarks measure <em>accuracy, efficiency, and generalization</em> to ensure <em>objective comparisons</em> across different models. Algorithmic benchmarks provide <em>performance baselines</em>, enabling systematic assessment of <em>trade-offs between model complexity and computational cost</em>. They drive <em>technological progress</em> by tracking improvements over time and identifying <em>limitations</em> in existing approaches.</p>
</div>
</div>
<p>Algorithmic benchmarks serve several critical functions in advancing AI. They establish clear performance baselines, enabling objective comparisons between competing approaches. By systematically evaluating trade-offs between model complexity, computational requirements, and task performance, they help researchers and practitioners identify optimal design choices. Moreover, they track technological progress by documenting improvements over time, guiding the development of new techniques while exposing limitations in existing methodologies. Through these roles, algorithmic benchmarks shape the trajectory of AI research and development, ensuring that innovations translate into measurable, real-world improvements.</p>
</section>
<section id="system-benchmarks" class="level3 page-columns page-full" data-number="12.3.2">
<h3 data-number="12.3.2" class="anchored" data-anchor-id="system-benchmarks"><span class="header-section-number">12.3.2</span> System Benchmarks</h3>
<p>AI computations, particularly in machine learning, place extraordinary demands on computational resources. The underlying hardware infrastructure, encompassing CPUs, GPUs, TPUs, and specialized accelerators, fundamentally determines the speed, efficiency, and scalability of AI solutions. System benchmarks establish standardized methodologies for evaluating hardware performance across diverse AI workloads, measuring critical metrics including computational throughput, memory bandwidth, power efficiency, and scaling characteristics <span class="citation" data-cites="reddi2020mlperf mattson2020mlperf">(<a href="../references.html#ref-reddi2020mlperf" role="doc-biblioref">Reddi et al. 2019</a>; <a href="../references.html#ref-mattson2020mlperf" role="doc-biblioref">Mattson et al. 2020</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-mattson2020mlperf" class="csl-entry" role="listitem">
Mattson, Peter, Vijay Janapa Reddi, Christine Cheng, Cody Coleman, Greg Diamos, David Kanter, Paulius Micikevicius, et al. 2020. <span>‚ÄúMLPerf: An Industry Standard Benchmark Suite for Machine Learning Performance.‚Äù</span> <em>IEEE Micro</em> 40 (2): 8‚Äì16. <a href="https://doi.org/10.1109/mm.2020.2974843">https://doi.org/10.1109/mm.2020.2974843</a>.
</div></div><div class="callout callout-style-default callout-note callout-titled" title="Definition of Machine Learning System Benchmarks">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition of Machine Learning System Benchmarks
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>ML System benchmarks</strong> refer to the evaluation of <em>computational infrastructure</em> used to execute AI workloads, assessing <em>performance, efficiency, and scalability</em> under standardized conditions. These benchmarks measure <em>throughput, latency, and resource utilization</em> to ensure <em>objective comparisons</em> across different system configurations. System benchmarks provide <em>insights into workload efficiency</em>, guiding <em>infrastructure selection, system optimization,</em> and <em>advancements in computational architectures</em>.</p>
</div>
</div>
<p>These benchmarks fulfill two essential functions in the AI ecosystem. First, they enable developers and organizations to make informed decisions when selecting hardware platforms for their AI applications by providing comprehensive comparative performance data across system configurations. Critical evaluation factors include training speed, inference latency, energy efficiency, and cost-effectiveness. Second, hardware manufacturers rely on these benchmarks to quantify generational improvements and guide the development of specialized AI accelerators, driving continuous advancement in computational capabilities.</p>
<p>System benchmarks evaluate performance across multiple scales, ranging from single-chip configurations to large distributed systems, and diverse AI workloads including both training and inference tasks. This comprehensive evaluation approach ensures that benchmarks accurately reflect real-world deployment scenarios and deliver actionable insights that inform both hardware selection decisions and system architecture design.</p>
</section>
<section id="data-benchmarks" class="level3 page-columns page-full" data-number="12.3.3">
<h3 data-number="12.3.3" class="anchored" data-anchor-id="data-benchmarks"><span class="header-section-number">12.3.3</span> Data Benchmarks</h3>
<p>Data quality, scale, and diversity fundamentally shape machine learning system performance, directly influencing how effectively algorithms learn and generalize to new situations. Data benchmarks establish standardized datasets and evaluation methodologies that enable consistent comparison of different approaches. These frameworks assess critical aspects of data quality, including domain coverage, potential biases, and resilience to real-world variations in input data <span class="citation" data-cites="gebru2021datasheets">(<a href="../references.html#ref-gebru2021datasheets" role="doc-biblioref">Gebru et al. 2021</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-gebru2021datasheets" class="csl-entry" role="listitem">
Gebru, Timnit, Jamie Morgenstern, Briana Vecchione, Jennifer Wortman Vaughan, Hanna Wallach, Hal Daum√© III, and Kate Crawford. 2021. <span>‚ÄúDatasheets for Datasets.‚Äù</span> <em>Communications of the ACM</em> 64 (12): 86‚Äì92. <a href="https://doi.org/10.1145/3458723">https://doi.org/10.1145/3458723</a>.
</div></div><div class="callout callout-style-default callout-note callout-titled" title="Definition of Machine Learning Data Benchmarks">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition of Machine Learning Data Benchmarks
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>ML Data benchmarks</strong> refer to the evaluation of <em>datasets and data quality</em> in machine learning, assessing <em>coverage, bias, and robustness</em> under standardized conditions. These benchmarks measure <em>data representativeness, consistency, and impact on model performance</em> to ensure <em>objective comparisons</em> across different AI approaches. Data benchmarks provide <em>insights into data reliability</em>, guiding <em>dataset selection, bias mitigation,</em> and <em>improvements in data-driven AI systems</em>.</p>
</div>
</div>
<p>Data benchmarks serve an essential function in understanding AI system behavior under diverse data conditions. Through systematic evaluation, they help identify common failure modes, expose gaps in data coverage, and reveal underlying biases that could impact model behavior in deployment. By providing common frameworks for data evaluation, these benchmarks enable the AI community to systematically improve data quality and address potential issues before deploying systems in production environments. This proactive approach to data quality assessment has become increasingly critical as AI systems take on more complex and consequential tasks across different domains.</p>
</section>
<section id="community-consensus" class="level3 page-columns page-full" data-number="12.3.4">
<h3 data-number="12.3.4" class="anchored" data-anchor-id="community-consensus"><span class="header-section-number">12.3.4</span> Community Consensus</h3>
<p>The proliferation of benchmarks spanning performance, energy efficiency, and domain-specific applications creates a fundamental challenge: establishing industry-wide standards. While early computing benchmarks primarily measured processor speed and memory bandwidth, modern benchmarks evaluate sophisticated aspects of system performance, from power consumption profiles to application-specific capabilities. This evolution in scope and complexity necessitates comprehensive validation and consensus from the computing community, particularly in rapidly evolving fields like machine learning where performance must be evaluated across multiple interdependent dimensions.</p>
<p>The lasting impact of a benchmark depends fundamentally on its acceptance by the research community, where technical excellence alone proves insufficient. Benchmarks developed without broad community input often fail to gain traction, frequently missing metrics that leading research groups consider essential. Successful benchmarks emerge through collaborative development involving academic institutions, industry partners, and domain experts. This inclusive approach ensures benchmarks evaluate capabilities most crucial for advancing the field, while balancing theoretical and practical considerations.</p>
<p>Benchmarks developed through extensive collaboration among respected institutions carry the authority necessary to drive widespread adoption, while those perceived as advancing particular corporate interests face skepticism and limited acceptance. The success of ImageNet demonstrates how sustained community engagement through workshops and challenges establishes long-term viability. This community-driven development creates a foundation for formal standardization, where organizations like IEEE and ISO transform these benchmarks into official standards.</p>
<p>The standardization process provides crucial infrastructure for benchmark formalization and adoption. <a href="https://standards.ieee.org/develop/wg/">IEEE working groups</a> transform community-developed benchmarking methodologies into formal industry standards, establishing precise specifications for measurement and reporting. The <a href="https://standards.ieee.org/ieee/2416/7065/">IEEE 2416-2019</a> standard for system power modeling<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> exemplifies this process, codifying best practices developed through community consensus. Similarly, <a href="https://www.iso.org/committee/45020.html">ISO/IEC technical committees</a> develop international standards for benchmark validation and certification, ensuring consistent evaluation across global research and industry communities. These organizations bridge the gap between community-driven innovation and formal standardization, providing frameworks that enable reliable comparison of results across different institutions and geographic regions.</p>
<div class="no-row-height column-margin column-container"><div id="fn4"><p><sup>4</sup>&nbsp;<strong>IEEE 2416-2019:</strong> A standard defining methodologies for parameterized power modeling, enabling system-level power analysis and optimization in electronic design, including AI hardware.</p></div></div><p>Successful community benchmarks establish clear governance structures for managing their evolution. Through rigorous version control systems and detailed change documentation, benchmarks maintain backward compatibility while incorporating new advances. This governance includes formal processes for proposing, reviewing, and implementing changes, ensuring that benchmarks remain relevant while maintaining stability. Modern benchmarks increasingly emphasize reproducibility requirements, incorporating automated verification systems and standardized evaluation environments.</p>
<p>Open access accelerates benchmark adoption and ensures consistent implementation. Projects that provide open-source reference implementations, comprehensive documentation, validation suites, and containerized evaluation environments reduce barriers to entry. This standardization enables research groups to evaluate solutions using uniform methods and metrics. Without such coordinated implementation frameworks, organizations might interpret benchmarks inconsistently, compromising result reproducibility and meaningful comparison across studies.</p>
<p>The most successful benchmarks strike a careful balance between academic rigor and industry practicality. Academic involvement ensures theoretical soundness and comprehensive evaluation methodology, while industry participation grounds benchmarks in practical constraints and real-world applications. This balance proves particularly crucial in machine learning benchmarks, where theoretical advances must translate to practical improvements in deployed systems <span class="citation" data-cites="patterson2021carbon">(<a href="../references.html#ref-patterson2021carbon" role="doc-biblioref">Patterson et al. 2021</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-patterson2021carbon" class="csl-entry" role="listitem">
Patterson, David, Joseph Gonzalez, Quoc Le, Chen Liang, Lluis-Miquel Munguia, Daniel Rothchild, David So, Maud Texier, and Jeff Dean. 2021. <span>‚ÄúCarbon Emissions and Large Neural Network Training.‚Äù</span> <em>arXiv Preprint arXiv:2104.10350</em>, April. <a href="http://arxiv.org/abs/2104.10350v3">http://arxiv.org/abs/2104.10350v3</a>.
</div></div><p>Community consensus establishes enduring benchmark relevance, while fragmentation impedes scientific progress. Through collaborative development and transparent operation, benchmarks evolve into authoritative standards for measuring advancement. The most successful benchmarks in energy efficiency and domain-specific applications share this foundation of community development and governance, demonstrating how collective expertise and shared purpose create lasting impact in rapidly advancing fields.</p>
</section>
</section>
<section id="benchmark-components" class="level2 page-columns page-full" data-number="12.4">
<h2 data-number="12.4" class="anchored" data-anchor-id="benchmark-components"><span class="header-section-number">12.4</span> Benchmark Components</h2>
<p>An AI benchmark is more than just a test or a score; it is a comprehensive evaluation framework designed to assess the performance and capabilities of artificial intelligence systems. To understand this in-depth, it is essential to break down the typical components that constitute an AI benchmark.</p>
<section id="standardized-datasets" class="level3 page-columns page-full" data-number="12.4.1">
<h3 data-number="12.4.1" class="anchored" data-anchor-id="standardized-datasets"><span class="header-section-number">12.4.1</span> Standardized Datasets</h3>
<p>Standardized datasets form the cornerstone of AI benchmarks, providing a consistent foundation for training and evaluating models. These datasets are meticulously curated to ensure that all models are tested on equal footing, allowing for meaningful comparisons across different approaches and architectures. Datasets such as <a href="http://www.image-net.org/">ImageNet</a> <span class="citation" data-cites="deng2009imagenet">(<a href="../references.html#ref-deng2009imagenet" role="doc-biblioref">Deng et al. 2009</a>)</span>, <a href="https://cocodataset.org/">COCO</a> <span class="citation" data-cites="lin2014microsoft">(<a href="../references.html#ref-lin2014microsoft" role="doc-biblioref">Lin et al. 2014</a>)</span>, and <a href="https://www.cs.toronto.edu/~kriz/cifar.html">CIFAR-10</a> <span class="citation" data-cites="krizhevsky2009learning">(<a href="../references.html#ref-krizhevsky2009learning" role="doc-biblioref">Krizhevsky, Hinton, et al. 2009</a>)</span> have become gold standards. For natural language processing, corpora such as <a href="https://rajpurkar.github.io/SQuAD-explorer/">SQuAD</a> <span class="citation" data-cites="rajpurkar2016squad">(<a href="../references.html#ref-rajpurkar2016squad" role="doc-biblioref">Rajpurkar et al. 2016</a>)</span>, <a href="https://gluebenchmark.com/">GLUE</a> <span class="citation" data-cites="wang2018glue">(<a href="../references.html#ref-wang2018glue" role="doc-biblioref">Wang et al. 2018</a>)</span>, and <a href="https://blog.einstein.ai/the-wikitext-long-term-dependency-language-modeling-dataset/">WikiText</a> <span class="citation" data-cites="merity2016pointer">(<a href="../references.html#ref-merity2016pointer" role="doc-biblioref">Merity et al. 2016</a>)</span> serve similar roles. These datasets often encompass a wide range of complexities and edge cases, pushing machine learning systems to their limits and revealing their true capabilities.</p>
<div class="no-row-height column-margin column-container"><div id="ref-krizhevsky2009learning" class="csl-entry" role="listitem">
Krizhevsky, Alex, Geoffrey Hinton, et al. 2009. <span>‚ÄúLearning Multiple Layers of Features from Tiny Images.‚Äù</span>
</div><div id="ref-rajpurkar2016squad" class="csl-entry" role="listitem">
Rajpurkar, Pranav, Jian Zhang, Konstantin Lopyrev, and Percy Liang. 2016. <span>‚ÄúSQuAD: 100,000+ Questions for Machine Comprehension of Text.‚Äù</span> <em>arXiv Preprint arXiv:1606.05250</em>, June. <a href="http://arxiv.org/abs/1606.05250v3">http://arxiv.org/abs/1606.05250v3</a>.
</div><div id="ref-wang2018glue" class="csl-entry" role="listitem">
Wang, Alex, Amanpreet Singh, Julian Michael, Felix Hill, Omer Levy, and Samuel R. Bowman. 2018. <span>‚ÄúGLUE: A Multi-Task Benchmark and Analysis Platform for Natural Language Understanding.‚Äù</span> <em>arXiv Preprint arXiv:1804.07461</em>, April. <a href="http://arxiv.org/abs/1804.07461v3">http://arxiv.org/abs/1804.07461v3</a>.
</div><div id="ref-merity2016pointer" class="csl-entry" role="listitem">
Merity, Stephen, Caiming Xiong, James Bradbury, and Richard Socher. 2016. <span>‚ÄúPointer Sentinel Mixture Models.‚Äù</span> <em>arXiv Preprint arXiv:1609.07843</em>, September. <a href="http://arxiv.org/abs/1609.07843v1">http://arxiv.org/abs/1609.07843v1</a>.
</div></div><p>The choice of dataset significantly influences benchmark results, making it crucial to select datasets that accurately represent real-world challenges. Moreover, as machine learning systems evolve, so too must these datasets to continue providing relevant and challenging evaluation scenarios.</p>
</section>
<section id="pre-defined-tasks" class="level3 page-columns page-full" data-number="12.4.2">
<h3 data-number="12.4.2" class="anchored" data-anchor-id="pre-defined-tasks"><span class="header-section-number">12.4.2</span> Pre-defined Tasks</h3>
<p>Pre-defined tasks are essential components of machine learning benchmarks, providing clear objectives against which models can be evaluated. These tasks simulate real-world problems and challenges, allowing researchers and practitioners to assess a model‚Äôs practical capabilities.</p>
<p>Tasks are typically designed to test specific aspects of machine learning systems, such as classification, regression, generation, or reasoning. For instance, in natural language processing, common tasks include sentiment analysis, machine translation, and question answering <span class="citation" data-cites="hirschberg2015advances">(<a href="../references.html#ref-hirschberg2015advances" role="doc-biblioref">Hirschberg and Manning 2015</a>)</span>. In computer vision, object detection, image segmentation, and facial recognition are frequently used benchmark tasks <span class="citation" data-cites="everingham2010pascal">(<a href="../references.html#ref-everingham2010pascal" role="doc-biblioref">Everingham et al. 2009</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-hirschberg2015advances" class="csl-entry" role="listitem">
Hirschberg, Julia, and Christopher D. Manning. 2015. <span>‚ÄúAdvances in Natural Language Processing.‚Äù</span> <em>Science</em> 349 (6245): 261‚Äì66. <a href="https://doi.org/10.1126/science.aaa8685">https://doi.org/10.1126/science.aaa8685</a>.
</div><div id="ref-everingham2010pascal" class="csl-entry" role="listitem">
Everingham, Mark, Luc Van Gool, Christopher K. I. Williams, John Winn, and Andrew Zisserman. 2009. <span>‚ÄúThe Pascal Visual Object Classes (VOC) Challenge.‚Äù</span> <em>International Journal of Computer Vision</em> 88 (2): 303‚Äì38. <a href="https://doi.org/10.1007/s11263-009-0275-4">https://doi.org/10.1007/s11263-009-0275-4</a>.
</div></div><p>The complexity and diversity of these tasks play a crucial role in the benchmark‚Äôs effectiveness. Well-designed tasks should:</p>
<ol type="1">
<li>Reflect real-world applications</li>
<li>Cover a range of difficulties</li>
<li>Test multiple aspects of model performance</li>
<li>Be clearly defined and unambiguous</li>
</ol>
<p>As machine learning advances, benchmark tasks must evolve to keep pace with emerging capabilities and challenges, ensuring they remain relevant and informative.</p>
</section>
<section id="evaluation-metrics" class="level3 page-columns page-full" data-number="12.4.3">
<h3 data-number="12.4.3" class="anchored" data-anchor-id="evaluation-metrics"><span class="header-section-number">12.4.3</span> Evaluation Metrics</h3>
<p>Evaluation metrics are quantitative measures used to assess the performance of machine learning models on specific tasks. These metrics provide objective standards for comparing different models and approaches, enabling researchers and practitioners to gauge the effectiveness of their solutions. The selection of appropriate evaluation metrics is a critical aspect of benchmark design. Metrics must align closely with the task objectives and provide meaningful insights into model performance. For classification tasks, common metrics include accuracy, precision, recall, and F1 score <span class="citation" data-cites="sokolova2009systematic">(<a href="../references.html#ref-sokolova2009systematic" role="doc-biblioref">Sokolova and Lapalme 2009</a>)</span>. These metrics offer different perspectives on a model‚Äôs ability to correctly identify and categorize data points.</p>
<div class="no-row-height column-margin column-container"><div id="ref-sokolova2009systematic" class="csl-entry" role="listitem">
Sokolova, Marina, and Guy Lapalme. 2009. <span>‚ÄúA Systematic Analysis of Performance Measures for Classification Tasks.‚Äù</span> <em>Information Processing &amp;Amp; Management</em> 45 (4): 427‚Äì37. <a href="https://doi.org/10.1016/j.ipm.2009.03.002">https://doi.org/10.1016/j.ipm.2009.03.002</a>.
</div><div id="fn5"><p><sup>5</sup>&nbsp;<strong>BLEU Score:</strong> A metric used in machine translation to measure the similarity between a machine-generated translation and human reference translations by comparing n-gram overlap.</p></div><div id="ref-papineni2002bleu" class="csl-entry" role="listitem">
Papineni, Kishore, Salim Roukos, Todd Ward, and Wei-Jing Zhu. 2001. <span>‚ÄúBLEU: A Method for Automatic Evaluation of Machine Translation.‚Äù</span> In <em>Proceedings of the 40th Annual Meeting on Association for Computational Linguistics - ACL ‚Äô02</em>, 311. Association for Computational Linguistics. <a href="https://doi.org/10.3115/1073083.1073135">https://doi.org/10.3115/1073083.1073135</a>.
</div></div><p>In regression tasks, where the goal is to predict continuous values, error-based metrics are typically employed. Mean Squared Error (MSE) and Mean Absolute Error (MAE) quantify the discrepancy between predicted and actual values, providing a measure of the model‚Äôs predictive accuracy. Certain domains require specialized metrics to capture task-specific nuances. In natural language processing, for instance, the BLEU score<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> is frequently used to evaluate machine translation quality, assessing the similarity between machine-generated translations and those produced by human experts <span class="citation" data-cites="papineni2002bleu">(<a href="../references.html#ref-papineni2002bleu" role="doc-biblioref">Papineni et al. 2001</a>)</span>.</p>
<p>It is important to note that commonly used metrics may not always capture the full complexity of model performance. For example, in imbalanced datasets, accuracy can be misleading. Researchers must consider the limitations of each metric and select those most appropriate for their specific task and data distribution. As machine learning models become more sophisticated and are increasingly deployed in real-world applications, additional performance aspects have gained prominence. Metrics related to inference time, model size, and energy efficiency are now often incorporated into benchmarks. These metrics address practical considerations of model deployment, reflecting the growing need for solutions that balance accuracy with computational efficiency.</p>
<p>No single metric can fully capture all aspects of model performance. Consequently, comprehensive benchmarks often employ a combination of metrics to provide a more holistic evaluation. This multi-faceted approach allows for a nuanced understanding of a model‚Äôs strengths and limitations across various performance dimensions.</p>
</section>
<section id="baselines-and-baseline-models" class="level3 page-columns page-full" data-number="12.4.4">
<h3 data-number="12.4.4" class="anchored" data-anchor-id="baselines-and-baseline-models"><span class="header-section-number">12.4.4</span> Baselines and Baseline Models</h3>
<p>Baselines and baseline models serve as fundamental reference points in AI benchmarks. These standard models or methods provide a basis for comparison, allowing researchers to contextualize the performance of more advanced techniques. In benchmark design, the selection of appropriate baselines is crucial. Simple models, such as linear regression for continuous predictions or logistic regression for classification tasks, often serve as initial baselines. These straightforward approaches establish a minimum performance threshold that more complex models should surpass. More sophisticated baselines may include established machine learning algorithms or architectures that have demonstrated strong performance on similar tasks. For instance, in natural language processing tasks, models like BERT<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> or GPT might serve as baselines against which newer models are compared.</p>
<div class="no-row-height column-margin column-container"><div id="fn6"><p><sup>6</sup>&nbsp;<strong>BERT (Bidirectional Encoder Representations from Transformers):</strong> A pre-trained transformer-based language model introduced by Google in 2018 that revolutionized NLP tasks by enabling bidirectional contextual understanding.</p></div></div><p>The inclusion of multiple baselines in a benchmark offers several advantages. Baselines provide a frame of reference for interpreting the results of more advanced models. By comparing new models to established baselines, researchers can quantify improvements in the field over time. Simple baselines can highlight cases where complex models may be unnecessarily sophisticated for a given task. Additionally, comparing advanced models to baselines across various datasets can reveal potential overfitting or task-specific optimizations.</p>
<p>It is important to note that as the field progresses, baselines that were once considered state-of-the-art may become outdated. Consequently, benchmark designers must periodically reassess and update their baseline models to ensure they remain relevant and challenging. By providing these points of comparison, baselines and baseline models play a critical role in the rigorous evaluation of machine learning techniques, contributing to the overall advancement of the field.</p>
</section>
<section id="hardware-and-software-specifications" class="level3" data-number="12.4.5">
<h3 data-number="12.4.5" class="anchored" data-anchor-id="hardware-and-software-specifications"><span class="header-section-number">12.4.5</span> Hardware and Software Specifications</h3>
<p>Hardware and software specifications are critical components of machine learning benchmarks, as they significantly influence model performance, training time, and reproducibility of results. These specifications provide a detailed description of the computational environment in which experiments are conducted.</p>
<p>Hardware specifications typically include:</p>
<ol type="1">
<li>Processor type and speed (e.g., CPU model, clock rate)</li>
<li>Graphics Processing Units (GPUs) or Tensor Processing Units (TPUs), if used</li>
<li>Memory capacity and type (e.g., RAM size, DDR4)</li>
<li>Storage type and capacity (e.g., SSD, HDD)</li>
<li>Network configuration, if relevant for distributed computing</li>
</ol>
<p>Software specifications generally encompass:</p>
<ol type="1">
<li>Operating system and version</li>
<li>Programming language and version</li>
<li>Machine learning frameworks and libraries (e.g., TensorFlow, PyTorch) with version numbers</li>
<li>Compiler information and optimization flags</li>
<li>Custom software or scripts used in the benchmark process</li>
</ol>
<p>The precise documentation of these specifications is crucial for several reasons. Firstly, it ensures reproducibility, allowing other researchers to replicate the benchmark environment as closely as possible. Secondly, it provides context for interpreting performance metrics, as hardware capabilities can significantly impact training and inference times. Lastly, it helps in understanding the scalability and resource requirements of different models.</p>
<p>In many cases, benchmarks may include results from multiple hardware configurations to provide a more comprehensive view of model performance across different computational environments. This approach is particularly valuable as it highlights the trade-offs between model complexity, computational resources, and performance.</p>
<p>As the field evolves, hardware and software specifications in benchmarks are increasingly including information about energy consumption and computational efficiency. This trend reflects growing concerns about the environmental impact of large-scale machine learning models and the need for sustainable AI practices.</p>
<p>By clearly defining hardware and software specifications, benchmarks contribute to the transparency and reliability of machine learning research, facilitating fair comparisons and fostering progress in the field.</p>
</section>
<section id="environmental-conditions" class="level3 page-columns page-full" data-number="12.4.6">
<h3 data-number="12.4.6" class="anchored" data-anchor-id="environmental-conditions"><span class="header-section-number">12.4.6</span> Environmental Conditions</h3>
<p>Environmental conditions in AI benchmarking refer to the physical and operational circumstances under which experiments are conducted. These conditions, while often overlooked, can significantly influence benchmark results and impact the reproducibility of experiments. Physical environmental factors include ambient temperature, humidity, air quality, and altitude. These elements can affect hardware performance in subtle but measurable ways. For instance, elevated temperatures may lead to thermal throttling<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> in processors, potentially reducing computational speed and affecting benchmark outcomes. Similarly, variations in altitude can impact cooling system efficiency and hard drive performance due to changes in air pressure.</p>
<div class="no-row-height column-margin column-container"><div id="fn7"><p><sup>7</sup>&nbsp;<strong>Thermal Throttling:</strong> A mechanism in computer processors that reduces performance to prevent overheating, often triggered by excessive computational load or inadequate cooling.</p></div></div><p>Operational environmental factors encompass the broader system context in which benchmarks are executed. This includes background processes running on the system, network conditions, and power supply stability. The presence of other active programs or services can compete for computational resources, potentially altering the performance characteristics of the model under evaluation. To ensure the validity and reproducibility of benchmark results, it is crucial to document and control these environmental conditions to the extent possible. This may involve conducting experiments in temperature-controlled environments, monitoring and reporting ambient conditions, standardizing the operational state of benchmark systems, and documenting any background processes or system loads.</p>
<p>In scenarios where controlling all environmental variables is impractical, such as in distributed or cloud-based benchmarking, it becomes essential to report these conditions in detail. This information allows other researchers to account for potential variations when interpreting or attempting to reproduce results. As machine learning models are increasingly deployed in diverse real-world environments, understanding the impact of environmental conditions on model performance becomes even more critical. This knowledge not only ensures more accurate benchmarking but also informs the development of robust models capable of consistent performance across varying operational conditions.</p>
</section>
<section id="reproducibility-rules" class="level3" data-number="12.4.7">
<h3 data-number="12.4.7" class="anchored" data-anchor-id="reproducibility-rules"><span class="header-section-number">12.4.7</span> Reproducibility Rules</h3>
<p>Reproducibility is a cornerstone of scientific research, and AI benchmarks are no exception. Reproducibility rules are guidelines and practices that ensure benchmark results can be reliably replicated by other researchers or practitioners. These rules are crucial for validating claims, building upon existing work, and advancing the field of machine learning. At the heart of reproducibility in AI benchmarks is the concept of controlled randomness. Many machine learning algorithms involve stochastic processes, such as random weight initialization or data shuffling. To address this, benchmarks often specify seed values for random number generators. By using the same seed, researchers can ensure that the ‚Äúrandom‚Äù elements of their experiments are consistent across different runs and environments.</p>
<p>Another key aspect of reproducibility is the complete documentation of hyperparameters. These are the settings that control the learning process but are not learned from the data itself. Examples include learning rates, batch sizes, and network architectures. Even small changes in hyperparameters can lead to significant differences in model performance, making their precise documentation essential. Benchmarks also typically require the preservation and sharing of training and evaluation datasets. In cases where data cannot be directly shared due to privacy or licensing concerns, benchmarks may provide detailed descriptions of data preprocessing steps and selection criteria. This allows other researchers to assemble comparable datasets or understand the characteristics of the data used in the original experiments.</p>
<p>Code availability is another critical component of reproducibility rules. Many benchmarks now require the publication of implementation code, preferably in a version-controlled repository. This code should include not only the model implementation but also scripts for data preprocessing, training, and evaluation. Some benchmarks go a step further, providing containerized environments that encapsulate all necessary dependencies and configurations. Detailed logging of the training process and intermediate results is also often mandated. This includes recording metrics at regular intervals during training, saving model checkpoints, and documenting any manual interventions or adjustments made during the experiment.</p>
<p>By adhering to these reproducibility rules, AI benchmarks foster transparency, facilitate peer review, and accelerate scientific progress. They allow the community to verify results, build upon successful approaches, and identify potential issues or limitations in proposed methods. As the field of machine learning continues to evolve rapidly, the importance of robust reproducibility practices in benchmarking cannot be overstated.</p>
</section>
<section id="result-interpretation-guidelines" class="level3 page-columns page-full" data-number="12.4.8">
<h3 data-number="12.4.8" class="anchored" data-anchor-id="result-interpretation-guidelines"><span class="header-section-number">12.4.8</span> Result Interpretation Guidelines</h3>
<p>Result interpretation guidelines are an essential component of AI benchmarks, providing a framework for understanding and contextualizing benchmark outcomes. These guidelines help researchers and practitioners draw meaningful conclusions from benchmark results, ensuring fair and informative comparisons between different models or approaches. A key aspect of result interpretation is understanding the statistical significance of performance differences. Benchmarks often specify guidelines for conducting appropriate statistical tests and reporting confidence intervals. This approach helps distinguish between meaningful improvements and variations that may be due to random chance or noise in the data.</p>
<p>Benchmarks typically provide context for interpreting metrics in light of real-world applications. For instance, a small improvement in accuracy might be considered significant for certain high-stakes applications, while in other contexts, factors like inference speed or model size might take precedence over marginal accuracy gains. It is crucial for users to understand the limitations of the benchmark itself. No benchmark can cover all possible use cases or scenarios. Guidelines often address where benchmark results are most applicable and where they might not generalize well, including discussions of dataset biases, task-specific quirks, or limitations in the evaluation metrics.</p>
<p>Many benchmarks now include guidelines for interpreting results across different performance axes. For example, a model might excel in accuracy but perform poorly in terms of computational efficiency. Interpretation guidelines help users navigate these trade-offs and select models that best fit their specific requirements and constraints. The issue of overfitting to the benchmark is frequently addressed in these guidelines. As benchmarks become widely used, there‚Äôs a risk that researchers might optimize their models specifically for the benchmark tasks, potentially at the expense of generalizability. Guidelines may suggest ways to assess a model‚Äôs performance beyond the specific benchmark tasks or caution against over-interpreting small performance gains.</p>
<p>Cross-validation<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> techniques play a crucial role in result interpretation. By evaluating models on multiple subsets of the data, researchers can gain a more robust understanding of model performance and reduce the risk of overfitting to a particular dataset split. Benchmark guidelines often specify cross-validation procedures to ensure consistent and reliable performance estimates. Result interpretation guidelines often encourage a holistic view of model performance. This may include considering factors beyond the primary metrics, such as model robustness, fairness across different demographic groups, or performance degradation over time.</p>
<div class="no-row-height column-margin column-container"><div id="fn8"><p><sup>8</sup>&nbsp;<strong>Cross-Validation:</strong> A statistical technique used in machine learning to evaluate model performance by partitioning data into multiple subsets, training on some and testing on others, to reduce overfitting.</p></div></div><p>By providing these interpretation guidelines, benchmarks not only offer a standardized way to measure performance but also promote a nuanced and contextualized understanding of machine learning model capabilities. This approach supports more informed decision-making in both research and practical applications of machine learning technologies.</p>
<p>Standardized datasets are the cornerstone of machine learning benchmarks, providing a consistent foundation for training and evaluation. These carefully curated collections of data ensure that all models are tested on equal footing, allowing for meaningful comparisons across different approaches and architectures.</p>
<p>Datasets like <a href="http://www.image-net.org/">ImageNet</a>, <a href="https://cocodataset.org/">COCO</a>, and <a href="https://www.cs.toronto.edu/~kriz/cifar.html">CIFAR-10</a> have become gold standards. For natural language processing, corpora such as <a href="https://rajpurkar.github.io/SQuAD-explorer/">SQuAD</a>, <a href="https://gluebenchmark.com/">GLUE</a>, and <a href="https://blog.einstein.ai/the-wikitext-long-term-dependency-language-modeling-dataset/">WikiText</a> serve similar roles. These datasets often encompass a wide range of complexities and edge cases, pushing machine learning systems to their limits and revealing their true capabilities.</p>
<p>The choice of dataset significantly influences benchmark results, making it crucial to select datasets that accurately represent real-world challenges. Moreover, as machine learning systems evolve, so too must these datasets to continue providing relevant and challenging evaluation scenarios.</p>
</section>
</section>
<section id="benchmarking-granularity" class="level2 page-columns page-full" data-number="12.5">
<h2 data-number="12.5" class="anchored" data-anchor-id="benchmarking-granularity"><span class="header-section-number">12.5</span> Benchmarking Granularity</h2>
<p>Machine learning system benchmarking provides a structured and systematic approach to assessing a system‚Äôs performance across various dimensions. Given the complexity of ML systems, we can dissect their performance through different levels of granularity and obtain a comprehensive view of the system‚Äôs efficiency, identify potential bottlenecks, and pinpoint areas for improvement. To this end, various types of benchmarks have evolved over the years and continue to persist.</p>
<p><a href="#fig-granularity" class="quarto-xref">Figure&nbsp;<span>12.1</span></a> shows the different layers of granularity of an ML system. At the application level, end-to-end benchmarks assess the overall system performance, considering factors like data preprocessing, model training, and inference. While at the model layer, benchmarks focus on assessing the efficiency and accuracy of specific models. This includes evaluating how well models generalize to new data and their computational efficiency during training and inference. Furthermore, benchmarking can extend to hardware and software infrastructure, examining the performance of individual components like GPUs or TPUs.</p>
<div id="fig-granularity" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-granularity-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/png/end2end.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Figure&nbsp;12.1: ML system granularity."><img src="images/png/end2end.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-granularity-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;12.1: ML system granularity.
</figcaption>
</figure>
</div>
<section id="micro-benchmarks" class="level3" data-number="12.5.1">
<h3 data-number="12.5.1" class="anchored" data-anchor-id="micro-benchmarks"><span class="header-section-number">12.5.1</span> Micro Benchmarks</h3>
<p>Micro-benchmarks are specialized evaluation tools that assess distinct components or specific operations within a broader machine learning process. These benchmarks isolate individual tasks to provide detailed insights into the computational demands of particular system elements, from neural network layers to optimization techniques to activation functions. For example, micro-benchmarks might measure the time required to execute a convolutional layer in a deep learning model or evaluate the speed of data preprocessing operations that prepare training data.</p>
<p>A key area of micro-benchmarking focuses on tensor operations, which are the computational foundation of deep learning. Libraries like <a href="https://developer.nvidia.com/cudnn">cuDNN</a> by NVIDIA provide benchmarks for measuring fundamental computations such as convolutions and matrix multiplications across different hardware configurations. These measurements help developers understand how their hardware handles the core mathematical operations that dominate ML workloads.</p>
<p>Micro-benchmarks also examine activation functions and neural network layers in isolation. This includes measuring the performance of various activation functions like ReLU, Sigmoid, and Tanh under controlled conditions, as well as evaluating the computational efficiency of distinct neural network components such as LSTM cells or Transformer blocks when processing standardized inputs.</p>
<p><a href="https://github.com/baidu-research/DeepBench">DeepBench</a>, developed by Baidu, was one of the first to demonstrate the value of comprehensive micro-benchmarking. It evaluates these fundamental operations across different hardware platforms, providing detailed performance data that helps developers optimize their deep learning implementations. By isolating and measuring individual operations, DeepBench enables precise comparison of hardware platforms and identification of potential performance bottlenecks.</p>
<div id="exr-cuda" class="callout callout-style-default callout-caution callout-titled" title="Benchmarking Tensor Operations">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-6-contents" aria-controls="callout-6" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise&nbsp;12.1: Benchmarking Tensor Operations
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-6" class="callout-6-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Ever wonder how your image filters get so fast? Special libraries like cuDNN supercharge those calculations on certain hardware. In this Colab, we‚Äôll use cuDNN with PyTorch to speed up image filtering. Think of it as a tiny benchmark, showing how the right software can unlock your GPU‚Äôs power!</p>
<p><a href="https://colab.research.google.com/github/RyanHartzell/cudnn-image-filtering/blob/master/notebooks/CuDNN%20Image%20Filtering%20Tutorial%20Using%20PyTorch.ipynb#scrollTo=1sWeXdYsATrr"><img src="https://colab.research.google.com/assets/colab-badge.png" class="img-fluid"></a></p>
</div>
</div>
</div>
</section>
<section id="macro-benchmarks" class="level3 page-columns page-full" data-number="12.5.2">
<h3 data-number="12.5.2" class="anchored" data-anchor-id="macro-benchmarks"><span class="header-section-number">12.5.2</span> Macro Benchmarks</h3>
<p>While micro-benchmarks examine individual operations like tensor computations and layer performance, macro benchmarks evaluate complete machine learning models. This shift from component-level to model-level assessment provides insights into how architectural choices and component interactions affect overall model behavior. For instance, while micro-benchmarks might show optimal performance for individual convolutional layers, macro-benchmarks reveal how these layers work together within a complete convolutional neural network.</p>
<p>Macro-benchmarks measure multiple performance dimensions that emerge only at the model level. These include prediction accuracy, which shows how well the model generalizes to new data; memory consumption patterns across different batch sizes and sequence lengths; throughput under varying computational loads; and latency across different hardware configurations. Understanding these metrics helps developers make informed decisions about model architecture, optimization strategies, and deployment configurations.</p>
<p>The assessment of complete models occurs under standardized conditions using established datasets and tasks. For example, computer vision models might be evaluated on <a href="https://www.image-net.org/">ImageNet</a>, measuring both computational efficiency and prediction accuracy. Natural language processing models might be assessed on translation tasks, examining how they balance quality and speed across different language pairs.</p>
<p>Several industry-standard benchmarks enable consistent model evaluation across platforms. <a href="https://github.com/mlcommons/inference">MLPerf Inference</a> provides comprehensive testing suites adapted for different computational environments <span class="citation" data-cites="reddi2020mlperf">(<a href="../references.html#ref-reddi2020mlperf" role="doc-biblioref">Reddi et al. 2019</a>)</span>. <a href="https://github.com/mlcommons/mobile_app_open">MLPerf Mobile</a> focuses on mobile device constraints <span class="citation" data-cites="janapa2022mlperf">(<a href="../references.html#ref-janapa2022mlperf" role="doc-biblioref">Janapa Reddi et al. 2022</a>)</span>, while <a href="https://github.com/mlcommons/tiny">MLPerf Tiny</a> addresses microcontroller deployments <span class="citation" data-cites="banbury2021mlperf">(<a href="../references.html#ref-banbury2021mlperf" role="doc-biblioref">Banbury et al. 2021</a>)</span>. For embedded systems, <a href="https://github.com/eembc/mlmark">EEMBC‚Äôs MLMark</a><a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> emphasizes both performance and power efficiency. The <a href="https://ai-benchmark.com/">AI-Benchmark</a> suite specializes in mobile platforms, evaluating models across diverse tasks from image recognition to face parsing.</p>
<div class="no-row-height column-margin column-container"><div id="ref-janapa2022mlperf" class="csl-entry" role="listitem">
Janapa Reddi, Vijay, David Kanter, Peter Mattson, Jared Duke, Thai Nguyen, Ramesh Chukka, Ken Shiring, et al. 2022. <span>‚ÄúMlperf Mobile Inference Benchmark: An Industry-Standard Open-Source Machine Learning Benchmark for on-Device Ai.‚Äù</span> <em>Proceedings of Machine Learning and Systems</em> 4: 352‚Äì69.
</div><div id="ref-banbury2021mlperf" class="csl-entry" role="listitem">
Banbury, Colby, Vijay Janapa Reddi, Peter Torelli, Jeremy Holleman, Nat Jeffries, Csaba Kiraly, Pietro Montino, et al. 2021. <span>‚ÄúMLPerf Tiny Benchmark.‚Äù</span> <em>arXiv Preprint arXiv:2106.07597</em>, June. <a href="http://arxiv.org/abs/2106.07597v4">http://arxiv.org/abs/2106.07597v4</a>.
</div><div id="fn9"><p><sup>9</sup>&nbsp;<strong>EEMBC (Embedded Microprocessor Benchmark Consortium):</strong> A nonprofit industry group that develops benchmarks for embedded systems, including MLMark for evaluating machine learning workloads.</p></div></div></section>
<section id="end-to-end-benchmarks" class="level3" data-number="12.5.3">
<h3 data-number="12.5.3" class="anchored" data-anchor-id="end-to-end-benchmarks"><span class="header-section-number">12.5.3</span> End-to-end Benchmarks</h3>
<p>End-to-end benchmarks provide an all-inclusive evaluation that extends beyond the boundaries of the ML model itself. Rather than focusing solely on a machine learning model‚Äôs computational efficiency or accuracy, these benchmarks encompass the entire pipeline of an AI system. This includes initial ETL (Extract-Transform-Load) or ELT (Extract-Load-Transform) data processing, the core model‚Äôs performance, post-processing of results, and critical infrastructure components like storage and network systems.</p>
<p>Data processing is the foundation of all AI systems, transforming raw data into a format suitable for model training or inference. In ETL pipelines, data undergoes extraction from source systems, transformation through cleaning and feature engineering, and loading into model-ready formats. These preprocessing steps‚Äô efficiency, scalability, and accuracy significantly impact overall system performance. End-to-end benchmarks must assess standardized datasets through these pipelines to ensure data preparation doesn‚Äôt become a bottleneck.</p>
<p>The post-processing phase plays an equally important role. This involves interpreting the model‚Äôs raw outputs, converting scores into meaningful categories, filtering results based on predefined tasks, or integrating with other systems. For instance, a computer vision system might need to post-process detection boundaries, apply confidence thresholds, and format results for downstream applications. In real-world deployments, this phase proves crucial for delivering actionable insights.</p>
<p>Beyond core AI operations, infrastructure components heavily influence overall performance and user experience. Storage solutions, whether cloud-based, on-premises, or hybrid, can significantly impact data retrieval and storage times, especially with vast AI datasets. Network interactions, vital for distributed systems, can become performance bottlenecks if not optimized. End-to-end benchmarks must evaluate these components under specified environmental conditions to ensure reproducible measurements of the entire system.</p>
<p>To date, there are no public, end-to-end benchmarks that fully account for data storage, network, and compute performance. While MLPerf Training and Inference approach end-to-end evaluation, they primarily focus on model performance rather than real-world deployment scenarios. Nonetheless, they provide valuable baseline metrics for assessing AI system capabilities.</p>
<p>Given the inherent specificity of end-to-end benchmarking, organizations typically perform these evaluations internally by instrumenting production deployments. This allows engineers to develop result interpretation guidelines based on realistic workloads, but given the sensitivity and specificity of the information, these benchmarks rarely appear in public settings.</p>
</section>
<section id="the-trade-offs" class="level3" data-number="12.5.4">
<h3 data-number="12.5.4" class="anchored" data-anchor-id="the-trade-offs"><span class="header-section-number">12.5.4</span> The Trade-offs</h3>
<p>As shown in <a href="#tbl-benchmark-comparison" class="quarto-xref">Table&nbsp;<span>12.1</span></a>, different challenges emerge at different stages of an AI system‚Äôs lifecycle. Each benchmarking approach provides unique insights: micro-benchmarks help engineers optimize specific components like GPU kernel implementations or data loading operations, macro-benchmarks guide model architecture decisions and algorithm selection, while end-to-end benchmarks reveal system-level bottlenecks in production environments.</p>
<div id="tbl-benchmark-comparison" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-benchmark-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;12.1: Comparison of benchmarking approaches across different dimensions. Each approach offers distinct advantages and focuses on different aspects of ML system evaluation.
</figcaption>
<div aria-describedby="tbl-benchmark-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 31%">
<col style="width: 30%">
<col style="width: 30%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Component</th>
<th style="text-align: left;">Micro Benchmarks</th>
<th style="text-align: left;">Macro Benchmarks</th>
<th style="text-align: left;">End-to-End Benchmarks</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Focus</td>
<td style="text-align: left;">Individual operations</td>
<td style="text-align: left;">Complete models</td>
<td style="text-align: left;">Full system pipeline</td>
</tr>
<tr class="even">
<td style="text-align: left;">Scope</td>
<td style="text-align: left;">Tensor ops, layers, activations</td>
<td style="text-align: left;">Model architecture, training, inference</td>
<td style="text-align: left;">ETL, model, infrastructure</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Example</td>
<td style="text-align: left;">Conv layer performance on cuDNN</td>
<td style="text-align: left;">ResNet-50 on ImageNet</td>
<td style="text-align: left;">Production recommendation system</td>
</tr>
<tr class="even">
<td style="text-align: left;">Advantages</td>
<td style="text-align: left;">Precise bottleneck identification, Component optimization</td>
<td style="text-align: left;">Model architecture comparison, Standardized evaluation</td>
<td style="text-align: left;">Realistic performance assessment, System-wide insights</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Challenges</td>
<td style="text-align: left;">May miss interaction effects</td>
<td style="text-align: left;">Limited infrastructure insights</td>
<td style="text-align: left;">Complex to standardize, Often proprietary</td>
</tr>
<tr class="even">
<td style="text-align: left;">Typical Use</td>
<td style="text-align: left;">Hardware selection, Operation optimization</td>
<td style="text-align: left;">Model selection, Research comparison</td>
<td style="text-align: left;">Production system evaluation</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Component interaction often produces unexpected behaviors. For example, while micro-benchmarks might show excellent performance for individual convolutional layers, and macro-benchmarks might demonstrate strong accuracy for the complete model, end-to-end evaluation could reveal that data preprocessing creates unexpected bottlenecks during high-traffic periods. These system-level insights often remain hidden when components undergo isolated testing.</p>
<p>Component interaction often produces unexpected behaviors. For example, while micro-benchmarks might show excellent performance for individual convolutional layers, and macro-benchmarks might demonstrate strong accuracy for the complete model, end-to-end evaluation could reveal that data preprocessing creates unexpected bottlenecks during high-traffic periods. These system-level insights often remain hidden when components undergo isolated testing.</p>
</section>
</section>
<section id="training-benchmarks" class="level2 page-columns page-full" data-number="12.6">
<h2 data-number="12.6" class="anchored" data-anchor-id="training-benchmarks"><span class="header-section-number">12.6</span> Training Benchmarks</h2>
<p>Training benchmarks provide a systematic approach to evaluating the efficiency, scalability, and resource demands of the training phase. They allow practitioners to assess how different design choices‚Äîsuch as model architectures, data loading mechanisms, hardware configurations, and distributed training strategies‚Äîimpact performance. These benchmarks are particularly vital as machine learning systems grow in scale, requiring billions of parameters, terabytes of data, and distributed computing environments.</p>
<p>For instance, large-scale models like <a href="https://arxiv.org/abs/2005.14165">OpenAI‚Äôs GPT-3</a> <span class="citation" data-cites="brown2020language">(<a href="../references.html#ref-brown2020language" role="doc-biblioref">Brown et al. 2020</a>)</span>, which consists of 175 billion parameters trained on 45 terabytes of data, highlight the immense computational demands of training. Benchmarks enable systematic evaluation of the underlying systems to ensure that hardware and software configurations can meet these demands efficiently.</p>
<div class="no-row-height column-margin column-container"></div><div class="callout callout-style-default callout-note callout-titled" title="Definition of ML Training Benchmarks">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition of ML Training Benchmarks
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>ML Training Benchmarks</strong> are standardized tools used to evaluate the <em>performance</em>, <em>efficiency</em>, and <em>scalability</em> of machine learning systems during the <em>training phase</em>. These benchmarks measure key <em>system-level metrics</em>, such as <em>time-to-accuracy</em>, <em>throughput</em>, <em>resource utilization</em>, and <em>energy consumption</em>. By providing a structured evaluation framework, training benchmarks enable <em>fair comparisons</em> across <em>hardware platforms</em>, <em>software frameworks</em>, and <em>distributed computing setups</em>. They help identify <em>bottlenecks</em> and optimize <em>training processes</em> for <em>large-scale machine learning models</em>, ensuring that computational resources are used effectively.</p>
</div>
</div>
<p>Efficient data storage and delivery during training also play a major role in the training process. For instance, in a machine learning model that predicts bounding boxes around objects in an image, thousands of images may be required. However, loading an entire image dataset into memory is typically infeasible, so practitioners rely on data loaders from ML frameworks. Successful model training depends on timely and efficient data delivery, making it essential to benchmark tools like data pipelines, preprocessing speed, and storage retrieval times to understand their impact on training performance.</p>
<p>Hardware selection is another key factor in training machine learning systems, as it can significantly impact training time. Training benchmarks evaluate CPU, GPU, memory, and network utilization during the training phase to guide system optimizations. Understanding how resources are used is essential: Are GPUs being fully leveraged? Is there unnecessary memory overhead? Benchmarks can uncover bottlenecks or inefficiencies in resource utilization, leading to cost savings and performance improvements.</p>
<p>In many cases, using a single hardware accelerator, such as a single GPU, is insufficient to meet the computational demands of large-scale model training. Machine learning models are often trained in data centers with multiple GPUs or TPUs, where distributed computing enables parallel processing across nodes. Training benchmarks assess how efficiently the system scales across multiple nodes, manages data sharding, and handles challenges like node failures or drop-offs during training.</p>
<p>To illustrate these benchmarking principles, we will reference <a href="https://mlcommons.org/benchmarks/training/">MLPerf Training</a> throughout this section. Briefly, MLPerf is an industry-standard benchmark suite designed to evaluate machine learning system performance. It provides standardized tests for training and inference across a range of deep learning workloads, including image classification, language modeling, object detection, and recommendation systems.</p>
<section id="purpose-1" class="level3 page-columns page-full" data-number="12.6.1">
<h3 data-number="12.6.1" class="anchored" data-anchor-id="purpose-1"><span class="header-section-number">12.6.1</span> Purpose</h3>
<p>From a systems perspective, training machine learning models is a computationally intensive process that requires careful optimization of resources. Training benchmarks serve as essential tools for evaluating system efficiency, identifying bottlenecks, and ensuring that machine learning systems can scale effectively. They provide a standardized approach to measuring how various system components‚Äîsuch as hardware accelerators, memory, storage, and network infrastructure‚Äîaffect training performance.</p>
<p>By systematically evaluating these factors, training benchmarks enable researchers and engineers to push the state-of-the-art, optimize configurations, improve scalability, and reduce overall resource consumption. As shown in <a href="#fig-mlperf-training-improve" class="quarto-xref">Figure&nbsp;<span>12.2</span></a>, the performance improvements in progressive versions of MLPerf Training benchmarks have consistently outpaced Moore‚Äôs Law‚Äîdemonstrating that what gets measured gets improved. Using standardized benchmarking trends allows us to rigorously showcase the rapid evolution of ML computing.</p>
<div id="fig-mlperf-training-improve" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-mlperf-training-improve-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/png/mlperf_training_06-12-2024.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="Figure&nbsp;12.2: MLPerf Training performance trends. Source: @tschand2024mlperf."><img src="images/png/mlperf_training_06-12-2024.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-mlperf-training-improve-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;12.2: MLPerf Training performance trends. Source: <span class="citation" data-cites="tschand2024mlperf">Tschand et al. (<a href="../references.html#ref-tschand2024mlperf" role="doc-biblioref">2024</a>)</span>.
</figcaption>
<div class="no-row-height column-margin column-container"></div></figure>
</div>
<section id="why-training-benchmarks-matter-for-ml-systems" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="why-training-benchmarks-matter-for-ml-systems">Why Training Benchmarks Matter for ML Systems</h4>
<p>As machine learning models grow in complexity, training becomes increasingly demanding in terms of compute power, memory, and data storage. The ability to measure and compare training efficiency is critical to ensuring that systems can effectively handle large-scale workloads. Training benchmarks provide a structured methodology for assessing performance across different hardware platforms, software frameworks, and optimization techniques.</p>
<p>One of the fundamental challenges in training machine learning models is the efficient allocation of computational resources. Training a transformer-based model such as GPT-3, which consists of 175 billion parameters and requires processing terabytes of data, places an enormous burden on modern computing infrastructure. Without standardized benchmarks, it becomes difficult to determine whether a system is fully utilizing its resources or whether inefficiencies‚Äîsuch as slow data loading, underutilized accelerators, or excessive memory overhead‚Äîare limiting performance.</p>
<p>Training benchmarks help uncover such inefficiencies by measuring key performance indicators, including system throughput, time-to-accuracy, and hardware utilization. These benchmarks allow practitioners to analyze whether GPUs, TPUs, and CPUs are being leveraged effectively or whether specific bottlenecks, such as memory bandwidth constraints or inefficient data pipelines, are reducing overall system performance. For example, a system using TF32<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> precision1 may achieve higher throughput than one using FP32, but if TF32 introduces numerical instability that increases the number of iterations required to reach the target accuracy, the overall training time may be longer. By providing insights into these factors, benchmarks support the design of more efficient training workflows that maximize hardware potential while minimizing unnecessary computation.</p>
<div class="no-row-height column-margin column-container"><div id="fn10"><p><sup>10</sup>&nbsp;<strong>TensorFloat-32 (TF32):</strong> Introduced in NVIDIA Ampere GPUs, provides higher throughput than FP32 but may introduce numerical stability issues affecting model convergence.</p></div></div></section>
<section id="optimizing-hardware-software-configurations" class="level4">
<h4 class="anchored" data-anchor-id="optimizing-hardware-software-configurations">Optimizing Hardware &amp; Software Configurations</h4>
<p>The performance of machine learning training is heavily influenced by the choice of hardware and software. Training benchmarks guide system designers in selecting optimal configurations by measuring how different architectures‚Äîsuch as GPUs, TPUs, and emerging AI accelerators‚Äîhandle computational workloads. These benchmarks also evaluate how well deep learning frameworks, such as TensorFlow and PyTorch, optimize performance across different hardware setups.</p>
<p>For example, the MLPerf Training benchmark suite is widely used to compare the performance of different accelerator architectures on tasks such as image classification, natural language processing, and recommendation systems. By running standardized benchmarks across multiple hardware configurations, engineers can determine whether certain accelerators are better suited for specific training workloads. This information is particularly valuable in large-scale data centers and cloud computing environments, where selecting the right combination of hardware and software can lead to significant performance gains and cost savings.</p>
<p>Beyond hardware selection, training benchmarks also inform software optimizations. Machine learning frameworks implement various low-level optimizations‚Äîsuch as mixed-precision training, memory-efficient data loading, and distributed training strategies‚Äîthat can significantly impact system performance. Benchmarks help quantify the impact of these optimizations, ensuring that training systems are configured for maximum efficiency.</p>
</section>
<section id="scalability-efficiency" class="level4">
<h4 class="anchored" data-anchor-id="scalability-efficiency">Scalability &amp; Efficiency</h4>
<p>As machine learning workloads continue to grow, efficient scaling across distributed computing environments has become a key concern. Many modern deep learning models are trained across multiple GPUs or TPUs, requiring efficient parallelization strategies to ensure that additional computing resources lead to meaningful performance improvements. Training benchmarks measure how well a system scales by evaluating system throughput, memory efficiency, and overall training time as additional computational resources are introduced.</p>
<p>Effective scaling is not always guaranteed. While adding more GPUs or TPUs should, in theory, reduce training time, issues such as communication overhead, data synchronization latency, and memory bottlenecks can limit scaling efficiency. Training benchmarks help identify these challenges by quantifying how performance scales with increasing hardware resources. A well-designed system should exhibit near-linear scaling, where doubling the number of GPUs results in a near-halving of training time. However, real-world inefficiencies often prevent perfect scaling, and benchmarks provide the necessary insights to optimize system design accordingly.</p>
<p>Another crucial factor in training efficiency is time-to-accuracy, which measures how quickly a model reaches a target accuracy level. Achieving faster convergence with fewer computational resources is a key goal in training optimization, and benchmarks help compare different training methodologies to determine which approaches strike the best balance between speed and accuracy. By leveraging training benchmarks, system designers can assess whether their infrastructure is capable of handling large-scale workloads efficiently while maintaining training stability and accuracy.</p>
</section>
<section id="cost-energy-considerations" class="level4">
<h4 class="anchored" data-anchor-id="cost-energy-considerations">Cost &amp; Energy Considerations</h4>
<p>The computational cost of training large-scale models has risen sharply in recent years, making cost-efficiency a critical consideration. Training a model such as GPT-3 can require millions of dollars in cloud computing resources, making it imperative to evaluate cost-effectiveness across different hardware and software configurations. Training benchmarks provide a means to quantify the cost per training run by analyzing computational expenses, cloud pricing models, and energy consumption.</p>
<p>Beyond financial cost, energy efficiency has become an increasingly important metric. Large-scale training runs consume vast amounts of electricity, contributing to significant carbon emissions. Benchmarks help evaluate energy efficiency by measuring power consumption per unit of training progress, allowing organizations to identify sustainable approaches to AI development.</p>
<p>For example, MLPerf includes an energy benchmarking component that tracks the power consumption of various hardware accelerators during training. This allows researchers to compare different computing platforms not only in terms of raw performance but also in terms of their environmental impact. By integrating energy efficiency metrics into benchmarking studies, organizations can design AI systems that balance computational power with sustainability goals.</p>
</section>
<section id="fair-comparisons-across-ml-systems" class="level4">
<h4 class="anchored" data-anchor-id="fair-comparisons-across-ml-systems">Fair Comparisons Across ML Systems</h4>
<p>One of the primary functions of training benchmarks is to establish a standardized framework for comparing ML systems. Given the wide variety of hardware architectures, deep learning frameworks, and optimization techniques available today, ensuring fair and reproducible comparisons is essential.</p>
<p>Standardized benchmarks provide a common evaluation methodology, allowing researchers and practitioners to assess how different training systems perform under identical conditions. For example, MLPerf Training benchmarks enable vendor-neutral comparisons by defining strict evaluation criteria for deep learning tasks such as image classification, language modeling, and recommendation systems. This ensures that performance results are meaningful and not skewed by differences in dataset preprocessing, hyperparameter tuning, or implementation details.</p>
<p>Furthermore, reproducibility is a major concern in machine learning research. Training benchmarks help address this challenge by providing clearly defined methodologies for performance evaluation, ensuring that results can be consistently reproduced across different computing environments. By adhering to standardized benchmarks, researchers can make informed decisions when selecting hardware, software, and training methodologies, ultimately driving progress in AI systems development.</p>
</section>
</section>
<section id="metrics" class="level3" data-number="12.6.2">
<h3 data-number="12.6.2" class="anchored" data-anchor-id="metrics"><span class="header-section-number">12.6.2</span> Metrics</h3>
<p>Evaluating the performance of machine learning training requires a set of well-defined metrics that go beyond conventional algorithmic measures. From a systems perspective, training benchmarks assess how efficiently and effectively a machine learning model can be trained to a predefined accuracy threshold. Metrics such as throughput, scalability, and energy efficiency are only meaningful in relation to whether the model successfully reaches its target accuracy. Without this constraint, optimizing for raw speed or resource utilization may lead to misleading conclusions.</p>
<p>Training benchmarks, such as MLPerf Training, define specific accuracy targets for different machine learning tasks, ensuring that performance measurements are made in a fair and reproducible manner. A system that trains a model quickly but fails to reach the required accuracy is not considered a valid benchmark result. Conversely, a system that achieves the best possible accuracy but takes an excessive amount of time or resources may not be practically useful. Effective benchmarking requires balancing speed, efficiency, and accuracy convergence.</p>
<section id="training-time-and-throughput" class="level4">
<h4 class="anchored" data-anchor-id="training-time-and-throughput">Training Time and Throughput</h4>
<p>One of the fundamental metrics for evaluating training efficiency is the time required to reach a predefined accuracy threshold. Training time (<span class="math inline">\(T_{\text{train}}\)</span>) measures how long a model takes to converge to an acceptable performance level, reflecting the overall computational efficiency of the system. It is formally defined as:</p>
<p><span class="math display">\[
T_{\text{train}} = \arg\min_{t} \{ \text{accuracy}(t) \geq \text{target accuracy} \}
\]</span></p>
<p>This metric ensures that benchmarking focuses on how quickly and effectively a system can achieve meaningful results.</p>
<p>Throughput, often expressed as the number of training samples processed per second, provides an additional measure of system performance:</p>
<p><span class="math display">\[
T = \frac{N_{\text{samples}}}{T_{\text{train}}}
\]</span></p>
<p>where <span class="math inline">\(N_{\text{samples}}\)</span> is the total number of training samples processed. However, throughput alone does not guarantee meaningful results, as a model may process a large number of samples quickly without necessarily reaching the desired accuracy.</p>
<p>For example, in MLPerf Training, the benchmark for ResNet-50 may require reaching an accuracy target like 75.9% top-1 on the ImageNet dataset. A system that processes 10,000 images per second but fails to achieve this accuracy is not considered a valid benchmark result, while a system that processes fewer images per second but converges efficiently is preferable. This highlights why throughput must always be evaluated in relation to time-to-accuracy rather than as an independent performance measure.</p>
</section>
<section id="scalability-and-parallelism" class="level4">
<h4 class="anchored" data-anchor-id="scalability-and-parallelism">Scalability and Parallelism</h4>
<p>As machine learning models increase in size, training workloads often require distributed computing across multiple processors or accelerators. Scalability measures how effectively training performance improves as more computational resources are added. An ideal system should exhibit near-linear scaling, where doubling the number of GPUs or TPUs leads to a proportional reduction in training time. However, real-world performance is often constrained by factors such as communication overhead, memory bandwidth limitations, and inefficiencies in parallelization strategies.</p>
<p>When training large-scale models such as GPT-3, OpenAI employed thousands of GPUs in a distributed training setup. While increasing the number of GPUs provided more raw computational power, the performance improvements were not perfectly linear due to network communication overhead between nodes. Benchmarks such as MLPerf quantify how well a system scales across multiple GPUs, providing insights into where inefficiencies arise in distributed training.</p>
<p>Parallelism in training is categorized into data parallelism, model parallelism, and pipeline parallelism, each presenting distinct challenges. Data parallelism, the most commonly used strategy, involves splitting the training dataset across multiple compute nodes. The efficiency of this approach depends on synchronization mechanisms and gradient communication overhead. In contrast, model parallelism partitions the neural network itself, requiring efficient coordination between processors. Benchmarks evaluate how well a system manages these parallelism strategies without degrading accuracy convergence.</p>
</section>
<section id="resource-utilization" class="level4">
<h4 class="anchored" data-anchor-id="resource-utilization">Resource Utilization</h4>
<p>The efficiency of machine learning training depends not only on speed and scalability but also on how well available hardware resources are utilized. Compute utilization measures the extent to which processing units, such as GPUs or TPUs, are actively engaged during training. Low utilization may indicate bottlenecks in data movement, memory access, or inefficient workload scheduling.</p>
<p>For instance, when training BERT on a TPU cluster, researchers observed that input pipeline inefficiencies were limiting overall throughput. Although the TPUs had high raw compute power, the system was not keeping them fully utilized due to slow data retrieval from storage. By profiling the resource utilization, engineers identified the bottleneck and optimized the input pipeline using TFRecord and data prefetching, leading to improved performance.</p>
<p>Memory bandwidth is another critical factor, as deep learning models require frequent access to large volumes of data during training. If memory bandwidth becomes a limiting factor, increasing compute power alone will not improve training speed. Benchmarks assess how well models leverage available memory, ensuring that data transfer rates between storage, main memory, and processing units do not become performance bottlenecks.</p>
<p>I/O performance also plays a significant role in training efficiency, particularly when working with large datasets that cannot fit entirely in memory. Benchmarks evaluate the efficiency of data loading pipelines, including preprocessing operations, caching mechanisms, and storage retrieval speeds. Systems that fail to optimize data loading can experience significant slowdowns, regardless of computational power.</p>
</section>
<section id="energy-efficiency-and-cost" class="level4">
<h4 class="anchored" data-anchor-id="energy-efficiency-and-cost">Energy Efficiency and Cost</h4>
<p>Training large-scale machine learning models requires substantial computational resources, leading to significant energy consumption and financial costs. Energy efficiency metrics quantify the power usage of training workloads, helping identify systems that optimize computational efficiency while minimizing energy waste. The increasing focus on sustainability has led to the inclusion of energy-based benchmarks, such as those in MLPerf Training, which measure power consumption per training run.</p>
<p>Training GPT-3 was estimated to consume 1,287 MWh of electricity, which is comparable to the yearly energy usage of 100 US households. If a system can achieve the same accuracy with fewer training iterations, it directly reduces energy consumption. Energy-aware benchmarks help guide the development of hardware and training strategies that optimize power efficiency while maintaining accuracy targets.</p>
<p>Cost considerations extend beyond electricity usage to include hardware expenses, cloud computing costs, and infrastructure maintenance. Training benchmarks provide insights into the cost-effectiveness of different hardware and software configurations by measuring training time in relation to resource expenditure. Organizations can use these benchmarks to balance performance and budget constraints when selecting training infrastructure.</p>
</section>
<section id="fault-tolerance-and-robustness" class="level4">
<h4 class="anchored" data-anchor-id="fault-tolerance-and-robustness">Fault Tolerance and Robustness</h4>
<p>Training workloads often run for extended periods, sometimes spanning days or weeks, making fault tolerance an essential consideration. A robust system must be capable of handling unexpected failures, including hardware malfunctions, network disruptions, and memory errors, without compromising accuracy convergence.</p>
<p>In large-scale cloud-based training, node failures are common due to hardware instability. If a GPU node in a distributed cluster fails, training must continue without corrupting the model. MLPerf Training includes evaluations of fault-tolerant training strategies, such as checkpointing, where models periodically save their progress. This ensures that failures do not require restarting the entire training process.</p>
</section>
<section id="reproducibility-and-standardization" class="level4">
<h4 class="anchored" data-anchor-id="reproducibility-and-standardization">Reproducibility and Standardization</h4>
<p>For benchmarks to be meaningful, results must be reproducible across different runs, hardware platforms, and software frameworks. Variability in training results can arise due to stochastic processes, hardware differences, and software optimizations. Ensuring reproducibility requires standardizing evaluation protocols, controlling for randomness in model initialization, and enforcing consistency in dataset processing.</p>
<p>MLPerf Training enforces strict reproducibility requirements, ensuring that accuracy results remain stable across multiple training runs. When NVIDIA submitted benchmark results for MLPerf, they had to demonstrate that their ResNet-50 ImageNet training time remained consistent across different GPUs. This ensures that benchmarks measure true system performance rather than noise from randomness.</p>
</section>
</section>
<section id="evaluating-training-performance" class="level3" data-number="12.6.3">
<h3 data-number="12.6.3" class="anchored" data-anchor-id="evaluating-training-performance"><span class="header-section-number">12.6.3</span> Evaluating Training Performance</h3>
<p>There are many different ways to analyze and evaluate system performance in machine learning training. The choice of benchmarking metrics depends on the specific goals of the evaluation‚Äîwhether the focus is on optimizing speed, improving resource utilization, enhancing energy efficiency, or ensuring fault tolerance. A well-rounded benchmarking approach must take all these factors into account while ensuring that models reach their intended accuracy targets in a reproducible and scalable manner.</p>
<p><a href="#tbl-training-metrics" class="quarto-xref">Table&nbsp;<span>12.2</span></a> provides a structured overview of key system-level training metrics, highlighting different evaluation dimensions and their relevance to training benchmarks. This table serves as a reference for how system performance can be analyzed in the context of machine learning training.</p>
<div id="tbl-training-metrics" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-training-metrics-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;12.2: Training benchmark metrics and evaluation dimensions.
</figcaption>
<div aria-describedby="tbl-training-metrics-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 17%">
<col style="width: 54%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Category</th>
<th style="text-align: left;">Key Metrics</th>
<th style="text-align: left;">Example Benchmark Use</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Training Time and Throughput</td>
<td style="text-align: left;">Time-to-accuracy (seconds, minutes, hours); Throughput (samples/sec)</td>
<td style="text-align: left;">Comparing training speed across different GPU architectures</td>
</tr>
<tr class="even">
<td style="text-align: left;">Scalability and Parallelism</td>
<td style="text-align: left;">Scaling efficiency (% of ideal speedup); Communication overhead (latency, bandwidth)</td>
<td style="text-align: left;">Analyzing distributed training performance for large models</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Resource Utilization</td>
<td style="text-align: left;">Compute utilization (% GPU/TPU usage); Memory bandwidth (GB/s); I/O efficiency (data loading speed)</td>
<td style="text-align: left;">Optimizing data pipelines to improve GPU utilization</td>
</tr>
<tr class="even">
<td style="text-align: left;">Energy Efficiency and Cost</td>
<td style="text-align: left;">Energy consumption per run (MWh, kWh); Performance per watt (TOPS/W)</td>
<td style="text-align: left;">Evaluating energy-efficient training strategies</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Fault Tolerance and Robustness</td>
<td style="text-align: left;">Checkpoint overhead (time per save); Recovery success rate (%)</td>
<td style="text-align: left;">Assessing failure recovery in cloud-based training systems</td>
</tr>
<tr class="even">
<td style="text-align: left;">Reproducibility and Standardization</td>
<td style="text-align: left;">Variance across runs (% difference in accuracy, training time); Framework consistency (TensorFlow vs.&nbsp;PyTorch vs.&nbsp;JAX)</td>
<td style="text-align: left;">Ensuring consistency in benchmark results across hardware</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<section id="common-pitfalls-in-training-benchmarks" class="level4">
<h4 class="anchored" data-anchor-id="common-pitfalls-in-training-benchmarks">Common Pitfalls in Training Benchmarks</h4>
<p>Despite the availability of well-defined benchmarking methodologies, certain misconceptions and flawed evaluation practices often lead to misleading conclusions. Understanding these pitfalls is important for interpreting benchmark results correctly.</p>
<section id="focusing-only-on-raw-throughput" class="level5">
<h5 class="anchored" data-anchor-id="focusing-only-on-raw-throughput">Focusing only on raw throughput</h5>
<p>A common mistake in training benchmarks is assuming that higher throughput always translates to better training performance. It is possible to artificially increase throughput by using lower numerical precision, reducing synchronization, or even bypassing certain computations. However, these optimizations do not necessarily lead to faster convergence.</p>
<p>For example, a system using TF32 precision may achieve higher throughput than one using FP32, but if TF32 introduces numerical instability that increases the number of iterations required to reach the target accuracy, the overall training time may be longer. The correct way to evaluate throughput is in relation to time-to-accuracy, ensuring that speed optimizations do not come at the expense of convergence efficiency.</p>
</section>
<section id="evaluating-single-node-performance-in-isolation" class="level5">
<h5 class="anchored" data-anchor-id="evaluating-single-node-performance-in-isolation">Evaluating single-node performance in isolation</h5>
<p>Benchmarking training performance on a single node without considering how well it scales in a distributed setting can lead to misleading conclusions. A GPU may demonstrate excellent throughput when used independently, but when deployed across hundreds of nodes, communication overhead and synchronization constraints may diminish these efficiency gains.</p>
<p>For instance, a system optimized for single-node performance may employ memory optimizations that do not generalize well to multi-node environments. Large-scale models such as GPT-3 require efficient gradient synchronization across multiple nodes, making it essential to assess scalability rather than relying solely on single-node performance metrics.</p>
</section>
<section id="ignoring-mid-training-failures-fault-tolerance-and-interference" class="level5">
<h5 class="anchored" data-anchor-id="ignoring-mid-training-failures-fault-tolerance-and-interference">Ignoring mid-training failures, fault tolerance, and interference</h5>
<p>Many benchmarks assume an idealized training environment where hardware failures, memory corruption, network instability, or interference from other processes do not occur. However, real-world training jobs often experience unexpected failures and workload interference that require checkpointing, recovery mechanisms, and resource management.</p>
<p>A system optimized for ideal-case performance but lacking fault tolerance and interference handling may achieve impressive benchmark results under controlled conditions, but frequent failures, inefficient recovery, and resource contention could make it impractical for large-scale deployment. Effective benchmarking should consider checkpointing overhead, failure recovery efficiency, and the impact of interference from other processes rather than assuming perfect execution conditions.</p>
</section>
<section id="assuming-that-scaling-efficiency-is-always-linear" class="level5">
<h5 class="anchored" data-anchor-id="assuming-that-scaling-efficiency-is-always-linear">Assuming that scaling efficiency is always linear</h5>
<p>When evaluating distributed training, it is often assumed that increasing the number of GPUs or TPUs will result in proportional speedups. In practice, communication bottlenecks, memory contention, and synchronization overheads lead to diminishing returns as more compute nodes are added.</p>
<p>For example, training a model across 1,000 GPUs does not necessarily provide 100 times the speed of training on 10 GPUs. At a certain scale, gradient communication costs become a limiting factor, offsetting the benefits of additional parallelism. Proper benchmarking should assess scalability efficiency rather than assuming idealized linear improvements.</p>
</section>
<section id="failing-to-consider-reproducibility-across-frameworks-and-hardware" class="level5">
<h5 class="anchored" data-anchor-id="failing-to-consider-reproducibility-across-frameworks-and-hardware">Failing to consider reproducibility across frameworks and hardware</h5>
<p>Benchmark results are often reported without verifying their reproducibility across different hardware and software frameworks. Even minor variations in floating-point arithmetic, memory layouts, or optimization strategies can introduce statistical differences in training time and accuracy.</p>
<p>For example, a benchmark run on TensorFlow with XLA optimizations may exhibit different convergence characteristics compared to the same model trained using PyTorch with Automatic Mixed Precision (AMP). Proper benchmarking requires evaluating results across multiple frameworks to ensure that software-specific optimizations do not distort performance comparisons.</p>
</section>
</section>
<section id="final-thoughts" class="level4">
<h4 class="anchored" data-anchor-id="final-thoughts">Final Thoughts</h4>
<p>Training benchmarks provide valuable insights into machine learning system performance, but their interpretation requires careful consideration of real-world constraints. High throughput does not necessarily mean faster training if it compromises accuracy convergence. Similarly, scaling efficiency must be evaluated holistically, taking into account both computational efficiency and communication overhead.</p>
<p>By avoiding common benchmarking pitfalls and employing structured evaluation methodologies, machine learning practitioners can gain a deeper understanding of how to optimize training workflows, design efficient AI systems, and develop scalable machine learning infrastructure. As models continue to increase in complexity, benchmarking methodologies must evolve to reflect real-world challenges, ensuring that benchmarks remain meaningful and actionable in guiding AI system development.</p>
</section>
</section>
</section>
<section id="inference-benchmarks" class="level2 page-columns page-full" data-number="12.7">
<h2 data-number="12.7" class="anchored" data-anchor-id="inference-benchmarks"><span class="header-section-number">12.7</span> Inference Benchmarks</h2>
<p>Inference benchmarks provide a systematic approach to evaluating the efficiency, latency, and resource demands of the inference phase in machine learning systems. Unlike training, where the focus is on optimizing large-scale computations over extensive datasets, inference involves deploying trained models to make real-time or batch predictions efficiently. These benchmarks help assess how various factors‚Äîsuch as model architectures, hardware configurations, quantization techniques, and runtime optimizations‚Äîimpact inference performance.</p>
<p>As deep learning models grow in complexity and size, efficient inference becomes a key challenge, particularly for applications requiring real-time decision-making, such as autonomous driving, healthcare diagnostics, and conversational AI. For example, serving large-scale models like <a href="https://arxiv.org/abs/2303.08774">OpenAI‚Äôs GPT-4</a> involves handling billions of parameters while maintaining low latency. Inference benchmarks enable systematic evaluation of the underlying hardware and software stacks to ensure that models can be deployed efficiently across different environments, from cloud data centers to edge devices.</p>
<div class="callout callout-style-default callout-note callout-titled" title="Definition of ML Inference Benchmarks">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition of ML Inference Benchmarks
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>ML Inference Benchmarks</strong> are standardized tools used to evaluate the <em>performance</em>, <em>efficiency</em>, and <em>scalability</em> of machine learning systems during the <em>inference phase</em>. These benchmarks measure key <em>system-level metrics</em>, such as <em>latency</em>, <em>throughput</em>, <em>energy consumption</em>, and <em>memory footprint</em>. By providing a structured evaluation framework, inference benchmarks enable <em>fair comparisons</em> across <em>hardware platforms</em>, <em>software runtimes</em>, and <em>deployment configurations</em>. They help identify <em>bottlenecks</em> and optimize <em>inference pipelines</em> for <em>real-time and large-scale machine learning applications</em>, ensuring that computational resources are utilized effectively.</p>
</div>
</div>
<p>Unlike training, which is often conducted in large-scale data centers with ample computational resources, inference must be optimized for diverse deployment scenarios, including mobile devices, IoT systems, and embedded processors. Efficient inference depends on multiple factors, such as optimized data pipelines, quantization, pruning, and hardware acceleration. Benchmarks help evaluate how well these optimizations improve real-world deployment performance.</p>
<p>Hardware selection plays an important role in inference efficiency. While GPUs and TPUs are widely used for training, inference workloads often require specialized accelerators like NPUs (Neural Processing Units), FPGAs, and dedicated inference chips such as Google‚Äôs Edge TPU. Inference benchmarks evaluate the utilization and performance of these hardware components, helping practitioners choose the right configurations for their deployment needs.</p>
<p>Scaling inference workloads across cloud servers, edge platforms, mobile devices and tinyML systems introduces additional challenges. Inference benchmarks assess the trade-offs between latency, cost, and energy efficiency, helping organizations make informed deployment decisions. As with training, we will reference MLPerf Inference throughout this section to illustrate benchmarking principles. MLPerf provides standardized inference tests across different workloads, including image classification, object detection, speech recognition, and language processing. A full discussion of MLPerf‚Äôs methodology and structure is presented later in this chapter.</p>
<section id="purpose-2" class="level3 page-columns page-full" data-number="12.7.1">
<h3 data-number="12.7.1" class="anchored" data-anchor-id="purpose-2"><span class="header-section-number">12.7.1</span> Purpose</h3>
<p>Deploying machine learning models for inference introduces a unique set of challenges distinct from training. While training optimizes large-scale computation over extensive datasets, inference must deliver predictions efficiently and at scale in real-world environments. Inference benchmarks provide a systematic approach to evaluating system performance, identifying bottlenecks, and ensuring that models can operate effectively across diverse deployment scenarios.</p>
<p>Unlike training, which typically runs on dedicated high-performance hardware, inference must adapt to varying constraints. A model deployed in a cloud server might prioritize high-throughput batch processing, while the same model running on a mobile device must operate under strict latency and power constraints. On edge devices with limited compute and memory, optimizations such as quantization and pruning become critical. Benchmarks help assess these trade-offs, ensuring that inference systems maintain the right balance between accuracy, speed, and efficiency across different platforms.</p>
<p>Inference benchmarks help answer fundamental questions about model deployment. How quickly can a model generate predictions in real-world conditions? What are the trade-offs between inference speed and accuracy? Can an inference system handle increasing demand while maintaining low latency? By evaluating these factors, benchmarks guide optimizations in both hardware and software to improve overall efficiency <span class="citation" data-cites="reddi2020mlperf">(<a href="../references.html#ref-reddi2020mlperf" role="doc-biblioref">Reddi et al. 2019</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-reddi2020mlperf" class="csl-entry" role="listitem">
Reddi, Vijay Janapa, Christine Cheng, David Kanter, Peter Mattson, Guenther Schmuelling, Carole-Jean Wu, Brian Anderson, et al. 2019. <span>‚ÄúMLPerf Inference Benchmark.‚Äù</span> <em>arXiv Preprint arXiv:1911.02549</em>, November, 446‚Äì59. <a href="https://doi.org/10.1109/isca45697.2020.00045">https://doi.org/10.1109/isca45697.2020.00045</a>.
</div></div><section id="why-inference-benchmarks-matter-for-ml-systems" class="level4">
<h4 class="anchored" data-anchor-id="why-inference-benchmarks-matter-for-ml-systems">Why Inference Benchmarks Matter for ML Systems</h4>
<p>Inference plays a critical role in AI applications, where performance directly affects usability and cost. Unlike training, which is often performed offline, inference typically operates in real-time or near real-time, making latency a primary concern. A self-driving car processing camera feeds must react within milliseconds, while a voice assistant generating responses should feel instantaneous to users.</p>
<p>Different applications impose varying constraints on inference. Some workloads require single-instance inference, where predictions must be made as quickly as possible for each individual input. This is crucial in real-time systems such as robotics, augmented reality, and conversational AI, where even small delays can impact responsiveness. Other workloads, such as large-scale recommendation systems or search engines, process massive batches of queries simultaneously, prioritizing throughput over per-query latency. Benchmarks allow engineers to evaluate both scenarios and ensure models are optimized for their intended use case.</p>
<p>A key difference between training and inference is that inference workloads often run continuously in production, meaning that small inefficiencies can compound over time. Unlike a training job that runs once and completes, an inference system deployed in the cloud may serve millions of queries daily, and a model running on a smartphone must manage battery consumption over extended use. Benchmarks provide a structured way to measure inference efficiency under these real-world constraints, helping developers make informed choices about model optimization, hardware selection, and deployment strategies.</p>
</section>
<section id="optimizing-hardware-software-configurations-1" class="level4">
<h4 class="anchored" data-anchor-id="optimizing-hardware-software-configurations-1">Optimizing Hardware &amp; Software Configurations</h4>
<p>Efficient inference depends on both hardware acceleration and software optimizations. While GPUs and TPUs dominate training, inference is more diverse in its hardware needs. A cloud-based AI service might leverage powerful accelerators for large-scale workloads, whereas mobile devices rely on specialized inference chips like NPUs or optimized CPU execution. On embedded systems, where resources are constrained, achieving high performance requires careful memory and compute efficiency. Benchmarks help evaluate how well different hardware platforms handle inference workloads, guiding deployment decisions.</p>
<p>Software optimizations are just as important. Frameworks like TensorRT, ONNX Runtime, and TVM apply optimizations such as operator fusion, quantization, and kernel tuning to improve inference speed and reduce computational overhead. These optimizations can make a significant difference, especially in environments with limited resources. Benchmarks allow developers to measure the impact of such techniques on latency, throughput, and power efficiency, ensuring that optimizations translate into real-world improvements without degrading model accuracy.</p>
</section>
<section id="scalability-efficiency-1" class="level4">
<h4 class="anchored" data-anchor-id="scalability-efficiency-1">Scalability &amp; Efficiency</h4>
<p>Inference workloads vary significantly in their scaling requirements. A cloud-based AI system handling millions of queries per second must ensure that increasing demand does not cause delays, while a mobile application running a model locally must execute quickly even under power constraints. Unlike training, which is typically performed on a fixed set of high-performance machines, inference must scale dynamically based on usage patterns and available computational resources.</p>
<p>Benchmarks evaluate how inference systems scale under different conditions. They measure how well performance holds up under increasing query loads, whether additional compute resources improve inference speed, and how efficiently models run across different deployment environments. Large-scale inference deployments often involve distributed inference servers, where multiple copies of a model process incoming requests in parallel. Benchmarks assess how efficiently this scaling occurs and whether additional resources lead to meaningful improvements in latency and throughput.</p>
<p>Another key factor in inference efficiency is cold-start performance‚Äîthe time it takes for a model to load and begin processing queries. This is especially relevant for applications that do not run inference continuously but instead load models on demand. Benchmarks help determine whether a system can quickly transition from idle to active execution without significant overhead.</p>
</section>
<section id="cost-energy-considerations-1" class="level4">
<h4 class="anchored" data-anchor-id="cost-energy-considerations-1">Cost &amp; Energy Considerations</h4>
<p>Because inference workloads run continuously, operational cost and energy efficiency are critical factors. Unlike training, where compute costs are incurred once, inference costs accumulate over time as models are deployed in production. Running an inefficient model at scale can significantly increase cloud compute expenses, while an inefficient mobile inference system can drain battery life quickly. Benchmarks provide insights into cost per inference request, helping organizations optimize for both performance and affordability.</p>
<p>Energy efficiency is also a growing concern, particularly for mobile and edge AI applications. Many inference workloads run on battery-powered devices, where excessive computation can impact usability. A model running on a smartphone, for example, must be optimized to minimize power consumption while maintaining responsiveness. Benchmarks help evaluate inference efficiency per watt, ensuring that models can operate sustainably across different platforms.</p>
</section>
<section id="fair-comparisons-across-ml-systems-1" class="level4">
<h4 class="anchored" data-anchor-id="fair-comparisons-across-ml-systems-1">Fair Comparisons Across ML Systems</h4>
<p>With many different hardware platforms and optimization techniques available, standardized benchmarking is essential for fair comparisons. Without well-defined benchmarks, it becomes difficult to determine whether performance gains come from genuine improvements or from optimizations that exploit specific hardware features. Inference benchmarks provide a consistent evaluation methodology, ensuring that comparisons are meaningful and reproducible.</p>
<p>For example, MLPerf Inference defines rigorous evaluation criteria for tasks such as image classification, object detection, and speech recognition, making it possible to compare different systems under controlled conditions. These standardized tests prevent misleading results caused by differences in dataset preprocessing, proprietary optimizations, or vendor-specific tuning. By enforcing reproducibility, benchmarks allow researchers and engineers to make informed decisions when selecting inference frameworks, hardware accelerators, and optimization techniques.</p>
</section>
</section>
<section id="metrics-1" class="level3 page-columns page-full" data-number="12.7.2">
<h3 data-number="12.7.2" class="anchored" data-anchor-id="metrics-1"><span class="header-section-number">12.7.2</span> Metrics</h3>
<p>Evaluating the performance of inference systems requires a distinct set of metrics from those used for training. While training benchmarks emphasize throughput, scalability, and time-to-accuracy, inference benchmarks must focus on latency, efficiency, and resource utilization in practical deployment settings. These metrics ensure that machine learning models perform well across different environments, from cloud data centers handling millions of requests to mobile and edge devices operating under strict power and memory constraints.</p>
<p>Unlike training, where the primary goal is to optimize learning speed, inference benchmarks evaluate how efficiently a trained model can process inputs and generate predictions at scale. The following sections describe the most important inference benchmarking metrics, explaining their relevance and how they are used to compare different systems.</p>
<section id="latency-and-tail-latency" class="level4">
<h4 class="anchored" data-anchor-id="latency-and-tail-latency">Latency and Tail Latency</h4>
<p>Latency is one of the most critical performance metrics for inference, particularly in real-time applications where delays can negatively impact user experience or system safety. Latency refers to the time taken for an inference system to process an input and produce a prediction. While the average latency of a system is useful, it does not capture performance in high-demand scenarios where occasional delays can degrade reliability.</p>
<p>To account for this, benchmarks often measure tail latency, which reflects the worst-case delays in a system. These are typically reported as the 95th percentile (p95) or 99th percentile (p99) latency, meaning that 95% or 99% of inferences are completed within a given time. For applications such as autonomous driving or real-time trading, maintaining low tail latency is essential to avoid unpredictable delays that could lead to catastrophic outcomes.</p>
</section>
<section id="throughput-and-batch-processing-efficiency" class="level4">
<h4 class="anchored" data-anchor-id="throughput-and-batch-processing-efficiency">Throughput and Batch Processing Efficiency</h4>
<p>While latency measures the speed of individual inference requests, throughput measures how many inference requests a system can process per second. It is typically expressed in queries per second (QPS) or frames per second (FPS) for vision tasks. Some inference systems operate on a single-instance basis, where each input is processed independently as soon as it arrives. Other systems process multiple inputs in parallel using batch inference, which can significantly improve efficiency by leveraging hardware optimizations.</p>
<p>For example, cloud-based services handling millions of queries per second benefit from batch inference, where large groups of inputs are processed together to maximize computational efficiency. In contrast, applications like robotics, interactive AI, and augmented reality require low-latency single-instance inference, where the system must respond immediately to each new input.</p>
<p>Benchmarks must consider both single-instance and batch throughput to provide a comprehensive understanding of inference performance across different deployment scenarios.</p>
</section>
<section id="numerical-precision-and-accuracy-trade-offs" class="level4">
<h4 class="anchored" data-anchor-id="numerical-precision-and-accuracy-trade-offs">Numerical Precision and Accuracy Trade-offs</h4>
<p>Optimizing inference performance often involves reducing numerical precision, which can significantly accelerate computation while reducing memory and energy consumption. However, lower-precision calculations can introduce accuracy degradation, making it essential to benchmark the trade-offs between speed and predictive quality.</p>
<p>Inference benchmarks evaluate how well models perform under different numerical settings, such as FP32, FP16, and INT8. Many modern AI accelerators support mixed-precision inference, allowing systems to dynamically adjust numerical representation based on workload requirements. Quantization and pruning techniques further improve efficiency, but their impact on model accuracy varies depending on the task and dataset. Benchmarks help determine whether these optimizations are viable for deployment, ensuring that improvements in efficiency do not come at the cost of unacceptable accuracy loss.</p>
</section>
<section id="memory-footprint-and-model-size" class="level4">
<h4 class="anchored" data-anchor-id="memory-footprint-and-model-size">Memory Footprint and Model Size</h4>
<p>Beyond computational optimizations, memory footprint is another critical consideration for inference systems, particularly for devices with limited resources. Efficient inference depends not only on speed but also on memory usage. Unlike training, where large models can be distributed across powerful GPUs or TPUs, inference often requires models to run within strict memory budgets. The total model size determines how much storage is required for deployment, while RAM usage reflects the working memory needed during execution. Some models require large memory bandwidth to efficiently transfer data between processing units, which can become a bottleneck if the hardware lacks sufficient capacity.</p>
<p>Inference benchmarks evaluate these factors to ensure that models can be deployed effectively across a range of devices. A model that achieves high accuracy but exceeds memory constraints may be impractical for real-world use. To address this, compression techniques such as quantization, pruning, and knowledge distillation are often applied to reduce model size while maintaining accuracy. Benchmarks help assess whether these optimizations strike the right balance between memory efficiency and predictive performance.</p>
</section>
<section id="cold-start-time-and-model-load-time" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="cold-start-time-and-model-load-time">Cold-Start Time and Model Load Time</h4>
<p>Once memory requirements are optimized, cold-start performance<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a> becomes critical for ensuring inference systems are ready to respond quickly upon deployment. In many deployment scenarios, models are not always kept in memory but instead loaded on demand when needed. This can introduce significant delays, particularly in serverless AI<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a> environments, where resources are allocated dynamically based on incoming requests. Cold-start performance measures how quickly a system can transition from idle to active execution, ensuring that inference is available without excessive wait times.</p>
<div class="no-row-height column-margin column-container"><div id="fn11"><p><sup>11</sup>&nbsp;<strong>Cold-Start Time:</strong> The time required for a model to initialize and become ready to process the first inference request after being loaded from disk or a low-power state.</p></div><div id="fn12"><p><sup>12</sup>&nbsp;<strong>Serverless AI:</strong> A deployment model where inference workloads are executed on demand, eliminating the need for dedicated compute resources but introducing cold-start latency challenges.</p></div></div><p>Model load time refers to the duration required to load a trained model into memory before it can process inputs. In some cases, particularly on resource-limited devices, models must be reloaded frequently to free up memory for other applications. The time taken for the first inference request is also an important consideration, as it reflects the total delay users experience when interacting with an AI-powered service. Benchmarks help quantify these delays, ensuring that inference systems can meet real-world responsiveness requirements.</p>
</section>
<section id="scalability-and-dynamic-workload-handling" class="level4">
<h4 class="anchored" data-anchor-id="scalability-and-dynamic-workload-handling">Scalability and Dynamic Workload Handling</h4>
<p>While cold-start latency addresses initial responsiveness, scalability ensures that inference systems can handle fluctuating workloads and concurrent demands over time Inference workloads must scale effectively across different usage patterns. In cloud-based AI services, this means efficiently handling millions of concurrent users, while on mobile or embedded devices, it involves managing multiple AI models running simultaneously without overloading the system.</p>
<p>Scalability measures how well inference performance improves when additional computational resources are allocated. In some cases, adding more GPUs or TPUs increases throughput significantly, but in other scenarios, bottlenecks such as memory bandwidth limitations or network latency may limit scaling efficiency. Benchmarks also assess how well a system balances multiple concurrent models in real-world deployment, where different AI-powered features may need to run at the same time without interference.</p>
<p>For cloud-based AI, benchmarks evaluate how efficiently a system handles fluctuating demand, ensuring that inference servers can dynamically allocate resources without compromising latency. In mobile and embedded AI, efficient multi-model execution is essential for running multiple AI-powered features simultaneously without degrading system performance.</p>
</section>
<section id="power-consumption-and-energy-efficiency" class="level4">
<h4 class="anchored" data-anchor-id="power-consumption-and-energy-efficiency">Power Consumption and Energy Efficiency</h4>
<p>Since inference workloads run continuously in production, power consumption and energy efficiency are critical considerations. This is particularly important for mobile and edge devices, where battery life and thermal constraints limit available computational resources. Even in large-scale cloud environments, power efficiency directly impacts operational costs and sustainability goals.</p>
<p>The energy required for a single inference is often measured in joules per inference, reflecting how efficiently a system processes inputs while minimizing power draw. In cloud-based inference, efficiency is commonly expressed as queries per second per watt (QPS/W) to quantify how well a system balances performance and energy consumption. For mobile AI applications, optimizing inference power consumption extends battery life and allows models to run efficiently on resource-constrained devices. Reducing energy use also plays a key role in making large-scale AI systems more environmentally sustainable, ensuring that computational advancements align with energy-conscious deployment strategies. By balancing power consumption with performance, energy-efficient inference systems enable AI to scale sustainably across diverse applications, from data centers to edge devices.</p>
</section>
</section>
<section id="evaluating-inference-performance" class="level3" data-number="12.7.3">
<h3 data-number="12.7.3" class="anchored" data-anchor-id="evaluating-inference-performance"><span class="header-section-number">12.7.3</span> Evaluating Inference Performance</h3>
<p>Evaluating inference performance is a critical step in understanding how well machine learning systems meet the demands of real-world applications. Unlike training, which is typically conducted offline, inference systems must process inputs and generate predictions efficiently across a wide range of deployment scenarios. Metrics such as latency, throughput, memory usage, and energy efficiency provide a structured way to measure system performance and identify areas for improvement.</p>
<p><a href="#tbl-inference-metrics" class="quarto-xref">Table&nbsp;<span>12.3</span></a> below summarizes the key metrics used to evaluate inference systems, highlighting their relevance to different contexts. While each metric offers unique insights, it is important to approach inference benchmarking holistically. Trade-offs between metrics‚Äîsuch as speed versus accuracy or throughput versus power consumption‚Äîare common, and understanding these trade-offs is essential for effective system design.</p>
<div id="tbl-inference-metrics" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-inference-metrics-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;12.3: Inference benchmark metrics and evaluation dimensions.
</figcaption>
<div aria-describedby="tbl-inference-metrics-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 44%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Category</th>
<th style="text-align: left;">Key Metrics</th>
<th style="text-align: left;">Example Benchmark Use</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Latency and Tail Latency</td>
<td style="text-align: left;">Mean latency (ms/request); Tail latency (p95, p99, p99.9)</td>
<td style="text-align: left;">Evaluating real-time performance for safety-critical AI</td>
</tr>
<tr class="even">
<td style="text-align: left;">Throughput and Efficiency</td>
<td style="text-align: left;">Queries per second (QPS); Frames per second (FPS); Batch throughput</td>
<td style="text-align: left;">Comparing large-scale cloud inference systems</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Numerical Precision Impact</td>
<td style="text-align: left;">Accuracy degradation (FP32 vs.&nbsp;INT8); Speedup from reduced precision</td>
<td style="text-align: left;">Balancing accuracy vs.&nbsp;efficiency in optimized inference</td>
</tr>
<tr class="even">
<td style="text-align: left;">Memory Footprint</td>
<td style="text-align: left;">Model size (MB/GB); RAM usage (MB); Memory bandwidth utilization</td>
<td style="text-align: left;">Assessing feasibility for edge and mobile deployments</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Cold-Start and Load Time</td>
<td style="text-align: left;">Model load time (s); First inference latency (s)</td>
<td style="text-align: left;">Evaluating responsiveness in serverless AI</td>
</tr>
<tr class="even">
<td style="text-align: left;">Scalability</td>
<td style="text-align: left;">Efficiency under load; Multi-model serving performance</td>
<td style="text-align: left;">Measuring robustness for dynamic, high-demand systems</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Power and Energy Efficiency</td>
<td style="text-align: left;">Power consumption (Watts); Performance per Watt (QPS/W)</td>
<td style="text-align: left;">Optimizing energy use for mobile and sustainable AI</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<section id="key-considerations-for-inference-systems" class="level4">
<h4 class="anchored" data-anchor-id="key-considerations-for-inference-systems">Key Considerations for Inference Systems</h4>
<p>Inference systems face unique challenges depending on where and how they are deployed. Real-time applications, such as self-driving cars or voice assistants, require low latency to ensure timely responses, while large-scale cloud deployments focus on maximizing throughput to handle millions of queries. Edge devices, on the other hand, are constrained by memory and power, making efficiency critical.</p>
<p>One of the most important aspects of evaluating inference performance is understanding the trade-offs between metrics. For example, optimizing for high throughput might increase latency, making a system unsuitable for real-time applications. Similarly, reducing numerical precision improves power efficiency and speed but may lead to minor accuracy degradation. A thoughtful evaluation must balance these trade-offs to align with the intended application.</p>
<p>The deployment environment also plays a significant role in determining evaluation priorities. Cloud-based systems often prioritize scalability and adaptability to dynamic workloads, while mobile and edge systems require careful attention to memory usage and energy efficiency. These differing priorities mean that benchmarks must be tailored to the context of the system‚Äôs use, rather than relying on one-size-fits-all evaluations.</p>
<p>Ultimately, evaluating inference performance requires a holistic approach. Focusing on a single metric, such as latency or energy efficiency, provides an incomplete picture. Instead, all relevant dimensions must be considered together to ensure that the system meets its functional, resource, and performance goals in a balanced way.</p>
</section>
<section id="common-pitfalls-in-inference-benchmarks" class="level4">
<h4 class="anchored" data-anchor-id="common-pitfalls-in-inference-benchmarks">Common Pitfalls in Inference Benchmarks</h4>
<p>Even with well-defined metrics, benchmarking inference systems can be challenging. Missteps during the evaluation process often lead to misleading conclusions. Below are common pitfalls that students and practitioners should be aware of when analyzing inference performance.</p>
<section id="focusing-only-on-average-latency" class="level5">
<h5 class="anchored" data-anchor-id="focusing-only-on-average-latency">Focusing Only on Average Latency</h5>
<p>While average latency provides a baseline measure of response time, it fails to capture how a system performs under peak load. In real-world scenarios, worst-case latency‚Äîcaptured through metrics like p95 or p99 tail latency‚Äîcan significantly impact system reliability. For instance, a conversational AI system may fail to provide timely responses if occasional latency spikes exceed acceptable thresholds.</p>
</section>
<section id="neglecting-memory-and-energy-constraints" class="level5">
<h5 class="anchored" data-anchor-id="neglecting-memory-and-energy-constraints">Neglecting Memory and Energy Constraints</h5>
<p>A model with excellent throughput or latency may be unsuitable for mobile or edge deployments if it requires excessive memory or power. For example, an inference system designed for cloud environments might fail to operate efficiently on a battery-powered device. Proper benchmarks must consider memory footprint and energy consumption to ensure practicality across deployment contexts.</p>
</section>
<section id="overlooking-cold-start-performance" class="level5">
<h5 class="anchored" data-anchor-id="overlooking-cold-start-performance">Overlooking Cold-Start Performance</h5>
<p>In serverless environments, where models are loaded on demand, cold-start latency is a critical factor. Ignoring the time it takes to initialize a model and process the first request can result in unrealistic expectations for responsiveness. Evaluating both model load time and first-inference latency ensures that systems are designed to meet real-world responsiveness requirements.</p>
</section>
<section id="evaluating-metrics-in-isolation" class="level5">
<h5 class="anchored" data-anchor-id="evaluating-metrics-in-isolation">Evaluating Metrics in Isolation</h5>
<p>Benchmarking inference systems often involves balancing competing metrics. For example, maximizing batch throughput might degrade latency, while aggressive quantization could reduce accuracy. Focusing on a single metric without considering its impact on others can lead to incomplete or misleading evaluations. Comprehensive benchmarks must account for these interactions.</p>
</section>
<section id="assuming-linear-scalability" class="level5">
<h5 class="anchored" data-anchor-id="assuming-linear-scalability">Assuming Linear Scalability</h5>
<p>Inference performance does not always scale proportionally with additional resources. Bottlenecks such as memory bandwidth, thermal limits, or communication overhead can limit the benefits of adding more GPUs or TPUs. Benchmarks that assume linear scaling behavior may overestimate system performance, particularly in distributed deployments.</p>
</section>
<section id="ignoring-application-specific-requirements" class="level5">
<h5 class="anchored" data-anchor-id="ignoring-application-specific-requirements">Ignoring Application-Specific Requirements</h5>
<p>Generic benchmarking results may fail to account for the specific needs of an application. For instance, a benchmark optimized for cloud inference might be irrelevant for edge devices, where energy and memory constraints dominate. Tailoring benchmarks to the deployment context ensures that results are meaningful and actionable.</p>
</section>
</section>
<section id="final-thoughts-1" class="level4">
<h4 class="anchored" data-anchor-id="final-thoughts-1">Final Thoughts</h4>
<p>Inference benchmarks are essential tools for understanding system performance, but their utility depends on careful and holistic evaluation. Metrics like latency, throughput, memory usage, and energy efficiency provide valuable insights, but their importance varies depending on the application and deployment context. Students should approach benchmarking as a process of balancing multiple priorities, rather than optimizing for a single metric.</p>
<p>By avoiding common pitfalls and considering the trade-offs between different metrics, practitioners can design inference systems that are reliable, efficient, and suitable for real-world deployment. The ultimate goal of benchmarking is to guide system improvements that align with the demands of the intended application.</p>
</section>
</section>
<section id="mlperf-inference-benchmarks" class="level3" data-number="12.7.4">
<h3 data-number="12.7.4" class="anchored" data-anchor-id="mlperf-inference-benchmarks"><span class="header-section-number">12.7.4</span> MLPerf Inference Benchmarks</h3>
<p>The MLPerf Inference benchmark, developed by <a href="https://mlcommons.org/en/">MLCommons</a>, provides a standardized framework for evaluating machine learning inference performance across a range of deployment environments. Initially, MLPerf started with a single inference benchmark, but as machine learning systems expanded into diverse applications, it became clear that a one-size-fits-all benchmark was insufficient. Different inference scenarios‚Äîranging from cloud-based AI services to resource-constrained embedded devices‚Äîdemanded tailored evaluations. This realization led to the development of a family of MLPerf inference benchmarks, each designed to assess performance within a specific deployment setting.</p>
<section id="mlperf-inference" class="level4">
<h4 class="anchored" data-anchor-id="mlperf-inference">MLPerf Inference</h4>
<p><a href="https://mlcommons.org/en/inference-datacenter/">MLPerf Inference</a> serves as the baseline benchmark, originally designed to evaluate large-scale inference systems. It primarily focuses on data center and cloud-based inference workloads, where high throughput, low latency, and efficient resource utilization are essential. The benchmark assesses performance across a range of deep learning models, including image classification, object detection, natural language processing, and recommendation systems. This version of MLPerf remains the gold standard for comparing AI accelerators, GPUs, TPUs, and CPUs in high-performance computing environments.</p>
</section>
<section id="mlperf-mobile" class="level4">
<h4 class="anchored" data-anchor-id="mlperf-mobile">MLPerf Mobile</h4>
<p><a href="https://mlcommons.org/en/mlperf-mobile/">MLPerf Mobile</a> extends MLPerf‚Äôs evaluation framework to smartphones and other mobile devices. Unlike cloud-based inference, mobile inference operates under strict power and memory constraints, requiring models to be optimized for efficiency without sacrificing responsiveness. The benchmark measures latency and responsiveness for real-time AI tasks, such as camera-based scene detection, speech recognition, and augmented reality applications. MLPerf Mobile has become an industry standard for assessing AI performance on flagship smartphones and mobile AI chips, helping developers optimize models for on-device AI workloads.</p>
</section>
<section id="mlperf-client" class="level4">
<h4 class="anchored" data-anchor-id="mlperf-client">MLPerf Client</h4>
<p><a href="https://mlcommons.org/en/inference-edge/">MLPerf Client</a> focuses on inference performance on consumer computing devices, such as laptops, desktops, and workstations. This benchmark addresses local AI workloads that run directly on personal devices, eliminating reliance on cloud inference. Tasks such as real-time video editing, speech-to-text transcription, and AI-enhanced productivity applications fall under this category. Unlike cloud-based benchmarks, MLPerf Client evaluates how AI workloads interact with general-purpose hardware, such as CPUs, discrete GPUs, and integrated neural processing units (NPUs), making it relevant for consumer and enterprise AI applications.</p>
</section>
<section id="mlperf-tiny" class="level4">
<h4 class="anchored" data-anchor-id="mlperf-tiny">MLPerf Tiny</h4>
<p><a href="https://mlcommons.org/en/inference-tiny/">MLPerf Tiny</a> was created to benchmark embedded and ultra-low-power AI systems, such as IoT devices, wearables, and microcontrollers. Unlike other MLPerf benchmarks, which assess performance on powerful accelerators, MLPerf Tiny evaluates inference on devices with limited compute, memory, and power resources. This benchmark is particularly relevant for applications such as smart sensors, AI-driven automation, and real-time industrial monitoring, where models must run efficiently on hardware with minimal processing capabilities. MLPerf Tiny plays a crucial role in the advancement of AI at the edge, helping developers optimize models for constrained environments.</p>
</section>
<section id="why-mlperf-inference-benchmarks-matter" class="level4">
<h4 class="anchored" data-anchor-id="why-mlperf-inference-benchmarks-matter">Why MLPerf Inference Benchmarks Matter</h4>
<p>The evolution of MLPerf Inference from a single benchmark to a spectrum of benchmarks reflects the diversity of AI deployment scenarios. Different environments‚Äîwhether cloud, mobile, desktop, or embedded‚Äîhave unique constraints and requirements, and MLPerf provides a structured way to evaluate AI models accordingly.</p>
<p>MLPerf serves as an essential tool for:</p>
<ul>
<li>Understanding how inference performance varies across deployment settings.<br>
</li>
<li>Learning which performance metrics are most relevant for different AI applications.<br>
</li>
<li>Optimizing models and hardware choices based on real-world usage constraints.</li>
</ul>
<p>By recognizing why tailored inference benchmarks are necessary, we gain a deeper appreciation for the challenges of AI deployment and the role of benchmarking in shaping efficient, scalable, and practical machine learning systems.</p>
</section>
</section>
</section>
<section id="measuring-energy-efficiency" class="level2 page-columns page-full" data-number="12.8">
<h2 data-number="12.8" class="anchored" data-anchor-id="measuring-energy-efficiency"><span class="header-section-number">12.8</span> Measuring Energy Efficiency</h2>
<p>As machine learning expands into diverse applications, concerns about its growing power consumption and ecological footprint have intensified. While performance benchmarks help optimize speed and accuracy, they do not always account for energy efficiency, which is an increasingly critical factor in real-world deployment. Efficient inference is particularly important in scenarios where power is a limited resource, such as mobile devices, embedded AI, and cloud-scale inference workloads. The need to optimize both performance and power consumption has led to the development of standardized energy efficiency benchmarks.</p>
<p>However, measuring power consumption in machine learning systems presents unique challenges. The energy demands of ML models vary dramatically across deployment environments‚Äîfrom TinyML devices consuming microwatts to data centers requiring megawatts of power. Creating a single standardized methodology for benchmarking energy efficiency requires accommodating these vastly different scales while ensuring that measurements are consistent, fair, and reproducible across diverse hardware configurations <span class="citation" data-cites="henderson2020towards">(<a href="../references.html#ref-henderson2020towards" role="doc-biblioref">Henderson et al. 2020</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-henderson2020towards" class="csl-entry" role="listitem">
Henderson, Peter, Jieru Hu, Joshua Romoff, Emma Brunskill, Dan Jurafsky, and Joelle Pineau. 2020. <span>‚ÄúTowards the Systematic Reporting of the Energy and Carbon Footprints of Machine Learning.‚Äù</span> <em>Journal of Machine Learning Research</em> 21 (248): 1‚Äì43. <a href="https://doi.org/10.48550/arxiv.2002.05651">https://doi.org/10.48550/arxiv.2002.05651</a>.
</div></div><section id="mlperf-power-a-standard-for-measuring-ai-energy-consumption" class="level3 page-columns page-full" data-number="12.8.1">
<h3 data-number="12.8.1" class="anchored" data-anchor-id="mlperf-power-a-standard-for-measuring-ai-energy-consumption"><span class="header-section-number">12.8.1</span> MLPerf Power: A Standard for Measuring AI Energy Consumption</h3>
<p>One of the most widely used methodologies for measuring energy efficiency is MLPerf Power <span class="citation" data-cites="tschand2024mlperf">(<a href="../references.html#ref-tschand2024mlperf" role="doc-biblioref">Tschand et al. 2024</a>)</span>, a benchmarking framework designed to accurately assess power consumption across different ML systems. This methodology extends across:</p>
<div class="no-row-height column-margin column-container"></div><ul>
<li>Datacenter Inference: Measuring power usage in large-scale AI workloads where optimizing energy consumption is crucial for reducing operational costs.<br>
</li>
<li>Edge Inference: Evaluating power efficiency in devices like smartphones, laptops, and AI-enabled edge hardware, where battery life is a key constraint.<br>
</li>
<li>Tiny Inference: Assessing energy consumption in ultra-low-power AI systems, such as IoT sensors and microcontrollers, where every milliwatt counts.</li>
</ul>
<p>The MLPerf Power methodology adapts to different hardware architectures, ranging from general-purpose CPUs to specialized AI accelerators, while maintaining a uniform measurement standard. This ensures that comparisons across platforms are meaningful and unbiased.</p>
</section>
<section id="understanding-power-measurement-boundaries" class="level3 page-columns page-full" data-number="12.8.2">
<h3 data-number="12.8.2" class="anchored" data-anchor-id="understanding-power-measurement-boundaries"><span class="header-section-number">12.8.2</span> Understanding Power Measurement Boundaries</h3>
<p><a href="#fig-power-diagram" class="quarto-xref">Figure&nbsp;<span>12.3</span></a> illustrates how power consumption is measured at different system scales, from TinyML devices to full-scale data center inference nodes. Each scenario highlights the components included within the measurement boundary and those excluded from direct measurement. This approach ensures that benchmarks reflect the true energy costs of running ML workloads in real-world settings.</p>
<div id="fig-power-diagram" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-power-diagram-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/png/power_component_diagram.png" class="lightbox" data-gallery="quarto-lightbox-gallery-4" title="Figure&nbsp;12.3: MLPerf Power system measurement diagram. Source: @tschand2024mlperf."><img src="images/png/power_component_diagram.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-power-diagram-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;12.3: MLPerf Power system measurement diagram. Source: <span class="citation" data-cites="tschand2024mlperf">Tschand et al. (<a href="../references.html#ref-tschand2024mlperf" role="doc-biblioref">2024</a>)</span>.
</figcaption>
<div class="no-row-height column-margin column-container"><div id="ref-tschand2024mlperf" class="csl-entry" role="listitem">
Tschand, Arya, Arun Tejusve Raghunath Rajan, Sachin Idgunji, Anirban Ghosh, Jeremy Holleman, Csaba Kiraly, Pawan Ambalkar, et al. 2024. <span>‚ÄúMLPerf Power: Benchmarking the Energy Efficiency of Machine Learning Systems from Microwatts to Megawatts for Sustainable AI.‚Äù</span> <em>arXiv Preprint arXiv:2410.12032</em>, October. <a href="https://doi.org/10.48550/arxiv.2410.12032">https://doi.org/10.48550/arxiv.2410.12032</a>.
</div></div></figure>
</div>
<p>By defining clear measurement boundaries, MLPerf Power ensures that power consumption metrics are comparable across different AI systems, helping researchers and engineers make informed decisions about energy-efficient AI deployment.</p>
</section>
<section id="the-trade-off-between-performance-and-energy-efficiency" class="level3 page-columns page-full" data-number="12.8.3">
<h3 data-number="12.8.3" class="anchored" data-anchor-id="the-trade-off-between-performance-and-energy-efficiency"><span class="header-section-number">12.8.3</span> The Trade-off Between Performance and Energy Efficiency</h3>
<p>It is important to recognize that optimizing a system purely for performance does not always result in the most energy-efficient execution. In many cases, sacrificing a small amount of accuracy or processing speed can lead to significant improvements in energy efficiency. This is particularly relevant for inference workloads running in battery-powered environments, where maximizing efficiency extends operational lifetime.</p>
<p>As benchmarking methodologies continue to evolve, energy efficiency metrics will play an increasingly central role in AI optimization. Future advancements in sustainable AI benchmarking<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a> will help researchers and engineers design systems that balance performance, power consumption, and environmental impact, ensuring that ML systems operate efficiently without unnecessary energy waste.</p>
<div class="no-row-height column-margin column-container"><div id="fn13"><p><sup>13</sup>&nbsp;Reducing the environmental impact of machine learning by improving energy efficiency, using renewable energy sources, and designing models that require fewer computational resources.</p></div></div></section>
</section>
<section id="challenges-and-limitations" class="level2 page-columns page-full" data-number="12.9">
<h2 data-number="12.9" class="anchored" data-anchor-id="challenges-and-limitations"><span class="header-section-number">12.9</span> Challenges and Limitations</h2>
<p>Benchmarking provides a structured framework for evaluating the performance of AI systems, but it comes with significant challenges. If these challenges are not properly addressed, they can undermine the credibility and usefulness of benchmarking results. One of the most fundamental issues is incomplete problem coverage. Many benchmarks, while useful for controlled comparisons, fail to capture the full diversity of real-world applications. For instance, common image classification datasets, such as <a href="https://www.cs.toronto.edu/kriz/cifar.html">CIFAR-10</a>, contain a limited variety of images. As a result, models that perform well on these datasets may struggle when applied to more complex, real-world scenarios with greater variability in lighting, perspective, and object composition.</p>
<p>Another challenge is statistical insignificance, which arises when benchmark evaluations are conducted on too few data samples or trials. For example, testing an optical character recognition (OCR) system on a small dataset may not accurately reflect its performance on large-scale, noisy text documents. Without sufficient trials and diverse input distributions, benchmarking results may be misleading or fail to capture true system reliability.</p>
<p>Reproducibility is also a major concern. Benchmark results can vary significantly depending on factors such as hardware configurations, software versions, and system dependencies. Small differences in compilers, numerical precision, or library updates can lead to inconsistent performance measurements across different environments. To mitigate this issue, MLPerf addresses reproducibility by providing reference implementations, standardized test environments, and strict submission guidelines. Even with these efforts, achieving true consistency across diverse hardware platforms remains an ongoing challenge.</p>
<p>A more fundamental limitation of benchmarking is the risk of misalignment with real-world goals. Many benchmarks emphasize metrics such as speed, accuracy, and throughput, but practical AI deployments often require balancing multiple objectives, including power efficiency, cost, and robustness. A model that achieves state-of-the-art accuracy on a benchmark may be impractical for deployment if it consumes excessive energy or requires expensive hardware. Furthermore, benchmarks can quickly become outdated due to the rapid evolution of AI models and hardware. New techniques may emerge that render existing benchmarks less relevant, necessitating continuous updates to keep benchmarking methodologies aligned with state-of-the-art developments.</p>
<p>While these challenges affect all benchmarking efforts, the most pressing concern is the role of benchmark engineering, which introduces the risk of over-optimization for specific benchmark tasks rather than meaningful improvements in real-world performance.</p>
<section id="the-hardware-lottery" class="level3 page-columns page-full" data-number="12.9.1">
<h3 data-number="12.9.1" class="anchored" data-anchor-id="the-hardware-lottery"><span class="header-section-number">12.9.1</span> The Hardware Lottery</h3>
<p>A critical issue in benchmarking is what has been described as the hardware lottery, a concept introduced by <span class="citation" data-cites="hooker2021hardware">(<a href="../references.html#ref-hooker2021hardware" role="doc-biblioref">Hooker 2021</a>)</span>. The success of a machine learning model is often dictated not only by its architecture and training data but also by how well it aligns with the underlying hardware used for inference. Some models perform exceptionally well, not because they are inherently better, but because they are optimized for the parallel processing capabilities of GPUs or TPUs. Meanwhile, other promising architectures may be overlooked because they do not map efficiently to dominant hardware platforms.</p>
<div class="no-row-height column-margin column-container"><div id="ref-hooker2021hardware" class="csl-entry" role="listitem">
Hooker, Sara. 2021. <span>‚ÄúThe Hardware Lottery.‚Äù</span> <em>Communications of the ACM</em> 64 (12): 58‚Äì65. <a href="https://doi.org/10.1145/3467017">https://doi.org/10.1145/3467017</a>.
</div></div><p>This dependence on hardware compatibility introduces biases into benchmarking. A model that is highly efficient on a specific GPU may perform poorly on a CPU or a custom AI accelerator. For instance, <a href="#fig-hw-lottery" class="quarto-xref">Figure&nbsp;<span>12.4</span></a> compares the performance of models across different hardware platforms. The multi-hardware models show comparable results to ‚ÄúMobileNetV3 Large min‚Äù on both the CPU <code>uint8</code> and GPU configurations. However, these multi-hardware models demonstrate significant performance improvements over the MobileNetV3 Large baseline when run on the EdgeTPU and DSP hardware. This emphasizes the variable efficiency of multi-hardware models in specialized computing environments.</p>
<div id="fig-hw-lottery" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-hw-lottery-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/png/hardware_lottery.png" class="lightbox" data-gallery="quarto-lightbox-gallery-5" title="Figure&nbsp;12.4: Accuracy-latency trade-offs of multiple ML models and how they perform on various hardware. Source: @chu2021discovering."><img src="images/png/hardware_lottery.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-hw-lottery-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;12.4: Accuracy-latency trade-offs of multiple ML models and how they perform on various hardware. Source: <span class="citation" data-cites="chu2021discovering">Chu et al. (<a href="../references.html#ref-chu2021discovering" role="doc-biblioref">2021</a>)</span>.
</figcaption>
<div class="no-row-height column-margin column-container"><div id="ref-chu2021discovering" class="csl-entry" role="listitem">
Chu, Grace, Okan Arikan, Gabriel Bender, Weijun Wang, Achille Brighton, Pieter-Jan Kindermans, Hanxiao Liu, Berkin Akin, Suyog Gupta, and Andrew Howard. 2021. <span>‚ÄúDiscovering Multi-Hardware Mobile Models via Architecture Search.‚Äù</span> In <em>2021 IEEE/CVF Conference on Computer Vision and Pattern Recognition Workshops (CVPRW)</em>, 3016‚Äì25. IEEE. <a href="https://doi.org/10.1109/cvprw53098.2021.00337">https://doi.org/10.1109/cvprw53098.2021.00337</a>.
</div></div></figure>
</div>
<p>Without careful benchmarking across diverse hardware configurations, the field risks favoring architectures that ‚Äúwin‚Äù the hardware lottery rather than selecting models based on their intrinsic strengths. This bias can shape research directions, influence funding allocation, and impact the design of next-generation AI systems. In extreme cases, it may even stifle innovation by discouraging exploration of alternative architectures that do not align with current hardware trends.</p>
</section>
<section id="benchmark-engineering" class="level3" data-number="12.9.2">
<h3 data-number="12.9.2" class="anchored" data-anchor-id="benchmark-engineering"><span class="header-section-number">12.9.2</span> Benchmark Engineering</h3>
<p>While the hardware lottery is an unintended consequence of hardware trends, benchmark engineering is an intentional practice where models or systems are explicitly optimized to excel on specific benchmark tests. This practice can lead to misleading performance claims and results that do not generalize beyond the benchmarking environment.</p>
<p>Benchmark engineering occurs when AI developers fine-tune hyperparameters, preprocessing techniques, or model architectures specifically to maximize benchmark scores rather than improve real-world performance. For example, an object detection model might be carefully optimized to achieve record-low latency on a benchmark but fail when deployed in dynamic, real-world environments with varying lighting, motion blur, and occlusions. Similarly, a language model might be tuned to excel on benchmark datasets but struggle when processing conversational speech with informal phrasing and code-switching.</p>
<p>The pressure to achieve high benchmark scores is often driven by competition, marketing, and research recognition. Benchmarks are frequently used to rank AI models and systems, creating an incentive to optimize specifically for them. While this can drive technical advancements, it also risks prioritizing benchmark-specific optimizations at the expense of broader generalization.</p>
</section>
<section id="bias-and-over-optimization" class="level3" data-number="12.9.3">
<h3 data-number="12.9.3" class="anchored" data-anchor-id="bias-and-over-optimization"><span class="header-section-number">12.9.3</span> Bias and Over-Optimization</h3>
<p>To ensure that benchmarks remain useful and fair, several strategies can be employed. Transparency is one of the most important factors in maintaining benchmarking integrity. Benchmark submissions should include detailed documentation on any optimizations applied, ensuring that improvements are clearly distinguished from benchmark-specific tuning. Researchers and developers should report both benchmark performance and real-world deployment results to provide a complete picture of a system‚Äôs capabilities.</p>
<p>Another approach is to diversify and evolve benchmarking methodologies. Instead of relying on a single static benchmark, AI systems should be evaluated across multiple, continuously updated benchmarks that reflect real-world complexity. This reduces the risk of models being overfitted to a single test set and encourages general-purpose improvements rather than narrow optimizations.</p>
<p>Standardization and third-party verification can also help mitigate bias. By establishing industry-wide benchmarking standards and requiring independent third-party audits of results, the AI community can improve the reliability and credibility of benchmarking outcomes. Third-party verification ensures that reported results are reproducible across different settings and helps prevent unintentional benchmark gaming.</p>
<p>Another important strategy is application-specific testing. While benchmarks provide controlled evaluations, real-world deployment testing remains essential. AI models should be assessed not only on benchmark datasets but also in practical deployment environments. For instance, an autonomous driving model should be tested in a variety of weather conditions and urban settings rather than being judged solely on controlled benchmark datasets.</p>
<p>Finally, fairness across hardware platforms must be considered. Benchmarks should test AI models on multiple hardware configurations to ensure that performance is not being driven solely by compatibility with a specific platform. This helps reduce the risk of the hardware lottery and provides a more balanced evaluation of AI system efficiency.</p>
</section>
<section id="evolving-benchmarks" class="level3" data-number="12.9.4">
<h3 data-number="12.9.4" class="anchored" data-anchor-id="evolving-benchmarks"><span class="header-section-number">12.9.4</span> Evolving Benchmarks</h3>
<p>One of the greatest challenges in benchmarking is that benchmarks are never static. As AI systems evolve, so must the benchmarks that evaluate them. What defines ‚Äúgood performance‚Äù today may be irrelevant tomorrow as models, hardware, and application requirements change. While benchmarks are essential for tracking progress, they can also quickly become outdated, leading to over-optimization for old metrics rather than real-world performance improvements.</p>
<p>This has already been evident in the evolution of AI benchmarks. Early benchmarks focused heavily on image classification and object detection, as these were some of the first widely studied deep learning tasks. However, as AI expanded into natural language processing, recommendation systems, and generative AI, it became clear that these early benchmarks no longer reflected the most important challenges in the field. In response, new benchmarks emerged to measure language understanding (GLUE, SuperGLUE), generative AI (HELM, OpenAI‚Äôs evals), and energy efficiency (MLPerf Power).</p>
<p>Benchmark evolution is not just about adding new tasks‚Äîit‚Äôs also about capturing new dimensions of performance. Traditional AI benchmarks emphasized accuracy and throughput, but modern AI applications require evaluation across fairness, robustness, scalability, and energy efficiency. For instance, AI deployed in edge environments must balance performance with power consumption, leading to benchmarks such as MLPerf Tiny that focus on resource-constrained inference. Similarly, cloud-based AI models must optimize not just for latency and accuracy, but also for cost efficiency and environmental impact, driving the need for new benchmarking methodologies.</p>
<p>The need for evolving benchmarks also presents a challenge: stability versus adaptability. On the one hand, benchmarks must remain stable for long enough to allow meaningful comparisons over time. If benchmarks change too frequently, it becomes difficult to track long-term progress and compare new results with historical performance. On the other hand, failing to update benchmarks leads to stagnation, where models are optimized for outdated tasks rather than advancing the field. Striking the right balance between benchmark longevity and adaptation is an ongoing challenge for the AI community.</p>
<p>Despite these difficulties, evolving benchmarks is essential for ensuring that AI progress remains meaningful. Without updates, benchmarks risk becoming detached from real-world needs, leading researchers and engineers to focus on optimizing models for artificial test cases rather than solving practical challenges. As AI continues to expand into new domains, benchmarking must keep pace, ensuring that performance evaluations remain relevant, fair, and aligned with real-world deployment scenarios.</p>
</section>
<section id="the-role-of-mlperf" class="level3" data-number="12.9.5">
<h3 data-number="12.9.5" class="anchored" data-anchor-id="the-role-of-mlperf"><span class="header-section-number">12.9.5</span> The Role of MLPerf</h3>
<p>MLPerf has played a crucial role in improving benchmarking by reducing bias, increasing generalizability, and ensuring benchmarks evolve alongside AI advancements. One of its key contributions is the standardization of benchmarking environments. By providing reference implementations, clearly defined rules, and reproducible test environments, MLPerf ensures that performance results are consistent across different hardware and software platforms, reducing variability in benchmarking outcomes.</p>
<p>Recognizing that AI is deployed in a variety of real-world settings, MLPerf has also introduced different categories of inference benchmarks. The inclusion of MLPerf Inference, MLPerf Mobile, MLPerf Client, and MLPerf Tiny reflects an effort to evaluate models in the contexts where they will actually be deployed. This approach mitigates issues such as the hardware lottery by ensuring that AI systems are tested across diverse computational environments, rather than being over-optimized for a single hardware type.</p>
<p>Beyond providing a structured benchmarking framework, MLPerf is continuously evolving to keep pace with the rapid progress in AI. New tasks are incorporated into benchmarks to reflect emerging challenges, such as generative AI models and energy-efficient computing, ensuring that evaluations remain relevant and forward-looking. By regularly updating its benchmarking methodologies, MLPerf helps prevent benchmarks from becoming outdated or encouraging overfitting to legacy performance metrics.</p>
<p>By prioritizing fairness, transparency, and adaptability, MLPerf ensures that benchmarking remains a meaningful tool for guiding AI research and deployment. Instead of simply measuring raw speed or accuracy, MLPerf‚Äôs evolving benchmarks aim to capture the complexities of real-world AI performance, ultimately fostering more reliable, efficient, and impactful AI systems.</p>
</section>
</section>
<section id="beyond-ml-system-benchmarking" class="level2 page-columns page-full" data-number="12.10">
<h2 data-number="12.10" class="anchored" data-anchor-id="beyond-ml-system-benchmarking"><span class="header-section-number">12.10</span> Beyond ML System Benchmarking</h2>
<p>While this chapter has primarily focused on system benchmarking, AI performance is not determined by system efficiency alone. Machine learning models and datasets play an equally crucial role in shaping AI capabilities. Model benchmarking evaluates algorithmic performance, while data benchmarking ensures that training datasets are high-quality, unbiased, and representative of real-world distributions. Understanding these aspects is vital because AI systems are not just computational pipelines‚Äîthey are deeply dependent on the models they execute and the data they are trained on.</p>
<section id="model-benchmarking" class="level3 page-columns page-full" data-number="12.10.1">
<h3 data-number="12.10.1" class="anchored" data-anchor-id="model-benchmarking"><span class="header-section-number">12.10.1</span> Model Benchmarking</h3>
<p>Model benchmarks measure how well different machine learning algorithms perform on specific tasks. Historically, benchmarks focused almost exclusively on accuracy, but as models have grown more complex, additional factors‚Äîsuch as fairness, robustness, efficiency, and generalizability‚Äîhave become equally important.</p>
<p>Over the years, datasets have driven model innovation. The <a href="https://www.tensorflow.org/datasets/catalog/mnist">MNIST dataset</a> <span class="citation" data-cites="lecun1998gradient">(<a href="../references.html#ref-lecun1998gradient" role="doc-biblioref">Lecun et al. 1998</a>)</span> was one of the earliest used for handwritten digit recognition, while the <a href="https://www.image-net.org/">ImageNet dataset</a> <span class="citation" data-cites="deng2009imagenet">(<a href="../references.html#ref-deng2009imagenet" role="doc-biblioref">Deng et al. 2009</a>)</span> led to breakthroughs in deep learning for image classification. More recently, datasets like <a href="https://cocodataset.org/">COCO</a> <span class="citation" data-cites="lin2014microsoft">(<a href="../references.html#ref-lin2014microsoft" role="doc-biblioref">Lin et al. 2014</a>)</span> for object detection and <a href="https://arxiv.org/abs/2005.14165">GPT-3‚Äôs training corpus</a> <span class="citation" data-cites="brown2020language">(<a href="../references.html#ref-brown2020language" role="doc-biblioref">Brown et al. 2020</a>)</span> have pushed model capabilities further.</p>
<div class="no-row-height column-margin column-container"><div id="ref-lecun1998gradient" class="csl-entry" role="listitem">
Lecun, Y., L. Bottou, Y. Bengio, and P. Haffner. 1998. <span>‚ÄúGradient-Based Learning Applied to Document Recognition.‚Äù</span> <em>Proceedings of the IEEE</em> 86 (11): 2278‚Äì2324. <a href="https://doi.org/10.1109/5.726791">https://doi.org/10.1109/5.726791</a>.
</div><div id="ref-deng2009imagenet" class="csl-entry" role="listitem">
Deng, Jia, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Li Fei-Fei. 2009. <span>‚ÄúImageNet: A Large-Scale Hierarchical Image Database.‚Äù</span> In <em>2009 IEEE Conference on Computer Vision and Pattern Recognition</em>, 248‚Äì55. Ieee; IEEE. <a href="https://doi.org/10.1109/cvpr.2009.5206848">https://doi.org/10.1109/cvpr.2009.5206848</a>.
</div><div id="ref-lin2014microsoft" class="csl-entry" role="listitem">
Lin, Tsung-Yi, Michael Maire, Serge Belongie, James Hays, Pietro Perona, Deva Ramanan, Piotr Doll√°r, and C. Lawrence Zitnick. 2014. <span>‚ÄúMicrosoft COCO: Common Objects in Context.‚Äù</span> In <em>Computer Vision ‚Äì ECCV 2014</em>, 740‚Äì55. Springer; Springer International Publishing. <a href="https://doi.org/10.1007/978-3-319-10602-1\_48">https://doi.org/10.1007/978-3-319-10602-1\_48</a>.
</div><div id="ref-brown2020language" class="csl-entry" role="listitem">
Brown, Tom B., Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhariwal, Arvind Neelakantan, et al. 2020. <span>‚ÄúLanguage Models Are Few-Shot Learners.‚Äù</span> Edited by Hugo Larochelle, Marc‚ÄôAurelio Ranzato, Raia Hadsell, Maria-Florina Balcan, and Hsuan-Tien Lin. <em>Advances in Neural Information Processing Systems</em> 33 (May): 1877‚Äì1901. <a href="https://doi.org/10.48550/arxiv.2005.14165">https://doi.org/10.48550/arxiv.2005.14165</a>.
</div><div id="ref-buolamwini2018gender" class="csl-entry" role="listitem">
Buolamwini, Joy, and Timnit Gebru. 2018. <span>‚ÄúGender Shades: Intersectional Accuracy Disparities in Commercial Gender Classification.‚Äù</span> In <em>Conference on Fairness, Accountability and Transparency</em>, 77‚Äì91. PMLR. <a href="http://proceedings.mlr.press/v81/buolamwini18a.html">http://proceedings.mlr.press/v81/buolamwini18a.html</a>.
</div></div><p>However, model benchmarks have limitations. Many models optimized for benchmarks fail in real-world conditions, a challenge known as the Sim2Real gap. For instance, high-performance models may be overfit to benchmark datasets, leading to poor generalization in real-world environments. Similarly, bias remains a significant issue. The <a href="http://gendershades.org/">Gender Shades project</a> <span class="citation" data-cites="buolamwini2018gender">(<a href="../references.html#ref-buolamwini2018gender" role="doc-biblioref">Buolamwini and Gebru 2018</a>)</span> showed that commercial facial recognition models performed far worse on darker-skinned individuals, underscoring the importance of evaluating fairness alongside accuracy. These challenges highlight the need to go beyond isolated accuracy metrics and develop benchmarks that test generalization, fairness, and efficiency under diverse conditions.</p>
<p>Emerging model benchmarks now evaluate:</p>
<ul>
<li>Computational efficiency, measured by floating-point operations (FLOPs) <span class="citation" data-cites="bianco2018benchmark">(<a href="../references.html#ref-bianco2018benchmark" role="doc-biblioref">Bianco et al. 2018</a>)</span>.<br>
</li>
<li>Adversarial robustness, as seen in ImageNet-A <span class="citation" data-cites="hendrycks2021natural">(<a href="../references.html#ref-hendrycks2021natural" role="doc-biblioref">Hendrycks et al. 2021</a>)</span> and ImageNet-C <span class="citation" data-cites="xie2020adversarial">(<a href="../references.html#ref-xie2020adversarial" role="doc-biblioref">Xie et al. 2020</a>)</span>.<br>
</li>
<li>Generalization to unseen data, studied in benchmarks like <a href="https://wilds.stanford.edu/">WILDS</a> <span class="citation" data-cites="koh2021wilds">(<a href="../references.html#ref-koh2021wilds" role="doc-biblioref">Koh et al. 2021</a>)</span>.<br>
</li>
<li>Fairness and bias, measured by tools like <a href="https://ai-fairness-360.org/">AI Fairness 360</a>.</li>
</ul>
<div class="no-row-height column-margin column-container"><div id="ref-bianco2018benchmark" class="csl-entry" role="listitem">
Bianco, Simone, Remi Cadene, Luigi Celona, and Paolo Napoletano. 2018. <span>‚ÄúBenchmark Analysis of Representative Deep Neural Network Architectures.‚Äù</span> <em>IEEE Access</em> 6: 64270‚Äì77. <a href="https://doi.org/10.1109/access.2018.2877890">https://doi.org/10.1109/access.2018.2877890</a>.
</div><div id="ref-hendrycks2021natural" class="csl-entry" role="listitem">
Hendrycks, Dan, Kevin Zhao, Steven Basart, Jacob Steinhardt, and Dawn Song. 2021. <span>‚ÄúNatural Adversarial Examples.‚Äù</span> In <em>2021 IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR)</em>, 15257‚Äì66. IEEE. <a href="https://doi.org/10.1109/cvpr46437.2021.01501">https://doi.org/10.1109/cvpr46437.2021.01501</a>.
</div><div id="ref-xie2020adversarial" class="csl-entry" role="listitem">
Xie, Cihang, Mingxing Tan, Boqing Gong, Jiang Wang, Alan L. Yuille, and Quoc V. Le. 2020. <span>‚ÄúAdversarial Examples Improve Image Recognition.‚Äù</span> In <em>2020 IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR)</em>, 816‚Äì25. IEEE. <a href="https://doi.org/10.1109/cvpr42600.2020.00090">https://doi.org/10.1109/cvpr42600.2020.00090</a>.
</div></div></section>
<section id="data-benchmarking" class="level3 page-columns page-full" data-number="12.10.2">
<h3 data-number="12.10.2" class="anchored" data-anchor-id="data-benchmarking"><span class="header-section-number">12.10.2</span> Data Benchmarking</h3>
<p>The evolution of artificial intelligence has traditionally focused on model-centric approaches, emphasizing architectural improvements and optimization techniques. However, contemporary AI development reveals that data quality, rather than model design alone, often determines performance boundaries. This recognition has elevated data benchmarking to a critical field that ensures AI models learn from datasets that are high-quality, diverse, and free from bias.</p>
<p>This shift toward data-centric AI development reflects a fundamental understanding: superior data quality, not just sophisticated models, produces more reliable and robust AI systems. Initiatives like DataPerf and DataComp have emerged to systematically evaluate how dataset improvements affect model performance. DataComp <span class="citation" data-cites="gadre2024datacomp">(<a href="../references.html#ref-gadre2024datacomp" role="doc-biblioref">Gadre et al. 2024</a>)</span> notably demonstrated that models trained on a carefully curated 30% subset of data achieved better results than those trained on the complete dataset, emphasizing that thoughtful data selection surpasses mere volume in importance <span class="citation" data-cites="northcutt2021pervasive">(<a href="../references.html#ref-northcutt2021pervasive" role="doc-biblioref">Northcutt, Athalye, and Mueller 2021</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-gadre2024datacomp" class="csl-entry" role="listitem">
Gadre, Samir Yitzhak, Gabriel Ilharco, Alex Fang, Jonathan Hayase, Georgios Smyrnis, Thao Nguyen, Ryan Marten, et al. 2024. <span>‚ÄúDatacomp: In Search of the Next Generation of Multimodal Datasets.‚Äù</span> <em>Advances in Neural Information Processing Systems</em> 36.
</div><div id="ref-northcutt2021pervasive" class="csl-entry" role="listitem">
Northcutt, Curtis G., Anish Athalye, and Jonas Mueller. 2021. <span>‚ÄúPervasive Label Errors in Test Sets Destabilize Machine Learning Benchmarks.‚Äù</span> <em>Advances in Neural Information Processing Systems</em> 34: 19075‚Äì90. <a href="https://doi.org/10.48550/arxiv.2103.14749">https://doi.org/10.48550/arxiv.2103.14749</a>.
</div></div><p>Dataset saturation presents a significant challenge in data benchmarking. With models achieving near-perfect accuracy on benchmarks like ImageNet, researchers must question whether these improvements represent genuine advances in AI capability or merely optimization to existing test sets. <a href="#fig-dataset-saturation" class="quarto-xref">Figure&nbsp;<span>12.5</span></a> illustrates this trend, showing AI systems surpassing human performance (marked by the horizontal line at 0) across various applications including handwriting recognition, speech recognition, image recognition, reading comprehension, and language understanding over the past decade.</p>
<div id="fig-dataset-saturation" class="quarto-float quarto-figure quarto-figure-center anchored page-columns page-full">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-dataset-saturation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/png/dynabench.png" class="lightbox" data-gallery="quarto-lightbox-gallery-6" title="Figure&nbsp;12.5: AI vs human performane. Source: @kiela2021dynabench"><img src="images/png/dynabench.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-dataset-saturation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;12.5: AI vs human performane. Source: <span class="citation" data-cites="kiela2021dynabench">Kiela et al. (<a href="../references.html#ref-kiela2021dynabench" role="doc-biblioref">2021</a>)</span>
</figcaption>
<div class="no-row-height column-margin column-container"></div></figure>
</div>
<p>The saturation of popular evaluation datasets raises important methodological questions <span class="citation" data-cites="kiela2021dynabench">(<a href="../references.html#ref-kiela2021dynabench" role="doc-biblioref">Kiela et al. 2021</a>)</span>. Consider the MNIST handwritten digit dataset: some test images that appear illegible to human observers were assigned specific labels during the dataset‚Äôs creation in 1994. When models correctly predict these labels, they may appear to demonstrate superhuman performance, but in reality, they might simply be learning dataset-specific patterns rather than developing genuine digit recognition capabilities.</p>
<div class="no-row-height column-margin column-container"><div id="ref-kiela2021dynabench" class="csl-entry" role="listitem">
Kiela, Douwe, Max Bartolo, Yixin Nie, Divyansh Kaushik, Atticus Geiger, Zhengxuan Wu, Bertie Vidgen, et al. 2021. <span>‚ÄúDynabench: Rethinking Benchmarking in NLP.‚Äù</span> <em>arXiv Preprint arXiv:2104.14337</em>, April, 4110‚Äì24. <a href="https://doi.org/10.18653/v1/2021.naacl-main.324">https://doi.org/10.18653/v1/2021.naacl-main.324</a>.
</div><div id="ref-beyer2020we" class="csl-entry" role="listitem">
Beyer, Lucas, Olivier J. H√©naff, Alexander Kolesnikov, Xiaohua Zhai, and A√§ron van den Oord. 2020. <span>‚ÄúAre We Done with ImageNet?‚Äù</span> <em>arXiv Preprint arXiv:2006.07159</em>, June. <a href="http://arxiv.org/abs/2006.07159v1">http://arxiv.org/abs/2006.07159v1</a>.
</div></div><p>This phenomenon extends beyond computer vision. The question ‚ÄúAre we done with ImageNet?‚Äù <span class="citation" data-cites="beyer2020we">(<a href="../references.html#ref-beyer2020we" role="doc-biblioref">Beyer et al. 2020</a>)</span> reflects broader concerns about the limitations of optimizing model architecture for fixed datasets. More critically, models trained on static datasets often struggle with distribution shifts‚Äîreal-world changes that occur after the training data was collected. This challenge has prompted the development of dynamic benchmarking approaches, such as Dynabench <span class="citation" data-cites="kiela2021dynabench">(<a href="../references.html#ref-kiela2021dynabench" role="doc-biblioref">Kiela et al. 2021</a>)</span>, which continuously updates test data based on model performance to prevent overfitting.</p>
<p>Current data benchmarking efforts focus on:</p>
<ul>
<li>Label quality, as explored in <a href="https://www.dataperf.org/">DataPerf‚Äôs debugging challenge</a>.<br>
</li>
<li>Bias and representation, studied in datasets like <a href="https://arxiv.org/pdf/1804.03209.pdf">MSWC</a> for speech recognition.<br>
</li>
<li>Out-of-distribution generalization, tested in benchmarks like RxRx and WILDS <span class="citation" data-cites="koh2021wilds">(<a href="../references.html#ref-koh2021wilds" role="doc-biblioref">Koh et al. 2021</a>)</span>.</li>
</ul>
<div class="no-row-height column-margin column-container"><div id="ref-koh2021wilds" class="csl-entry" role="listitem">
Koh, Pang Wei, Shiori Sagawa, Henrik Marklund, Sang Michael Xie, Marvin Zhang, Akshay Balsubramani, Weihua Hu, et al. 2021. <span>‚ÄúWILDS: A Benchmark of in-the-Wild Distribution Shifts.‚Äù</span> In <em>Proceedings of the 38th International Conference on Machine Learning, ICML 2021, 18-24 July 2021, Virtual Event</em>, edited by Marina Meila and Tong Zhang, 139:5637‚Äì64. Proceedings of Machine Learning Research. PMLR. <a href="http://proceedings.mlr.press/v139/koh21a.html">http://proceedings.mlr.press/v139/koh21a.html</a>.
</div></div></section>
<section id="the-benchmarking-trifecta" class="level3" data-number="12.10.3">
<h3 data-number="12.10.3" class="anchored" data-anchor-id="the-benchmarking-trifecta"><span class="header-section-number">12.10.3</span> The Benchmarking Trifecta</h3>
<p>AI benchmarking has traditionally evaluated systems, models, and data separately, but real-world AI performance emerges from the interplay between these three components. A fast system cannot compensate for a poorly trained model, and a powerful model is only as good as the data it learns from.</p>
<p>The future of benchmarking lies in an integrated approach that evaluates how system efficiency, model performance, and data quality interact. This trifecta of benchmarking will allow researchers to uncover new optimization opportunities that are invisible when these components are analyzed in isolation. For instance, co-designing efficient AI models with optimized hardware and curated datasets can lead to better performance with lower computational cost.</p>
<p>As AI continues to evolve, benchmarking must evolve with it. Understanding AI performance requires evaluating systems, models, and data together, ensuring that benchmarks drive not just higher accuracy, but also efficiency, fairness, and robustness. This holistic perspective will be critical for building AI that is not only powerful, but also practical and ethical.</p>
<div id="fig-benchmarking-trifecta" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-benchmarking-trifecta-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/png/benchmarking_trifecta.png" class="lightbox" data-gallery="quarto-lightbox-gallery-7" title="Figure&nbsp;12.6: Benchmarking trifecta."><img src="images/png/benchmarking_trifecta.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-benchmarking-trifecta-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;12.6: Benchmarking trifecta.
</figcaption>
</figure>
</div>
</section>
</section>
<section id="conclusion" class="level2" data-number="12.11">
<h2 data-number="12.11" class="anchored" data-anchor-id="conclusion"><span class="header-section-number">12.11</span> Conclusion</h2>
<p><em>‚ÄúWhat gets measured gets improved.‚Äù</em> Benchmarking plays a foundational role in the advancement of AI, providing the essential measurements needed to track progress, identify limitations, and drive innovation. This chapter has explored the multifaceted nature of benchmarking, spanning systems, models, and data, and has highlighted its critical role in optimizing AI performance across different dimensions.</p>
<p>ML system benchmarks enable optimizations in speed, efficiency, and scalability, ensuring that hardware and infrastructure can support increasingly complex AI workloads. Model benchmarks provide standardized tasks and evaluation metrics beyond accuracy, driving progress in algorithmic innovation. Data benchmarks, meanwhile, reveal key issues related to data quality, bias, and representation, ensuring that AI models are built on fair and diverse datasets.</p>
<p>While these components‚Äîsystems, models, and data‚Äîare often evaluated in isolation, future benchmarking efforts will likely adopt a more integrated approach. By measuring the interplay between system, model, and data benchmarks, AI researchers and engineers can uncover new insights into the co-design of data, algorithms, and infrastructure. This holistic perspective will be essential as AI applications grow more sophisticated and are deployed across increasingly diverse environments.</p>
<p>Benchmarking is not static‚Äîit must continuously evolve to capture new AI capabilities, address emerging challenges, and refine evaluation methodologies. As AI systems become more complex and influential, the need for rigorous, transparent, and socially beneficial benchmarking standards becomes even more pressing. Achieving this requires close collaboration between industry, academia, and standardization bodies to ensure that benchmarks remain relevant, unbiased, and aligned with real-world needs.</p>
<p>Ultimately, benchmarking serves as the compass that guides AI progress. By persistently measuring and openly sharing results, we can navigate toward AI systems that are performant, robust, and trustworthy. However, benchmarking must also be aligned with human-centered principles, ensuring that AI serves society in a fair and ethical manner. The future of benchmarking is already expanding into new frontiers, including the evaluation of AI safety, fairness, and generative AI models, which will shape the next generation of AI benchmarks. These topics, while beyond the scope of this chapter, will be explored further in the discussion on Generative AI.</p>
<p>For those interested in emerging trends in AI benchmarking, the article <em><a href="https://towardsdatascience.com/the-olympics-of-ai-benchmarking-machine-learning-systems-c4b2051fbd2b">The Olympics of AI: Benchmarking Machine Learning Systems</a></em> provides a broader look at benchmarking efforts in robotics, extended reality, and neuromorphic computing. As benchmarking continues to evolve, it remains an essential tool for understanding, improving, and shaping the future of AI.</p>
</section>
<section id="sec-benchmarking-ai-resource" class="level2" data-number="12.12">
<h2 data-number="12.12" class="anchored" data-anchor-id="sec-benchmarking-ai-resource"><span class="header-section-number">12.12</span> Resources</h2>
<p>Here is a curated list of resources to support students and instructors in their learning and teaching journeys. We are continuously working on expanding this collection and will add new exercises soon.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-9-contents" aria-controls="callout-9" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Slides
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-9" class="callout-9-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>These slides are a valuable tool for instructors to deliver lectures and for students to review the material at their own pace. We encourage students and instructors to leverage these slides to improve their understanding and facilitate effective knowledge transfer.</p>
<ul>
<li><p><a href="https://docs.google.com/presentation/d/17udz3gxeYF3r3X1r4ePwu1I9H8ljb53W3ktFSmuDlGs/edit?usp=drive_link&amp;resourcekey=0-Espn0a0x81kl2txL_jIWjw">Why is benchmarking important?</a></p></li>
<li><p><a href="https://docs.google.com/presentation/d/18PI_0xmcW1xwwfcjmj25PikqBM_92vQfOXFV4hah-6I/edit?resourcekey=0-KO3HQcDAsR--jgbKd5cp4w#slide=id.g94db9f9f78_0_2">Embedded inference benchmarking.</a></p></li>
</ul>
</div>
</div>
</div>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-10-contents" aria-controls="callout-10" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Videos
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-10" class="callout-10-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<ul>
<li><em>Coming soon.</em></li>
</ul>
</div>
</div>
</div>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-11-contents" aria-controls="callout-11" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercises
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-11" class="callout-11-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>To reinforce the concepts covered in this chapter, we have curated a set of exercises that challenge students to apply their knowledge and deepen their understanding.</p>
<ul>
<li><a href="#exr-cuda" class="quarto-xref">Exercise&nbsp;<span>12.1</span></a></li>
</ul>
<!-- * @exr-perf -->
</div>
</div>
</div>



</section>


</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
});
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
<script>
function loadGiscusWhenReady() {
  // Function to get the theme based on body class
  const getTheme = () => {
    const baseTheme = document.getElementById('giscus-base-theme').value;
    const altTheme = document.getElementById('giscus-alt-theme').value;
    return document.body.classList.contains('quarto-dark') ? altTheme : baseTheme;
  };
  // Create the Giscus script and add it to the desired location
  const loadGiscus = () => {
    const script = document.createElement("script");
    script.src = "https://giscus.app/client.js";
    script.async = true;
    script.dataset.repo = "harvard-edge/cs249r_book";
    script.dataset.repoId = "R_kgDOKQSOaw";
    script.dataset.category = "General";
    script.dataset.categoryId = "DIC_kwDOKQSOa84CZ8Ry";
    script.dataset.mapping = "title";
    script.dataset.reactionsEnabled = "1";
    script.dataset.emitMetadata = "0";
    script.dataset.inputPosition = "top";
    script.dataset.theme = getTheme();
    script.dataset.lang = "en";
    script.crossOrigin = "anonymous";
    // Append the script to the desired div instead of at the end of the body
    document.getElementById("quarto-content").appendChild(script);
  };
  // MutationObserver to detect when the 'quarto-light' or 'quarto-dark' class is added to the body
  const observer = new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type === "attributes" && mutation.attributeName === "class") {
        if (document.body.classList.contains('quarto-light') || document.body.classList.contains('quarto-dark')) {
          loadGiscus();
          observer.disconnect(); // Stop observing once Giscus is loaded
          break;
        }
      }
    }
  });
  // Start observing the body for class attribute changes
  observer.observe(document.body, {
    attributes: true,
    attributeFilter: ["class"],
  });
}
loadGiscusWhenReady();
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../../contents/core/hw_acceleration/hw_acceleration.html" class="pagination-link" aria-label="AI Acceleration">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">AI Acceleration</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../../contents/core/ops/ops.html" class="pagination-link" aria-label="ML Operations">
        <span class="nav-page-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">ML Operations</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Written, edited and curated by Prof.&nbsp;Vijay Janapa Reddi (Harvard University)</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/harvard-edge/cs249r_book/edit/dev/contents/core/benchmarking/benchmarking.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/harvard-edge/cs249r_book/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li><li><a href="https://github.com/harvard-edge/cs249r_book/blob/dev/contents/core/benchmarking/benchmarking.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>This book was built with <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>