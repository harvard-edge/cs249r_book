<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.22">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>7&nbsp; AI Frameworks – Machine Learning Systems</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../contents/core/training/training.html" rel="next">
<link href="../../../contents/core/data_engineering/data_engineering.html" rel="prev">
<link href="../../../favicon.png" rel="icon" type="image/png">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-dark-34508e5e58b8127575b7405b0c3a6b03.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-68bca3a50acd80feb0cb8c3c361c6f22.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-dark-d167033a53f69da842b30d500eb1a98e.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../../site_libs/bootstrap/bootstrap-be4537a5adc4a6810fd8df2b6c24e47a.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<script src="../../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "~",
    "/"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-M21L0CBCVN"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-M21L0CBCVN', { 'anonymize_ip': true});
</script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-M21L0CBCVN"></script>
<script type="module" src="../../../scripts/ai_menu/dist/bundle.js" defer=""></script>
<script type="module" src="../../../scripts/ai_menu/dist/sqlite3-opfs-async-proxy-B_ImRJXp.js"></script>
<script type="module" src="../../../scripts/ai_menu/dist/sqlite3-worker1-bundler-friendly-CbDNa4by.js"></script>
<script type="module" src="../../../scripts/ai_menu/dist/worker-voUF5YDa.js"></script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating nav-fixed slimcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Machine Learning Systems</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-wide tools-end">
    <a href="https://github.com/harvard-edge/cs249r_book" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="../../../Machine-Learning-Systems.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
    <div class="dropdown">
      <a href="" title="Share" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" role="link" aria-label="Share"><i class="bi bi-share"></i></a>
      <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item quarto-navbar-tools-item" href="https://twitter.com/intent/tweet?url=|url|">
              <i class="bi bi-twitter pe-1"></i>
            Twitter
            </a>
          </li>
          <li>
            <a class="dropdown-item quarto-navbar-tools-item" href="https://www.facebook.com/sharer/sharer.php?u=|url|">
              <i class="bi bi-facebook pe-1"></i>
            Facebook
            </a>
          </li>
      </ul>
    </div>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../contents/core/frameworks/frameworks.html"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">AI Frameworks</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
  <div id="quarto-announcement" data-announcement-id="516b1a1219b9ad93e03bf11eebdf0272" class="alert alert-primary hidden"><i class="bi bi-book quarto-announcement-icon"></i><div class="quarto-announcement-content">
🔔 <b>What’s New in the Book?</b><br> 📘 <b>[May 05]:</b> Revised Ch. 14 (<i>On-Device Learning</i> 📱).<br> 🛠️ <b>[Mar 25]:</b> Major updates to Ch. 13 (<i>ML Operations</i> ⚙️), Ch. 17–19 (<i>Sustainable AI</i> 🌿, <i>Robust AI</i> 🛡️, <i>AI for Good</i> 🌍).<br> 🚀 <b>[Mar 03]:</b> Updated Ch. 10 (<i>AI Acceleration</i>) &amp; Ch. 12 (<i>Benchmarking AI</i> 📊).<br> ⚡ <b>[Feb 02]:</b> Updates to Ch. 8 (<i>AI Training</i> 🏋️) &amp; Ch. 9 (<i>Efficient AI</i>).<br> 📚 <b>[Jan 16]:</b> Expanded Ch. 1–7 + brand-new Ch. 4! 🔢<br> 🗒️ <b>More Updates:</b> <a href="contents/frontmatter/changelog/changelog.html">See the Full Changelog</a>.<br>
<div style="height: 1px; background-color: #ccc; margin: 5px 0;">

</div>
<p>🌍 <b>Shaping the Future:</b> Every GitHub ⭐ supports global AI education and open learning.<br> 🙏 <b>Support the Mission:</b> Your ⭐ keeps this resource free, high-quality, and evolving.<br> ✍️ <b>Keep It Growing:</b> A ⭐ a day keeps Vijay writing all day! → <a href="https://github.com/harvard-edge/cs249r_book"><b>Star the book on GitHub</b></a></p>
</div><i class="bi bi-x-lg quarto-announcement-action"></i></div>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/foreword.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Author’s Note</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/about/about.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About the Book</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/changelog/changelog.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Book Changelog</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/acknowledgements/acknowledgements.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Acknowledgements</span></a>
  </div>
</li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/frontmatter/ai/socratiq.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">SocratiQ AI</span></a>
  </div>
</li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text"><div class="part">AI Essentials</div></span></span>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/introduction/introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ml_systems/ml_systems.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">ML Systems</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/dl_primer/dl_primer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">DL Primer</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/dnn_architectures/dnn_architectures.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">DNN Architectures</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text"><div class="part">AI Engineering Principles</div></span></span>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/workflow/workflow.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">AI Workflow</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/data_engineering/data_engineering.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Data Engineering</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/frameworks/frameworks.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">AI Frameworks</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/training/training.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">AI Training</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/efficient_ai/efficient_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Efficient AI</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/optimizations/optimizations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Model Optimizations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/hw_acceleration/hw_acceleration.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">AI Acceleration</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/benchmarking/benchmarking.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Benchmarking AI</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ops/ops.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">ML Operations</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text"><div class="part">AI Best Practices</div></span></span>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ondevice_learning/ondevice_learning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">On-Device Learning</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/privacy_security/privacy_security.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Security &amp; Privacy</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/responsible_ai/responsible_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Responsible AI</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/sustainable_ai/sustainable_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Sustainable AI</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/robust_ai/robust_ai.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Robust AI</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text"><div class="part">AI Perspectives</div></span></span>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/ai_for_good/ai_for_good.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">AI for Good</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/conclusion/conclusion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Conclusion</span></span></a>
  </div>
</li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text">LABS</span></span>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/overview.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Overview</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/getting_started.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Getting Started</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../contents/labs/arduino/nicla_vision/nicla_vision.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Nicla Vision</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/setup/setup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Setup</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/image_classification/image_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Image Classification</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/object_detection/object_detection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Object Detection</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/kws/kws.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Keyword Spotting (KWS)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/arduino/nicla_vision/motion_classification/motion_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Motion Classification and Anomaly Detection</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../contents/labs/seeed/xiao_esp32s3/xiao_esp32s3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">XIAO ESP32S3</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/setup/setup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Setup</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/image_classification/image_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Image Classification</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/object_detection/object_detection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Object Detection</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/kws/kws.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Keyword Spotting (KWS)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/seeed/xiao_esp32s3/motion_classification/motion_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Motion Classification and Anomaly Detection</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../contents/labs/raspi/raspi.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Raspberry Pi</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-8" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/setup/setup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Setup</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/image_classification/image_classification.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Image Classification</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/object_detection/object_detection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Object Detection</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/llm/llm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Small Language Models (SLM)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/raspi/vlm/vlm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Vision-Language Models (VLM)</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../contents/labs/shared/shared.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Shared Labs</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-9" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/shared/kws_feature_eng/kws_feature_eng.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">KWS Feature Engineering</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/labs/shared/dsp_spectral_features_block/dsp_spectral_features_block.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">DSP Spectral Features</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-10" role="navigation" aria-expanded="false">
 <span class="menu-text">Appendix</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-10" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-10" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/appendix/phd_survival_guide.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">PhD Survival Guide</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="px-0"><hr class="sidebar-divider hi "></li>
        <li class="sidebar-item sidebar-item-section">
      <span class="sidebar-item-text sidebar-link text-start">
 <span class="menu-text">REFERENCES</span></span>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../contents/core/references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#purpose" id="toc-purpose" class="nav-link active" data-scroll-target="#purpose">Purpose</a></li>
  <li><a href="#overview" id="toc-overview" class="nav-link" data-scroll-target="#overview"><span class="header-section-number">7.1</span> Overview</a></li>
  <li><a href="#evolution-history" id="toc-evolution-history" class="nav-link" data-scroll-target="#evolution-history"><span class="header-section-number">7.2</span> Evolution History</a>
  <ul>
  <li><a href="#evolution-timeline" id="toc-evolution-timeline" class="nav-link" data-scroll-target="#evolution-timeline"><span class="header-section-number">7.2.1</span> Evolution Timeline</a></li>
  <li><a href="#early-numerical-libraries" id="toc-early-numerical-libraries" class="nav-link" data-scroll-target="#early-numerical-libraries"><span class="header-section-number">7.2.2</span> Early Numerical Libraries</a></li>
  <li><a href="#first-generation-frameworks" id="toc-first-generation-frameworks" class="nav-link" data-scroll-target="#first-generation-frameworks"><span class="header-section-number">7.2.3</span> First-Generation Frameworks</a></li>
  <li><a href="#emergence-of-deep-learning-frameworks" id="toc-emergence-of-deep-learning-frameworks" class="nav-link" data-scroll-target="#emergence-of-deep-learning-frameworks"><span class="header-section-number">7.2.4</span> Emergence of Deep Learning Frameworks</a></li>
  <li><a href="#hardware-impact-on-design" id="toc-hardware-impact-on-design" class="nav-link" data-scroll-target="#hardware-impact-on-design"><span class="header-section-number">7.2.5</span> Hardware Impact on Design</a></li>
  </ul></li>
  <li><a href="#fundamental-concepts" id="toc-fundamental-concepts" class="nav-link" data-scroll-target="#fundamental-concepts"><span class="header-section-number">7.3</span> Fundamental Concepts</a>
  <ul>
  <li><a href="#computational-graphs" id="toc-computational-graphs" class="nav-link" data-scroll-target="#computational-graphs"><span class="header-section-number">7.3.1</span> Computational Graphs</a>
  <ul class="collapse">
  <li><a href="#basic-concepts" id="toc-basic-concepts" class="nav-link" data-scroll-target="#basic-concepts">Basic Concepts</a></li>
  <li><a href="#static-graphs" id="toc-static-graphs" class="nav-link" data-scroll-target="#static-graphs">Static Graphs</a></li>
  <li><a href="#dynamic-graphs" id="toc-dynamic-graphs" class="nav-link" data-scroll-target="#dynamic-graphs">Dynamic Graphs</a></li>
  <li><a href="#system-consequences" id="toc-system-consequences" class="nav-link" data-scroll-target="#system-consequences">System Consequences</a></li>
  </ul></li>
  <li><a href="#automatic-differentiation" id="toc-automatic-differentiation" class="nav-link" data-scroll-target="#automatic-differentiation"><span class="header-section-number">7.3.2</span> Automatic Differentiation</a>
  <ul class="collapse">
  <li><a href="#computational-methods" id="toc-computational-methods" class="nav-link" data-scroll-target="#computational-methods">Computational Methods</a></li>
  <li><a href="#integration-with-frameworks" id="toc-integration-with-frameworks" class="nav-link" data-scroll-target="#integration-with-frameworks">Integration with Frameworks</a></li>
  <li><a href="#memory-consequences" id="toc-memory-consequences" class="nav-link" data-scroll-target="#memory-consequences">Memory Consequences</a></li>
  <li><a href="#system-considerations" id="toc-system-considerations" class="nav-link" data-scroll-target="#system-considerations">System Considerations</a></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a></li>
  </ul></li>
  <li><a href="#data-structures" id="toc-data-structures" class="nav-link" data-scroll-target="#data-structures"><span class="header-section-number">7.3.3</span> Data Structures</a>
  <ul class="collapse">
  <li><a href="#tensors" id="toc-tensors" class="nav-link" data-scroll-target="#tensors">Tensors</a></li>
  <li><a href="#specialized-structures" id="toc-specialized-structures" class="nav-link" data-scroll-target="#specialized-structures">Specialized Structures</a></li>
  </ul></li>
  <li><a href="#programming-models" id="toc-programming-models" class="nav-link" data-scroll-target="#programming-models"><span class="header-section-number">7.3.4</span> Programming Models</a>
  <ul class="collapse">
  <li><a href="#symbolic-programming" id="toc-symbolic-programming" class="nav-link" data-scroll-target="#symbolic-programming">Symbolic Programming</a></li>
  <li><a href="#imperative-programming" id="toc-imperative-programming" class="nav-link" data-scroll-target="#imperative-programming">Imperative Programming</a></li>
  <li><a href="#system-implementation-considerations" id="toc-system-implementation-considerations" class="nav-link" data-scroll-target="#system-implementation-considerations">System Implementation Considerations</a></li>
  </ul></li>
  <li><a href="#execution-models" id="toc-execution-models" class="nav-link" data-scroll-target="#execution-models"><span class="header-section-number">7.3.5</span> Execution Models</a>
  <ul class="collapse">
  <li><a href="#eager-execution" id="toc-eager-execution" class="nav-link" data-scroll-target="#eager-execution">Eager Execution</a></li>
  <li><a href="#graph-execution" id="toc-graph-execution" class="nav-link" data-scroll-target="#graph-execution">Graph Execution</a></li>
  <li><a href="#just-in-time-compilation" id="toc-just-in-time-compilation" class="nav-link" data-scroll-target="#just-in-time-compilation">Just-In-Time Compilation</a></li>
  <li><a href="#distributed-execution" id="toc-distributed-execution" class="nav-link" data-scroll-target="#distributed-execution">Distributed Execution</a></li>
  </ul></li>
  <li><a href="#core-operations" id="toc-core-operations" class="nav-link" data-scroll-target="#core-operations"><span class="header-section-number">7.3.6</span> Core Operations</a>
  <ul class="collapse">
  <li><a href="#hardware-abstraction-operations" id="toc-hardware-abstraction-operations" class="nav-link" data-scroll-target="#hardware-abstraction-operations">Hardware Abstraction Operations</a></li>
  <li><a href="#basic-numerical-operations" id="toc-basic-numerical-operations" class="nav-link" data-scroll-target="#basic-numerical-operations">Basic Numerical Operations</a></li>
  <li><a href="#system-level-operations" id="toc-system-level-operations" class="nav-link" data-scroll-target="#system-level-operations">System-Level Operations</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#framework-components" id="toc-framework-components" class="nav-link" data-scroll-target="#framework-components"><span class="header-section-number">7.4</span> Framework Components</a>
  <ul>
  <li><a href="#apis-and-abstractions" id="toc-apis-and-abstractions" class="nav-link" data-scroll-target="#apis-and-abstractions"><span class="header-section-number">7.4.1</span> APIs and Abstractions</a></li>
  <li><a href="#core-libraries" id="toc-core-libraries" class="nav-link" data-scroll-target="#core-libraries"><span class="header-section-number">7.4.2</span> Core Libraries</a></li>
  <li><a href="#extensions-and-plugins" id="toc-extensions-and-plugins" class="nav-link" data-scroll-target="#extensions-and-plugins"><span class="header-section-number">7.4.3</span> Extensions and Plugins</a></li>
  <li><a href="#development-tools" id="toc-development-tools" class="nav-link" data-scroll-target="#development-tools"><span class="header-section-number">7.4.4</span> Development Tools</a></li>
  </ul></li>
  <li><a href="#system-integration" id="toc-system-integration" class="nav-link" data-scroll-target="#system-integration"><span class="header-section-number">7.5</span> System Integration</a>
  <ul>
  <li><a href="#hardware-integration" id="toc-hardware-integration" class="nav-link" data-scroll-target="#hardware-integration"><span class="header-section-number">7.5.1</span> Hardware Integration</a></li>
  <li><a href="#software-stack" id="toc-software-stack" class="nav-link" data-scroll-target="#software-stack"><span class="header-section-number">7.5.2</span> Software Stack</a></li>
  <li><a href="#deployment-considerations" id="toc-deployment-considerations" class="nav-link" data-scroll-target="#deployment-considerations"><span class="header-section-number">7.5.3</span> Deployment Considerations</a></li>
  <li><a href="#workflow-orchestration" id="toc-workflow-orchestration" class="nav-link" data-scroll-target="#workflow-orchestration"><span class="header-section-number">7.5.4</span> Workflow Orchestration</a></li>
  </ul></li>
  <li><a href="#major-frameworks" id="toc-major-frameworks" class="nav-link" data-scroll-target="#major-frameworks"><span class="header-section-number">7.6</span> Major Frameworks</a>
  <ul>
  <li><a href="#tensorflow-ecosystem" id="toc-tensorflow-ecosystem" class="nav-link" data-scroll-target="#tensorflow-ecosystem"><span class="header-section-number">7.6.1</span> TensorFlow Ecosystem</a></li>
  <li><a href="#pytorch" id="toc-pytorch" class="nav-link" data-scroll-target="#pytorch"><span class="header-section-number">7.6.2</span> PyTorch</a></li>
  <li><a href="#jax" id="toc-jax" class="nav-link" data-scroll-target="#jax"><span class="header-section-number">7.6.3</span> JAX</a></li>
  <li><a href="#framework-comparison" id="toc-framework-comparison" class="nav-link" data-scroll-target="#framework-comparison"><span class="header-section-number">7.6.4</span> Framework Comparison</a></li>
  </ul></li>
  <li><a href="#framework-specialization" id="toc-framework-specialization" class="nav-link" data-scroll-target="#framework-specialization"><span class="header-section-number">7.7</span> Framework Specialization</a>
  <ul>
  <li><a href="#cloud-based-frameworks" id="toc-cloud-based-frameworks" class="nav-link" data-scroll-target="#cloud-based-frameworks"><span class="header-section-number">7.7.1</span> Cloud-Based Frameworks</a></li>
  <li><a href="#edge-based-frameworks" id="toc-edge-based-frameworks" class="nav-link" data-scroll-target="#edge-based-frameworks"><span class="header-section-number">7.7.2</span> Edge-Based Frameworks</a></li>
  <li><a href="#mobile-based-frameworks" id="toc-mobile-based-frameworks" class="nav-link" data-scroll-target="#mobile-based-frameworks"><span class="header-section-number">7.7.3</span> Mobile-Based Frameworks</a></li>
  <li><a href="#tinyml-frameworks" id="toc-tinyml-frameworks" class="nav-link" data-scroll-target="#tinyml-frameworks"><span class="header-section-number">7.7.4</span> TinyML Frameworks</a></li>
  </ul></li>
  <li><a href="#framework-selection" id="toc-framework-selection" class="nav-link" data-scroll-target="#framework-selection"><span class="header-section-number">7.8</span> Framework Selection</a>
  <ul>
  <li><a href="#model-requirements" id="toc-model-requirements" class="nav-link" data-scroll-target="#model-requirements"><span class="header-section-number">7.8.1</span> Model Requirements</a></li>
  <li><a href="#software-dependencies" id="toc-software-dependencies" class="nav-link" data-scroll-target="#software-dependencies"><span class="header-section-number">7.8.2</span> Software Dependencies</a></li>
  <li><a href="#hardware-constraints" id="toc-hardware-constraints" class="nav-link" data-scroll-target="#hardware-constraints"><span class="header-section-number">7.8.3</span> Hardware Constraints</a></li>
  <li><a href="#additional-selection-factors" id="toc-additional-selection-factors" class="nav-link" data-scroll-target="#additional-selection-factors"><span class="header-section-number">7.8.4</span> Additional Selection Factors</a>
  <ul class="collapse">
  <li><a href="#performance-optimization" id="toc-performance-optimization" class="nav-link" data-scroll-target="#performance-optimization">Performance Optimization</a></li>
  <li><a href="#deployment-scalability" id="toc-deployment-scalability" class="nav-link" data-scroll-target="#deployment-scalability">Deployment Scalability</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">7.9</span> Conclusion</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/harvard-edge/cs249r_book/edit/widget_quiz/contents/core/frameworks/frameworks.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/harvard-edge/cs249r_book/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li><li><a href="https://github.com/harvard-edge/cs249r_book/blob/widget_quiz/contents/core/frameworks/frameworks.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">
<script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    window.setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        disableStylesheet(primaryStylesheets)
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      window.setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    window.hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(darkModeDefault) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const darkModeDefault = false;
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !window.hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
    };
    // Switch to dark mode if need be
    if (window.hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">AI Frameworks</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Resources: <a href="#sec-ai-frameworks-resource">Slides</a>, <a href="#sec-ai-frameworks-resource">Videos</a>, <a href="#sec-ai-frameworks-resource">Exercises</a></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="images/png/cover_ml_frameworks.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="DALL·E 3 Prompt: Illustration in a rectangular format, designed for a professional textbook, where the content spans the entire width. The vibrant chart represents training and inference frameworks for ML. Icons for TensorFlow, Keras, PyTorch, ONNX, and TensorRT are spread out, filling the entire horizontal space, and aligned vertically. Each icon is accompanied by brief annotations detailing their features. The lively colors like blues, greens, and oranges highlight the icons and sections against a soft gradient background. The distinction between training and inference frameworks is accentuated through color-coded sections, with clean lines and modern typography maintaining clarity and focus."><img src="images/png/cover_ml_frameworks.png" class="img-fluid figure-img" alt="DALL·E 3 Prompt: Illustration in a rectangular format, designed for a professional textbook, where the content spans the entire width. The vibrant chart represents training and inference frameworks for ML. Icons for TensorFlow, Keras, PyTorch, ONNX, and TensorRT are spread out, filling the entire horizontal space, and aligned vertically. Each icon is accompanied by brief annotations detailing their features. The lively colors like blues, greens, and oranges highlight the icons and sections against a soft gradient background. The distinction between training and inference frameworks is accentuated through color-coded sections, with clean lines and modern typography maintaining clarity and focus."></a></p>
<figcaption><em>DALL·E 3 Prompt: Illustration in a rectangular format, designed for a professional textbook, where the content spans the entire width. The vibrant chart represents training and inference frameworks for ML. Icons for TensorFlow, Keras, PyTorch, ONNX, and TensorRT are spread out, filling the entire horizontal space, and aligned vertically. Each icon is accompanied by brief annotations detailing their features. The lively colors like blues, greens, and oranges highlight the icons and sections against a soft gradient background. The distinction between training and inference frameworks is accentuated through color-coded sections, with clean lines and modern typography maintaining clarity and focus.</em></figcaption>
</figure>
</div>
<section id="purpose" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="purpose">Purpose</h2>
<p><em>How do AI frameworks bridge the gap between theoretical design and practical implementation, and what role do they play in enabling scalable and effiicent machine learning systems?</em></p>
<p>AI frameworks are the middleware software layer that transforms abstract model specifications into executable implementations. The evolution of these frameworks reveals fundamental patterns for translating high-level designs into efficient computational workflows and system execution. Their architecture shines light on the essential trade-offs between abstraction, performance, and portability, providing systematic approaches to managing complexity in machine learning systems. Understanding framework capabilities and constraints offers insights into the engineering decisions that shape system scalability, enabling the development of robust, deployable solutions across diverse computing environments.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Learning Objectives
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><p>Trace the evolution of machine learning frameworks from early numerical libraries to modern deep learning systems</p></li>
<li><p>Analyze framework fundamentals including tensor data structures, computational graphs, execution models, and memory management</p></li>
<li><p>Differentiate between machine learning frameworks architectures, execution strategies, and development tools</p></li>
<li><p>Compare framework specializations across cloud, edge, mobile, and TinyML applications</p></li>
</ul>
</div>
</div>
</section>
<section id="overview" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="overview"><span class="header-section-number">7.1</span> Overview</h2>
<p>Modern machine learning development relies fundamentally on machine learning frameworks, which are comprehensive software libraries or platforms designed to simplify the development, training, and deployment of machine learning models. These frameworks play multiple roles in ML systems, much like operating systems are the foundation of computing systems. Just as operating systems abstract away the complexity of hardware resources and provide standardized interfaces for applications, ML frameworks abstract the intricacies of mathematical operations and hardware acceleration, providing standardized APIs for ML development.</p>
<p>The capabilities of ML frameworks are diverse and continuously evolving. They provide efficient implementations of mathematical operations, automatic differentiation capabilities, and tools for managing model development, hardware acceleration, and memory utilization. For production systems, they offer standardized approaches to model deployment, versioning, and optimization. However, due to their diversity, there is no universally agreed-upon definition of an ML framework. To establish clarity for this chapter, we adopt the following definition:</p>
<div class="callout callout-style-default callout-note callout-titled" title="Framework Definition">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Framework Definition
</div>
</div>
<div class="callout-body-container callout-body">
<p>A <strong>Machine Learning Framework (ML Framework)</strong> is a <em>software platform</em> that provides tools and abstractions for designing, training, and deploying machine learning models. It bridges <em>user applications</em> with <em>infrastructure</em>, enabling <em>algorithmic expressiveness</em> through computational graphs and operators, <em>workflow orchestration</em> across the machine learning lifecycle, <em>hardware optimization</em> with schedulers and compilers, <em>scalability</em> for distributed and edge systems, and <em>extensibility</em> to support diverse use cases. ML frameworks form the foundation of modern machine learning systems by simplifying development and deployment processes.</p>
</div>
</div>
<p>The landscape of ML frameworks continues to evolve with the field itself. Today’s frameworks must address diverse requirements: from training large language models on distributed systems to deploying compact neural networks on tiny IoT devices. Popular frameworks like PyTorch and TensorFlow have developed rich ecosystems that extend far beyond basic model implementation, encompassing tools for data preprocessing, model optimization, and deployment.</p>
<p>As we progress into examining training, optimization, and deployment, understanding ML frameworks becomes necessary as they orchestrate the entire machine learning lifecycle. These frameworks provide the architecture that connects all aspects of ML systems, from data ingestion to model deployment. Just as understanding a blueprint is important before studying construction techniques, grasping framework architecture is vital before diving into training methodologies and deployment strategies. Modern frameworks encapsulate the complete ML workflow, and their design choices influence how we approach training, optimization, and inference.</p>
<p>This chapter helps us learn how these complex frameworks function, their architectural principles, and their role in modern ML systems. Understanding these concepts will provide the necessary context as we explore specific aspects of the ML lifecycle in subsequent chapters.</p>
</section>
<section id="evolution-history" class="level2 page-columns page-full" data-number="7.2">
<h2 data-number="7.2" class="anchored" data-anchor-id="evolution-history"><span class="header-section-number">7.2</span> Evolution History</h2>
<p>The evolution of machine learning frameworks mirrors the broader development of artificial intelligence and computational capabilities. This section explores the distinct phases that reflect both technological advances and changing requirements of the AI community, from early numerical computing libraries to modern deep learning frameworks.</p>
<section id="evolution-timeline" class="level3" data-number="7.2.1">
<h3 data-number="7.2.1" class="anchored" data-anchor-id="evolution-timeline"><span class="header-section-number">7.2.1</span> Evolution Timeline</h3>
<p>The development of machine learning frameworks has been built upon decades of foundational work in computational libraries. From the early building blocks of BLAS and LAPACK to today’s cutting-edge frameworks like TensorFlow, PyTorch, and JAX, this journey represents a steady progression toward higher-level abstractions that make machine learning more accessible and powerful.</p>
<p>Looking at <a href="#fig-mlfm-timeline" class="quarto-xref">Figure&nbsp;<span>7.1</span></a>, we can trace how these fundamental numerical computing libraries laid the groundwork for modern ML development. The mathematical foundations established by BLAS and LAPACK enabled the creation of more user-friendly tools like NumPy and SciPy, which in turn set the stage for today’s sophisticated deep learning frameworks.</p>
<div id="fig-mlfm-timeline" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-mlfm-timeline-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="192c0bf590065201a107df4f3e5a3745ad474686.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Figure&nbsp;7.1: Timeline of major developments in computational libraries and machine learning frameworks."><img src="frameworks_files/mediabag/192c0bf590065201a107df4f3e5a3745ad474686.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-mlfm-timeline-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7.1: Timeline of major developments in computational libraries and machine learning frameworks.
</figcaption>
</figure>
</div>
<p>This evolution reflects a clear trend: each new layer of abstraction has made complex computational tasks more approachable while building upon the robust foundations of its predecessors. Let us examine how these systems built on top of one another.</p>
</section>
<section id="early-numerical-libraries" class="level3 page-columns page-full" data-number="7.2.2">
<h3 data-number="7.2.2" class="anchored" data-anchor-id="early-numerical-libraries"><span class="header-section-number">7.2.2</span> Early Numerical Libraries</h3>
<p>The foundation for modern ML frameworks begins at the most fundamental level of computation: matrix operations. Machine learning computations are primarily matrix-matrix and matrix-vector multiplications. The Basic Linear Algebra Subprograms (<a href="https://www.netlib.org/blas/">BLAS</a>), developed in 1979, provided these essential matrix operations that would become the computational backbone of machine learning <span class="citation" data-cites="kung1979systolic">(<a href="../references.html#ref-kung1979systolic" role="doc-biblioref">Kung and Leiserson 1979</a>)</span>. These low-level operations, when combined and executed efficiently, enable the complex calculations required for training neural networks and other ML models.</p>
<div class="no-row-height column-margin column-container"><div id="ref-kung1979systolic" class="csl-entry" role="listitem">
Kung, Hsiang Tsung, and Charles E Leiserson. 1979. <span>“Systolic Arrays (for VLSI).”</span> In <em>Sparse Matrix Proceedings 1978</em>, 1:256–82. Society for industrial; applied mathematics Philadelphia, PA, USA.
</div></div><p>Building upon BLAS, the Linear Algebra Package (<a href="https://www.netlib.org/lapack/">LAPACK</a>) emerged in 1992, extending these capabilities with more sophisticated linear algebra operations such as matrix decompositions, eigenvalue problems, and linear system solutions. This layered approach of building increasingly complex operations from fundamental matrix computations became a defining characteristic of ML frameworks.</p>
<p>The development of <a href="https://numpy.org/">NumPy</a> in 2006 marked an important milestone in this evolution, building upon its predecessors Numeric and Numarray to become the fundamental package for numerical computation in Python. NumPy introduced n-dimensional array objects and essential mathematical functions, but more importantly, it provided an efficient interface to these underlying BLAS and LAPACK operations. This abstraction allowed developers to work with high-level array operations while maintaining the performance of optimized low-level matrix computations.</p>
<p>In 2001, <a href="https://scipy.org/">SciPy</a> emerged as a powerful extension built on top of NumPy, adding specialized functions for optimization, linear algebra, and signal processing. This further exemplified the pattern of progressive abstraction in ML frameworks: from basic matrix operations to sophisticated numerical computations, and eventually to high-level machine learning algorithms. This layered architecture, starting from fundamental matrix operations and building upward, would become a blueprint for future ML frameworks, as we will see in this chapter.</p>
</section>
<section id="first-generation-frameworks" class="level3 page-columns page-full" data-number="7.2.3">
<h3 data-number="7.2.3" class="anchored" data-anchor-id="first-generation-frameworks"><span class="header-section-number">7.2.3</span> First-Generation Frameworks</h3>
<p>The transition from numerical libraries to dedicated machine learning frameworks marked an important evolution in abstraction. While the underlying computations remained rooted in matrix operations, frameworks began to encapsulate these operations into higher-level machine learning primitives. The University of Waikato introduced Weka in 1993 <span class="citation" data-cites="witten2002data">(<a href="../references.html#ref-witten2002data" role="doc-biblioref">Witten and Frank 2002</a>)</span>, one of the earliest ML frameworks, which abstracted matrix operations into data mining tasks, though it was limited by its Java implementation and focus on smaller-scale computations.</p>
<div class="no-row-height column-margin column-container"><div id="ref-witten2002data" class="csl-entry" role="listitem">
Witten, Ian H., and Eibe Frank. 2002. <span>“Data Mining: Practical Machine Learning Tools and Techniques with Java Implementations.”</span> <em>ACM SIGMOD Record</em> 31 (1): 76–77. <a href="https://doi.org/10.1145/507338.507355">https://doi.org/10.1145/507338.507355</a>.
</div></div><p><a href="https://scikit-learn.org/stable/">Scikit-learn</a>, emerging in 2007, was a significant advancement in this abstraction. Building upon the NumPy and SciPy foundation, it transformed basic matrix operations into intuitive ML algorithms. For example, what was fundamentally a series of matrix multiplications and gradient computations became a simple <code>fit()</code> method call in a logistic regression model. This abstraction pattern - hiding complex matrix operations behind clean APIs - would become a defining characteristic of modern ML frameworks.</p>
<p><a href="https://github.com/Theano/Theano">Theano</a>, which appeared in 2007, was a major advancement—developed at the Montreal Institute for Learning Algorithms (MILA)—Theano introduced two revolutionary concepts: computational graphs and GPU acceleration <span class="citation" data-cites="al2016theano">(<a href="../references.html#ref-al2016theano" role="doc-biblioref">Team et al. 2016</a>)</span>. Computational graphs represented mathematical operations as directed graphs, with matrix operations as nodes and data flowing between them. This graph-based approach allowed for automatic differentiation and optimization of the underlying matrix operations. More importantly, it enabled the framework to automatically route these operations to GPU hardware, dramatically accelerating matrix computations.</p>
<div class="no-row-height column-margin column-container"><div id="ref-al2016theano" class="csl-entry" role="listitem">
Team, The Theano Development, Rami Al-Rfou, Guillaume Alain, Amjad Almahairi, Christof Angermueller, Dzmitry Bahdanau, Nicolas Ballas, et al. 2016. <span>“Theano: A Python Framework for Fast Computation of Mathematical Expressions,”</span> May. <a href="http://arxiv.org/abs/1605.02688v1">http://arxiv.org/abs/1605.02688v1</a>.
</div></div><p>Meanwhile, <a href="http://torch.ch/">Torch</a>, created at NYU in 2002, took a different approach to handling matrix operations. It emphasized immediate execution of operations (eager execution) and provided a flexible interface for neural network implementations. Torch’s design philosophy of prioritizing developer experience while maintaining high performance influenced many subsequent frameworks. Its architecture demonstrated how to balance high-level abstractions with efficient low-level matrix operations, establishing design patterns that would later influence frameworks like PyTorch.</p>
</section>
<section id="emergence-of-deep-learning-frameworks" class="level3 page-columns page-full" data-number="7.2.4">
<h3 data-number="7.2.4" class="anchored" data-anchor-id="emergence-of-deep-learning-frameworks"><span class="header-section-number">7.2.4</span> Emergence of Deep Learning Frameworks</h3>
<p>The deep learning revolution demanded a fundamental shift in how frameworks handled matrix operations, primarily due to three factors: the massive scale of computations, the complexity of gradient calculations through deep networks, and the need for distributed processing. Traditional frameworks, designed for classical machine learning algorithms, could not efficiently handle the billions of matrix operations required for training deep neural networks.</p>
<p>The foundations for modern deep learning frameworks emerged from academic research. The University of Montreal’s <a href="https://github.com/Theano/Theano">Theano</a>, released in 2007, established the concepts that would shape future frameworks <span class="citation" data-cites="bergstra2010theano">(<a href="../references.html#ref-bergstra2010theano" role="doc-biblioref">Bergstra et al. 2010</a>)</span>. It introduced key concepts such as computational graphs for automatic differentiation and GPU acceleration, which we will explore in more detail later in this chapter, demonstrating how to efficiently organize and optimize complex neural network computations.</p>
<div class="no-row-height column-margin column-container"><div id="ref-bergstra2010theano" class="csl-entry" role="listitem">
Bergstra, James, Olivier Breuleux, Frédéric Bastien, Pascal Lamblin, Razvan Pascanu, Guillaume Desjardins, Joseph Turian, David Warde-Farley, and Yoshua Bengio. 2010. <span>“Theano: A CPU and GPU Math Compiler in Python.”</span> In <em>Proceedings of the 9th Python in Science Conference</em>, 4:18–24. 1. SciPy. <a href="https://doi.org/10.25080/majora-92bf1922-003">https://doi.org/10.25080/majora-92bf1922-003</a>.
</div><div id="ref-jia2014caffe" class="csl-entry" role="listitem">
Jia, Yangqing, Evan Shelhamer, Jeff Donahue, Sergey Karayev, Jonathan Long, Ross Girshick, Sergio Guadarrama, and Trevor Darrell. 2014. <span>“Caffe: Convolutional Architecture for Fast Feature Embedding.”</span> In <em>Proceedings of the 22nd ACM International Conference on Multimedia</em>, 675–78. ACM. <a href="https://doi.org/10.1145/2647868.2654889">https://doi.org/10.1145/2647868.2654889</a>.
</div></div><p><a href="https://caffe.berkeleyvision.org/">Caffe</a>, released by UC Berkeley in 2013, advanced this evolution by introducing specialized implementations of convolutional operations <span class="citation" data-cites="jia2014caffe">(<a href="../references.html#ref-jia2014caffe" role="doc-biblioref">Jia et al. 2014</a>)</span>. While convolutions are mathematically equivalent to specific patterns of matrix multiplication, Caffe optimized these patterns specifically for computer vision tasks, demonstrating how specialized matrix operation implementations could dramatically improve performance for specific network architectures.</p>
<p>Google’s <a href="https://www.tensorflow.org/">TensorFlow</a>, introduced in 2015, revolutionized the field by treating matrix operations as part of a distributed computing problem <span class="citation" data-cites="dean2012large">(<a href="../references.html#ref-dean2012large" role="doc-biblioref">Dean et al. 2012</a>)</span>. It represented all computations, from individual matrix multiplications to entire neural networks, as a static computational graph that could be split across multiple devices. This approach enabled training of unprecedented model sizes by distributing matrix operations across clusters of computers and specialized hardware. TensorFlow’s static graph approach, while initially constraining, allowed for aggressive optimization of matrix operations through techniques like kernel fusion (combining multiple operations into a single kernel for efficiency) and memory planning (pre-allocating memory for operations).</p>
<div class="no-row-height column-margin column-container"><div id="ref-dean2012large" class="csl-entry" role="listitem">
Dean, Jeffrey, Greg Corrado, Rajat Monga, Kai Chen 0010, Matthieu Devin, Quoc V. Le, Mark Z. Mao, et al. 2012. <span>“Large Scale Distributed Deep Networks.”</span> In <em>Advances in Neural Information Processing Systems 25: 26th Annual Conference on Neural Information Processing Systems 2012. Proceedings of a Meeting Held December 3-6, 2012, Lake Tahoe, Nevada, United States</em>, edited by Peter L. Bartlett, Fernando C. N. Pereira, Christopher J. C. Burges, Léon Bottou, and Kilian Q. Weinberger, 1232–40. <a href="https://proceedings.neurips.cc/paper/2012/hash/6aca97005c68f1206823815f66102863-Abstract.html">https://proceedings.neurips.cc/paper/2012/hash/6aca97005c68f1206823815f66102863-Abstract.html</a>.
</div><div id="ref-seide2016cntk" class="csl-entry" role="listitem">
Seide, Frank, and Amit Agarwal. 2016. <span>“CNTK: Microsoft’s Open-Source Deep-Learning Toolkit.”</span> In <em>Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</em>, 2135–35. ACM. <a href="https://doi.org/10.1145/2939672.2945397">https://doi.org/10.1145/2939672.2945397</a>.
</div></div><p>Microsoft’s <a href="https://learn.microsoft.com/en-us/cognitive-toolkit/">CNTK</a> entered the landscape in 2016, bringing robust implementations for speech recognition and natural language processing tasks <span class="citation" data-cites="seide2016cntk">(<a href="../references.html#ref-seide2016cntk" role="doc-biblioref">Seide and Agarwal 2016</a>)</span>. Its architecture emphasized scalability across distributed systems while maintaining efficient computation for sequence-based models.</p>
<p>Facebook’s <a href="https://pytorch.org/">PyTorch</a>, also launched in 2016, took a radically different approach to handling matrix computations. Instead of static graphs, PyTorch introduced dynamic computational graphs that could be modified on the fly <span class="citation" data-cites="paszke2019pytorch">(<a href="../references.html#ref-paszke2019pytorch" role="doc-biblioref">Ansel et al. 2024</a>)</span>. This dynamic approach, while potentially sacrificing some optimization opportunities, made it much easier for researchers to debug and understand the flow of matrix operations in their models. PyTorch’s success demonstrated that the ability to introspect and modify computations dynamically was as important as raw performance for many applications.</p>
<div class="no-row-height column-margin column-container"></div><p>Amazon’s <a href="https://mxnet.apache.org/">MXNet</a> approached the challenge of large-scale matrix operations by focusing on memory efficiency and scalability across different hardware configurations. It introduced a hybrid approach that combined aspects of both static and dynamic graphs, allowing for flexible model development while still enabling aggressive optimization of the underlying matrix operations.</p>
<p>As deep learning applications grew more diverse, the need for specialized and higher-level abstractions became apparent. <a href="https://keras.io/">Keras</a> emerged in 2015 to address this need, providing a unified interface that could run on top of multiple lower-level frameworks <span class="citation" data-cites="chollet2015keras">(<a href="../references.html#ref-chollet2015keras" role="doc-biblioref">Chollet et al. 2015</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-chollet2015keras" class="csl-entry" role="listitem">
Chollet, François et al. 2015. <span>“Keras.”</span> <em>GitHub Repository</em>. <a href="https://github.com/fchollet/keras">https://github.com/fchollet/keras</a>.
</div><div id="ref-jax2018github" class="csl-entry" role="listitem">
Bradbury, James, Roy Frostig, Peter Hawkins, Matthew James Johnson, Chris Leary, Dougal Maclaurin, George Necula, et al. 2018. <span>“JAX: Composable Transformations of Python+NumPy Programs.”</span> <a href="http://github.com/google/jax">http://github.com/google/jax</a>.
</div><div id="ref-howard2020fastai" class="csl-entry" role="listitem">
Howard, Jeremy, and Sylvain Gugger. 2020. <span>“Fastai: A Layered API for Deep Learning.”</span> <em>Information</em> 11 (2): 108. <a href="https://doi.org/10.3390/info11020108">https://doi.org/10.3390/info11020108</a>.
</div></div><p>Google’s <a href="https://github.com/google/jax">JAX</a>, introduced in 2018, brought functional programming principles to deep learning computations, enabling new patterns of model development <span class="citation" data-cites="jax2018github">(<a href="../references.html#ref-jax2018github" role="doc-biblioref">Bradbury et al. 2018</a>)</span>. <a href="https://www.fast.ai/">FastAI</a> built upon PyTorch to package common deep learning patterns into reusable components, making advanced techniques more accessible to practitioners <span class="citation" data-cites="howard2020fastai">(<a href="../references.html#ref-howard2020fastai" role="doc-biblioref">Howard and Gugger 2020</a>)</span>. These higher-level frameworks demonstrated how abstraction could simplify development while maintaining the performance benefits of their underlying implementations.</p>
</section>
<section id="hardware-impact-on-design" class="level3" data-number="7.2.5">
<h3 data-number="7.2.5" class="anchored" data-anchor-id="hardware-impact-on-design"><span class="header-section-number">7.2.5</span> Hardware Impact on Design</h3>
<p>Hardware developments have fundamentally reshaped how frameworks implement and optimize matrix operations. The introduction of <a href="https://developer.nvidia.com/cuda-toolkit">NVIDIA’s CUDA platform</a> in 2007 marked a pivotal moment in framework design by enabling general-purpose computing on GPUs. This was transformative because GPUs excel at parallel matrix operations, offering orders of magnitude speedup for the computations in deep learning. While a CPU might process matrix elements sequentially, a GPU can process thousands of elements simultaneously, fundamentally changing how frameworks approach computation scheduling.</p>
<p>The development of hardware-specific accelerators further revolutionized framework design. <a href="https://cloud.google.com/tpu/">Google’s Tensor Processing Units (TPUs)</a>, first deployed in 2016, were purpose-built for tensor operations, the fundamental building blocks of deep learning computations. TPUs introduced systolic array architectures, which are particularly efficient for matrix multiplication and convolution operations. This hardware architecture prompted frameworks like TensorFlow to develop specialized compilation strategies that could map high-level operations directly to TPU instructions, bypassing traditional CPU-oriented optimizations.</p>
<p>Mobile hardware accelerators, such as <a href="https://machinelearning.apple.com/research/neural-engine-transformers">Apple’s Neural Engine (2017)</a> and Qualcomm’s Neural Processing Units, brought new constraints and opportunities to framework design. These devices emphasized power efficiency over raw computational speed, requiring frameworks to develop new strategies for quantization and operator fusion. Mobile frameworks like TensorFlow Lite (more recently rebraneded to <a href="https://ai.google.dev/edge/litert">LiteRT</a>) and <a href="https://pytorch.org/mobile/home/">PyTorch Mobile</a> needed to balance model accuracy with energy consumption, leading to innovations in how matrix operations are scheduled and executed.</p>
<p>The emergence of custom ASIC (Application-Specific Integrated Circuit) solutions has further diversified the hardware landscape. Companies like <a href="https://www.graphcore.ai/">Graphcore</a>, <a href="https://www.cerebras.net/">Cerebras</a>, and <a href="https://sambanova.ai/">SambaNova</a> have developed unique architectures for matrix computation, each with different strengths and optimization opportunities. This proliferation of specialized hardware has pushed frameworks to adopt more flexible intermediate representations of matrix operations, allowing for target-specific optimization while maintaining a common high-level interface.</p>
<p>Field Programmable Gate Arrays (FPGAs) introduced yet another dimension to framework optimization. Unlike fixed-function ASICs, FPGAs allow for reconfigurable circuits that can be optimized for specific matrix operation patterns. Frameworks responding to this capability developed just-in-time compilation strategies that could generate optimized hardware configurations based on the specific needs of a model.</p>
</section>
</section>
<section id="fundamental-concepts" class="level2 page-columns page-full" data-number="7.3">
<h2 data-number="7.3" class="anchored" data-anchor-id="fundamental-concepts"><span class="header-section-number">7.3</span> Fundamental Concepts</h2>
<p>Modern machine learning frameworks operate through the integration of four key layers: Fundamentals, Data Handling, Developer Interface, and Execution and Abstraction. These layers function together to provide a structured and efficient foundation for model development and deployment, as illustrated in <a href="#fig-fm_blocks" class="quarto-xref">Figure&nbsp;<span>7.2</span></a>.</p>
<div id="fig-fm_blocks" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="htb" data-fig-env="figure">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-fm_blocks-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="ab00e4e305cdd5a449061d2f50d0f82bd5f93f5c.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="Figure&nbsp;7.2: Framework component interaction."><img src="frameworks_files/mediabag/ab00e4e305cdd5a449061d2f50d0f82bd5f93f5c.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-fm_blocks-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7.2: Framework component interaction.
</figcaption>
</figure>
</div>
<p>The Fundamentals layer establishes the structural basis of these frameworks through computational graphs. These graphs represent the operations within a model as directed acyclic graphs (DAGs), enabling automatic differentiation and optimization. By organizing operations and data dependencies, computational graphs provide the framework with the ability to distribute workloads and execute computations efficiently across a variety of hardware platforms.</p>
<p>The Data Handling layer manages numerical data and parameters essential for machine learning workflows. Central to this layer are specialized data structures, such as tensors, which handle high-dimensional arrays while optimizing memory usage and device placement. Additionally, memory management and data movement strategies ensure that computational workloads are executed efficiently, particularly in environments with diverse or limited hardware resources.</p>
<p>The Developer Interface layer provides the tools and abstractions through which users interact with the framework. Programming models allow developers to define machine learning algorithms in a manner suited to their specific needs. These are categorized as either imperative or symbolic. Imperative models offer flexibility and ease of debugging, while symbolic models prioritize performance and deployment efficiency. Execution models further shape this interaction by defining whether computations are carried out eagerly (immediately) or as pre-optimized static graphs.</p>
<p>The Execution and Abstraction layer transforms these high-level representations into efficient hardware-executable operations. Core operations, encompassing everything from basic linear algebra to complex neural network layers, are highly optimized for diverse hardware platforms. This layer also includes mechanisms for allocating resources and managing memory dynamically, ensuring robust and scalable performance in both training and inference settings.</p>
<p>Understanding these interconnected layers is essential for leveraging machine learning frameworks effectively. Each layer plays a distinct yet interdependent role in facilitating experimentation, optimization, and deployment. By mastering these concepts, practitioners can make informed decisions about resource utilization, scaling strategies, and the suitability of specific frameworks for various tasks.</p>
<section id="computational-graphs" class="level3 page-columns page-full" data-number="7.3.1">
<h3 data-number="7.3.1" class="anchored" data-anchor-id="computational-graphs"><span class="header-section-number">7.3.1</span> Computational Graphs</h3>
<p>Machine learning frameworks must efficiently translate high-level model descriptions into executable computations across diverse hardware platforms. At the center of this translation lies the computational graph—a powerful abstraction that represents mathematical operations and their dependencies. We begin by examining the fundamental structure of computational graphs, then investigate their implementation in modern frameworks, and analyze their implications for system design and performance.</p>
<section id="basic-concepts" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="basic-concepts">Basic Concepts</h4>
<p>Computational graphs emerged as a fundamental abstraction in machine learning frameworks to address the growing complexity of deep learning models. As models grew larger and more sophisticated, the need for efficient execution across diverse hardware platforms became crucial. The computational graph bridges the gap between high-level model descriptions and low-level hardware execution <span class="citation" data-cites="Baydin_2018">(<a href="../references.html#ref-Baydin_2018" role="doc-biblioref">Baydin et al. 2017a</a>)</span>, representing a machine learning model as a directed acyclic graph (DAG) where nodes represent operations and edges represent data flow.</p>
<div class="no-row-height column-margin column-container"><div id="ref-Baydin_2018" class="csl-entry" role="listitem">
Baydin, Atilim Gunes, Barak A. Pearlmutter, Alexey Andreyevich Radul, and Jeffrey Mark Siskind. 2017a. <span>“Automatic Differentiation in Machine Learning: A Survey.”</span> <em>J. Mach. Learn. Res.</em> 18: 153:1–43. <a href="https://jmlr.org/papers/v18/17-468.html">https://jmlr.org/papers/v18/17-468.html</a>.
</div></div><p>For example, a node might represent a matrix multiplication operation, taking two input matrices (or tensors) and producing an output matrix (or tensor). To visualize this, consider the simple example in <a href="#fig-comp-graph" class="quarto-xref">Figure&nbsp;<span>7.3</span></a>. The directed acyclic graph computes <span class="math inline">\(z = x \times y\)</span>, where each variable is just numbers.</p>
<div id="fig-comp-graph" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="htb" data-fig-env="figure">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-comp-graph-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="8de4c63fb10f7b924d681363ba33217504e7402e.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-4" title="Figure&nbsp;7.3: Basic example of a computational graph."><img src="frameworks_files/mediabag/8de4c63fb10f7b924d681363ba33217504e7402e.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-comp-graph-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7.3: Basic example of a computational graph.
</figcaption>
</figure>
</div>
<p>As shown in <a href="#fig-mlfm-comp-graph" class="quarto-xref">Figure&nbsp;<span>7.4</span></a>, the structure of the computation graph involves defining interconnected layers, such as convolution, activation, pooling, and normalization, which are optimized before execution. The figure also demonstrates key system-level interactions, including memory management and device placement, showing how the static graph approach enables comprehensive pre-execution analysis and resource allocation.</p>
<div id="fig-mlfm-comp-graph" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="htb" data-fig-env="figure">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-mlfm-comp-graph-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="4d64429f98884a93daf67a671fb763bfd59d627b.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-5" title="Figure&nbsp;7.4: Example of a computational graph."><img src="frameworks_files/mediabag/4d64429f98884a93daf67a671fb763bfd59d627b.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-mlfm-comp-graph-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7.4: Example of a computational graph.
</figcaption>
</figure>
</div>
<section id="layers-and-tensors" class="level5">
<h5 class="anchored" data-anchor-id="layers-and-tensors">Layers and Tensors</h5>
<p>Modern machine learning frameworks implement neural network computations through two key abstractions: layers and tensors. Layers represent computational units that perform operations like convolution, pooling, or dense transformations. Each layer maintains internal states, including weights and biases, that evolve during model training. When data flows through these layers, it takes the form of tensors—immutable mathematical objects that hold and transmit numerical values.</p>
<p>The relationship between layers and tensors mirrors the distinction between operations and data in traditional programming. A layer defines how to transform input tensors into output tensors, much like a function defines how to transform its inputs into outputs. However, layers add an extra dimension: they maintain and update internal parameters during training. For example, a convolutional layer not only specifies how to perform convolution operations but also learns and stores the optimal convolution filters for a given task.</p>
<p>Frameworks like TensorFlow and PyTorch leverage this abstraction to simplify model implementation. When a developer writes <code>tf.keras.layers.</code> <code>Conv2D</code>, the framework constructs the necessary graph nodes for convolution operations, parameter management, and data flow. This high-level interface shields developers from the complexities of implementing convolution operations, managing memory, or handling parameter updates during training.</p>
</section>
<section id="neural-network-construction" class="level5">
<h5 class="anchored" data-anchor-id="neural-network-construction">Neural Network Construction</h5>
<p>The power of computational graphs extends beyond basic layer operations. Activation functions, essential for introducing non-linearity in neural networks, become nodes in the graph. Functions like ReLU, sigmoid, and tanh transform the output tensors of layers, enabling networks to approximate complex mathematical functions. Frameworks provide optimized implementations of these activation functions, allowing developers to experiment with different non-linearities without worrying about implementation details.</p>
<p>Modern frameworks further extend this abstraction by providing complete model architectures as pre-configured computational graphs. Models like ResNet and MobileNet, which have proven effective across many tasks, come ready to use. Developers can start with these architectures, customize specific layers for their needs, and leverage transfer learning from pre-trained weights. This approach accelerates development while maintaining the benefits of carefully optimized implementations.</p>
</section>
<section id="system-level-consequences" class="level5">
<h5 class="anchored" data-anchor-id="system-level-consequences">System-Level Consequences</h5>
<p>The computational graph abstraction fundamentally shapes how machine learning frameworks operate. By representing computations as a directed acyclic graph, frameworks gain the ability to analyze and optimize the entire computation before execution begins. The explicit representation of data dependencies enables automatic differentiation—a crucial capability for training neural networks through gradient-based optimization.</p>
<p>This graph structure also provides flexibility in execution. The same model definition can run efficiently across different hardware platforms, from CPUs to GPUs to specialized accelerators. The framework handles the complexity of mapping operations to specific hardware capabilities, optimizing memory usage, and coordinating parallel execution. Moreover, the graph structure enables model serialization, allowing trained models to be saved, shared, and deployed across different environments.</p>
<p>While neural network diagrams help visualize model architecture, computational graphs serve a deeper purpose. They provide the precise mathematical representation needed to bridge the gap between intuitive model design and efficient execution. Understanding this representation reveals how frameworks transform high-level model descriptions into optimized, hardware-specific implementations, making modern deep learning practical at scale.</p>
<p>It is important to differentiate computational graphs from neural network diagrams, such as those for multilayer perceptrons (MLPs), which depict nodes and layers. Neural network diagrams visualize the architecture and flow of data through nodes and layers, providing an intuitive understanding of the model’s structure. In contrast, computational graphs provide a low-level representation of the underlying mathematical operations and data dependencies required to implement and train these networks.</p>
<p>From a systems perspective, computational graphs provide several key capabilities that influence the entire machine learning pipeline. They enable automatic differentiation, which we will discuss later, provide clear structure for analyzing data dependencies and potential parallelism, and serve as an intermediate representation that can be optimized and transformed for different hardware targets. Understanding this architecture is essential for comprehending how frameworks translate high-level model descriptions into efficient executable code.</p>
</section>
</section>
<section id="static-graphs" class="level4">
<h4 class="anchored" data-anchor-id="static-graphs">Static Graphs</h4>
<p>Static computation graphs, pioneered by early versions of TensorFlow, implement a “define-then-run” execution model. In this approach, developers must specify the entire computation graph before execution begins. This architectural choice has significant implications for both system performance and development workflow, as we will examine later.</p>
<p>A static computation graph implements a clear separation between the definition of operations and their execution. During the definition phase, each mathematical operation, variable, and data flow connection is explicitly declared and added to the graph structure. This graph is a complete specification of the computation but does not perform any actual calculations. Instead, the framework constructs an internal representation of all operations and their dependencies, which will be executed in a subsequent phase.</p>
<p>This upfront definition enables powerful system-level optimizations. The framework can analyze the complete structure to identify opportunities for operation fusion, eliminating unnecessary intermediate results. Memory requirements can be precisely calculated and optimized in advance, leading to efficient allocation strategies. Furthermore, static graphs can be compiled into highly optimized executable code for specific hardware targets, taking full advantage of platform-specific features. Once validated, the same computation can be run repeatedly with high confidence in its behavior and performance characteristics.</p>
<p><a href="#fig-mlfm-static-graph" class="quarto-xref">Figure&nbsp;<span>7.5</span></a> illustrates this fundamental two-phase approach: first, the complete computational graph is constructed and optimized; then, during the execution phase, actual data flows through the graph to produce results. This separation enables the framework to perform comprehensive analysis and optimization of the entire computation before any execution begins.</p>
<div id="fig-mlfm-static-graph" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="htb" data-fig-env="figure">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-mlfm-static-graph-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="9a3844e713bd51f5ab2639435e2f2f251800daac.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-6" title="Figure&nbsp;7.5: The two-phase execution model of static computation graphs."><img src="frameworks_files/mediabag/9a3844e713bd51f5ab2639435e2f2f251800daac.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-mlfm-static-graph-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7.5: The two-phase execution model of static computation graphs.
</figcaption>
</figure>
</div>
</section>
<section id="dynamic-graphs" class="level4">
<h4 class="anchored" data-anchor-id="dynamic-graphs">Dynamic Graphs</h4>
<p>Dynamic computation graphs, popularized by PyTorch, implement a “define-by-run” execution model. This approach constructs the graph during execution, offering greater flexibility in model definition and debugging. Unlike static graphs, which rely on predefined memory allocation, dynamic graphs allocate memory as operations execute, making them susceptible to memory fragmentation in long-running tasks.</p>
<p>As shown in <a href="#fig-mlfm-dynamic-graph-flow" class="quarto-xref">Figure&nbsp;<span>7.6</span></a>, each operation is defined, executed, and completed before moving on to define the next operation. This contrasts sharply with static graphs, where all operations must be defined upfront. When an operation is defined, it is immediately executed, and its results become available for subsequent operations or for inspection during debugging. This cycle continues until all operations are complete.</p>
<div id="fig-mlfm-dynamic-graph-flow" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="htb" data-fig-env="figure">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-mlfm-dynamic-graph-flow-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="db6a15c36b8d3247713dd8ab8205c37aa4d58f50.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-7" title="Figure&nbsp;7.6: Dynamic graph execution model, illustrating runtime graph construction and immediate execution."><img src="frameworks_files/mediabag/db6a15c36b8d3247713dd8ab8205c37aa4d58f50.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-mlfm-dynamic-graph-flow-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7.6: Dynamic graph execution model, illustrating runtime graph construction and immediate execution.
</figcaption>
</figure>
</div>
<p>Dynamic graphs excel in scenarios that require conditional execution or dynamic control flow, such as when processing variable-length sequences or implementing complex branching logic. They provide immediate feedback during development, making it easier to identify and fix issues in the computational pipeline. This flexibility aligns naturally with imperative programming patterns familiar to most developers, allowing them to inspect and modify computations at runtime. These characteristics make dynamic graphs particularly valuable during the research and development phase of ML projects.</p>
</section>
<section id="system-consequences" class="level4">
<h4 class="anchored" data-anchor-id="system-consequences">System Consequences</h4>
<p>The architectural differences between static and dynamic computational graphs have multiple implications for how machine learning systems are designed and executed. These implications touch on various aspects of memory usage, device utilization, execution optimization, and debugging, all of which play crucial roles in determining the efficiency and scalability of a system. Here, we start with a focus on memory management and device placement as foundational concepts, leaving more detailed discussions for later chapters. This allows us to build a clear understanding before exploring more complex topics like optimization and fault tolerance.</p>
<section id="memory-management" class="level5">
<h5 class="anchored" data-anchor-id="memory-management">Memory Management</h5>
<p>Memory management occurs when executing computational graphs. Static graphs benefit from their predefined structure, allowing for precise memory planning before execution. Frameworks can calculate memory requirements in advance, optimize allocation, and minimize overhead through techniques like memory reuse. This structured approach helps ensure consistent performance, particularly in resource-constrained environments, such as Mobile and Tiny ML systems.</p>
<p>Dynamic graphs, by contrast, allocate memory dynamically as operations are executed. While this flexibility is invaluable for handling dynamic control flows or variable input sizes, it can result in higher memory overhead and fragmentation. These trade-offs are often most apparent during development, where dynamic graphs enable rapid iteration and debugging but may require additional optimization for production deployment.</p>
</section>
<section id="device-placement" class="level5">
<h5 class="anchored" data-anchor-id="device-placement">Device Placement</h5>
<p>Device placement, the process of assigning operations to hardware resources such as CPUs, GPUs, or specialized ASICS like TPUs, is another system-level consideration. Static graphs allow for detailed pre-execution analysis, enabling the framework to map computationally intensive operations efficiently to devices while minimizing communication overhead. This capability makes static graphs well-suited for optimizing execution on specialized hardware, where performance gains can be significant.</p>
<p>Dynamic graphs, in contrast, handle device placement at runtime. This allows them to adapt to changing conditions, such as hardware availability or workload demands. However, the lack of a complete graph structure before execution can make it challenging to optimize device utilization fully, potentially leading to inefficiencies in large-scale or distributed setups.</p>
</section>
<section id="broader-perspective" class="level5">
<h5 class="anchored" data-anchor-id="broader-perspective">Broader Perspective</h5>
<p>The trade-offs between static and dynamic graphs extend well beyond memory and device considerations. As shown in <a href="#tbl-mlfm-graphs" class="quarto-xref">Table&nbsp;<span>7.1</span></a>, these architectures influence optimization potential, debugging capabilities, scalability, and deployment complexity. While these broader implications are not the focus of this section, they will be explored in detail in later chapters, particularly in the context of training workflows and system-level optimizations.</p>
<p>These hybrid solutions aim to provide the flexibility of dynamic graphs during development while enabling the performance optimizations of static graphs in production environments. The choice between static and dynamic graphs often depends on specific project requirements, balancing factors like development speed, production performance, and system complexity.</p>
<div id="tbl-mlfm-graphs" class="hover striped quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-mlfm-graphs-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;7.1: Comparison of static and dynamic computational graphs.
</figcaption>
<div aria-describedby="tbl-mlfm-graphs-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-hover table-striped caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 36%">
<col style="width: 38%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Aspect</th>
<th style="text-align: left;">Static Graphs</th>
<th style="text-align: left;">Dynamic Graphs</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Memory Management</td>
<td style="text-align: left;">Precise allocation planning, optimized memory usage</td>
<td style="text-align: left;">Flexible but potentially less efficient allocation</td>
</tr>
<tr class="even">
<td style="text-align: left;">Optimization Potential</td>
<td style="text-align: left;">Comprehensive graph-level optimizations possible</td>
<td style="text-align: left;">Limited to local optimizations due to runtime construction</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Hardware Utilization</td>
<td style="text-align: left;">Can generate highly optimized hardware-specific code</td>
<td style="text-align: left;">May sacrifice some hardware-specific optimizations</td>
</tr>
<tr class="even">
<td style="text-align: left;">Development Experience</td>
<td style="text-align: left;">Requires more upfront planning, harder to debug</td>
<td style="text-align: left;">Better debugging, faster iteration cycles</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Runtime Flexibility</td>
<td style="text-align: left;">Fixed computation structure</td>
<td style="text-align: left;">Can adapt to runtime conditions</td>
</tr>
<tr class="even">
<td style="text-align: left;">Production Performance</td>
<td style="text-align: left;">Generally better performance at scale</td>
<td style="text-align: left;">May have overhead from runtime graph construction</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Integration with Traditional Code</td>
<td style="text-align: left;">More separation between definition and execution</td>
<td style="text-align: left;">Natural integration with imperative code</td>
</tr>
<tr class="even">
<td style="text-align: left;">Memory Overhead</td>
<td style="text-align: left;">Lower memory overhead due to planned allocations</td>
<td style="text-align: left;">Higher memory overhead due to dynamic allocations</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Debugging Capability</td>
<td style="text-align: left;">Limited to pre-execution analysis</td>
<td style="text-align: left;">Runtime inspection and modification possible</td>
</tr>
<tr class="even">
<td style="text-align: left;">Deployment Complexity</td>
<td style="text-align: left;">Simpler deployment due to fixed structure</td>
<td style="text-align: left;">May require additional runtime support</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</section>
</section>
</section>
<section id="automatic-differentiation" class="level3 page-columns page-full" data-number="7.3.2">
<h3 data-number="7.3.2" class="anchored" data-anchor-id="automatic-differentiation"><span class="header-section-number">7.3.2</span> Automatic Differentiation</h3>
<p>Machine learning frameworks must solve a fundamental computational challenge: calculating derivatives through complex chains of mathematical operations efficiently and accurately. This capability enables the training of neural networks by computing how millions of parameters should be adjusted to improve the model’s performance <span class="citation" data-cites="baydin2018">(<a href="../references.html#ref-baydin2018" role="doc-biblioref">Baydin et al. 2017b</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-baydin2018" class="csl-entry" role="listitem">
———. 2017b. <span>“Automatic Differentiation in Machine Learning: A Survey.”</span> <em>J. Mach. Learn. Res.</em> 18 (153): 153:1–43. <a href="https://jmlr.org/papers/v18/17-468.html">https://jmlr.org/papers/v18/17-468.html</a>.
</div></div><p>Consider a simple computation that illustrates this challenge:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> x <span class="op">*</span> x      <span class="co"># Square</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> sin(x)     <span class="co"># Sine</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">*</span> b   <span class="co"># Product</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Even in this basic example, computing derivatives manually would require careful application of calculus rules - the product rule, the chain rule, and derivatives of trigonometric functions. Now imagine scaling this to a neural network with millions of operations. This is where automatic differentiation (AD) becomes essential.</p>
<p>Automatic differentiation calculates derivatives of functions implemented as computer programs by decomposing them into elementary operations. In our example, AD breaks down f(x) into three basic steps:</p>
<ol type="1">
<li>Computing <code>a = x * x</code> (squaring)</li>
<li>Computing <code>b = sin(x)</code> (sine function)</li>
<li>Computing the final product <code>a * b</code></li>
</ol>
<p>For each step, AD knows the basic derivative rules:</p>
<ul>
<li>For squaring: <code>d(x²)/dx = 2x</code></li>
<li>For sine: <code>d(sin(x))/dx = cos(x)</code></li>
<li>For products: <code>d(uv)/dx = u(dv/dx) + v(du/dx)</code></li>
</ul>
<p>By tracking how these operations combine and systematically applying the chain rule, AD computes exact derivatives through the entire computation. When implemented in frameworks like PyTorch or TensorFlow, this enables automatic computation of gradients through arbitrary neural network architectures. This fundamental understanding of how AD decomposes and tracks computations sets the foundation for examining its implementation in machine learning frameworks. We will explore its mathematical principles, system architecture implications, and performance considerations that make modern machine learning possible.</p>
<section id="computational-methods" class="level4">
<h4 class="anchored" data-anchor-id="computational-methods">Computational Methods</h4>
<section id="forward-mode" class="level5">
<h5 class="anchored" data-anchor-id="forward-mode">Forward Mode</h5>
<p>Forward mode automatic differentiation computes derivatives alongside the original computation, tracking how changes propagate from input to output. This approach mirrors how we might manually compute derivatives, making it intuitive to understand and implement in machine learning frameworks.</p>
<p>Consider our previous example with a slight modification to show how forward mode works:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):    <span class="co"># Computing both value and derivative</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Step 1: x -&gt; x²</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  a <span class="op">=</span> x <span class="op">*</span> x           <span class="co"># Value: x²</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  da <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> x          <span class="co"># Derivative: 2x</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Step 2: x -&gt; sin(x)</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  b <span class="op">=</span> sin(x)          <span class="co"># Value: sin(x)</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  db <span class="op">=</span> cos(x)         <span class="co"># Derivative: cos(x)</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Step 3: Combine using product rule</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  result <span class="op">=</span> a <span class="op">*</span> b      <span class="co"># Value: x² * sin(x)</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  dresult <span class="op">=</span> a <span class="op">*</span> db <span class="op">+</span> b <span class="op">*</span> da  <span class="co"># Derivative: x²*cos(x) + sin(x)*2x</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> result, dresult</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Forward mode achieves this systematic derivative computation by augmenting each number with its derivative value, creating what mathematicians call a “dual number.” When x = 2.0, the computation tracks both values and derivatives:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="fl">2.0</span>    <span class="co"># Initial value</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>dx <span class="op">=</span> <span class="fl">1.0</span>   <span class="co"># We're tracking derivative with respect to x</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: x²</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="fl">4.0</span>    <span class="co"># (2.0)²</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>da <span class="op">=</span> <span class="fl">4.0</span>   <span class="co"># 2 * 2.0</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2: sin(x)</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="fl">0.909</span>   <span class="co"># sin(2.0)</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>db <span class="op">=</span> <span class="op">-</span><span class="fl">0.416</span> <span class="co"># cos(2.0)</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Final result</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> <span class="fl">3.637</span>   <span class="co"># 4.0 * 0.909</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>dresult <span class="op">=</span> <span class="fl">2.805</span>  <span class="co"># 4.0 * (-0.416) + 0.909 * 4.0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="implementation-structure" class="level6">
<h6 class="anchored" data-anchor-id="implementation-structure">Implementation Structure</h6>
<p>Forward mode AD structures computations to track both values and derivatives simultaneously through programs. Consider again our simple example:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> x <span class="op">*</span> x</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> sin(x)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">*</span> b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>When a framework executes this function in forward mode, it augments each computation to carry two pieces of information: the value itself and how that value changes with respect to the input. This paired movement of value and derivative mirrors how we think about rates of change:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Conceptually, each computation tracks (value, derivative)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> (<span class="fl">2.0</span>, <span class="fl">1.0</span>)           <span class="co"># Input value and its derivative</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> (<span class="fl">4.0</span>, <span class="fl">4.0</span>)           <span class="co"># x² and its derivative 2x</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> (<span class="fl">0.909</span>, <span class="op">-</span><span class="fl">0.416</span>)      <span class="co"># sin(x) and its derivative cos(x)</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> (<span class="fl">3.637</span>, <span class="fl">2.805</span>)  <span class="co"># Final value and derivative</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This forward propagation of derivative information happens automatically within the framework’s computational machinery. The framework: 1. Enriches each value with derivative information 2. Transforms each basic operation to handle both value and derivative 3. Propagates this information forward through the computation</p>
<p>The beauty of this approach is that it follows the natural flow of computation - as values move forward through the program, their derivatives move with them. This makes forward mode particularly well-suited for functions with single inputs and multiple outputs, as the derivative information follows the same path as the regular computation.</p>
</section>
<section id="performance-characteristics" class="level6">
<h6 class="anchored" data-anchor-id="performance-characteristics">Performance Characteristics</h6>
<p>Forward mode AD exhibits distinct performance patterns that influence when and how frameworks employ it. Understanding these characteristics helps explain why frameworks choose different AD approaches for different scenarios.</p>
<p>Forward mode performs one derivative computation alongside each original operation. For a function with one input variable, this means roughly doubling the computational work - once for the value, once for the derivative. The cost scales linearly with the number of operations in the program, making it predictable and manageable for simple computations.</p>
<p>However, consider a neural network layer computing derivatives for matrix multiplication between weights and inputs. To compute derivatives with respect to all weights, forward mode would need to perform the computation once for each weight parameter - potentially thousands of times. This reveals an important characteristic: forward mode’s efficiency depends on the number of input variables we need derivatives for.</p>
<p>Forward mode’s memory requirements are relatively modest. It needs to store the original value, a single derivative value, and temporary results during computation. The memory usage stays constant regardless of how complex the computation becomes. This predictable memory pattern makes forward mode particularly suitable for embedded systems with limited memory, real-time applications requiring consistent memory use, and systems where memory bandwidth is a bottleneck.</p>
<p>This combination of computational scaling with input variables but constant memory usage creates specific trade-offs that influence framework design decisions. Forward mode shines in scenarios with few inputs but many outputs, where its straightforward implementation and predictable resource usage outweigh the computational cost of multiple passes.</p>
</section>
<section id="use-cases" class="level6">
<h6 class="anchored" data-anchor-id="use-cases">Use Cases</h6>
<p>While forward mode automatic differentiation isn’t the primary choice for training full neural networks, it plays several important roles in modern machine learning frameworks. Its strength lies in scenarios where we need to understand how small changes in inputs affect a network’s behavior. Consider a data scientist trying to understand why their model makes certain predictions. They might want to analyze how changing a single pixel in an image or a specific feature in their data affects the model’s output:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> analyze_image_sensitivity(model, image):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Forward mode tracks how changing one pixel</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># affects the final classification</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    layer1 <span class="op">=</span> relu(W1 <span class="op">@</span> image <span class="op">+</span> b1)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    layer2 <span class="op">=</span> relu(W2 <span class="op">@</span> layer1 <span class="op">+</span> b2)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    predictions <span class="op">=</span> softmax(W3 <span class="op">@</span> layer2 <span class="op">+</span> b3)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> predictions</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>As the computation moves through each layer, forward mode carries both values and derivatives, making it straightforward to see how input perturbations ripple through to the final prediction. For each operation, we can track exactly how small changes propagate forward.</p>
<p>Neural network interpretation presents another compelling application. When researchers want to generate saliency maps or attribution scores, they often need to compute how each input element influences the output:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_feature_importance(model, input_features):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Track influence of each input feature</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># through the network's computation</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    hidden <span class="op">=</span> tanh(W1 <span class="op">@</span> input_features <span class="op">+</span> b1)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    logits <span class="op">=</span> W2 <span class="op">@</span> hidden <span class="op">+</span> b2</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Forward mode efficiently computes d(logits)/d(input)</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> logits</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In specialized training scenarios, particularly those involving online learning where models update on individual examples, forward mode offers advantages. The framework can track derivatives for a single example through the network efficiently, though this approach becomes less practical when dealing with batch training or updating multiple model parameters simultaneously.</p>
<p>Understanding these use cases helps explain why machine learning frameworks maintain forward mode capabilities alongside other differentiation strategies. While reverse mode handles the heavy lifting of full model training, forward mode provides an elegant solution for specific analytical tasks where its computational pattern matches the problem structure.</p>
</section>
</section>
<section id="reverse-mode" class="level5">
<h5 class="anchored" data-anchor-id="reverse-mode">Reverse Mode</h5>
<p>Reverse mode automatic differentiation forms the computational backbone of modern neural network training. This isn’t by accident - reverse mode’s structure perfectly matches what we need for training neural networks. During training, we have one scalar output (the loss function) and need derivatives with respect to millions of parameters (the network weights). Reverse mode is exceptionally efficient at computing exactly this pattern of derivatives.</p>
<p>Let’s examine a simple computation in detail:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> x <span class="op">*</span> x        <span class="co"># First operation: square x</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> sin(x)       <span class="co"># Second operation: sine of x</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> a <span class="op">*</span> b        <span class="co"># Third operation: multiply results</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> c</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In this function, we have three operations that create a computational chain. Notice how ‘x’ influences the final result ‘c’ through two different paths: once through squaring (a = x²) and once through sine (b = sin(x)). We’ll need to account for both paths when computing derivatives.</p>
<p>First, the forward pass computes and stores values:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Forward pass - computing and storing each intermediate value</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="fl">2.0</span>             <span class="co"># Our input value</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="fl">4.0</span>             <span class="co"># x * x = 2.0 * 2.0 = 4.0</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="fl">0.909</span>           <span class="co"># sin(2.0) ≈ 0.909</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> <span class="fl">3.637</span>           <span class="co"># a * b = 4.0 * 0.909 ≈ 3.637</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Then comes the backward pass. This is where reverse mode shows its elegance. We start at the output and work backwards:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Backward pass - computing derivatives in reverse</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>dc<span class="op">/</span>dc <span class="op">=</span> <span class="fl">1.0</span>    <span class="co"># Derivative of output with respect to itself is 1</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Moving backward through multiplication c = a * b</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>dc<span class="op">/</span>da <span class="op">=</span> b      <span class="co"># ∂(a*b)/∂a = b = 0.909</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>dc<span class="op">/</span>db <span class="op">=</span> a      <span class="co"># ∂(a*b)/∂b = a = 4.0</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Finally, combining derivatives for x through both paths</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Path 1: x -&gt; x² -&gt; c    contribution: 2x * dc/da</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Path 2: x -&gt; sin(x) -&gt; c contribution: cos(x) * dc/db</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>dc<span class="op">/</span>dx <span class="op">=</span> (<span class="dv">2</span><span class="er">x</span> <span class="op">*</span> dc<span class="op">/</span>da) <span class="op">+</span> (cos(x) <span class="op">*</span> dc<span class="op">/</span>db)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>      <span class="op">=</span> (<span class="dv">2</span> <span class="op">*</span> <span class="fl">2.0</span> <span class="op">*</span> <span class="fl">0.909</span>) <span class="op">+</span> (cos(<span class="fl">2.0</span>) <span class="op">*</span> <span class="fl">4.0</span>)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>      <span class="op">=</span> <span class="fl">3.636</span> <span class="op">+</span> (<span class="op">-</span><span class="fl">0.416</span> <span class="op">*</span> <span class="fl">4.0</span>)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>      <span class="op">=</span> <span class="fl">2.805</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The power of reverse mode becomes clear when we consider what would happen if we added more operations that depend on x. Forward mode would need to track derivatives through each new path, but reverse mode efficiently handles all paths in a single backward pass. This is exactly the scenario in neural networks, where each weight can affect the final loss through multiple paths in the network.</p>
<section id="implementation-structure-1" class="level6">
<h6 class="anchored" data-anchor-id="implementation-structure-1">Implementation Structure</h6>
<p>The implementation of reverse mode in machine learning frameworks requires careful orchestration of computation and memory. While forward mode simply augments each computation, reverse mode needs to maintain a record of the forward computation to enable the backward pass. Modern frameworks accomplish this through computational graphs and automatic gradient accumulation.</p>
<p>Let’s extend our previous example to a small neural network computation to see how this works:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simple_network(x, w1, w2):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Forward pass</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    hidden <span class="op">=</span> x <span class="op">*</span> w1             <span class="co"># First layer multiplication</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    activated <span class="op">=</span> <span class="bu">max</span>(<span class="dv">0</span>, hidden)  <span class="co"># ReLU activation</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> activated <span class="op">*</span> w2     <span class="co"># Second layer multiplication</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> output               <span class="co"># Final output (before loss)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>During the forward pass, the framework doesn’t just compute values - it builds a graph of operations while tracking intermediate results:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Forward pass with value tracking</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>w1 <span class="op">=</span> <span class="fl">2.0</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>w2 <span class="op">=</span> <span class="fl">3.0</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>hidden <span class="op">=</span> <span class="fl">2.0</span>        <span class="co"># x * w1 = 1.0 * 2.0</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>activated <span class="op">=</span> <span class="fl">2.0</span>     <span class="co"># max(0, 2.0) = 2.0</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> <span class="fl">6.0</span>        <span class="co"># activated * w2 = 2.0 * 3.0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The backward pass then uses this saved information to compute gradients for each parameter:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Backward pass through computation</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>d_output <span class="op">=</span> <span class="fl">1.0</span>          <span class="co"># Start with derivative of output</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>d_w2 <span class="op">=</span> activated        <span class="co"># d_output * d(output)/d_w2</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># = 1.0 * 2.0 = 2.0</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>d_activated <span class="op">=</span> w2        <span class="co"># d_output * d(output)/d_activated</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># = 1.0 * 3.0 = 3.0</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="co"># ReLU gradient: 1 if input was &gt; 0, 0 otherwise</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>d_hidden <span class="op">=</span> d_activated <span class="op">*</span> (<span class="dv">1</span> <span class="cf">if</span> hidden <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span>) <span class="co"># 3.0 * 1 = 3.0</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>d_w1 <span class="op">=</span> x <span class="op">*</span> d_hidden    <span class="co"># 1.0 * 3.0 = 3.0</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>d_x <span class="op">=</span> w1 <span class="op">*</span> d_hidden    <span class="co"># 2.0 * 3.0 = 6.0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This example illustrates several key implementation considerations: 1. The framework must track dependencies between operations 2. Intermediate values must be stored for the backward pass 3. Gradient computations follow the reverse topological order of the forward computation 4. Each operation needs both forward and backward implementations</p>
</section>
<section id="memory-management-strategies" class="level6">
<h6 class="anchored" data-anchor-id="memory-management-strategies">Memory Management Strategies</h6>
<p>Memory management represents one of the key challenges in implementing reverse mode differentiation in machine learning frameworks. Unlike forward mode where we can discard intermediate values as we go, reverse mode requires storing results from the forward pass to compute gradients during the backward pass.</p>
<p>Consider our neural network example extended to show memory usage patterns:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> deep_network(x, w1, w2, w3):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Forward pass - must store intermediates</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    hidden1 <span class="op">=</span> x <span class="op">*</span> w1</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    activated1 <span class="op">=</span> <span class="bu">max</span>(<span class="dv">0</span>, hidden1)   <span class="co"># Store for backward</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    hidden2 <span class="op">=</span> activated1 <span class="op">*</span> w2</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    activated2 <span class="op">=</span> <span class="bu">max</span>(<span class="dv">0</span>, hidden2)   <span class="co"># Store for backward</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> activated2 <span class="op">*</span> w3</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> output</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Each intermediate value needed for gradient computation must be kept in memory until its backward pass completes. As networks grow deeper, this memory requirement grows linearly with network depth. For a typical deep neural network processing a batch of images, this can mean gigabytes of stored activations.</p>
<p>Frameworks employ several strategies to manage this memory burden:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Conceptual example of memory management</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> training_step(model, input_batch):</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Strategy 1: Checkpointing</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> checkpoint_scope():</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        hidden1 <span class="op">=</span> activation(layer1(input_batch))</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Framework might free some memory here</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        hidden2 <span class="op">=</span> activation(layer2(hidden1))</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># More selective memory management</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        output <span class="op">=</span> layer3(hidden2)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Strategy 2: Gradient accumulation</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    loss <span class="op">=</span> compute_loss(output)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Backward pass with managed memory</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    loss.backward()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Modern frameworks automatically balance memory usage and computation speed. They might recompute some intermediate values during the backward pass rather than storing everything, particularly for memory-intensive operations. This trade-off between memory and computation becomes especially important in large-scale training scenarios.</p>
</section>
<section id="optimization-techniques" class="level6">
<h6 class="anchored" data-anchor-id="optimization-techniques">Optimization Techniques</h6>
<p>Reverse mode automatic differentiation in machine learning frameworks employs several key optimization techniques to enhance training efficiency. These optimizations become crucial when training large neural networks where computational and memory resources are pushed to their limits.</p>
<p>Modern frameworks implement gradient checkpointing, a technique that strategically balances computation and memory. Consider a deep neural network:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> deep_network(input_tensor):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># A typical deep network computation</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    layer1 <span class="op">=</span> large_dense_layer(input_tensor)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    activation1 <span class="op">=</span> relu(layer1)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    layer2 <span class="op">=</span> large_dense_layer(activation1)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    activation2 <span class="op">=</span> relu(layer2)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ... many more layers</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> final_layer(activation_n)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> output</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Instead of storing all intermediate activations, frameworks can strategically recompute certain values during the backward pass. This trades additional computation for reduced memory usage. The framework might save activations only every few layers:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Conceptual representation of checkpointing</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>checkpoint1 <span class="op">=</span> save_for_backward(activation1)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Intermediate activations can be recomputed</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>checkpoint2 <span class="op">=</span> save_for_backward(activation4)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Framework balances storage vs recomputation</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Another crucial optimization involves operation fusion. Rather than treating each mathematical operation separately, frameworks combine operations that commonly occur together. Matrix multiplication followed by bias addition, for instance, can be fused into a single operation, reducing memory transfers and improving hardware utilization.</p>
<p>The backward pass itself can be optimized by reordering computations to maximize hardware efficiency. Consider the gradient computation for a convolution layer - rather than directly translating the mathematical definition into code, frameworks implement specialized backward operations that take advantage of modern hardware capabilities.</p>
<p>These optimizations work together to make the training of large neural networks practical. Without them, many modern architectures would be prohibitively expensive to train, both in terms of memory usage and computation time.</p>
</section>
</section>
</section>
<section id="integration-with-frameworks" class="level4">
<h4 class="anchored" data-anchor-id="integration-with-frameworks">Integration with Frameworks</h4>
<p>The integration of automatic differentiation into machine learning frameworks requires careful system design to balance flexibility, performance, and usability. Modern frameworks like PyTorch and TensorFlow expose AD capabilities through high-level APIs while maintaining the sophisticated underlying machinery.</p>
<p>Let’s examine how frameworks present AD to users:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># PyTorch-style automatic differentiation</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> neural_network(x):</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Framework transparently tracks operations</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    layer1 <span class="op">=</span> nn.Linear(<span class="dv">784</span>, <span class="dv">256</span>)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    layer2 <span class="op">=</span> nn.Linear(<span class="dv">256</span>, <span class="dv">10</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Each operation is automatically tracked</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    hidden <span class="op">=</span> torch.relu(layer1(x))</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> layer2(hidden)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> output</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Training loop showing AD integration</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> batch_x, batch_y <span class="kw">in</span> data_loader:</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    optimizer.zero_grad()    <span class="co"># Clear previous gradients</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> neural_network(batch_x)</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    loss <span class="op">=</span> loss_function(output, batch_y)</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Framework handles all AD machinery</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    loss.backward()         <span class="co"># Automatic backward pass</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    optimizer.step()        <span class="co"># Parameter updates</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>While this code appears straightforward, it masks considerable complexity. The framework must:</p>
<ol type="1">
<li>Track all operations during the forward pass</li>
<li>Build and maintain the computational graph</li>
<li>Manage memory for intermediate values</li>
<li>Schedule gradient computations efficiently</li>
<li>Interface with hardware accelerators</li>
</ol>
<p>This integration extends beyond basic training. Frameworks must handle complex scenarios like higher-order gradients, where we compute derivatives of derivatives, and mixed-precision training, where different parts of the computation use different numerical precisions:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Computing higher-order gradients</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.set_grad_enabled(<span class="va">True</span>):</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># First-order gradient computation</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  output <span class="op">=</span> model(<span class="bu">input</span>)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  grad_output <span class="op">=</span> torch.autograd.grad(</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>       output,</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>       model.parameters())</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Second-order gradient computation</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>  grad2_output <span class="op">=</span> torch.autograd.grad(</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>       grad_output,</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>       model.parameters())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="memory-consequences" class="level4">
<h4 class="anchored" data-anchor-id="memory-consequences">Memory Consequences</h4>
<p>The memory demands of automatic differentiation stem from a fundamental requirement: to compute gradients during the backward pass, we must remember what happened during the forward pass. This seemingly simple requirement creates interesting challenges for machine learning frameworks. Unlike traditional programs that can discard intermediate results as soon as they’re used, AD systems must carefully preserve computational history.</p>
<p>Consider what happens in a neural network’s forward pass:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> neural_network(x):</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Each operation creates values we need to remember</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> layer1(x)      <span class="co"># Must store for backward pass</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> relu(a)        <span class="co"># Must store input to relu</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> layer2(b)      <span class="co"># Must store for backward pass</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> c</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>When this network processes data, each operation creates not just its output, but also a memory obligation. The multiplication in layer1 needs to remember its inputs because computing its gradient later will require them. Even the seemingly simple relu function must track which inputs were negative to correctly propagate gradients. As networks grow deeper, these memory requirements accumulate.</p>
<p>This memory challenge becomes particularly interesting with deep neural networks:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># A deeper network shows the accumulating memory needs</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>hidden1 <span class="op">=</span> large_matrix_multiply(<span class="bu">input</span>, weights1)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>activated1 <span class="op">=</span> relu(hidden1)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>hidden2 <span class="op">=</span> large_matrix_multiply(activated1, weights2)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>activated2 <span class="op">=</span> relu(hidden2)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> large_matrix_multiply(activated2, weights3)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Each layer’s computation adds to our memory burden. The framework must keep hidden1 in memory until we’ve computed gradients through hidden2, but after that, we can safely discard it. This creates a wave of memory usage that peaks when we start the backward pass and gradually recedes as we compute gradients.</p>
<p>Modern frameworks handle this memory choreography automatically. They track the lifetime of each intermediate value - how long it must remain in memory for gradient computation. When training large models, this careful memory management becomes as crucial as the numerical computations themselves. The framework frees memory as soon as it’s no longer needed for gradient computation, ensuring that our memory usage, while necessarily large, remains as efficient as possible.</p>
</section>
<section id="system-considerations" class="level4">
<h4 class="anchored" data-anchor-id="system-considerations">System Considerations</h4>
<p>Automatic differentiation’s integration into machine learning frameworks raises important system-level considerations that affect both framework design and training performance. These considerations become particularly apparent when training large neural networks where efficiency at every level matters.</p>
<p>Consider a typical training loop that highlights these system-level interactions:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> train_epoch(model, data_loader):</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> batch_x, batch_y <span class="kw">in</span> data_loader:</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Moving data between CPU and accelerator</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>        batch_x <span class="op">=</span> batch_x.to(device)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>        batch_y <span class="op">=</span> batch_y.to(device)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Forward pass builds computational graph</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>        outputs <span class="op">=</span> model(batch_x)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        loss <span class="op">=</span> criterion(outputs, batch_y)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Backward pass computes gradients</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>        loss.backward()</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>        optimizer.step()</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>        optimizer.zero_grad()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This simple loop masks complex system interactions. The AD system must coordinate with multiple framework components: the memory allocator, the device manager, the operation scheduler, and the optimizer. Each gradient computation potentially triggers data movement between devices, memory allocation, and kernel launches on accelerators.</p>
<p>The scheduling of AD operations becomes particularly intricate with modern hardware accelerators:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Complex model with parallel computations</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parallel_network(x):</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># These operations could run concurrently</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    branch1 <span class="op">=</span> conv_layer1(x)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    branch2 <span class="op">=</span> conv_layer2(x)</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Must synchronize for combination</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    combined <span class="op">=</span> branch1 <span class="op">+</span> branch2</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> final_layer(combined)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The AD system must track dependencies not just for correct gradient computation, but also for efficient hardware utilization. It needs to determine which gradient computations can run in parallel and which must wait for others to complete. This dependency tracking extends across both forward and backward passes, creating a complex scheduling problem.</p>
<p>Modern frameworks handle these system-level concerns while maintaining a simple interface for users. Behind the scenes, they make sophisticated decisions about operation scheduling, memory allocation, and data movement, all while ensuring correct gradient computation through the computational graph.</p>
</section>
<section id="summary" class="level4">
<h4 class="anchored" data-anchor-id="summary">Summary</h4>
<p>Automatic differentiation systems represent an important computational abstraction in machine learning frameworks, transforming the mathematical concept of derivatives into efficient implementations. Through our examination of both forward and reverse modes, we’ve seen how frameworks balance mathematical precision with computational efficiency to enable training of modern neural networks.</p>
<p>The implementation of AD systems reveals key design patterns in machine learning frameworks:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Simple computation showing AD machinery</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> computation(x, w):</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Framework tracks operations</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    hidden <span class="op">=</span> x <span class="op">*</span> w     <span class="co"># Stored for backward pass</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> relu(hidden)  <span class="co"># Tracks activation pattern</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> output</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This simple computation embodies several fundamental concepts:</p>
<ol type="1">
<li>Operation tracking for derivative computation</li>
<li>Memory management for intermediate values</li>
<li>System coordination for efficient execution</li>
</ol>
<p>Modern frameworks abstract these complexities behind clean interfaces while maintaining high performance:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Framework hides AD complexity</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>loss <span class="op">=</span> model(<span class="bu">input</span>)  <span class="co"># Forward pass tracks computation</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>loss.backward()      <span class="co"># Triggers efficient reverse mode AD</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>optimizer.step()     <span class="co"># Uses computed gradients</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The effectiveness of automatic differentiation systems stems from their careful balance of competing demands. They must maintain sufficient computational history for accurate gradients while managing memory constraints, schedule operations efficiently while preserving correctness, and provide flexibility while optimizing performance.</p>
<p>Understanding these systems proves essential for both framework developers and practitioners. Framework developers must implement efficient AD to enable modern deep learning, while practitioners benefit from understanding AD’s capabilities and constraints when designing and training models.</p>
<p>While automatic differentiation provides the computational foundation for gradient-based learning, its practical implementation depends heavily on how frameworks organize and manipulate data. This brings us to our next topic: the data structures that enable efficient computation and memory management in machine learning frameworks. These structures must not only support AD operations but also provide efficient access patterns for the diverse hardware platforms that power modern machine learning.</p>
<section id="looking-forward" class="level5">
<h5 class="anchored" data-anchor-id="looking-forward">Looking Forward</h5>
<p>The automatic differentiation systems we’ve explored provide the computational foundation for neural network training, but they don’t operate in isolation. These systems need efficient ways to represent and manipulate the data flowing through them. This brings us to our next topic: the data structures that machine learning frameworks use to organize and process information.</p>
<p>Consider how our earlier examples handled numerical values:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> neural_network(x):</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    hidden <span class="op">=</span> w1 <span class="op">*</span> x     <span class="co"># What exactly is x?</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    activated <span class="op">=</span> relu(hidden)  <span class="co"># How is hidden stored?</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> w2 <span class="op">*</span> activated  <span class="co"># What type of multiplication?</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> output</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>These operations appear straightforward, but they raise important questions. How do frameworks represent these values? How do they organize data to enable efficient computation and automatic differentiation? Most importantly, how do they structure data to take advantage of modern hardware?</p>
<p>The next section examines how frameworks answer these questions through specialized data structures, particularly tensors, that form the basic building blocks of machine learning computations.</p>
</section>
</section>
</section>
<section id="data-structures" class="level3 page-columns page-full" data-number="7.3.3">
<h3 data-number="7.3.3" class="anchored" data-anchor-id="data-structures"><span class="header-section-number">7.3.3</span> Data Structures</h3>
<p>Machine learning frameworks extend computational graphs with specialized data structures, bridging high-level computations with practical implementations. These data structures have two essential purposes: they provide containers for the numerical data that powers machine learning models, and they manage how this data is stored and moved across different memory spaces and devices.</p>
<p>While computational graphs specify the logical flow of operations, data structures determine how these operations actually access and manipulate data in memory. This dual role of organizing numerical data for model computations while handling the complexities of memory management and device placement shapes how frameworks translate mathematical operations into efficient executions across diverse computing platforms.</p>
<p>The effectiveness of machine learning frameworks depends heavily on their underlying data organization. While machine learning theory can be expressed through mathematical equations, turning these equations into practical implementations demands thoughtful consideration of data organization, storage, and manipulation. Modern machine learning models must process enormous amounts of data during training and inference, making efficient data access and memory usage critical across diverse hardware platforms.</p>
<p>A framework’s data structures must excel in three key areas. First, they need to deliver high performance, supporting rapid data access and efficient memory use across different hardware. This includes optimizing memory layouts for cache efficiency and enabling smooth data transfer between memory hierarchies and devices. Second, they must offer flexibility, accommodating various model architectures and training approaches while supporting different data types and precision requirements. Third, they should provide clear and intuitive interfaces to developers while handling complex memory management and device placement behind the scenes.</p>
<p>These data structures bridge mathematical concepts and practical computing systems. The operations in machine learning—matrix multiplication, convolution, activation functions—set basic requirements for how data must be organized. These structures must maintain numerical precision and stability while enabling efficient implementation of common operations and automatic gradient computation. However, they must also work within real-world computing constraints, dealing with limited memory bandwidth, varying hardware capabilities, and the needs of distributed computing.</p>
<p>The design choices made in implementing these data structures significantly influence what machine learning frameworks can achieve. Poor decisions in data structure design can result in excessive memory use, limiting model size and batch capabilities. They might create performance bottlenecks that slow down training and inference, or produce interfaces that make programming error-prone. On the other hand, thoughtful design enables automatic optimization of memory usage and computation, efficient scaling across hardware configurations, and intuitive programming interfaces that support rapid implementation of new techniques.</p>
<p>As we explore specific data structures in the following sections, we’ll examine how frameworks address these challenges through careful design decisions and optimization approaches. This understanding proves essential for anyone working with machine learning systems, whether developing new models, optimizing existing ones, or creating new framework capabilities. We begin with tensor abstractions, the fundamental building blocks of modern machine learning frameworks, before exploring more specialized structures for parameter management, dataset handling, and execution control.</p>
<section id="tensors" class="level4">
<h4 class="anchored" data-anchor-id="tensors">Tensors</h4>
<p>Machine learning frameworks process and store numerical data as tensors. Every computation in a neural network, from processing input data to updating model weights, operates on tensors. Training batches of images, activation maps in convolutional networks, and parameter gradients during backpropagation all take the form of tensors. This unified representation allows frameworks to implement consistent interfaces for data manipulation and optimize operations across different hardware architectures.</p>
<section id="structure-and-dimensionality" class="level5">
<h5 class="anchored" data-anchor-id="structure-and-dimensionality">Structure and Dimensionality</h5>
<p>A tensor is a mathematical object that generalizes scalars, vectors, and matrices to higher dimensions. The dimensionality forms a natural hierarchy: a scalar is a zero-dimensional tensor containing a single value, a vector is a one-dimensional tensor containing a sequence of values, and a matrix is a two-dimensional tensor containing values arranged in rows and columns. Higher-dimensional tensors extend this pattern through nested structures; for instance, as illustrated in <a href="#fig-tensor-data-structure-a" class="quarto-xref">Figure&nbsp;<span>7.7</span></a>, a three-dimensional tensor can be visualized as a stack of matrices. Therefore, vectors and matrices can be considered special cases of tensors with 1D and 2D dimensions, respectively.</p>
<div id="fig-tensor-data-structure-a" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="htb" data-fig-env="figure">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-tensor-data-structure-a-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="5a14326be5b802a50e34197aefbddc65a5cafdec.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-8" title="Figure&nbsp;7.7: Visualization of a tensor data structure."><img src="frameworks_files/mediabag/5a14326be5b802a50e34197aefbddc65a5cafdec.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-tensor-data-structure-a-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7.7: Visualization of a tensor data structure.
</figcaption>
</figure>
</div>
<p>In practical applications, tensors naturally arise when dealing with complex data structures. As illustrated in <a href="#fig-tensor-data-structure-b" class="quarto-xref">Figure&nbsp;<span>7.8</span></a>, image data exemplifies this concept particularly well. Color images comprise three channels, where each channel represents the intensity values of red, green, or blue as a distinct matrix. These channels combine to create the full colored image, forming a natural 3D tensor structure. When processing multiple images simultaneously, such as in batch operations, a fourth dimension can be added to create a 4D tensor, where each slice represents a complete three-channel image. This hierarchical organization demonstrates how tensors efficiently handle multidimensional data while maintaining clear structural relationships.</p>
<div id="fig-tensor-data-structure-b" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="htb" data-fig-env="figure">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-tensor-data-structure-b-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="3116c0bce7529c4032c36143899dc2272d09fe5e.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-9" title="Figure&nbsp;7.8: Visualization of colored image structure that can be easily stored as a 3D Tensor. Credit: Niklas Lang"><img src="frameworks_files/mediabag/3116c0bce7529c4032c36143899dc2272d09fe5e.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-tensor-data-structure-b-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7.8: Visualization of colored image structure that can be easily stored as a 3D Tensor. Credit: <a href="https://towardsdatascience.com/what-are-tensors-in-machine-learning-5671814646ff">Niklas Lang</a>
</figcaption>
</figure>
</div>
<p>In machine learning frameworks, tensors take on additional properties beyond their mathematical definition to meet the demands of modern ML systems. While mathematical tensors provide a foundation as multi-dimensional arrays with transformation properties, machine learning introduces requirements for practical computation. These requirements shape how frameworks balance mathematical precision with computational performance.</p>
<p>Framework tensors combine numerical data arrays with computational metadata. The dimensional structure, or shape, ranges from simple vectors and matrices to higher-dimensional arrays that represent complex data like image batches or sequence models. This dimensional information plays a critical role in operation validation and optimization. Matrix multiplication operations, for example, depend on shape metadata to verify dimensional compatibility and determine optimal computation paths.</p>
<p>Memory layout implementation introduces distinct challenges in tensor design. While tensors provide an abstraction of multi-dimensional data, physical computer memory remains linear. Stride patterns address this disparity by creating mappings between multi-dimensional tensor indices and linear memory addresses. These patterns significantly impact computational performance by determining memory access patterns during tensor operations. Careful alignment of stride patterns with hardware memory hierarchies maximizes cache efficiency and memory throughput.</p>
</section>
<section id="type-systems-and-precision" class="level5">
<h5 class="anchored" data-anchor-id="type-systems-and-precision">Type Systems and Precision</h5>
<p>Tensor implementations use type systems to control numerical precision and memory consumption. The standard choice in machine learning has been 32-bit floating-point numbers (<code>float32</code>), offering a balance of precision and efficiency. Modern frameworks extend this with multiple numeric types for different needs. Integer types support indexing and embedding operations. Reduced-precision types like 16-bit floating-point numbers enable efficient mobile deployment. 8-bit integers allow fast inference on specialized hardware.</p>
<p>The choice of numeric type affects both model behavior and computational efficiency. Neural network training typically requires float32 precision to maintain stable gradient computations. Inference tasks can often use lower precision (<code>int8</code> or even <code>int4</code>), reducing memory usage and increasing processing speed. Mixed-precision training approaches combine these benefits by using float32 for critical accumulations while performing most computations at lower precision.</p>
<p>Type conversions between different numeric representations require careful management. Operating on tensors with different types demands explicit conversion rules to preserve numerical correctness. These conversions introduce computational costs and risk precision loss. Frameworks provide type casting capabilities but rely on developers to maintain numerical precision across operations.</p>
</section>
<section id="device-placement-and-memory-management" class="level5">
<h5 class="anchored" data-anchor-id="device-placement-and-memory-management">Device Placement and Memory Management</h5>
<p>The rise of heterogeneous computing has transformed how machine learning frameworks manage tensor operations. Modern frameworks must seamlessly operate across CPUs, GPUs, TPUs, and various other accelerators, each offering different computational advantages and memory characteristics. This diversity creates a fundamental challenge: tensors must move efficiently between devices while maintaining computational coherency throughout the execution of machine learning workloads.</p>
<p>Device placement decisions significantly influence both computational performance and memory utilization. Moving tensors between devices introduces latency costs and consumes precious bandwidth on system interconnects. Keeping multiple copies of tensors across different devices can accelerate computation by reducing data movement, but this strategy increases overall memory consumption and requires careful management of consistency between copies. Frameworks must therefore implement sophisticated memory management systems that track tensor locations and orchestrate data movement while considering these tradeoffs.</p>
<p>These memory management systems maintain a dynamic view of available device memory and implement strategies for efficient data transfer. When operations require tensors that reside on different devices, the framework must either move data or redistribute computation. This decision process integrates deeply with the framework’s computational graph execution and operation scheduling. Memory pressure on individual devices, data transfer costs, and computational load all factor into placement decisions.</p>
<p>The interplay between device placement and memory management extends beyond simple data movement. Frameworks must anticipate future computational needs to prefetch data efficiently, manage memory fragmentation across devices, and handle cases where memory demands exceed device capabilities. This requires close coordination between the memory management system and the operation scheduler, especially in scenarios involving parallel computation across multiple devices or distributed training across machine boundaries.</p>
</section>
</section>
<section id="specialized-structures" class="level4 page-columns page-full">
<h4 class="anchored" data-anchor-id="specialized-structures">Specialized Structures</h4>
<p>While tensors are the building blocks of machine learning frameworks, they are not the only structures required for effective system operation. Frameworks rely on a suite of specialized data structures tailored to address the distinct needs of data processing, model parameter management, and execution coordination. These structures ensure that the entire workflow—from raw data ingestion to optimized execution on hardware—proceeds seamlessly and efficiently.</p>
<section id="dataset-structures" class="level5">
<h5 class="anchored" data-anchor-id="dataset-structures">Dataset Structures</h5>
<p>Dataset structures handle the critical task of transforming raw input data into a format suitable for machine learning computations. These structures bridge the gap between diverse data sources and the tensor abstractions required by models, automating the process of reading, parsing, and preprocessing data.</p>
<p>Dataset structures must support efficient memory usage while dealing with input data far larger than what can fit into memory at once. For example, when training on large image datasets, these structures load images from disk, decode them into tensor-compatible formats, and apply transformations like normalization or augmentation in real time. Frameworks implement mechanisms such as data streaming, caching, and shuffling to ensure a steady supply of preprocessed batches without bottlenecks.</p>
<p>The design of dataset structures directly impacts training performance. Poorly designed structures can create significant overhead, limiting data throughput to GPUs or other accelerators. In contrast, well-optimized dataset handling can leverage parallelism across CPU cores, disk I/O, and memory transfers to feed accelerators at full capacity.</p>
<p>In large, multi-system distributed training scenarios, dataset structures also handle coordination between nodes, ensuring that each worker processes a distinct subset of data while maintaining consistency in operations like shuffling. This coordination prevents redundant computation and supports scalability across multiple devices and machines.</p>
</section>
<section id="parameter-structures" class="level5 page-columns page-full">
<h5 class="anchored" data-anchor-id="parameter-structures">Parameter Structures</h5>
<p>Parameter structures store the numerical values that define a machine learning model. These include the weights and biases of neural network layers, along with auxiliary data such as batch normalization statistics and optimizer state. Unlike datasets, which are transient, parameters persist throughout the lifecycle of model training and inference.</p>
<p>The design of parameter structures must balance efficient storage with rapid access during computation. For example, convolutional neural networks require parameters for filters, fully connected layers, and normalization layers, each with unique shapes and memory alignment requirements. Frameworks organize these parameters into compact representations that minimize memory consumption while enabling fast read and write operations.</p>
<p>A key challenge for parameter structures is managing memory efficiently across multiple devices <span class="citation" data-cites="li2014communication">(<a href="../references.html#ref-li2014communication" role="doc-biblioref">0003 et al. 2014</a>)</span>. During distributed training, frameworks may replicate parameters across GPUs for parallel computation while keeping a synchronized master copy on the CPU. This strategy ensures consistency while reducing the latency of gradient updates. Additionally, parameter structures often leverage memory sharing techniques to minimize duplication, such as storing gradients and optimizer states in place to conserve memory.</p>
<div class="no-row-height column-margin column-container"><div id="ref-li2014communication" class="csl-entry" role="listitem">
0003, Mu Li, David G. Andersen, Alexander J. Smola, and Kai Yu. 2014. <span>“Communication Efficient Distributed Machine Learning with the Parameter Server.”</span> In <em>Advances in Neural Information Processing Systems 27: Annual Conference on Neural Information Processing Systems 2014, December 8-13 2014, Montreal, Quebec, Canada</em>, edited by Zoubin Ghahramani, Max Welling, Corinna Cortes, Neil D. Lawrence, and Kilian Q. Weinberger, 19–27. <a href="https://proceedings.neurips.cc/paper/2014/hash/1ff1de774005f8da13f42943881c655f-Abstract.html">https://proceedings.neurips.cc/paper/2014/hash/1ff1de774005f8da13f42943881c655f-Abstract.html</a>.
</div></div><p>Parameter structures must also adapt to various precision requirements. While training typically uses 32-bit floating-point precision for stability, reduced precision such as 16-bit floating-point or even 8-bit integers is increasingly used for inference and large-scale training. Frameworks implement type casting and mixed-precision management to enable these optimizations without compromising numerical accuracy.</p>
</section>
<section id="execution-structures" class="level5 page-columns page-full">
<h5 class="anchored" data-anchor-id="execution-structures">Execution Structures</h5>
<p>Execution structures coordinate how computations are performed on hardware, ensuring that operations execute efficiently while respecting device constraints. These structures work closely with computational graphs, determining how data flows through the system and how memory is allocated for intermediate results.</p>
<p>One of the primary roles of execution structures is memory management. During training or inference, intermediate computations such as activation maps or gradients can consume significant memory. Execution structures dynamically allocate and deallocate memory buffers to avoid fragmentation and maximize hardware utilization. For example, a deep neural network might reuse memory allocated for activation maps across layers, reducing the overall memory footprint.</p>
<p>These structures also handle operation scheduling, ensuring that computations are performed in the correct order and with optimal hardware utilization. On GPUs, for instance, execution structures can overlap computation and data transfer operations, hiding latency and improving throughput. When running on multiple devices, they synchronize dependent computations to maintain consistency without unnecessary delays.</p>
<p>Distributed training introduces additional complexity, as execution structures must manage data and computation across multiple nodes. This includes partitioning computational graphs, synchronizing gradients, and redistributing data as needed. Efficient execution structures minimize communication overhead, allowing distributed systems to scale linearly with additional hardware <span class="citation" data-cites="mcmahan2023communicationefficient">(<a href="../references.html#ref-mcmahan2023communicationefficient" role="doc-biblioref">McMahan et al. 2017</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-mcmahan2023communicationefficient" class="csl-entry" role="listitem">
McMahan, Brendan, Eider Moore, Daniel Ramage, Seth Hampson, and Blaise Agüera y Arcas. 2017. <span>“Communication-Efficient Learning of Deep Networks from Decentralized Data.”</span> In <em>Proceedings of the 20th International Conference on Artificial Intelligence and Statistics, AISTATS 2017, 20-22 April 2017, Fort Lauderdale, FL, USA</em>, edited by Aarti Singh and Xiaojin (Jerry) Zhu, 54:1273–82. Proceedings of Machine Learning Research. PMLR. <a href="http://proceedings.mlr.press/v54/mcmahan17a.html">http://proceedings.mlr.press/v54/mcmahan17a.html</a>.
</div></div></section>
</section>
</section>
<section id="programming-models" class="level3" data-number="7.3.4">
<h3 data-number="7.3.4" class="anchored" data-anchor-id="programming-models"><span class="header-section-number">7.3.4</span> Programming Models</h3>
<p>Programming models define how developers express computations in code. In previous sections, we explored computational graphs and specialized data structures, which together define the computational processes of machine learning frameworks. Computational graphs outline the sequence of operations, such as matrix multiplication or convolution, while data structures like tensors store the numerical values that these operations manipulate. These models fall into two categories: symbolic programming and imperative programming.</p>
<section id="symbolic-programming" class="level4">
<h4 class="anchored" data-anchor-id="symbolic-programming">Symbolic Programming</h4>
<p>Symbolic programming involves constructing abstract representations of computations first and executing them later. This approach aligns naturally with static computational graphs, where the entire structure is defined before any computation occurs.</p>
<p>For instance, in symbolic programming, variables and operations are represented as symbols. These symbolic expressions are not evaluated until explicitly executed, allowing the framework to analyze and optimize the computation graph before running it.</p>
<p>Consider the following symbolic programming example:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Expressions are constructed but not evaluated</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> tf.Variable(tf.random.normal([<span class="dv">784</span>, <span class="dv">10</span>]))</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="bu">input</span> <span class="op">=</span> tf.placeholder(tf.float32, [<span class="va">None</span>, <span class="dv">784</span>])</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> tf.matmul(<span class="bu">input</span>, weights)</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Separate evaluation phase</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> tf.Session() <span class="im">as</span> sess:</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    sess.run(tf.global_variables_initializer())</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> sess.run(output, feed_dict<span class="op">=</span>{<span class="bu">input</span>: data})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This approach enables frameworks to apply global optimizations across the entire computation, making it efficient for deployment scenarios. Additionally, static graphs can be serialized and executed across different environments, enhancing portability. Predefined graphs also facilitate efficient parallel execution strategies. However, debugging can be challenging because errors often surface during execution rather than graph construction, and modifying a static graph dynamically is cumbersome.</p>
</section>
<section id="imperative-programming" class="level4">
<h4 class="anchored" data-anchor-id="imperative-programming">Imperative Programming</h4>
<p>Imperative programming takes a more traditional approach, executing operations immediately as they are encountered. This method corresponds to dynamic computational graphs, where the structure evolves dynamically during execution.</p>
<p>In this programming paradigm, computations are performed directly as the code executes, closely resembling the procedural style of most general-purpose programming languages. For example:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Imperative Programming Example</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Each expression evaluates immediately</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> torch.randn(<span class="dv">784</span>, <span class="dv">10</span>)</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="bu">input</span> <span class="op">=</span> torch.randn(<span class="dv">32</span>, <span class="dv">784</span>)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> <span class="bu">input</span> <span class="op">@</span> weights  <span class="co"># Computation occurs now</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The immediate execution model is intuitive and aligns with common programming practices, making it easier to use. Errors can be detected and resolved immediately during execution, simplifying debugging. Dynamic graphs allow for adjustments on-the-fly, making them ideal for tasks requiring variable graph structures, such as reinforcement learning or sequence modeling. However, the creation of dynamic graphs at runtime can introduce computational overhead, and the framework’s ability to optimize the entire computation graph is limited due to the step-by-step execution process.</p>
</section>
<section id="system-implementation-considerations" class="level4">
<h4 class="anchored" data-anchor-id="system-implementation-considerations">System Implementation Considerations</h4>
<p>The choice between symbolic and imperative programming models fundamentally influences how ML frameworks manage system-level features such as memory management and optimization strategies.</p>
<section id="performance-trade-offs" class="level5">
<h5 class="anchored" data-anchor-id="performance-trade-offs">Performance Trade-offs</h5>
<p>In symbolic programming, frameworks can analyze the entire computation graph upfront. This allows for efficient memory allocation strategies. For example, memory can be reused for intermediate results that are no longer needed during later stages of computation. This global view also enables advanced optimization techniques such as operation fusion, automatic differentiation, and hardware-specific kernel selection. These optimizations make symbolic programming highly effective for production environments where performance is critical.</p>
<p>In contrast, imperative programming makes memory management and optimization more challenging since decisions must be made at runtime. Each operation executes immediately, which prevents the framework from globally analyzing the computation. This trade-off, however, provides developers with greater flexibility and immediate feedback during development. Beyond system-level features, the choice of programming model also impacts the developer experience, particularly during model development and debugging.</p>
</section>
<section id="development-and-debugging" class="level5">
<h5 class="anchored" data-anchor-id="development-and-debugging">Development and Debugging</h5>
<p>Symbolic programming requires developers to conceptualize their models as complete computational graphs. This often involves extra steps to inspect intermediate values, as symbolic execution defers computation until explicitly invoked. For example, in TensorFlow 1.x, developers need to use sessions and feed dictionaries to debug intermediate results, which can slow down the development process.</p>
<p>Imperative programming offers a more straightforward debugging experience. Operations execute immediately, allowing developers to inspect tensor values and shapes as the code runs. This immediate feedback simplifies experimentation and makes it easier to identify and fix issues in the model. As a result, imperative programming is well-suited for rapid prototyping and iterative model development.</p>
</section>
<section id="navigating-trade-offs" class="level5">
<h5 class="anchored" data-anchor-id="navigating-trade-offs">Navigating Trade-offs</h5>
<p>The choice between symbolic and imperative programming models often depends on the specific needs of a project. Symbolic programming excels in scenarios where performance and optimization are critical, such as production deployments. In contrast, imperative programming provides the flexibility and ease of use necessary for research and development.</p>
<p>Modern frameworks have introduced hybrid approaches that combine the strengths of both paradigms. For instance, TensorFlow 2.x allows developers to write code in an imperative style while converting computations into optimized graph representations for deployment. Similarly, PyTorch provides tools like TorchScript to convert dynamic models into static graphs for production use. These hybrid approaches help bridge the gap between the flexibility of imperative programming and the efficiency of symbolic programming, enabling developers to navigate the trade-offs effectively.</p>
</section>
</section>
</section>
<section id="execution-models" class="level3" data-number="7.3.5">
<h3 data-number="7.3.5" class="anchored" data-anchor-id="execution-models"><span class="header-section-number">7.3.5</span> Execution Models</h3>
<p>Machine learning frameworks employ various execution paradigms to determine how computations are performed. These paradigms significantly influence the development experience, performance characteristics, and deployment options of ML systems. Understanding the trade-offs between execution models is essential for selecting the right approach for a given application. Let’s explore three key execution paradigms: eager execution, graph execution, and just-in-time (JIT) compilation.</p>
<section id="eager-execution" class="level4">
<h4 class="anchored" data-anchor-id="eager-execution">Eager Execution</h4>
<p>Eager execution is the most straightforward and intuitive execution paradigm. In this model, operations are executed immediately as they are called in the code. This approach closely mirrors the way traditional imperative programming languages work, making it familiar to many developers.</p>
<p>Consider the following example using TensorFlow 2.x, which employs eager execution by default:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tensorflow <span class="im">as</span> tf</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> tf.constant([[<span class="fl">1.</span>, <span class="fl">2.</span>], [<span class="fl">3.</span>, <span class="fl">4.</span>]])</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> tf.constant([[<span class="dv">1</span>, <span class="dv">2</span>], [<span class="dv">3</span>, <span class="dv">4</span>]])</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> tf.matmul(x, y)</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(z)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In this code snippet, each line is executed sequentially. When we create the tensors <code>x</code> and <code>y</code>, they are immediately instantiated in memory. The matrix multiplication <code>tf.matmul(x, y)</code> is computed right away, and the result is stored in <code>z</code>. When we print <code>z</code>, we see the output of the computation immediately.</p>
<p>Eager execution offers several advantages. It provides immediate feedback, allowing developers to inspect intermediate values easily. This makes debugging more straightforward and intuitive. It also allows for more dynamic and flexible code structures, as the computation graph can change with each execution.</p>
<p>However, eager execution has its trade-offs. Since operations are executed immediately, the framework has less opportunity to optimize the overall computation graph. This can lead to lower performance compared to more optimized execution paradigms, especially for complex models or when dealing with large datasets.</p>
<p>Eager execution is particularly well-suited for research, interactive development, and rapid prototyping. It allows data scientists and researchers to quickly iterate on their ideas and see results immediately. Many modern ML frameworks, including TensorFlow 2.x and PyTorch, use eager execution as their default mode due to its developer-friendly nature.</p>
</section>
<section id="graph-execution" class="level4">
<h4 class="anchored" data-anchor-id="graph-execution">Graph Execution</h4>
<p>Graph execution, also known as static graph execution, takes a different approach to computing operations in ML frameworks. In this paradigm, developers first define the entire computational graph, and then execute it as a separate step.</p>
<p>Consider the following example using TensorFlow 1.x style, which employs graph execution:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tensorflow.compat.v1 <span class="im">as</span> tf</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>tf.disable_eager_execution()</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the graph</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> tf.placeholder(tf.float32, shape<span class="op">=</span>(<span class="dv">2</span>, <span class="dv">2</span>))</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> tf.placeholder(tf.float32, shape<span class="op">=</span>(<span class="dv">2</span>, <span class="dv">2</span>))</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> tf.matmul(x, y)</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Execute the graph</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> tf.Session() <span class="im">as</span> sess:</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> sess.run(z, feed_dict<span class="op">=</span>{</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>        x: [[<span class="fl">1.</span>, <span class="fl">2.</span>], [<span class="fl">3.</span>, <span class="fl">4.</span>]],</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>        y: [[<span class="dv">1</span>, <span class="dv">2</span>], [<span class="dv">3</span>, <span class="dv">4</span>]]</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In this code snippet, we first define the structure of our computation. The <code>placeholder</code> operations create nodes in the graph for input data, while <code>tf.matmul</code> creates a node representing matrix multiplication. Importantly, no actual computation occurs during this definition phase.</p>
<p>The execution of the graph happens when we create a session and call <code>sess.run()</code>. At this point, we provide the actual input data through the <code>feed_dict</code> parameter. The framework then has the complete graph and can perform optimizations before running the computation.</p>
<p>Graph execution offers several advantages. It allows the framework to see the entire computation ahead of time, enabling global optimizations that can improve performance, especially for complex models. Once defined, the graph can be easily saved and deployed across different environments, enhancing portability. It’s particularly efficient for scenarios where the same computation is repeated many times with different data inputs.</p>
<p>However, graph execution also has its trade-offs. It requires developers to think in terms of building a graph rather than writing sequential operations, which can be less intuitive. Debugging can be more challenging because errors often don’t appear until the graph is executed. Additionally, implementing dynamic computations can be more difficult with a static graph.</p>
<p>Graph execution is well-suited for production environments where performance and deployment consistency are crucial. It is commonly used in scenarios involving large-scale distributed training and when deploying models for predictions in high-throughput applications.</p>
</section>
<section id="just-in-time-compilation" class="level4">
<h4 class="anchored" data-anchor-id="just-in-time-compilation">Just-In-Time Compilation</h4>
<p>Just-In-Time compilation is a middle ground between eager execution and graph execution. This paradigm aims to combine the flexibility of eager execution with the performance benefits of graph optimization.</p>
<p>Let’s examine an example using PyTorch’s JIT compilation:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="at">@torch.jit.script</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute(x, y):</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> torch.matmul(x, y)</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> torch.randn(<span class="dv">2</span>, <span class="dv">2</span>)</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> torch.randn(<span class="dv">2</span>, <span class="dv">2</span>)</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a><span class="co"># First call compiles the function</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> compute(x, y)</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Subsequent calls use the optimized version</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> compute(x, y)</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In this code snippet, we define a function <code>compute</code> and decorate it with <code>@torch.jit.script</code>. This decorator tells PyTorch to compile the function using its JIT compiler. The first time <code>compute</code> is called, PyTorch analyzes the function, optimizes it, and generates efficient machine code. This compilation process occurs just before the function is executed, hence the term “Just-In-Time”.</p>
<p>Subsequent calls to <code>compute</code> use the optimized version, potentially offering significant performance improvements, especially for complex operations or when called repeatedly.</p>
<p>JIT compilation provides a balance between development flexibility and runtime performance. It allows developers to write code in a natural, eager-style manner while still benefiting from many of the optimizations typically associated with graph execution.</p>
<p>This approach offers several advantages. It maintains the immediate feedback and intuitive debugging of eager execution, as most of the code still executes eagerly. At the same time, it can deliver performance improvements for critical parts of the computation. JIT compilation can also adapt to the specific data types and shapes being used, potentially resulting in more efficient code than static graph compilation.</p>
<p>However, JIT compilation also has some considerations. The first execution of a compiled function may be slower due to the overhead of the compilation process. Additionally, some complex Python constructs may not be easily JIT-compiled, requiring developers to be aware of what can be optimized effectively.</p>
<p>JIT compilation is particularly useful in scenarios where you need both the flexibility of eager execution for development and prototyping, and the performance benefits of compilation for production or large-scale training. It’s commonly used in research settings where rapid iteration is necessary but performance is still a concern.</p>
<p>Many modern ML frameworks incorporate JIT compilation to provide developers with a balance of ease-of-use and performance optimization, as shown in <a href="#tbl-mlfm-execmodes" class="quarto-xref">Table&nbsp;<span>7.2</span></a>. This balance manifests across multiple dimensions, from the learning curve that gradually introduces optimization concepts to the runtime behavior that combines immediate feedback with performance enhancements. The table highlights how JIT compilation bridges the gap between eager execution’s programming simplicity and graph execution’s performance benefits, particularly in areas like memory usage and optimization scope.</p>
<div id="tbl-mlfm-execmodes" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-mlfm-execmodes-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;7.2: Comparison of execution models in machine learning frameworks.
</figcaption>
<div aria-describedby="tbl-mlfm-execmodes-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 12%">
<col style="width: 28%">
<col style="width: 28%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Aspect</th>
<th style="text-align: left;">Eager Execution</th>
<th style="text-align: left;">Graph Execution</th>
<th style="text-align: left;">JIT Compilation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Approach</td>
<td style="text-align: left;">Computes each operation immediately when encountered</td>
<td style="text-align: left;">Builds entire computation plan first, then executes</td>
<td style="text-align: left;">Analyzes code at runtime, creates optimized version</td>
</tr>
<tr class="even">
<td style="text-align: left;">Memory Usage</td>
<td style="text-align: left;">Holds intermediate results throughout computation</td>
<td style="text-align: left;">Optimizes memory by planning complete data flow</td>
<td style="text-align: left;">Adapts memory usage based on actual execution patterns</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Optimization Scope</td>
<td style="text-align: left;">Limited to local operation patterns</td>
<td style="text-align: left;">Global optimization across entire computation chain</td>
<td style="text-align: left;">Combines runtime analysis with targeted optimizations</td>
</tr>
<tr class="even">
<td style="text-align: left;">Debugging Approach</td>
<td style="text-align: left;">Examine values at any point during computation</td>
<td style="text-align: left;">Must set up specific monitoring points in graph</td>
<td style="text-align: left;">Initial runs show original behavior, then optimizes</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Speed vs Flexibility</td>
<td style="text-align: left;">Prioritizes flexibility over speed</td>
<td style="text-align: left;">Prioritizes performance over flexibility</td>
<td style="text-align: left;">Balances flexibility and performance</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</section>
<section id="distributed-execution" class="level4">
<h4 class="anchored" data-anchor-id="distributed-execution">Distributed Execution</h4>
<p>As machine learning models continue to grow in size and complexity, training them on a single device is often no longer feasible. Large models require significant computational power and memory, while massive datasets demand efficient processing across multiple machines. To address these challenges, modern AI frameworks provide built-in support for distributed execution, allowing computations to be split across multiple GPUs, TPUs, or distributed clusters. By abstracting the complexities of parallel execution, these frameworks enable practitioners to scale machine learning workloads efficiently while maintaining ease of use.</p>
<p>At the essence of distributed execution are two primary strategies: data parallelism and model parallelism. Data parallelism allows multiple devices to train the same model on different subsets of data, ensuring faster convergence without increasing memory requirements. Model parallelism, on the other hand, partitions the model itself across multiple devices, allowing the training of architectures too large to fit into a single device’s memory. While model parallelism comes in several variations, which will be explored in later chapters, both techniques are essential for training modern machine learning models efficiently.</p>
<section id="data-parallelism" class="level5">
<h5 class="anchored" data-anchor-id="data-parallelism">Data Parallelism</h5>
<p>Data parallelism is the most widely used approach for distributed training, enabling machine learning models to scale across multiple devices while maintaining efficiency. In this method, each computing device holds an identical copy of the model but processes a unique subset of the training data, as illustrated in <a href="../training/training.html#fig-data-parallelism" class="quarto-xref">Figure&nbsp;<span>8.13</span></a>. Once the computations are complete, the gradients computed on each device are synchronized before updating the model parameters, ensuring consistency across all copies. This approach allows models to learn from larger datasets in parallel without increasing memory requirements per device.</p>
<div id="fig-data-parallelism" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="htb" data-fig-env="figure">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-data-parallelism-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="f35f3f52bd5ee07e1e3259618b5da5784969adae.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-10" title="Figure&nbsp;7.9: Data parallelism."><img src="frameworks_files/mediabag/f35f3f52bd5ee07e1e3259618b5da5784969adae.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-data-parallelism-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7.9: Data parallelism.
</figcaption>
</figure>
</div>
<p>AI frameworks provide built-in mechanisms to manage the key challenges of data parallel execution, including data distribution, gradient synchronization, and performance optimization. In PyTorch, the <code>DistributedDataParallel (DDP)</code> module automates these tasks, ensuring efficient training across multiple GPUs or nodes. TensorFlow offers <code>tf.distribute.MirroredStrategy</code>, which enables seamless gradient synchronization for multi-GPU training. Similarly, JAX’s <code>pmap()</code> function facilitates parallel execution across multiple accelerators, optimizing inter-device communication to reduce overhead.</p>
<p>By handling synchronization and communication automatically, these frameworks make distributed training accessible to a wide range of users, from researchers exploring novel architectures to engineers deploying large-scale AI systems. The implementation details vary, but the fundamental goal remains the same: enabling efficient multi-device training without requiring users to manually manage low-level parallelization.</p>
</section>
<section id="model-parallelism" class="level5">
<h5 class="anchored" data-anchor-id="model-parallelism">Model Parallelism</h5>
<p>While data parallelism is effective for many machine learning workloads, some models are too large to fit within the memory of a single device. Model parallelism addresses this limitation by partitioning the model itself across multiple devices, allowing each to process a different portion of the computation. Unlike data parallelism, where the entire model is replicated on each device, model parallelism divides layers, tensors, or specific operations among available hardware resources, as shown in <a href="../training/training.html#fig-model-parallelism" class="quarto-xref">Figure&nbsp;<span>8.14</span></a>. This approach enables training of large-scale models that would otherwise be constrained by single-device memory limits.</p>
<div id="fig-model-parallelism" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="htb" data-fig-env="figure">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-model-parallelism-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="9cedc1b9fd9356814150321f0584b322a99f62bd.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-11" title="Figure&nbsp;7.10: Model parallelism."><img src="frameworks_files/mediabag/9cedc1b9fd9356814150321f0584b322a99f62bd.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-model-parallelism-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7.10: Model parallelism.
</figcaption>
</figure>
</div>
<p>AI frameworks provide structured APIs to simplify model parallel execution, abstracting away much of the complexity associated with workload distribution and communication. PyTorch supports pipeline parallelism through <code>torch.distributed.pipeline.sync</code>, enabling different GPUs to process sequential layers of a model while maintaining efficient execution flow. TensorFlow’s <code>TPUStrategy</code> allows for automatic partitioning of large models across TPU cores, optimizing execution for high-speed interconnects. Additionally, frameworks like DeepSpeed and Megatron-LM extend PyTorch by implementing advanced model sharding techniques, including tensor parallelism, which splits model weights across multiple devices to reduce memory overhead.</p>
<p>There are multiple variations of model parallelism, each suited to different architectures and hardware configurations. These include tensor parallelism, pipeline parallelism, and expert parallelism, among others. The specific trade-offs and applications of these techniques will be explored in later chapters. Regardless of the exact approach, AI frameworks play an important role in managing workload partitioning, scheduling computations efficiently, and minimizing communication overhead—ensuring that even the largest models can be trained at scale.</p>
</section>
</section>
</section>
<section id="core-operations" class="level3" data-number="7.3.6">
<h3 data-number="7.3.6" class="anchored" data-anchor-id="core-operations"><span class="header-section-number">7.3.6</span> Core Operations</h3>
<p>Machine learning frameworks employ multiple layers of operations that translate high-level model descriptions into efficient computations on hardware. These operations form a hierarchy: hardware abstraction operations manage the complexity of diverse computing platforms, basic numerical operations implement fundamental mathematical computations, and system-level operations coordinate resources and execution. This operational hierarchy is key to understanding how frameworks transform mathematical models into practical implementations. <a href="#fig-mlfm-core-ops" class="quarto-xref">Figure&nbsp;<span>7.11</span></a> illustrates this hierarchy, showing the relationship between the three layers and their respective subcomponents.</p>
<div id="fig-mlfm-core-ops" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="htb" data-fig-env="figure">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-mlfm-core-ops-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="70f03560d31cd9df27454d9b2068f101cacd6b97.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-12" title="Figure&nbsp;7.11: Hierarchical structure of operations in machine learning frameworks."><img src="frameworks_files/mediabag/70f03560d31cd9df27454d9b2068f101cacd6b97.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-mlfm-core-ops-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7.11: Hierarchical structure of operations in machine learning frameworks.
</figcaption>
</figure>
</div>
<section id="hardware-abstraction-operations" class="level4">
<h4 class="anchored" data-anchor-id="hardware-abstraction-operations">Hardware Abstraction Operations</h4>
<p>At the lowest level, hardware abstraction operations provide the foundation for executing computations across diverse computing platforms. These operations isolate higher layers from hardware-specific details while maintaining computational efficiency. The abstraction layer must handle three fundamental aspects: compute kernel management, memory system abstraction, and execution control.</p>
<section id="compute-kernel-management" class="level5">
<h5 class="anchored" data-anchor-id="compute-kernel-management">Compute Kernel Management</h5>
<p>Compute kernel management involves selecting and dispatching optimal implementations of mathematical operations for different hardware architectures. This requires maintaining multiple implementations of core operations and sophisticated dispatch logic. For example, a matrix multiplication operation might be implemented using AVX-512 vector instructions on modern CPUs, <a href="https://developer.nvidia.com/cublas">cuBLAS</a> on NVIDIA GPUs, or specialized tensor processing instructions on AI accelerators. The kernel manager must consider input sizes, data layout, and hardware capabilities when selecting implementations. It must also handle fallback paths for when specialized implementations are unavailable or unsuitable.</p>
</section>
<section id="memory-system-abstraction" class="level5">
<h5 class="anchored" data-anchor-id="memory-system-abstraction">Memory System Abstraction</h5>
<p>Memory system abstractions manage data movement through complex memory hierarchies. These abstractions must handle various memory types (registered, pinned, unified) and their specific access patterns. Data layouts often require transformation between hardware-preferred formats - for instance, between row-major and column-major matrix layouts, or between interleaved and planar image formats. The memory system must also manage alignment requirements, which can vary from 4-byte alignment on CPUs to 128-byte alignment on some accelerators. Additionally, it handles cache coherency issues when multiple execution units access the same data.</p>
</section>
<section id="execution-control" class="level5">
<h5 class="anchored" data-anchor-id="execution-control">Execution Control</h5>
<p>Execution control operations coordinate computation across multiple execution units and memory spaces. This includes managing execution queues, handling event dependencies, and controlling asynchronous operations. Modern hardware often supports multiple execution streams that can operate concurrently. For example, independent GPU streams or CPU thread pools. The execution controller must manage these streams, handle synchronization points, and ensure correct ordering of dependent operations. It must also provide error handling and recovery mechanisms for hardware-specific failures.</p>
</section>
</section>
<section id="basic-numerical-operations" class="level4">
<h4 class="anchored" data-anchor-id="basic-numerical-operations">Basic Numerical Operations</h4>
<p>Building upon hardware abstractions, frameworks implement fundamental numerical operations that form the building blocks of machine learning computations. These operations must balance mathematical precision with computational efficiency. General Matrix Multiply (GEMM) operations, which dominate the computational cost of most machine learning workloads. GEMM operations follow the pattern C = <span class="math inline">\(\alpha\)</span>AB + <span class="math inline">\(\beta\)</span>C, where A, B, and C are matrices, and <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> are scaling factors.</p>
<p>The implementation of GEMM operations requires sophisticated optimization techniques. These include blocking for cache efficiency, where matrices are divided into smaller tiles that fit in cache memory; loop unrolling to increase instruction-level parallelism; and specialized implementations for different matrix shapes and sparsity patterns. For example, fully-connected neural network layers typically use regular dense GEMM operations, while convolutional layers often employ specialized GEMM variants that exploit input locality patterns.</p>
<p>Beyond GEMM, frameworks must efficiently implement BLAS operations such as vector addition (AXPY), matrix-vector multiplication (GEMV), and various reduction operations. These operations require different optimization strategies. AXPY operations are typically memory-bandwidth limited, while GEMV operations must balance memory access patterns with computational efficiency.</p>
<p>Element-wise operations form another critical category, including both basic arithmetic operations (addition, multiplication) and transcendental functions (exponential, logarithm, trigonometric functions). While conceptually simpler than GEMM, these operations present significant optimization opportunities through vectorization and operation fusion. For example, multiple element-wise operations can often be fused into a single kernel to reduce memory bandwidth requirements. The efficiency of these operations becomes particularly important in neural network activation functions and normalization layers, where they process large volumes of data.</p>
<p>Modern frameworks must also handle operations with varying numerical precision requirements. For example, training often requires 32-bit floating-point precision for numerical stability, while inference can often use reduced precision formats like 16-bit floating-point or even 8-bit integers. Frameworks must therefore provide efficient implementations across multiple numerical formats while maintaining acceptable accuracy.</p>
</section>
<section id="system-level-operations" class="level4">
<h4 class="anchored" data-anchor-id="system-level-operations">System-Level Operations</h4>
<p>System-level operations build upon the previously discussed computational graph abstractions, hardware abstractions, and numerical operations to manage overall computation flow and resource utilization. These operations handle three critical aspects: operation scheduling, memory management, and resource optimization.</p>
<p>Operation scheduling leverages the computational graph structure discussed earlier to determine execution ordering. Building on the static or dynamic graph representation, the scheduler must identify parallelization opportunities while respecting dependencies. The implementation challenges differ between static graphs, where the entire dependency structure is known in advance, and dynamic graphs, where dependencies emerge during execution. The scheduler must also handle advanced execution patterns like conditional operations and loops that create dynamic control flow within the graph structure.</p>
<p>Memory management implements sophisticated strategies for allocating and deallocating memory resources across the computational graph. Different data types require different management strategies. Model parameters typically persist throughout execution and may require specific memory types for efficient access. Intermediate results have bounded lifetimes defined by the operation graph. For example, activation values are needed only during the backward pass. The memory manager employs techniques like reference counting for automatic cleanup, memory pooling to reduce allocation overhead, and workspace management for temporary buffers. It must also handle memory fragmentation, particularly in long-running training sessions where allocation patterns can change over time.</p>
<p>Resource optimization integrates scheduling and memory decisions to maximize performance within system constraints. A key optimization is gradient checkpointing, where some intermediate results are discarded and recomputed rather than stored, trading computation time for memory savings. The optimizer must also manage concurrent execution streams, balancing load across available compute units while respecting dependencies. For operations with multiple possible implementations, it selects between alternatives based on runtime conditions - for instance, choosing between matrix multiplication algorithms based on matrix shapes and system load.</p>
<p>Together, these operational layers build upon the computational graph foundation to execute machine learning workloads efficiently while abstracting implementation complexity from model developers. The interaction between these layers determines overall system performance and sets the foundation for advanced optimization techniques discussed in subsequent chapters.</p>
</section>
</section>
</section>
<section id="framework-components" class="level2 page-columns page-full" data-number="7.4">
<h2 data-number="7.4" class="anchored" data-anchor-id="framework-components"><span class="header-section-number">7.4</span> Framework Components</h2>
<p>Machine learning frameworks organize their fundamental capabilities into distinct components that work together to provide a complete development and deployment environment. These components create layers of abstraction that make frameworks both usable for high-level model development and efficient for low-level execution. Understanding how these components interact helps developers choose and use frameworks effectively.</p>
<section id="apis-and-abstractions" class="level3 page-columns page-full" data-number="7.4.1">
<h3 data-number="7.4.1" class="anchored" data-anchor-id="apis-and-abstractions"><span class="header-section-number">7.4.1</span> APIs and Abstractions</h3>
<p>The API layer of machine learning frameworks provides the primary interface through which developers interact with the framework’s capabilities. This layer must balance multiple competing demands: it must be intuitive enough for rapid development, flexible enough to support diverse use cases, and efficient enough to enable high-performance implementations.</p>
<p>Modern framework APIs typically implement multiple levels of abstraction. At the lowest level, they provide direct access to tensor operations and computational graph construction. These low-level APIs expose the fundamental operations discussed in the previous section, allowing fine-grained control over computation. For example, frameworks like PyTorch and TensorFlow offer such low-level interfaces, enabling researchers to define custom computations and explore novel algorithms <span class="citation" data-cites="paszke2019pytorch Abadi_2016">(<a href="../references.html#ref-paszke2019pytorch" role="doc-biblioref">Ansel et al. 2024</a>; <a href="../references.html#ref-Abadi_2016" role="doc-biblioref">Abadi et al. 2016</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-paszke2019pytorch" class="csl-entry" role="listitem">
Ansel, Jason, Edward Yang, Horace He, Natalia Gimelshein, Animesh Jain, Michael Voznesensky, Bin Bao, et al. 2024. <span>“PyTorch 2: Faster Machine Learning Through Dynamic Python Bytecode Transformation and Graph Compilation.”</span> In <em>Proceedings of the 29th ACM International Conference on Architectural Support for Programming Languages and Operating Systems, Volume 2</em>, edited by Hanna M. Wallach, Hugo Larochelle, Alina Beygelzimer, Florence d’Alché-Buc, Emily B. Fox, and Roman Garnett, 929–47. ACM. <a href="https://doi.org/10.1145/3620665.3640366">https://doi.org/10.1145/3620665.3640366</a>.
</div><div id="ref-Abadi_2016" class="csl-entry" role="listitem">
Abadi, Martı́n, Paul Barham, Jianmin Chen, Zhifeng Chen, Andy Davis, Jeffrey Dean, Matthieu Devin, et al. 2016. <span>“TensorFlow: A System for Large-Scale Machine Learning.”</span> In <em>12th USENIX Symposium on Operating Systems Design and Implementation (OSDI 16)</em>, 265–83. USENIX Association. <a href="https://www.usenix.org/conference/osdi16/technical-sessions/presentation/abadi">https://www.usenix.org/conference/osdi16/technical-sessions/presentation/abadi</a>.
</div></div><div class="sourceCode" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Low-level API example</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Manual tensor operations</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> torch.randn(<span class="dv">2</span>, <span class="dv">3</span>)</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> torch.randn(<span class="dv">3</span>, <span class="dv">4</span>)</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> torch.randn(<span class="dv">4</span>)</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> torch.matmul(x, w) <span class="op">+</span> b</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Manual gradient computation</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>y.backward(torch.ones_like(y))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Building on these primitives, frameworks implement higher-level APIs that package common patterns into reusable components. Neural network layers represent a classic example—while a convolution operation could be implemented manually using basic tensor operations, frameworks provide pre-built layer abstractions that handle the implementation details. This approach is exemplified by libraries such as PyTorch’s <code>torch.nn</code> and TensorFlow’s Keras API, which enable efficient and user-friendly model development <span class="citation" data-cites="chollet2018keras">(<a href="../references.html#ref-chollet2018keras" role="doc-biblioref">Chollet 2018</a>)</span>.</p>
<div class="no-row-height column-margin column-container"><div id="ref-chollet2018keras" class="csl-entry" role="listitem">
Chollet, François. 2018. <span>“Introduction to Keras.”</span> <em>March 9th</em>.
</div></div><div class="sourceCode" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Mid-level API example using nn modules</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SimpleNet(nn.Module):</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.conv <span class="op">=</span> nn.Conv2d(<span class="dv">3</span>, <span class="dv">64</span>, kernel_size<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fc <span class="op">=</span> nn.Linear(<span class="dv">64</span>, <span class="dv">10</span>)</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.conv(x)</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> torch.relu(x)</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.fc(x)</span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>At the highest level, frameworks often provide model-level abstractions that automate common workflows. For example, the Keras API provides a highly abstract interface that hides most implementation details:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># High-level API example using Keras</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tensorflow <span class="im">import</span> keras</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> keras.Sequential([</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    keras.layers.Conv2D(</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>        <span class="dv">64</span>,</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>        <span class="dv">3</span>,</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>        activation<span class="op">=</span><span class="st">'relu'</span>,</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>        input_shape<span class="op">=</span>(<span class="dv">32</span>, <span class="dv">32</span>, <span class="dv">3</span>)),</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>    keras.layers.Flatten(),</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>    keras.layers.Dense(<span class="dv">10</span>)</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Automated training workflow</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>model.<span class="bu">compile</span>(</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>    optimizer<span class="op">=</span><span class="st">'adam'</span>,</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>    loss<span class="op">=</span><span class="st">'sparse_categorical_crossentropy'</span>)</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>model.fit(train_data, train_labels, epochs<span class="op">=</span><span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The organization of these API layers reflects fundamental trade-offs in framework design. Lower-level APIs provide maximum flexibility but require more expertise to use effectively. Higher-level APIs improve developer productivity but may constrain implementation choices. Framework APIs must therefore provide clear paths between abstraction levels, allowing developers to mix different levels of abstraction as needed for their specific use cases.## Framework Components</p>
<p>Machine learning frameworks organize their fundamental capabilities into distinct components that work together to provide a complete development and deployment environment. These components create layers of abstraction that make frameworks both usable for high-level model development and efficient for low-level execution. Understanding how these components interact helps developers choose and use frameworks effectively.</p>
</section>
<section id="core-libraries" class="level3" data-number="7.4.2">
<h3 data-number="7.4.2" class="anchored" data-anchor-id="core-libraries"><span class="header-section-number">7.4.2</span> Core Libraries</h3>
<p>At the heart of every machine learning framework lies a set of core libraries, forming the foundation upon which all other components are built. These libraries provide the essential building blocks for machine learning operations, implementing fundamental tensor operations that serve as the backbone of numerical computations. Heavily optimized for performance, these operations often leverage low-level programming languages and hardware-specific optimizations to ensure efficient execution of tasks like matrix multiplication, a cornerstone of neural network computations.</p>
<p>Alongside these basic operations, core libraries implement automatic differentiation capabilities, enabling the efficient computation of gradients for complex functions. This feature is crucial for the backpropagation algorithm that powers most neural network training. The implementation often involves intricate graph manipulation and symbolic computation techniques, abstracting away the complexities of gradient calculation from the end-user.</p>
<p>Building upon these fundamental operations, core libraries typically provide pre-implemented neural network layers such as convolutional, recurrent, and attention mechanisms. These ready-to-use components save developers from reinventing the wheel for common model architectures, allowing them to focus on higher-level model design rather than low-level implementation details. Similarly, optimization algorithms like various flavors of gradient descent are provided out-of-the-box, further streamlining the model development process.</p>
<p>Here is a simplified example of how these components might be used in practice:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn <span class="im">as</span> nn</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a simple neural network</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> nn.Sequential(</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    nn.Linear(<span class="dv">10</span>, <span class="dv">20</span>),</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    nn.ReLU(),</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    nn.Linear(<span class="dv">20</span>, <span class="dv">1</span>)</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Define loss function and optimizer</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>loss_fn <span class="op">=</span> nn.MSELoss()</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>optimizer <span class="op">=</span> torch.optim.Adam(model.parameters(), lr<span class="op">=</span><span class="fl">0.01</span>)</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Forward pass, compute loss, and backward pass</span></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> torch.randn(<span class="dv">32</span>, <span class="dv">10</span>)</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> torch.randn(<span class="dv">32</span>, <span class="dv">1</span>)</span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>y_pred <span class="op">=</span> model(x)</span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>loss <span class="op">=</span> loss_fn(y_pred, y)</span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>loss.backward()</span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>optimizer.step()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This example demonstrates how core libraries provide high-level abstractions for model creation, loss computation, and optimization, while handling low-level details internally.</p>
</section>
<section id="extensions-and-plugins" class="level3" data-number="7.4.3">
<h3 data-number="7.4.3" class="anchored" data-anchor-id="extensions-and-plugins"><span class="header-section-number">7.4.3</span> Extensions and Plugins</h3>
<p>While core libraries offer essential functionality, the true power of modern machine learning frameworks often lies in their extensibility. Extensions and plugins expand the capabilities of frameworks, allowing them to address specialized needs and leverage cutting-edge research. Domain-specific libraries, for instance, cater to particular areas like computer vision or natural language processing, providing pre-trained models, specialized data augmentation techniques, and task-specific layers.</p>
<p>Hardware acceleration plugins play an important role in performance optimization as it enables frameworks to take advantage of specialized hardware like GPUs or TPUs. These plugins dramatically speed up computations and allow seamless switching between different hardware backends, a key feature for scalability and flexibility in modern machine learning workflows.</p>
<p>As models and datasets grow in size and complexity, distributed computing extensions also become important. These tools enable training across multiple devices or machines, handling complex tasks like data parallelism, model parallelism, and synchronization between compute nodes. This capability is essential for researchers and companies tackling large-scale machine learning problems.</p>
<p>Complementing these computational tools are visualization and experiment tracking extensions. Visualization tools provide invaluable insights into the training process and model behavior, displaying real-time metrics and even offering interactive debugging capabilities. Experiment tracking extensions help manage the complexity of machine learning research, allowing systematic logging and comparison of different model configurations and hyperparameters.</p>
</section>
<section id="development-tools" class="level3" data-number="7.4.4">
<h3 data-number="7.4.4" class="anchored" data-anchor-id="development-tools"><span class="header-section-number">7.4.4</span> Development Tools</h3>
<p>The ecosystem of development tools surrounding a machine learning framework further enhances its effectiveness and adoption. Interactive development environments, such as Jupyter notebooks, have become nearly ubiquitous in machine learning workflows, allowing for rapid prototyping and seamless integration of code, documentation, and outputs. Many frameworks provide custom extensions for these environments to enhance the development experience.</p>
<p>Debugging and profiling tools address the unique challenges presented by machine learning models. Specialized debuggers allow developers to inspect the internal state of models during training and inference, while profiling tools identify bottlenecks in model execution, guiding optimization efforts. These tools are essential for developing efficient and reliable machine learning systems.</p>
<p>As projects grow in complexity, version control integration becomes increasingly important. Tools that allow versioning of not just code, but also model weights, hyperparameters, and training data, help manage the iterative nature of model development. This comprehensive versioning approach ensures reproducibility and facilitates collaboration in large-scale machine learning projects.</p>
<p>Finally, deployment utilities bridge the gap between development and production environments. These tools handle tasks like model compression, conversion to deployment-friendly formats, and integration with serving infrastructure, streamlining the process of moving models from experimental settings to real-world applications.</p>
</section>
</section>
<section id="system-integration" class="level2" data-number="7.5">
<h2 data-number="7.5" class="anchored" data-anchor-id="system-integration"><span class="header-section-number">7.5</span> System Integration</h2>
<p>System integration is about implementing machine learning frameworks in real-world environments. This section explores how ML frameworks integrate with broader software and hardware ecosystems, addressing the challenges and considerations at each level of the integration process.</p>
<section id="hardware-integration" class="level3" data-number="7.5.1">
<h3 data-number="7.5.1" class="anchored" data-anchor-id="hardware-integration"><span class="header-section-number">7.5.1</span> Hardware Integration</h3>
<p>Effective hardware integration is crucial for optimizing the performance of machine learning models. Modern ML frameworks must adapt to a diverse range of computing environments, from high-performance GPU clusters to resource-constrained edge devices.</p>
<p>For GPU acceleration, frameworks like TensorFlow and PyTorch provide robust support, allowing seamless utilization of NVIDIA’s CUDA platform. This integration enables significant speedups in both training and inference tasks. Similarly, support for Google’s TPUs in TensorFlow allows for even further acceleration of specific workloads.</p>
<p>In distributed computing scenarios, frameworks must efficiently manage multi-device and multi-node setups. This involves strategies for data parallelism, where the same model is replicated across devices, and model parallelism, where different parts of the model are distributed across hardware units. Frameworks like Horovod have emerged to simplify distributed training across different backend frameworks.</p>
<p>For edge deployment, frameworks are increasingly offering lightweight versions optimized for mobile and IoT devices. TensorFlow Lite and PyTorch Mobile, for instance, provide tools for model compression and optimization, ensuring efficient execution on devices with limited computational resources and power constraints.</p>
</section>
<section id="software-stack" class="level3" data-number="7.5.2">
<h3 data-number="7.5.2" class="anchored" data-anchor-id="software-stack"><span class="header-section-number">7.5.2</span> Software Stack</h3>
<p>Integrating ML frameworks into existing software stacks presents unique challenges and opportunities. A key consideration is how the ML system interfaces with data processing pipelines. Frameworks often provide connectors to popular big data tools like Apache Spark or Apache Beam, allowing seamless data flow between data processing systems and ML training environments.</p>
<p>Containerization technologies like Docker have become essential in ML workflows, ensuring consistency between development and production environments. Kubernetes has emerged as a popular choice for orchestrating containerized ML workloads, providing scalability and manageability for complex deployments.</p>
<p>ML frameworks must also interface with other enterprise systems such as databases, message queues, and web services. For instance, TensorFlow Serving provides a flexible, high-performance serving system for machine learning models, which can be easily integrated into existing microservices architectures.</p>
</section>
<section id="deployment-considerations" class="level3" data-number="7.5.3">
<h3 data-number="7.5.3" class="anchored" data-anchor-id="deployment-considerations"><span class="header-section-number">7.5.3</span> Deployment Considerations</h3>
<p>Deploying ML models to production environments involves several critical considerations. Model serving strategies must balance performance, scalability, and resource efficiency. Approaches range from batch prediction for large-scale offline processing to real-time serving for interactive applications.</p>
<p>Scaling ML systems to meet production demands often involves techniques like horizontal scaling of inference servers, caching of frequent predictions, and load balancing across multiple model versions. Frameworks like TensorFlow Serving and TorchServe provide built-in solutions for many of these scaling challenges.</p>
<p>Monitoring and logging are crucial for maintaining ML systems in production. This includes tracking model performance metrics, detecting concept drift, and logging prediction inputs and outputs for auditing purposes. Tools like Prometheus and Grafana are often integrated with ML serving systems to provide comprehensive monitoring solutions.</p>
</section>
<section id="workflow-orchestration" class="level3" data-number="7.5.4">
<h3 data-number="7.5.4" class="anchored" data-anchor-id="workflow-orchestration"><span class="header-section-number">7.5.4</span> Workflow Orchestration</h3>
<p>Managing end-to-end ML pipelines requires orchestrating multiple stages, from data preparation and model training to deployment and monitoring. MLOps practices have emerged to address these challenges, bringing DevOps principles to machine learning workflows.</p>
<p>Continuous Integration and Continuous Deployment (CI/CD) practices are being adapted for ML workflows. This involves automating model testing, validation, and deployment processes. Tools like Jenkins or GitLab CI can be extended with ML-specific stages to create robust CI/CD pipelines for machine learning projects.</p>
<p>Automated model retraining and updating is another critical aspect of ML workflow orchestration. This involves setting up systems to automatically retrain models on new data, evaluate their performance, and seamlessly update production models when certain criteria are met. Frameworks like Kubeflow provide end-to-end ML pipelines that can automate many of these processes.</p>
<p>Version control for ML assets, including data, model architectures, and hyperparameters, is essential for reproducibility and collaboration. Tools like DVC (Data Version Control) and MLflow have emerged to address these ML-specific version control needs.</p>
</section>
</section>
<section id="major-frameworks" class="level2" data-number="7.6">
<h2 data-number="7.6" class="anchored" data-anchor-id="major-frameworks"><span class="header-section-number">7.6</span> Major Frameworks</h2>
<p>As we have seen earlier, machine learning frameworks are complicated. Over the years, several machine learning frameworks have emerged, each with its unique strengths and ecosystem, but few have remained as industry standards. Here we examine the mature and major players in the field, starting with a comprehensive look at TensorFlow, followed by PyTorch, JAX, and other notable frameworks.</p>
<section id="tensorflow-ecosystem" class="level3" data-number="7.6.1">
<h3 data-number="7.6.1" class="anchored" data-anchor-id="tensorflow-ecosystem"><span class="header-section-number">7.6.1</span> TensorFlow Ecosystem</h3>
<p>TensorFlow was developed by the Google Brain team and was released as an open-source software library on November 9, 2015. It was designed for numerical computation using data flow graphs and has since become popular for a wide range of machine learning applications.</p>
<p>TensorFlow is a training and inference framework that provides built-in functionality to handle everything from model creation and training to deployment, as shown in <a href="#fig-tensorflow-architecture" class="quarto-xref">Figure&nbsp;<span>7.12</span></a>. Since its initial development, the TensorFlow ecosystem has grown to include many different “varieties” of TensorFlow, each intended to allow users to support ML on different platforms.</p>
<ol type="1">
<li><p><a href="https://www.tensorflow.org/tutorials">TensorFlow Core</a>: primary package that most developers engage with. It provides a comprehensive, flexible platform for defining, training, and deploying machine learning models. It includes <a href="https://www.tensorflow.org/guide/keras">tf.keras</a> as its high-level API.</p></li>
<li><p><a href="https://www.tensorflow.org/lite">TensorFlow Lite</a>: designed for deploying lightweight models on mobile, embedded, and edge devices. It offers tools to convert TensorFlow models to a more compact format suitable for limited-resource devices and provides optimized pre-trained models for mobile.</p></li>
<li><p><a href="https://www.tensorflow.org/lite/microcontrollers">TensorFlow Lite Micro</a>: designed for running machine learning models on microcontrollers with minimal resources. It operates without the need for operating system support, standard C or C++ libraries, or dynamic memory allocation, using only a few kilobytes of memory.</p></li>
<li><p><a href="https://www.tensorflow.org/js">TensorFlow.js</a>: JavaScript library that allows training and deployment of machine learning models directly in the browser or on Node.js. It also provides tools for porting pre-trained TensorFlow models to the browser-friendly format.</p></li>
<li><p><a href="https://developers.googleblog.com/2019/03/introducing-coral-our-platform-for.html">TensorFlow on Edge Devices (Coral)</a>: platform of hardware components and software tools from Google that allows the execution of TensorFlow models on edge devices, leveraging Edge TPUs for acceleration.</p></li>
<li><p><a href="https://www.tensorflow.org/federated">TensorFlow Federated (TFF)</a>: framework for machine learning and other computations on decentralized data. TFF facilitates federated learning, allowing model training across many devices without centralizing the data.</p></li>
</ol>
<ol start="7" type="1">
<li><p><a href="https://www.tensorflow.org/graphics">TensorFlow Graphics</a>: library for using TensorFlow to carry out graphics-related tasks, including 3D shapes and point clouds processing, using deep learning.</p></li>
<li><p><a href="https://www.tensorflow.org/hub">TensorFlow Hub</a>: repository of reusable machine learning model components to allow developers to reuse pre-trained model components, facilitating transfer learning and model composition.</p></li>
<li><p><a href="https://www.tensorflow.org/tfx/guide/serving">TensorFlow Serving</a>: framework designed for serving and deploying machine learning models for inference in production environments. It provides tools for versioning and dynamically updating deployed models without service interruption.</p></li>
<li><p><a href="https://www.tensorflow.org/tfx">TensorFlow Extended (TFX)</a>: end-to-end platform designed to deploy and manage machine learning pipelines in production settings. TFX encompasses data validation, preprocessing, model training, validation, and serving components.</p></li>
</ol>
<div id="fig-tensorflow-architecture" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="htb" data-fig-env="figure">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-tensorflow-architecture-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="f56e78010ba72d3921b997fd36aecc250fb6646e.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-13" title="Figure&nbsp;7.12: Architecture overview of TensorFlow 2.0. Source: Tensorflow."><img src="frameworks_files/mediabag/f56e78010ba72d3921b997fd36aecc250fb6646e.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-tensorflow-architecture-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7.12: Architecture overview of TensorFlow 2.0. Source: <a href="https://blog.tensorflow.org/2019/01/whats-coming-in-tensorflow-2-0.html">Tensorflow.</a>
</figcaption>
</figure>
</div>
</section>
<section id="pytorch" class="level3" data-number="7.6.2">
<h3 data-number="7.6.2" class="anchored" data-anchor-id="pytorch"><span class="header-section-number">7.6.2</span> PyTorch</h3>
<p>PyTorch, developed by Facebook’s AI Research lab, has gained significant traction in the machine learning community, particularly among researchers and academics. Its design philosophy emphasizes ease of use, flexibility, and dynamic computation, which aligns well with the iterative nature of research and experimentation.</p>
<p>PyTorch’s architecture lies its dynamic computational graph system. Unlike the static graphs used in earlier versions of TensorFlow, PyTorch builds the computational graph on-the-fly during execution. This approach, often referred to as “define-by-run,” allows for more intuitive model design and easier debugging that we discussed earlier. Moreover, developers can use standard Python control flow statements within their models, and the graph structure can change from iteration to iteration. This flexibility is particularly advantageous when working with variable-length inputs or complex, dynamic neural network architectures.</p>
<p>PyTorch’s eager execution mode is tightly coupled with its dynamic graph approach. Operations are executed immediately as they are called, rather than being deferred for later execution in a static graph. This immediate execution facilitates easier debugging and allows for more natural integration with Python’s native debugging tools. The eager execution model aligns closely with PyTorch’s imperative programming style, which many developers find more intuitive and Pythonic.</p>
<p>PyTorch’s fundamental data structure is the tensor, similar to TensorFlow and other frameworks discussed in earlier sections. PyTorch tensors are conceptually equivalent to multi-dimensional arrays and can be manipulated using a rich set of operations. The framework provides seamless integration with CUDA, much like TensorFlow, enabling efficient GPU acceleration for tensor computations. PyTorch’s autograd system automatically tracks all operations performed on tensors, facilitating automatic differentiation for gradient-based optimization algorithms.</p>
</section>
<section id="jax" class="level3" data-number="7.6.3">
<h3 data-number="7.6.3" class="anchored" data-anchor-id="jax"><span class="header-section-number">7.6.3</span> JAX</h3>
<p>JAX, developed by Google Research, is a newer entrant in the field of machine learning frameworks. Unlike TensorFlow and PyTorch, which were primarily designed for deep learning, JAX focuses on high-performance numerical computing and advanced machine learning research. Its design philosophy centers around functional programming principles and composition of transformations, offering a fresh perspective on building and optimizing machine learning systems.</p>
<p>JAX is built as a NumPy-like library with added capabilities for automatic differentiation and just-in-time compilation. This foundation makes JAX feel familiar to researchers accustomed to scientific computing in Python, while providing powerful tools for optimization and acceleration. Where TensorFlow uses static computational graphs and PyTorch employs dynamic ones, JAX takes a different approach altogether—a system for transforming numerical functions.</p>
<p>One of JAX’s key features is its powerful automatic differentiation system. Unlike TensorFlow’s static graph approach or PyTorch’s dynamic computation, JAX can differentiate native Python and NumPy functions, including those with loops, branches, and recursion. This capability extends beyond simple scalar-to-scalar functions, allowing for complex transformations like vectorization and JIT compilation. This flexibility is particularly valuable for researchers exploring novel machine learning techniques and architectures.</p>
<p>JAX leverages XLA (Accelerated Linear Algebra) for just-in-time compilation, similar to TensorFlow but with a more central role in its operation. This allows JAX to optimize and compile Python code for various hardware accelerators, including GPUs and TPUs. In contrast to PyTorch’s eager execution and TensorFlow’s graph optimization, JAX’s approach can lead to significant performance improvements, especially for complex computational patterns.</p>
<p>Where TensorFlow and PyTorch primarily use object-oriented and imperative programming models, JAX embraces functional programming. This approach encourages the use of pure functions and immutable data, which can lead to more predictable and easier-to-optimize code. It’s a significant departure from the stateful models common in other frameworks and can require a shift in thinking for developers accustomed to TensorFlow or PyTorch.</p>
<p>JAX introduces a set of composable function transformations that set it apart from both TensorFlow and PyTorch. These include automatic differentiation (grad), just-in-time compilation, automatic vectorization (vmap), and parallel execution across multiple devices (pmap). These transformations can be composed, allowing for powerful and flexible operations that are not as straightforward in other frameworks.</p>
</section>
<section id="framework-comparison" class="level3" data-number="7.6.4">
<h3 data-number="7.6.4" class="anchored" data-anchor-id="framework-comparison"><span class="header-section-number">7.6.4</span> Framework Comparison</h3>
<p><a href="#tbl-mlfm-comparison" class="quarto-xref">Table&nbsp;<span>7.3</span></a> provides a concise comparison of three major machine learning frameworks: TensorFlow, PyTorch, and JAX. These frameworks, while serving similar purposes, exhibit fundamental differences in their design philosophies and technical implementations.</p>
<div id="tbl-mlfm-comparison" class="hover striped quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-mlfm-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;7.3: Core characteristics of major machine learning frameworks.
</figcaption>
<div aria-describedby="tbl-mlfm-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-hover table-striped caption-top table">
<colgroup>
<col style="width: 23%">
<col style="width: 29%">
<col style="width: 23%">
<col style="width: 23%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Aspect</th>
<th style="text-align: left;">TensorFlow</th>
<th style="text-align: left;">PyTorch</th>
<th style="text-align: left;">JAX</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Graph Type</td>
<td style="text-align: left;">Static (1.x), Dynamic (2.x)</td>
<td style="text-align: left;">Dynamic</td>
<td style="text-align: left;">Functional transformations</td>
</tr>
<tr class="even">
<td style="text-align: left;">Programming Model</td>
<td style="text-align: left;">Imperative (2.x), Symbolic (1.x)</td>
<td style="text-align: left;">Imperative</td>
<td style="text-align: left;">Functional</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Core Data Structure</td>
<td style="text-align: left;">Tensor (mutable)</td>
<td style="text-align: left;">Tensor (mutable)</td>
<td style="text-align: left;">Array (immutable)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Execution Mode</td>
<td style="text-align: left;">Eager (2.x default), Graph</td>
<td style="text-align: left;">Eager</td>
<td style="text-align: left;">Just-in-time compilation</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Automatic Differentiation</td>
<td style="text-align: left;">Reverse mode</td>
<td style="text-align: left;">Reverse mode</td>
<td style="text-align: left;">Forward and Reverse mode</td>
</tr>
<tr class="even">
<td style="text-align: left;">Hardware Acceleration</td>
<td style="text-align: left;">CPU, GPU, TPU</td>
<td style="text-align: left;">CPU, GPU</td>
<td style="text-align: left;">CPU, GPU, TPU</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</section>
</section>
<section id="framework-specialization" class="level2 page-columns page-full" data-number="7.7">
<h2 data-number="7.7" class="anchored" data-anchor-id="framework-specialization"><span class="header-section-number">7.7</span> Framework Specialization</h2>
<p>Machine learning frameworks have evolved significantly to meet the diverse needs of different computational environments. As ML applications expand beyond traditional data centers to encompass edge devices, mobile platforms, and even tiny microcontrollers, the need for specialized frameworks has become increasingly apparent.</p>
<p>Framework specialization refers to the process of tailoring ML frameworks to optimize performance, efficiency, and functionality for specific deployment environments. This specialization is crucial because the computational resources, power constraints, and use cases vary dramatically across different platforms.</p>
<p>Machine learning frameworks have addressed interoperability challenges through standardized model formats, with the Open Neural Network Exchange (ONNX) emerging as a widely adopted solution. ONNX defines a common representation for neural network models that enables seamless translation between different frameworks and deployment environments.</p>
<p>The ONNX format serves two primary purposes. First, it provides a framework-neutral specification for describing model architecture and parameters. Second, it includes runtime implementations that can execute these models across diverse hardware platforms. This standardization eliminates the need to manually convert or reimplement models when moving between frameworks.</p>
<p>In practice, ONNX facilitates important workflow patterns in production machine learning systems. For example, a research team might develop and train a model using PyTorch’s dynamic computation graphs, then export it to ONNX for deployment using TensorFlow’s production-optimized serving infrastructure. Similarly, models can be converted to ONNX format for execution on edge devices using specialized runtimes like ONNX Runtime. This interoperability, illustrated in <a href="#fig-onnx" class="quarto-xref">Figure&nbsp;<span>7.13</span></a>, has become increasingly important as the machine learning ecosystem has expanded. Organizations frequently need to leverage different frameworks’ strengths at various stages of the machine learning lifecycle, from research and development.</p>
<div id="fig-onnx" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-onnx-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/png/onnx.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-14" title="Figure&nbsp;7.13: Interoperability enabled by ONNX across major ML frameworks."><img src="images/png/onnx.jpg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-onnx-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7.13: Interoperability enabled by ONNX across major ML frameworks.
</figcaption>
</figure>
</div>
<p>Machine learning deployment environments shape how frameworks specialize and evolve. Cloud ML environments leverage high-performance servers that offer abundant computational resources for complex operations. Edge ML operates on devices with moderate computing power, where real-time processing often takes priority. Mobile ML adapts to the varying capabilities and energy constraints of smartphones and tablets. Tiny ML functions within the strict limitations of microcontrollers and other highly constrained devices that possess minimal resources.</p>
<p>Each of these environments presents unique challenges that influence framework design. Cloud frameworks prioritize scalability and distributed computing. Edge frameworks focus on low-latency inference and adaptability to diverse hardware. Mobile frameworks emphasize energy efficiency and integration with device-specific features. TinyML frameworks specialize in extreme resource optimization for severely constrained environments.</p>
<p>In the following sections, we will explore how ML frameworks adapt to each of these environments. We will examine the specific techniques and design choices that enable frameworks to address the unique challenges of each domain, highlighting the trade-offs and optimizations that characterize framework specialization.</p>
<section id="cloud-based-frameworks" class="level3" data-number="7.7.1">
<h3 data-number="7.7.1" class="anchored" data-anchor-id="cloud-based-frameworks"><span class="header-section-number">7.7.1</span> Cloud-Based Frameworks</h3>
<p>Cloud ML frameworks are sophisticated software infrastructures designed to leverage the vast computational resources available in cloud environments. These frameworks specialize in three primary areas: distributed computing architectures, management of large-scale data and models, and integration with cloud-native services.</p>
<p>Distributed computing is a fundamental specialization of cloud ML frameworks. These frameworks implement advanced strategies for partitioning and coordinating computational tasks across multiple machines or graphics processing units (GPUs). This capability is essential for training large-scale models on massive datasets. Both TensorFlow and PyTorch, two leading cloud ML frameworks, offer robust support for distributed computing. TensorFlow’s graph-based approach (in its 1.x version) was particularly well-suited for distributed execution, while PyTorch’s dynamic computational graph allows for more flexible distributed training strategies.</p>
<p>The ability to handle large-scale data and models is another key specialization. Cloud ML frameworks are optimized to work with datasets and models that far exceed the capacity of single machines. This specialization is reflected in the data structures of these frameworks. For instance, both TensorFlow and PyTorch use mutable Tensor objects as their primary data structure, allowing for efficient in-place operations on large datasets. JAX, a more recent framework, uses immutable arrays, which can provide benefits in terms of functional programming paradigms and optimization opportunities in distributed settings.</p>
<p>Integration with cloud-native services is the third major specialization area. This integration enables automated resource scaling, seamless access to cloud storage, and incorporation of cloud-based monitoring and logging systems. The execution modes of different frameworks play a role here. TensorFlow 2.x and PyTorch both default to eager execution, which allows for easier integration with cloud services and debugging. JAX’s just-in-time compilation offers potential performance benefits in cloud environments by optimizing computations for specific hardware.</p>
<p>Hardware acceleration is an important aspect of cloud ML frameworks. All major frameworks support CPU and GPU execution, with TensorFlow and JAX also offering native support for Google’s TPU. <a href="https://developer.nvidia.com/tensorrt">NVIDIA’s TensorRT</a> is an optimization tool dedicated for GPU-based inference, providing sophisticated optimizations like layer fusion, precision calibration, and kernel auto-tuning to maximize throughput on NVIDIA GPUs. These hardware acceleration options allow cloud ML frameworks to efficiently utilize the diverse computational resources available in cloud environments.</p>
<p>The automatic differentiation capabilities of these frameworks are particularly important in cloud settings where complex models with millions of parameters are common. While TensorFlow and PyTorch primarily use reverse-mode differentiation, JAX’s support for both forward and reverse-mode differentiation can offer advantages in certain large-scale optimization scenarios.</p>
<p>These specializations enable cloud ML frameworks to fully utilize the scalability and computational power of cloud infrastructure. However, this capability comes with increased complexity in deployment and management, often requiring specialized knowledge to fully leverage these frameworks. The focus on scalability and integration makes cloud ML frameworks particularly suitable for large-scale research projects, enterprise-level ML applications, and scenarios requiring massive computational resources.</p>
</section>
<section id="edge-based-frameworks" class="level3" data-number="7.7.2">
<h3 data-number="7.7.2" class="anchored" data-anchor-id="edge-based-frameworks"><span class="header-section-number">7.7.2</span> Edge-Based Frameworks</h3>
<p>Edge ML frameworks are specialized software tools designed to facilitate machine learning operations in edge computing environments, characterized by proximity to data sources, stringent latency requirements, and limited computational resources. Examples of popular edge ML frameworks include <a href="https://www.tensorflow.org/lite">TensorFlow Lite</a> and <a href="https://www.edgeimpulse.com">Edge Impulse</a>. The specialization of these frameworks addresses three primary challenges: real-time inference optimization, adaptation to heterogeneous hardware, and resource-constrained operation.</p>
<p>Real-time inference optimization is a critical feature of edge ML frameworks. This often involves leveraging different execution modes and graph types. For instance, while TensorFlow Lite (the edge-focused version of TensorFlow) uses a static graph approach to optimize inference, frameworks like <a href="https://pytorch.org/mobile/home/">PyTorch Mobile</a> maintain a dynamic graph capability, allowing for more flexible model structures at the cost of some performance. The choice between static and dynamic graphs in edge frameworks often is a trade-off between optimization potential and model flexibility.</p>
<p>Adaptation to heterogeneous hardware is crucial for edge deployments. Edge ML frameworks extend the hardware acceleration capabilities of their cloud counterparts but with a focus on edge-specific hardware. For instance, TensorFlow Lite supports acceleration on mobile GPUs and edge TPUs, while frameworks like <a href="https://developer.arm.com/solutions/machine-learning-on-arm/developer-material/how-to-guides">ARM’s Compute Library</a> optimize for ARM-based processors. This specialization often involves custom operator implementations and low-level optimizations specific to edge hardware.</p>
<p>Operating within resource constraints is another aspect of edge ML framework specialization. This is reflected in the data structures and execution models of these frameworks. For instance, many edge frameworks use quantized tensors as their primary data structure, representing values with reduced precision (e.g., 8-bit integers instead of 32-bit floats) to decrease memory usage and computational demands. The automatic differentiation capabilities, while crucial for training in cloud environments, are often stripped down or removed entirely in edge frameworks to reduce model size and improve inference speed.</p>
<p>Edge ML frameworks also often include features for model versioning and updates, allowing for the deployment of new models with minimal system downtime. Some frameworks support limited on-device learning, enabling models to adapt to local data without compromising data privacy.</p>
<p>The specializations of edge ML frameworks collectively enable high-performance inference in resource-constrained environments. This capability expands the potential applications of AI in areas with limited cloud connectivity or where real-time processing is crucial. However, effective utilization of these frameworks requires careful consideration of target hardware specifications and application-specific requirements, necessitating a balance between model accuracy and resource utilization.</p>
</section>
<section id="mobile-based-frameworks" class="level3" data-number="7.7.3">
<h3 data-number="7.7.3" class="anchored" data-anchor-id="mobile-based-frameworks"><span class="header-section-number">7.7.3</span> Mobile-Based Frameworks</h3>
<p>Mobile ML frameworks are specialized software tools designed for deploying and executing machine learning models on smartphones and tablets. Examples include TensorFlow Lite and <a href="https://developer.apple.com/documentation/coreml/">Apple’s Core ML</a>. These frameworks address the unique challenges of mobile environments, including limited computational resources, constrained power consumption, and diverse hardware configurations. The specialization of mobile ML frameworks primarily focuses on on-device inference optimization, energy efficiency, and integration with mobile-specific hardware and sensors.</p>
<p>On-device inference optimization in mobile ML frameworks often involves a careful balance between graph types and execution modes. For instance, TensorFlow Lite, also a popular mobile ML framework, uses a static graph approach to optimize inference performance. This contrasts with the dynamic graph capability of PyTorch Mobile, which offers more flexibility at the cost of some performance. The choice between static and dynamic graphs in mobile frameworks is a trade-off between optimization potential and model adaptability, crucial in the diverse and changing mobile environment.</p>
<p>The data structures in mobile ML frameworks are optimized for efficient memory usage and computation. While cloud-based frameworks like TensorFlow and PyTorch use mutable tensors, mobile frameworks often employ more specialized data structures. For example, many mobile frameworks use quantized tensors, representing values with reduced precision (e.g., 8-bit integers instead of 32-bit floats) to decrease memory footprint and computational demands. This specialization is critical given the limited RAM and processing power of mobile devices.</p>
<p>Energy efficiency, a paramount concern in mobile environments, influences the design of execution modes in mobile ML frameworks. Unlike cloud frameworks that may use eager execution for ease of development, mobile frameworks often prioritize graph-based execution for its potential energy savings. For instance, Apple’s Core ML uses a compiled model approach, converting ML models into a form that can be efficiently executed by iOS devices, optimizing for both performance and energy consumption.</p>
<p>Integration with mobile-specific hardware and sensors is another key specialization area. Mobile ML frameworks extend the hardware acceleration capabilities of their cloud counterparts but with a focus on mobile-specific processors. For example, TensorFlow Lite can leverage mobile GPUs and neural processing units (NPUs) found in many modern smartphones. Qualcomm’s Neural Processing SDK is designed to efficiently utilize the AI accelerators present in Snapdragon SoCs. This hardware-specific optimization often involves custom operator implementations and low-level optimizations tailored for mobile processors.</p>
<p>Automatic differentiation, while crucial for training in cloud environments, is often minimized or removed entirely in mobile frameworks to reduce model size and improve inference speed. Instead, mobile ML frameworks focus on efficient inference, with model updates typically performed off-device and then deployed to the mobile application.</p>
<p>Mobile ML frameworks also often include features for model updating and versioning, allowing for the deployment of improved models without requiring full app updates. Some frameworks support limited on-device learning, enabling models to adapt to user behavior or environmental changes without compromising data privacy.</p>
<p>The specializations of mobile ML frameworks collectively enable the deployment of sophisticated ML models on resource-constrained mobile devices. This expands the potential applications of AI in mobile environments, ranging from real-time image and speech recognition to personalized user experiences. However, effectively utilizing these frameworks requires careful consideration of the target device capabilities, user experience requirements, and privacy implications, necessitating a balance between model performance and resource utilization.</p>
</section>
<section id="tinyml-frameworks" class="level3 page-columns page-full" data-number="7.7.4">
<h3 data-number="7.7.4" class="anchored" data-anchor-id="tinyml-frameworks"><span class="header-section-number">7.7.4</span> TinyML Frameworks</h3>
<p>TinyML frameworks are specialized software infrastructures designed for deploying machine learning models on extremely resource-constrained devices, typically microcontrollers and low-power embedded systems. These frameworks address the severe limitations in processing power, memory, and energy consumption characteristic of tiny devices. The specialization of TinyML frameworks primarily focuses on extreme model compression, optimizations for severely constrained environments, and integration with microcontroller-specific architectures.</p>
<p>Extreme model compression in TinyML frameworks takes the quantization techniques mentioned in mobile and edge frameworks to their logical conclusion. While mobile frameworks might use 8-bit quantization, TinyML often employs even more aggressive techniques, such as 4-bit, 2-bit, or even 1-bit (binary) representations of model parameters. Frameworks like TensorFlow Lite Micro exemplify this approach <span class="citation" data-cites="david2021tensorflow">(<a href="../references.html#ref-david2021tensorflow" role="doc-biblioref">David et al. 2021</a>)</span>, pushing the boundaries of model compression to fit within the kilobytes of memory available on microcontrollers.</p>
<div class="no-row-height column-margin column-container"><div id="ref-david2021tensorflow" class="csl-entry" role="listitem">
David, Robert, Jared Duke, Advait Jain, Vijay Janapa Reddi, Nat Jeffries, Jian Li, Nick Kreeger, et al. 2021. <span>“Tensorflow Lite Micro: Embedded Machine Learning for Tinyml Systems.”</span> <em>Proceedings of Machine Learning and Systems</em> 3: 800–811.
</div></div><p>The execution model in TinyML frameworks is highly specialized. Unlike the dynamic graph capabilities seen in some cloud and mobile frameworks, TinyML frameworks almost exclusively use static, highly optimized graphs. The just-in-time compilation approach seen in frameworks like JAX is typically not feasible in TinyML due to memory constraints. Instead, these frameworks often employ ahead-of-time compilation techniques to generate highly optimized, device-specific code.</p>
<p>Memory management in TinyML frameworks is far more constrained than in other environments. While edge and mobile frameworks might use dynamic memory allocation, TinyML frameworks like <a href="https://github.com/uTensor/uTensor">uTensor</a> often rely on static memory allocation to avoid runtime overhead and fragmentation. This approach requires careful planning of the memory layout at compile time, a stark contrast to the more flexible memory management in cloud-based frameworks.</p>
<p>Hardware integration in TinyML frameworks is highly specific to microcontroller architectures. Unlike the general GPU support seen in cloud frameworks or the mobile GPU/NPU support in mobile frameworks, TinyML frameworks often provide optimizations for specific microcontroller instruction sets. For example, ARM’s CMSIS-NN <span class="citation" data-cites="lai2018cmsis">(<a href="../references.html#ref-lai2018cmsis" role="doc-biblioref">Lai, Suda, and Chandra 2018</a>)</span> provides optimized neural network kernels for Cortex-M series microcontrollers, which are often integrated into TinyML frameworks.</p>
<div class="no-row-height column-margin column-container"><div id="ref-lai2018cmsis" class="csl-entry" role="listitem">
Lai, Liangzhen, Naveen Suda, and Vikas Chandra. 2018. <span>“CMSIS-NN: Efficient Neural Network Kernels for Arm Cortex-m CPUs.”</span> <em>ArXiv Preprint</em> abs/1801.06601 (January). <a href="http://arxiv.org/abs/1801.06601v1">http://arxiv.org/abs/1801.06601v1</a>.
</div></div><p>The concept of automatic differentiation, central to cloud-based frameworks and present to some degree in edge and mobile frameworks, is typically absent in TinyML frameworks. The focus is almost entirely on inference, with any learning or model updates usually performed off-device due to the severe computational constraints.</p>
<p>TinyML frameworks also specialize in power management to a degree not seen in other ML environments. Features like duty cycling and ultra-low-power wake-up capabilities are often integrated directly into the ML pipeline, enabling always-on sensing applications that can run for years on small batteries.</p>
<p>The extreme specialization of TinyML frameworks enables ML deployments in previously infeasible environments, from smart dust sensors to implantable medical devices. However, this specialization comes with significant trade-offs in model complexity and accuracy, requiring careful consideration of the balance between ML capabilities and the severe resource constraints of target devices.</p>
</section>
</section>
<section id="framework-selection" class="level2" data-number="7.8">
<h2 data-number="7.8" class="anchored" data-anchor-id="framework-selection"><span class="header-section-number">7.8</span> Framework Selection</h2>
<p>Framework selection builds on our understanding of framework specialization across computing environments. Engineers must evaluate three interdependent factors when choosing a framework: model requirements, hardware constraints, and software dependencies. The TensorFlow ecosystem demonstrates how these factors shape framework design through its variants: TensorFlow, TensorFlow Lite, and TensorFlow Lite Micro.</p>
<p><a href="#tbl-tf-comparison" class="quarto-xref">Table&nbsp;<span>7.4</span></a> illustrates key differences between TensorFlow variants. Each variant represents specific trade-offs between computational capability and resource requirements. These trade-offs manifest in supported operations, binary size, and integration requirements.</p>
<div id="tbl-tf-comparison" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-tf-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;7.4: TensorFlow framework comparison - General.
</figcaption>
<div aria-describedby="tbl-tf-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 42%">
<col style="width: 19%">
<col style="width: 19%">
<col style="width: 19%">
</colgroup>
<thead>
<tr class="header">
<th>Model</th>
<th style="text-align: center;"><a href="images/png/TensorFlowLogo.png" class="lightbox" data-gallery="quarto-lightbox-gallery-15" title="Table&nbsp;7.4: TensorFlow framework comparison - General."><img src="images/png/TensorFlowLogo.png" style="height:6mm" class="figure-img"></a></th>
<th style="text-align: center;"><a href="images/png/TensorFlowLiteLogo.png" class="lightbox" data-gallery="quarto-lightbox-gallery-16" title="Table&nbsp;7.4: TensorFlow framework comparison - General."><img src="images/png/TensorFlowLiteLogo.png" style="height:6mm" class="figure-img"></a></th>
<th style="text-align: center;"><a href="images/png/TensorFlowLiteMicroLogo.png" class="lightbox" data-gallery="quarto-lightbox-gallery-17" title="Table&nbsp;7.4: TensorFlow framework comparison - General."><img src="images/png/TensorFlowLiteMicroLogo.png" style="height:6mm" class="figure-img"></a></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Training</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="even">
<td>Inference</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
</tr>
<tr class="odd">
<td></td>
<td style="text-align: center;">(<em>but inefficient on edge</em>)</td>
<td style="text-align: center;">(<em>and efficient</em>)</td>
<td style="text-align: center;">(<em>and even <strong>more</strong> efficient</em>)</td>
</tr>
<tr class="even">
<td>How Many Ops</td>
<td style="text-align: center;">~1400</td>
<td style="text-align: center;">~130</td>
<td style="text-align: center;">~50</td>
</tr>
<tr class="odd">
<td>Native Quantization Tooling + Support</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Engineers analyze three primary aspects when selecting a framework:</p>
<ol type="1">
<li>Model requirements determine which operations and architectures the framework must support</li>
<li>Software dependencies define operating system and runtime requirements</li>
<li>Hardware constraints establish memory and processing limitations</li>
</ol>
<p>This systematic analysis enables engineers to select frameworks that align with their deployment requirements. As we examine the TensorFlow variants, we will explore how each aspect influences framework selection and shapes the capabilities of deployed machine learning systems.</p>
<section id="model-requirements" class="level3" data-number="7.8.1">
<h3 data-number="7.8.1" class="anchored" data-anchor-id="model-requirements"><span class="header-section-number">7.8.1</span> Model Requirements</h3>
<p>Model architecture capabilities vary significantly across TensorFlow variants, with clear trade-offs between functionality and efficiency. <a href="#tbl-tf-comparison" class="quarto-xref">Table&nbsp;<span>7.4</span></a> quantifies these differences across four key dimensions: training capability, inference efficiency, operation support, and quantization features.</p>
<p>TensorFlow supports approximately 1,400 operations and enables both training and inference. However, as <a href="#tbl-tf-comparison" class="quarto-xref">Table&nbsp;<span>7.4</span></a> indicates, its inference capabilities are inefficient for edge deployment. TensorFlow Lite reduces the operation count to roughly 130 operations while improving inference efficiency. It eliminates training support but adds native quantization tooling. TensorFlow Lite Micro further constrains the operation set to approximately 50 operations, achieving even higher inference efficiency through these constraints. Like TensorFlow Lite, it includes native quantization support but removes training capabilities.</p>
<p>This progressive reduction in operations enables deployment on increasingly constrained devices. The addition of native quantization in both TensorFlow Lite and TensorFlow Lite Micro provides essential optimization capabilities absent in the full TensorFlow framework. Quantization transforms models to use lower precision operations, reducing computational and memory requirements for resource-constrained deployments.</p>
</section>
<section id="software-dependencies" class="level3" data-number="7.8.2">
<h3 data-number="7.8.2" class="anchored" data-anchor-id="software-dependencies"><span class="header-section-number">7.8.2</span> Software Dependencies</h3>
<p><a href="#tbl-tf-sw-comparison" class="quarto-xref">Table&nbsp;<span>7.5</span></a> reveals three key software considerations that differentiate TensorFlow variants: operating system requirements, memory management capabilities, and accelerator support. These differences reflect each variant’s optimization for specific deployment environments.</p>
<div id="tbl-tf-sw-comparison" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-tf-sw-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;7.5: TensorFlow framework comparison - Software.
</figcaption>
<div aria-describedby="tbl-tf-sw-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 22%">
<col style="width: 22%">
<col style="width: 22%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Software</strong></th>
<th style="text-align: center;"><a href="images/png/TensorFlowLogo.png" class="lightbox" data-gallery="quarto-lightbox-gallery-18" title="Table&nbsp;7.5: TensorFlow framework comparison - Software."><img src="images/png/TensorFlowLogo.png" style="height:6mm" class="figure-img"></a></th>
<th style="text-align: center;"><a href="images/png/TensorFlowLiteLogo.png" class="lightbox" data-gallery="quarto-lightbox-gallery-19" title="Table&nbsp;7.5: TensorFlow framework comparison - Software."><img src="images/png/TensorFlowLiteLogo.png" style="height:6mm" class="figure-img"></a></th>
<th style="text-align: center;"><a href="images/png/TensorFlowLiteMicroLogo.png" class="lightbox" data-gallery="quarto-lightbox-gallery-20" title="Table&nbsp;7.5: TensorFlow framework comparison - Software."><img src="images/png/TensorFlowLiteMicroLogo.png" style="height:6mm" class="figure-img"></a></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Needs an OS</strong></td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="even">
<td><strong>Memory Mapping of Models</strong></td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
</tr>
<tr class="odd">
<td><strong>Delegation to accelerators</strong></td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Operating system dependencies mark a fundamental distinction between variants. TensorFlow and TensorFlow Lite require an operating system, while TensorFlow Lite Micro operates without OS support. This enables TensorFlow Lite Micro to reduce memory overhead and startup time, though it can still integrate with real-time operating systems like FreeRTOS, Zephyr, and Mbed OS when needed.</p>
<p>Memory management capabilities also distinguish the variants. TensorFlow Lite and TensorFlow Lite Micro support model memory mapping, enabling direct model access from flash storage rather than loading into RAM. TensorFlow lacks this capability, reflecting its design for environments with abundant memory resources. Memory mapping becomes increasingly important as deployment moves toward resource-constrained devices.</p>
<p>Accelerator delegation capabilities further differentiate the variants. Both TensorFlow and TensorFlow Lite support delegation to accelerators, enabling efficient computation distribution. TensorFlow Lite Micro omits this feature, acknowledging the limited availability of specialized accelerators in embedded systems. This design choice maintains the framework’s minimal footprint while matching typical embedded hardware configurations.</p>
</section>
<section id="hardware-constraints" class="level3" data-number="7.8.3">
<h3 data-number="7.8.3" class="anchored" data-anchor-id="hardware-constraints"><span class="header-section-number">7.8.3</span> Hardware Constraints</h3>
<p><a href="#tbl-tf-hw-comparison" class="quarto-xref">Table&nbsp;<span>7.6</span></a> quantifies the hardware requirements across TensorFlow variants through three metrics: base binary size, memory footprint, and processor architecture support. These metrics demonstrate the progressive optimization for constrained computing environments.</p>
<div id="tbl-tf-hw-comparison" class="striped hover quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-tf-hw-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;7.6: TensorFlow framework comparison—Hardware.
</figcaption>
<div aria-describedby="tbl-tf-hw-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 31%">
<col style="width: 17%">
<col style="width: 22%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Hardware</strong></th>
<th style="text-align: center;"><a href="images/png/TensorFlowLogo.png" class="lightbox" data-gallery="quarto-lightbox-gallery-21" title="Table&nbsp;7.6: TensorFlow framework comparison—Hardware."><img src="images/png/TensorFlowLogo.png" style="height:6mm" class="figure-img"></a></th>
<th style="text-align: center;"><a href="images/png/TensorFlowLiteLogo.png" class="lightbox" data-gallery="quarto-lightbox-gallery-22" title="Table&nbsp;7.6: TensorFlow framework comparison—Hardware."><img src="images/png/TensorFlowLiteLogo.png" style="height:6mm" class="figure-img"></a></th>
<th style="text-align: center;"><a href="images/png/TensorFlowLiteMicroLogo.png" class="lightbox" data-gallery="quarto-lightbox-gallery-23" title="Table&nbsp;7.6: TensorFlow framework comparison—Hardware."><img src="images/png/TensorFlowLiteMicroLogo.png" style="height:6mm" class="figure-img"></a></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Base Binary Size</strong></td>
<td style="text-align: center;">3 MB+</td>
<td style="text-align: center;">100 KB</td>
<td style="text-align: center;">~10 KB</td>
</tr>
<tr class="even">
<td><strong>Base Memory Footprint</strong></td>
<td style="text-align: center;">~5 MB</td>
<td style="text-align: center;">300 KB</td>
<td style="text-align: center;">20 KB</td>
</tr>
<tr class="odd">
<td><strong>Optimized Architectures</strong></td>
<td style="text-align: center;">X86, TPUs, GPUs</td>
<td style="text-align: center;">Arm Cortex A, x86</td>
<td style="text-align: center;">Arm Cortex M, DSPs, MCUs</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Binary size requirements decrease significantly across variants. TensorFlow requires over 3 MB for its base binary, reflecting its comprehensive feature set. TensorFlow Lite reduces this to 100 KB by eliminating training capabilities and unused operations. TensorFlow Lite Micro achieves a remarkable 10 KB binary size through aggressive optimization and feature reduction.</p>
<p>Memory footprint follows a similar pattern of reduction. TensorFlow requires approximately 5 MB of base memory, while TensorFlow Lite operates within 300 KB. TensorFlow Lite Micro further reduces memory requirements to 20 KB, enabling deployment on highly constrained devices.</p>
<p>Processor architecture support aligns with each variant’s intended deployment environment. TensorFlow supports x86 processors and accelerators including TPUs and GPUs, enabling high-performance computing in data centers. TensorFlow Lite targets mobile and edge processors, supporting Arm Cortex-A and x86 architectures. TensorFlow Lite Micro specializes in microcontroller deployment, supporting Arm Cortex-M cores, digital signal processors (DSPs), and various microcontroller units (MCUs) including STM32, NXP Kinetis, and Microchip AVR.</p>
</section>
<section id="additional-selection-factors" class="level3" data-number="7.8.4">
<h3 data-number="7.8.4" class="anchored" data-anchor-id="additional-selection-factors"><span class="header-section-number">7.8.4</span> Additional Selection Factors</h3>
<p>Framework selection for embedded systems extends beyond technical specifications of model architecture, hardware requirements, and software dependencies. Additional factors affect development efficiency, maintenance requirements, and deployment success. These factors require systematic evaluation to ensure optimal framework selection.</p>
<section id="performance-optimization" class="level4">
<h4 class="anchored" data-anchor-id="performance-optimization">Performance Optimization</h4>
<p>Performance in embedded systems encompasses multiple metrics beyond computational speed. Framework evaluation must consider:</p>
<p>Inference latency determines system responsiveness and real-time processing capabilities. Memory utilization affects both static storage requirements and runtime efficiency. Power consumption impacts battery life and thermal management requirements. Frameworks must provide optimization tools for these metrics, including quantization, operator fusion, and hardware-specific acceleration.</p>
</section>
<section id="deployment-scalability" class="level4">
<h4 class="anchored" data-anchor-id="deployment-scalability">Deployment Scalability</h4>
<p>Scalability requirements span both technical capabilities and operational considerations. Framework support must extend across deployment scales and scenarios:</p>
<p>Device scaling enables consistent deployment from microcontrollers to more powerful embedded processors. Operational scaling supports the transition from development prototypes to production deployments. Version management facilitates model updates and maintenance across deployed devices. The framework must maintain consistent performance characteristics throughout these scaling dimensions.</p>
</section>
</section>
</section>
<section id="conclusion" class="level2" data-number="7.9">
<h2 data-number="7.9" class="anchored" data-anchor-id="conclusion"><span class="header-section-number">7.9</span> Conclusion</h2>
<p>AI frameworks have evolved from basic numerical libraries into sophisticated software systems that shape how we develop and deploy machine learning applications. The progression from early numerical computing to modern deep learning frameworks demonstrates the field’s rapid technological advancement.</p>
<p>Modern frameworks like TensorFlow, PyTorch, and JAX implement distinct approaches to common challenges in machine learning development. Each framework offers varying tradeoffs between ease of use, performance, and flexibility. TensorFlow emphasizes production deployment, PyTorch focuses on research and experimentation, while JAX prioritizes functional programming patterns.</p>
<p>The specialization of frameworks into cloud, edge, mobile, and tiny ML implementations reflects the diverse requirements of machine learning applications. Cloud frameworks optimize for scalability and distributed computing. Edge and mobile frameworks prioritize model efficiency and reduced resource consumption. TinyML frameworks target constrained environments with minimal computing resources.</p>
<p>Understanding framework architecture, from tensor operations to execution models, enables developers to select appropriate tools for specific use cases, optimize application performance, debug complex computational graphs, and deploy models across different computing environments.</p>
<p>The continuing evolution of AI frameworks will likely focus on improving developer productivity, hardware acceleration, and deployment flexibility. These advancements will shape how machine learning systems are built and deployed across increasingly diverse computing environments.</p>



</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    window.setColorSchemeToggle(window.hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
  });
  </script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
<script>
function loadGiscusWhenReady() {
  // Function to get the theme based on body class
  const getTheme = () => {
    const baseTheme = document.getElementById('giscus-base-theme').value;
    const altTheme = document.getElementById('giscus-alt-theme').value;
    return document.body.classList.contains('quarto-dark') ? altTheme : baseTheme;
  };
  // Create the Giscus script and add it to the desired location
  const loadGiscus = () => {
    const script = document.createElement("script");
    script.src = "https://giscus.app/client.js";
    script.async = true;
    script.dataset.repo = "harvard-edge/cs249r_book";
    script.dataset.repoId = "R_kgDOKQSOaw";
    script.dataset.category = "General";
    script.dataset.categoryId = "DIC_kwDOKQSOa84CZ8Ry";
    script.dataset.mapping = "title";
    script.dataset.reactionsEnabled = "1";
    script.dataset.emitMetadata = "0";
    script.dataset.inputPosition = "top";
    script.dataset.theme = getTheme();
    script.dataset.lang = "en";
    script.crossOrigin = "anonymous";
    // Append the script to the desired div instead of at the end of the body
    document.getElementById("quarto-content").appendChild(script);
  };
  // MutationObserver to detect when the 'quarto-light' or 'quarto-dark' class is added to the body
  const observer = new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type === "attributes" && mutation.attributeName === "class") {
        if (document.body.classList.contains('quarto-light') || document.body.classList.contains('quarto-dark')) {
          loadGiscus();
          observer.disconnect(); // Stop observing once Giscus is loaded
          break;
        }
      }
    }
  });
  // Start observing the body for class attribute changes
  observer.observe(document.body, {
    attributes: true,
    attributeFilter: ["class"],
  });
}
loadGiscusWhenReady();
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../../contents/core/data_engineering/data_engineering.html" class="pagination-link" aria-label="Data Engineering">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Data Engineering</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../../contents/core/training/training.html" class="pagination-link" aria-label="AI Training">
        <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">AI Training</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Written, edited and curated by Prof.&nbsp;Vijay Janapa Reddi (Harvard University)</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/harvard-edge/cs249r_book/edit/widget_quiz/contents/core/frameworks/frameworks.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/harvard-edge/cs249r_book/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li><li><a href="https://github.com/harvard-edge/cs249r_book/blob/widget_quiz/contents/core/frameworks/frameworks.qmd" class="toc-action"><i class="bi empty"></i>View source</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>This book was built with <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>