---
bibliography: frameworks.bib
---

# AI Frameworks {#sec-ai_frameworks}

::: {.content-visible when-format="html"}
Resources: [Slides](#sec-ai-frameworks-resource), [Videos](#sec-ai-frameworks-resource), [Exercises](#sec-ai-frameworks-resource)
:::

![_DALLÂ·E 3 Prompt: Illustration in a rectangular format, designed for a professional textbook, where the content spans the entire width. The vibrant chart represents training and inference frameworks for ML. Icons for TensorFlow, Keras, PyTorch, ONNX, and TensorRT are spread out, filling the entire horizontal space, and aligned vertically. Each icon is accompanied by brief annotations detailing their features. The lively colors like blues, greens, and oranges highlight the icons and sections against a soft gradient background. The distinction between training and inference frameworks is accentuated through color-coded sections, with clean lines and modern typography maintaining clarity and focus._](images/png/cover_ml_frameworks.png)

## Purpose {.unnumbered}

_How do AI frameworks bridge the gap between theoretical design and practical implementation, and what role do they play in enabling scalable machine learning systems?_

AI frameworks are a critical middleware software layer that that transforms abstract model specifications into executable implementations. The evolution of these frameworks reveals fundamental patterns for translating high-level designs into efficient computational workflows and system execution. Their architecture illuminates essential trade-offs between abstraction, performance, and portability, providing systematic approaches to managing complexity in machine learning systems. Understanding framework capabilities and constraints offers crucial insights into the engineering decisions that shape system scalability, enabling the development of robust, deployable solutions across diverse computing environments.

::: {.callout-tip}

## Learning Objectives

* Understand the evolution and capabilities of major machine learning frameworks. This includes graph execution models, programming paradigms, hardware acceleration support, and how they have expanded over time.

* Learn frameworks' core components and functionality, such as computational graphs, data pipelines, optimization algorithms, training loops, etc., that enable efficient model building.

* Compare frameworks across different environments, such as cloud, edge, and TinyML. Learn how frameworks specialize based on computational constraints and hardware.

* Dive deeper into embedded and TinyML-focused frameworks like TensorFlow Lite Micro, CMSIS-NN, TinyEngine, etc., and how they optimize for microcontrollers.

* When choosing a framework, explore model conversion and deployment considerations, including latency, memory usage, and hardware support.

* Evaluate key factors in selecting the right framework, like performance, hardware compatibility, community support, ease of use, etc., based on the specific project needs and constraints.

* Understand the limitations of current frameworks and potential future trends, such as using ML to improve frameworks, decomposed ML systems, and high-performance compilers.

:::

## Overview

Modern machine learning development relies fundamentally on machine learning frameworks, which are comprehensive software libraries or platforms designed to simplify the development, training, and deployment of machine learning models. These frameworks serve multiple roles in ML systems, much like operating systems are the foundation of computing systems. Just as operating systems abstract away the complexity of hardware resources and provide standardized interfaces for applications, ML frameworks abstract the intricacies of mathematical operations and hardware acceleration, providing standardized APIs for ML development.

The capabilities of ML frameworks are diverse and continuously evolving. They provide efficient implementations of mathematical operations, automatic differentiation capabilities, and tools for managing model development, hardware acceleration, and memory utilization. For production systems, they offer standardized approaches to model deployment, versioning, and optimization. However, due to their diversity, there is no universally agreed-upon definition of an ML framework.

To establish clarity for this chapter, we adopt the following definition:

::: {.callout-note}

### Definition of Machine Learning Framework

A **Machine Learning Framework (ML Framework)** is a *software platform* that provides tools and abstractions for designing, training, and deploying machine learning models. It bridges *user applications* with *infrastructure*, enabling *algorithmic expressiveness* through computational graphs and operators, *workflow orchestration* across the machine learning lifecycle, *hardware optimization* with schedulers and compilers, *scalability* for distributed and edge systems, and *extensibility* to support diverse use cases. ML frameworks form the foundation of modern machine learning systems by simplifying development and deployment processes.

:::

The landscape of ML frameworks continues to evolve with the field itself. Today's frameworks must address diverse requirements: from training large language models on distributed systems to deploying compact neural networks on tiny IoT devices. Popular frameworks like PyTorch and TensorFlow have developed rich ecosystems that extend far beyond basic model implementation, encompassing tools for data preprocessing, model optimization, and deployment.

As we progress into examining training, optimization, and deployment, understanding ML frameworks becomes crucial as they orchestrate the entire machine learning lifecycle. These frameworks provide the core architecture that connects all aspects of ML systems, from data ingestion to model deployment. Just as understanding a blueprint is important before studying construction techniques, grasping framework architecture is vital before diving into training methodologies and deployment strategies. Modern frameworks encapsulate the complete ML workflow, and their design choices influence how we approach training, optimization, and inference.

This chapter helps us learn how these complex frameworks function, their architectural principles, and their role in modern ML systems. Understanding these concepts will provide the necessary context as we explore specific aspects of the ML lifecycle in subsequent chapters.

## Historical Evolution

The evolution of machine learning frameworks mirrors the broader development of artificial intelligence and computational capabilities. This section explores the distinct phases that reflect both technological advances and changing requirements of the AI community, from early numerical computing libraries to modern deep learning frameworks.

### Early Numerical Libraries

The foundation for modern ML frameworks begins at the most fundamental level of computation: matrix operations. At their core, machine learning computations are primarily matrix-matrix and matrix-vector multiplications. The Basic Linear Algebra Subprograms (BLAS), developed in 1979, provided these essential matrix operations that would become the computational backbone of machine learning. These low-level operations, when combined and executed efficiently, enable the complex calculations required for training neural networks and other ML models.

Building upon BLAS, the Linear Algebra Package (LAPACK) emerged in 1992, extending these capabilities with more sophisticated linear algebra operations such as matrix decompositions, eigenvalue problems, and linear system solutions. This layered approach of building increasingly complex operations from fundamental matrix computations became a defining characteristic of ML frameworks.

The development of NumPy in 2006 marked a crucial milestone in this evolution, building upon its predecessors Numeric and Numarray to become the fundamental package for numerical computation in Python. NumPy introduced n-dimensional array objects and essential mathematical functions, but more importantly, it provided an efficient interface to these underlying BLAS and LAPACK operations. This abstraction allowed developers to work with high-level array operations while maintaining the performance of optimized low-level matrix computations.

In 2001, SciPy emerged as a powerful extension built on top of NumPy, adding specialized functions for optimization, linear algebra, and signal processing. This further exemplified the pattern of progressive abstraction in ML frameworks: from basic matrix operations to sophisticated numerical computations, and eventually to high-level machine learning algorithms. This layered architecture, starting from fundamental matrix operations and building upward, would become a blueprint for future ML frameworks.

## First-Generation ML Frameworks

The transition from numerical libraries to dedicated machine learning frameworks marked a crucial evolution in abstraction. While the underlying computations remained rooted in matrix operations, frameworks began to encapsulate these operations into higher-level machine learning primitives. The University of Waikato introduced Weka in 1993, one of the earliest ML frameworks, which abstracted matrix operations into data mining tasks, though it was limited by its Java implementation and focus on smaller-scale computations.

Scikit-learn, emerging in 2007, represented a significant advancement in this abstraction. Building upon the NumPy and SciPy foundation, it transformed basic matrix operations into intuitive ML algorithms. For example, what was fundamentally a series of matrix multiplications and gradient computations became a simple "fit()" method call in a logistic regression model. This abstraction pattern - hiding complex matrix operations behind clean APIs - would become a defining characteristic of modern ML frameworks.

A pivotal advancement came with Theano in 2007, developed at the Montreal Institute for Learning Algorithms (MILA). Theano introduced two revolutionary concepts: computational graphs and GPU acceleration. Computational graphs represented mathematical operations as directed graphs, with matrix operations as nodes and data flowing between them. This graph-based approach allowed for automatic differentiation and optimization of the underlying matrix operations. More importantly, it enabled the framework to automatically route these operations to GPU hardware, dramatically accelerating matrix computations.

Meanwhile, Torch, created at NYU in 2002, took a different approach to handling matrix operations. It emphasized immediate execution of operations (eager execution) and provided a flexible interface for neural network implementations. Torch's design philosophy of prioritizing developer experience while maintaining high performance influenced many subsequent frameworks. Its architecture demonstrated how to balance high-level abstractions with efficient low-level matrix operations, establishing design patterns that would later influence frameworks like PyTorch.

### Rise of Deep Learning Frameworks

The deep learning revolution demanded a fundamental shift in how frameworks handled matrix operations, primarily due to three factors: the massive scale of computations, the complexity of gradient calculations through deep networks, and the need for distributed processing. Traditional frameworks, designed for classical machine learning algorithms, couldn't efficiently handle the billions of matrix operations required for training deep neural networks.

Caffe, released by UC Berkeley in 2013, pioneered this new generation by introducing specialized implementations of convolutional operations. While convolutions are mathematically equivalent to specific patterns of matrix multiplication, Caffe optimized these patterns specifically for computer vision tasks, demonstrating how specialized matrix operation implementations could dramatically improve performance for specific network architectures.

Google's TensorFlow, introduced in 2015, revolutionized the field by treating matrix operations as part of a distributed computing problem. It represented all computations, from individual matrix multiplications to entire neural networks, as a static computational graph that could be split across multiple devices. This approach enabled training of unprecedented model sizes by distributing matrix operations across clusters of computers and specialized hardware. TensorFlow's static graph approach, while initially constraining, allowed for aggressive optimization of matrix operations through techniques like kernel fusion and memory planning.

Facebook's PyTorch, launched in 2016, took a radically different approach to handling matrix computations. Instead of static graphs, PyTorch introduced dynamic computational graphs that could be modified on the fly. This dynamic approach, while potentially sacrificing some optimization opportunities, made it much easier for researchers to debug and understand the flow of matrix operations in their models. PyTorch's success demonstrated that the ability to introspect and modify computations dynamically was as important as raw performance for many applications.

Amazon's MXNet approached the challenge of large-scale matrix operations by focusing on memory efficiency and scalability across different hardware configurations. It introduced a hybrid approach that combined aspects of both static and dynamic graphs, allowing for flexible model development while still enabling aggressive optimization of the underlying matrix operations.

### Hardware Influence on Design

Hardware developments have fundamentally reshaped how frameworks implement and optimize matrix operations. The introduction of NVIDIA's CUDA platform in 2007 marked a pivotal moment in framework design by enabling general-purpose computing on GPUs. This was transformative because GPUs excel at parallel matrix operations, offering orders of magnitude speedup for the core computations in deep learning. While a CPU might process matrix elements sequentially, a GPU can process thousands of elements simultaneously, fundamentally changing how frameworks approach computation scheduling.

The development of hardware-specific accelerators further revolutionized framework design. Google's Tensor Processing Units (TPUs), first deployed in 2016, were purpose-built for tensor operations, the fundamental building blocks of deep learning computations. TPUs introduced systolic array architectures, which are particularly efficient for matrix multiplication and convolution operations. This hardware architecture prompted frameworks like TensorFlow to develop specialized compilation strategies that could map high-level operations directly to TPU instructions, bypassing traditional CPU-oriented optimizations.

Mobile hardware accelerators, such as Apple's Neural Engine (2017) and Qualcomm's Neural Processing Units, brought new constraints and opportunities to framework design. These devices emphasized power efficiency over raw computational speed, requiring frameworks to develop new strategies for quantization and operator fusion. Mobile frameworks like TensorFlow Lite and PyTorch Mobile needed to balance model accuracy with energy consumption, leading to innovations in how matrix operations are scheduled and executed.

The emergence of custom ASIC (Application-Specific Integrated Circuit) solutions has further diversified the hardware landscape. Companies like Graphcore, Cerebras, and SambaNova have developed unique architectures for matrix computation, each with different strengths and optimization opportunities. This proliferation of specialized hardware has pushed frameworks to adopt more flexible intermediate representations of matrix operations, allowing for target-specific optimization while maintaining a common high-level interface.

Field Programmable Gate Arrays (FPGAs) introduced yet another dimension to framework optimization. Unlike fixed-function ASICs, FPGAs allow for reconfigurable circuits that can be optimized for specific matrix operation patterns. Frameworks responding to this capability developed just-in-time compilation strategies that could generate optimized hardware configurations based on the specific needs of a model.

### Industry Impact

Industry requirements fundamentally changed how machine learning frameworks evolved from research tools to production systems. As companies began deploying models at scale, they encountered challenges that academic implementations hadn't addressed. The need to serve millions of predictions per second while maintaining consistent latency led to the development of specialized serving systems. TensorFlow Serving pioneered this space by introducing model versioning, batching optimizations, and efficient resource management. PyTorch followed with TorchServe, focusing on making model deployment more intuitive for developers.

Cloud computing introduced new possibilities and challenges for framework development. The ability to access vast computational resources demanded frameworks that could efficiently scale across hundreds or thousands of machines. This led to innovations in distributed training architectures, where frameworks had to orchestrate complex matrix operations across network-connected devices while managing communication overhead. Cloud providers developed specialized services like AWS SageMaker and Google Cloud ML Engine, which influenced how frameworks approached model training and deployment.

Enterprise adoption brought requirements for production-grade features that research-oriented frameworks hadn't prioritized. Organizations needed robust monitoring to track model performance and resource usage in real-time. Version control became crucial as teams collaborated on model development, leading to the integration of model registries and artifact tracking. Security considerations drove the development of encrypted computation capabilities and access controls within frameworks.

The rise of automated machine learning (AutoML) platforms pushed frameworks to become more modular. These platforms needed to programmatically construct and modify models, requiring frameworks to expose standardized interfaces for model architecture manipulation. This led to the development of higher-level APIs that could abstract away the complexity of model construction while maintaining performance.

The increasing focus on model governance and compliance influenced framework development in unexpected ways. Organizations needed to track model lineage, explain predictions, and ensure reproducibility. Frameworks responded by adding capabilities for model documentation, experiment tracking, and deterministic computation modes. These features became as important as raw computational performance for many enterprise deployments.

This evolution from pure research tools to enterprise-ready platforms marks a significant maturation in the machine learning ecosystem. Modern frameworks must balance multiple competing demands: maintaining the flexibility and ease of use that researchers require, while providing the robustness and scalability that industry demands. This balance has led to the emergence of rich framework ecosystems, where core libraries are supplemented by specialized tools for deployment, monitoring, and governance. As machine learning continues to be adopted across industries, frameworks continue to evolve, incorporating lessons learned from real-world deployments while maintaining their foundational role in advancing the field.

## Framework Fundamentals

The core of modern ML frameworks rests on four main aspects that work in concert to enable efficient machine learning development. @fig-fm_blocks illustrates the relationship between the four core components: computational graphs, data structures, programming models, and core operations.

At the lowest level (i.e., the foundation level), computational graphs are the mathematical backbone, representing model operations and enabling efficient computation across hardware platforms. These graphs provide the essential structure for automatic differentiation and optimization, allowing frameworks to analyze and distribute workloads effectively.

![Framework component interaction.](images/png/fm_building_blocks.png){#fig-fm_blocks width=80%}

Built upon this foundation, specialized data structures form the next layer of the framework architecture. Chief among these are tensors, which act as the primary containers for numerical data and model parameters. These structures are meticulously designed to handle the high-dimensional arrays typical in machine learning while efficiently managing memory and device placement.

The programming model of a framework defines how developers interact with these underlying structures and operations. Modern frameworks offer a range of approaches, from imperative programming paradigms (flexible and interactive) to symbolic paradigms (optimized for deployment). Each approach provides distinct advantages in terms of development experience, debugging capabilities, and execution efficiency. The choice of programming model greatly influences how algorithms are expressed and how frameworks optimize their execution.

At the highest level of abstraction, frameworks implement core operations that handle essential mathematical and machine learning computations. These operations, ranging from basic linear algebra to complex neural network layers, are optimized for performance across various hardware platforms. They serve as the building blocks for constructing sophisticated machine learning models.

When selecting a downstream framework for deployment, a solid grasp of these concepts is essential. This knowledge enables informed decisions about resource utilization, scaling strategies, and deployment architectures. In production systems, understanding these aspects ensures efficient performance and scalability.

### Computational Graphs

The computational graph is the basic abstraction in modern machine learning frameworks. It bridges the gap between high-level model descriptions and low-level hardware execution. 

A computational graph represents a machine learning model as a directed acyclic graph (DAG) where nodes represent operations and edges represent data flow. This representation enables frameworks to perform system-level optimizations, manage hardware resources, and efficiently execute complex mathematical operations across diverse computing platforms.

As shown in @fig-mlfm-static-graph, the structure of the computation graph involves defining a sequence of interconnected layers, such as convolution, activation, pooling, and normalization, which are optimized before execution. The figure also highlights system-level interactions, including memory management and device placement, showcasing how the static graph approach enables comprehensive pre-execution analysis and resource allocation.

![Example of a computational graph.](images/png/comp_graph.png){#fig-mlfm-comp-graph width=80%}

From a systems perspective, computational graphs provide several key capabilities that influence the entire machine learning pipeline. They enable automatic differentiation, provide clear structure for analyzing data dependencies and potential parallelism, and serve as an intermediate representation that can be optimized and transformed for different hardware targets. Understanding this architecture is essential for comprehending how frameworks translate high-level model descriptions into efficient executable code.

#### Static Graphs

Static computation graphs, pioneered by early versions of TensorFlow, implement a "define-then-run" execution model. In this approach, developers must specify the entire computation graph before execution begins. This architectural choice has significant implications for both system performance and development workflow.

A static computation graph implements a clear separation between the definition of operations and their execution. During the definition phase, each mathematical operation, variable, and data flow connection is explicitly declared and added to the graph structure. This graph is a complete specification of the computation but does not perform any actual calculations. Instead, the framework constructs an internal representation of all operations and their dependencies, which will be executed in a subsequent phase.

This upfront definition enables powerful system-level optimizations. The framework can analyze the complete structure to identify opportunities for operation fusion, eliminating unnecessary intermediate results. Memory requirements can be precisely calculated and optimized in advance, leading to efficient allocation strategies. Furthermore, static graphs can be compiled into highly optimized executable code for specific hardware targets, taking full advantage of platform-specific features. Once validated, the same computation can be run repeatedly with high confidence in its behavior and performance characteristics.

@fig-mlfm-static-graph illustrates this fundamental two-phase approach: first, the complete computational graph is constructed and optimized; then, during the execution phase, actual data flows through the graph to produce results. This separation enables the framework to perform comprehensive analysis and optimization of the entire computation before any execution begins.

![The two-phase execution model of static computation graphs.](images/png/static_graph.png){#fig-mlfm-static-graph}


#### Dynamic Graphs

Dynamic computation graphs, popularized by PyTorch, implement a "define-by-run" execution model. This approach constructs the graph during execution, offering greater flexibility in model definition and debugging. From a systems perspective, this architectural choice presents a different set of tradeoffs. The dynamic approach enables immediate execution of operations and allows graph structure to depend on runtime conditions. 

As shown in @fig-mlfm-dynamic-graph-flow, each operation is defined, executed, and completed before moving on to define the next operation. This contrasts sharply with static graphs, where all operations must be defined upfront. When an operation is defined, it is immediately executed, and its results become available for subsequent operations or for inspection during debugging. This cycle continues until all operations are complete.

![Dynamic graph execution model, illustrating runtime graph construction and immediate execution.](images/png/dynamic_graph.png){#fig-mlfm-dynamic-graph-flow width=30%}

Dynamic graphs excel in scenarios that require conditional execution or dynamic control flow, such as when processing variable-length sequences or implementing complex branching logic. They provide immediate feedback during development, making it easier to identify and fix issues in the computational pipeline. This flexibility aligns naturally with imperative programming patterns familiar to most developers, allowing them to inspect and modify computations at runtime. These characteristics make dynamic graphs particularly valuable during the research and development phase of ML projects.

#### System Implications

The architectural differences between static and dynamic computational graphs have multiple implications for how machine learning systems are designed and executed. These implications touch on various aspects of memory usage, device utilization, execution optimization, and debugging, all of which play crucial roles in determining the efficiency and scalability of a system. Here, we start with a focus on memory management and device placement as foundational concepts, leaving more detailed discussions for later chapters. This allows us to build a clear understanding before exploring more complex topics like optimization and fault tolerance.

##### Memory Management

Memory management is when executing computational graphs. Static graphs benefit from their predefined structure, enabling precise memory planning before execution. Frameworks can calculate memory requirements in advance, optimize allocation, and minimize overhead through techniques such as memory reuse. This structured approach helps ensure consistent performance, especially in environments where resources are constrained, such as in Mobile and Tiny ML systems.

Dynamic graphs, by contrast, allocate memory dynamically as operations are executed. While this flexibility is invaluable for handling dynamic control flows or variable input sizes, it can result in higher memory overhead and fragmentation. These trade-offs are often most apparent during development, where dynamic graphs enable rapid iteration and debugging but may require additional optimization for production deployment.

##### Device Placement

Device placement, the process of assigning operations to hardware resources like CPUs, GPUs, or specialized ASICS like TPUs, is another system-level consideration. Static graphs allow for detailed pre-execution analysis, enabling the framework to map computationally intensive operations efficiently to devices while minimizing communication overhead. This capability makes static graphs well-suited for optimizing execution on specialized hardware, where performance gains can be significant.

Dynamic graphs, in contrast, handle device placement at runtime. This allows them to adapt to changing conditions, such as hardware availability or workload demands. However, the lack of a complete graph structure before execution can make it challenging to optimize device utilization fully, potentially leading to inefficiencies in large-scale or distributed setups.

##### A Broader Perspective

The trade-offs between static and dynamic graphs extend well beyond memory and device considerations. As shown in @tbl-mlfm-graphs, these architectures influence optimization potential, debugging capabilities, scalability, and deployment complexity. While these broader implications are not the focus of this section, they will be explored in detail in later chapters, particularly in the context of training workflows and system-level optimizations.

These hybrid solutions aim to provide the flexibility of dynamic graphs during development while enabling the performance optimizations of static graphs in production environments. The choice between static and dynamic graphs often depends on specific project requirements, balancing factors like development speed, production performance, and system complexity.

+-----------------------------------+------------------------------------------------------+------------------------------------------------------------+
| Aspect                            | Static Graphs                                        | Dynamic Graphs                                             |
+:==================================+:=====================================================+:===========================================================+
| Memory Management                 | Precise allocation planning, optimized memory usage  | Flexible but potentially less efficient allocation         |
+-----------------------------------+------------------------------------------------------+------------------------------------------------------------+
| Optimization Potential            | Comprehensive graph-level optimizations possible     | Limited to local optimizations due to runtime construction |
+-----------------------------------+------------------------------------------------------+------------------------------------------------------------+
| Hardware Utilization              | Can generate highly optimized hardware-specific code | May sacrifice some hardware-specific optimizations         |
+-----------------------------------+------------------------------------------------------+------------------------------------------------------------+
| Development Experience            | Requires more upfront planning, harder to debug      | Better debugging, faster iteration cycles                  |
+-----------------------------------+------------------------------------------------------+------------------------------------------------------------+
| Runtime Flexibility               | Fixed computation structure                          | Can adapt to runtime conditions                            |
+-----------------------------------+------------------------------------------------------+------------------------------------------------------------+
| Production Performance            | Generally better performance at scale                | May have overhead from runtime graph construction          |
+-----------------------------------+------------------------------------------------------+------------------------------------------------------------+
| Integration with Traditional Code | More separation between definition and execution     | Natural integration with imperative code                   |
+-----------------------------------+------------------------------------------------------+------------------------------------------------------------+
| Memory Overhead                   | Lower memory overhead due to planned allocations     | Higher memory overhead due to dynamic allocations          |
+-----------------------------------+------------------------------------------------------+------------------------------------------------------------+
| Debugging Capability              | Limited to pre-execution analysis                    | Runtime inspection and modification possible               |
+-----------------------------------+------------------------------------------------------+------------------------------------------------------------+
| Deployment Complexity             | Simpler deployment due to fixed structure            | May require additional runtime support                     |
+-----------------------------------+------------------------------------------------------+------------------------------------------------------------+

: Comparsion of static and dynamic computational graphs. {#tbl-mlfm-graphs .hover .striped}
