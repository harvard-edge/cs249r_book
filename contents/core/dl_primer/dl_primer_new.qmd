---
bibliography: dl_primer.bib
---

# DL Primer NEW ðŸš€ {#sec-dl_primer}

::: {.content-visible when-format="html"}
Resources: [Slides](#sec-deep-learning-primer-resource), [Videos](#sec-deep-learning-primer-resource), [Exercises](#sec-deep-learning-primer-resource)
:::

![_DALLÂ·E 3 Prompt: Photo of a classic classroom with a large blackboard dominating one wall. Chalk drawings showcase a detailed deep neural network with several hidden layers, and each node and connection is precisely labeled with white chalk. The rustic wooden floor and brick walls provide a contrast to the modern concepts. Surrounding the room, posters mounted on frames emphasize deep learning themes: convolutional networks, transformers, neurons, activation functions, and more._](images/png/cover_dl_primer.png)

This chapter is a primer on deep learning from a systems perspective, providing us with essential context and the foundational knowledge that is needed to implement and optimize deep learning solutions effectively. ML systems represents the bridge between theoretical machine learning concepts and their practical implementation in real-world computing systems. Our goal is to help readers understand how theoretical constructs translate into computational requirements, resource constraints, and system design decisions.

We begin with an overview of deep learning's evolution and its significance in modern computing systems, from edge devices to data centers. We introduce the core concepts like neural networks with a dual focus: first understanding their theoretical foundations, then examining their practical implications for system implementation. The primer explores major deep learning architectures through this systems lens, examining how architectural choices impact compute, memory, and communication requirements.

We then analyze common computational patterns in deep learning and their implications for system design. We examine how different architectures translate to specific hardware demands, software stack requirements, and deployment considerations. Through practical case studies, we demonstrate how these concepts apply to real-world scenarios, from scaling large language models to optimizing models for edge devices. We also compare deep learning to traditional machine learning approaches, helping readers make informed architectural choices based on system constraints and requirements. This comprehensive overview sets the context for the more detailed techniques and optimizations covered in subsequent chapters.

::: {.callout-tip}

## Learning Objectives

* Bridge theoretical deep learning concepts with their practical system implementations.

* Understand how different deep learning architectures impact system requirements.

* Compare traditional ML and deep learning approaches from a systems perspective.

* Identify core computational patterns in deep learning and their deployment implications.

* Apply systems thinking to deep learning model development and deployment.
  
:::

## Overview

Deep learning, a specialized area within machine learning and artificial intelligence (AI), utilizes algorithms modeled after the structure and function of neural networks to process and learn from large amounts of data. From a systems perspective, deep learning represents a unique intersection of algorithms, hardware, and software infrastructure working together to solve complex computational problems.

When implementing deep learning in real-world systems, we need to consider it as part of a broader computing stack. @fig-ai-ml-dl provides a visual representation of how deep learning fits within the broader context of AI and machine learning. As shown in the figure, AI represents the overarching field, encompassing all computational methods that mimic human cognitive functions. Machine learning, shown as a subset of AI, includes algorithms capable of learning from data. Deep learning, the smallest subset in the diagram, specifically involves neural networks that are able to learn more complex patterns from large volumes of data.

![The diagram illustrates artificial intelligence as the overarching field encompassing all computational methods that mimic human cognitive functions. Machine learning is a subset of AI that includes algorithms capable of learning from data. Deep learning, a further subset of ML, specifically involves neural networks that are able to learn more complex patterns in large volumes of data. Source: NVIDIA.](images/png/ai_dl_progress_nvidia.png){#fig-ai-ml-dl}

This progression from AI to deep learning represents key shifts across three fundamental dimensions:

1. **Data**: From structured, rule-based knowledge to massive datasets of raw, unstructured information. Deep learning's ability to learn from raw data eliminates the need for manual feature engineering but demands substantially larger datasets.

2. **Algorithms**: From explicit programming to learned patterns. While traditional AI relies on handcrafted rules and machine learning uses statistical methods, deep learning algorithms automatically discover hierarchical representations in data through multiple layers of abstraction.

3. **Computation**: From basic arithmetic operations to massive parallel processing. The computational demands grow significantly as we move from simple AI algorithms to complex deep neural networks, driving innovations in specialized hardware and distributed computing.

This evolution has profound implications for how we build and deploy AI systems. Deep learning's appetite for data and computation has spurred developments in specialized hardware like GPUs and TPUs, scalable software frameworks, and efficient data pipelines. Understanding these relationships is important for effectively implementing deep learning solutions across different computing environments, from powerful data centers to resource-constrained edge devices. To build this understanding, we must start with the fundamentals. In the following sections, we first examine the historical development and computational growth of deep learning systems. We then explore core neural network concepts, focusing on how theoretical principles translate into practical implementations. This foundation will enable us to better understand modern architectures, their computational patterns, and ultimately, how to build ML systems.

## Understanding Deep Learning

### What Makes Deep Learning Different

Deep learning represents a fundamental shift in how we approach problem solving with computers. To understand this shift, let's consider the classic example of computer vision---specifically, the task of identifying objects in images. 

#### Traditional Programming: The Era of Explicit Rules

Traditional programming requires developers to explicitly define rules that tell computers how to process inputs and produce outputs. Consider a simple game like Breakout, shown in @fig-breakout. The program needs explicit rules for every interaction: when the ball hits a brick, the code must specify that the brick should be removed and the ball's direction should be reversed. While this approach works well for games with clear physics and limited states, it demonstrates an inherent limitation of rule-based systems.

![Rule-based programming.](images/png/breakout.png){#fig-breakout}

This rules-based paradigm extends to all traditional programming, as illustrated in @fig-traditional. The program takes both rules for processing and input data to produce outputs. Early artificial intelligence research explored whether this approach could scale to solve complex problems by encoding sufficient rules to capture intelligent behavior.

![Traditional programming.](images/png/traditional.png){#fig-traditional}

However, the limitations of rule-based approaches become evident when addressing complex real-world tasks. Consider the problem of recognizing human activities, shown in @fig-activity-rules. Initial rules might appear straightforward: classify movement below 4 mph as walking and faster movement as running. Yet real-world complexity quickly emerges. The classification must account for variations in speed, transitions between activities, and numerous edge cases. Each new consideration requires additional rules, leading to increasingly complex decision trees.

![Activity rules.](images/png/activities.png){#fig-activity-rules}

This challenge extends to computer vision tasks. Detecting objects like cats in images would require rules about characteristic features: pointed ears, whiskers, typical body shapes. Such rules would need to account for variations in viewing angle, lighting conditions, partial occlusions, and natural variations among instances. Early computer vision systems attempted this approach through geometric rules but achieved success only in controlled environments with well-defined objects.

This knowledge engineering approach characterized artificial intelligence research in the 1970s and 1980s. Expert systems encoded domain knowledge as explicit rules, showing promise in specific domains with well-defined parameters but struggling with tasks humans perform naturally---such as object recognition, speech understanding, or natural language interpretation. These limitations highlighted a fundamental challenge: many aspects of intelligent behavior rely on implicit knowledge that resists explicit rule-based representation.

#### Machine Learning: Learning from Engineered Patterns

The limitations of pure rule-based systems led researchers to explore approaches that could learn from data. Machine learning offered a promising direction: instead of writing rules for every situation, we could write programs that found patterns in examples. However, the success of these methods still depended heavily on human insight to define what patterns might be important---a process known as feature engineering.

Feature engineering involves transforming raw data into representations that make patterns more apparent to learning algorithms. In computer vision, researchers developed sophisticated methods to extract meaningful patterns from images. The Histogram of Oriented Gradients (HOG) method, shown in @fig-hog, exemplifies this approach. HOG works by first identifying edges in an image---places where brightness changes sharply, often indicating object boundaries. It then divides the image into small cells and measures how edges are oriented within each cell, summarizing these orientations in a histogram. This transformation converts raw pixel values into a representation that captures important shape information while being robust to variations in lighting and small changes in position.

![Histogram of Oriented Gradients (HOG) requires explicit feature engineering.](images/png/hog.png){#fig-hog}

Other feature extraction methods like SIFT (Scale-Invariant Feature Transform) and Gabor filters provided different ways to capture patterns in images. SIFT found distinctive points that could be recognized even when an object's size or orientation changed. Gabor filters helped identify textures and repeated patterns. Each method encoded different types of human insight about what makes visual patterns recognizable.

These engineered features enabled significant advances in computer vision during the 2000s. Systems could now recognize objects with some robustness to real-world variations, leading to applications in face detection, pedestrian detection, and object recognition. However, the approach had fundamental limitations. Experts needed to carefully design feature extractors for each new problem, and the resulting features might miss important patterns that weren't anticipated in their design.

#### Deep Learning

Deep learning fundamentally differs by learning directly from raw data. Traditional programming, as we saw earlier in @fig-traditional, required both rules and data as inputs to produce answers. Machine learning inverts this relationship, as shown in @fig-deeplearning. Instead of writing rules, we provide examples (data) and their correct answers to discover the underlying rules automatically. This shift eliminates the need for humans to specify what patterns are important.

![Deep learning.](images/png/ml_rules.png){#fig-deeplearning}

The system discovers these patterns automatically from examples. When shown millions of images of cats, the system learns to identify increasingly complex visual patterns---from simple edges to more sophisticated combinations that make up cat-like features. This mirrors how our own visual system works, building up understanding from basic visual elements to complex objects.

Unlike traditional approaches where performance often plateaus with more data and computation, deep learning systems continue to improve as we provide more resources. More training examples help the system recognize more variations and nuances. More computational power enables the system to discover more subtle patterns. This scalability has led to dramatic improvements in performance---for example, the accuracy of image recognition systems has improved from 74% in 2012 to over 95% today.

This different approach has profound implications for how we build AI systems. Deep learning's ability to learn directly from raw data eliminates the need for manual feature engineering, but it comes with new demands. We need sophisticated infrastructure to handle massive datasets, powerful computers to process this data, and specialized hardware to perform the complex mathematical calculations efficiently. The computational requirements of deep learning have even driven the development of new types of computer chips optimized for these calculations.

The success of deep learning in computer vision exemplifies how this approach, when given sufficient data and computation, can surpass traditional methods. This pattern has repeated across many domains, from speech recognition to game playing, establishing deep learning as a transformative approach to artificial intelligence.

### From Brain to Artificial Neurons

The quest to create artificial intelligence has been profoundly influenced by our understanding of biological intelligence, particularly the human brain. This isn't surprising---the brain represents the most sophisticated information processing system we know of, capable of learning, adapting, and solving complex problems while maintaining remarkable energy efficiency. The way our brains function has provided fundamental insights that continue to shape how we approach artificial intelligence.

#### Bilogoical Intelligence

When we observe biological intelligence, several key principles emerge. The brain demonstrates an extraordinary ability to learn from experience, constantly modifying its neural connections based on new information and interactions with the environment. This adaptability is fundamental---every experience potentially alters the brain's structure, refining its responses for future situations. This biological capability directly inspired one of the core principles of machine learning: the ability to learn and improve from data rather than following fixed, pre-programmed rules.

Another striking feature of biological intelligence is its parallel processing capability. The brain processes vast amounts of information simultaneously, with different regions specializing in specific functions while working in concert. This distributed, parallel architecture stands in stark contrast to traditional sequential computing and has significantly influenced modern AI system design. The brain's ability to efficiently coordinate these parallel processes while maintaining coherent function represents a level of sophistication we're still working to fully understand and replicate.

The brain's pattern recognition capabilities are particularly noteworthy. Biological systems excel at identifying patterns in complex, noisy data---whether recognizing faces in a crowd, understanding speech in a noisy environment, or identifying objects from partial information. This remarkable ability has inspired numerous AI applications, particularly in computer vision and speech recognition systems. The brain accomplishes these tasks with an efficiency that artificial systems are still striving to match.

Perhaps most remarkably, biological systems achieve all this with incredible energy efficiency. The human brain operates on approximately 20 watts of power---about the same as a low-power light bulb---while performing complex cognitive tasks that would require orders of magnitude more power in current artificial systems. This efficiency hasn't just impressed researchers; it has become a crucial goal in the development of AI hardware and algorithms.

These biological principles have led to two distinct but complementary approaches in artificial intelligence. The first attempts to directly mimic neural structure and function, leading to artificial neural networks and deep learning architectures that structurally resemble biological neural networks. The second takes a more abstract approach, adapting biological principles to work efficiently within the constraints of computer hardware without necessarily copying biological structures exactly.

#### Aritificial Intelligence

The translation from biological principles to artificial computation requires a systematic understanding of what makes biological neural networks effective. The brain's computational architecture offers several fundamental insights that inform the design of artificial neural systems.

The brain processes information through distributed computation across billions of neurons, each operating relatively slowly compared to silicon transistors. A biological neuron fires at approximately 200Hz, while modern processors operate at gigahertz frequencies. Despite this speed limitation, the brain's parallel architecture enables sophisticated real-time processing of complex sensory input, decision making, and control of behavior.

This computational efficiency emerges from the brain's basic organizational principles. Each neuron acts as a simple processing unit, integrating inputs from thousands of other neurons and producing a binary output signal based on whether this integrated input exceeds a threshold. The connection strengths between neurons, mediated by synapses, are continuously modified through experience. This synaptic plasticity forms the basis for learning and adaptation in biological neural networks.

These biological principles suggest key computational elements needed in artificial neural systems:

* Simple processing units that integrate multiple inputs
* Adjustable connection strengths between units
* Nonlinear activation based on input thresholds
* Parallel processing architecture
* Learning through modification of connection strengths

These fundamental elements provide the blueprint for artificial neural networks. However, translating these biological principles into practical computational systems requires careful consideration of how to implement each element within the constraints and capabilities of digital hardware.

#### Computational Translation

The challenge in artificial neural networks becomes implementing these principles within the constraints of digital computing systems. This translation requires careful consideration of how to represent neural activity, connection strengths, and learning mechanisms in ways that can be efficiently computed while preserving the essential computational properties that make biological neural networks effective.

@tbl-bio2comp provides a systematic view of how key biological features map to their computational counterparts. As we can see from the table, each biological feature has an analog in computational systems, which we will discuss next, although often in a simplified or abstracted form. These translations, while preserving essential computational properties, impose specific demands on the computing systems that must implement them.

+---------------------+---------------------------+
| Biological Feature  | Computational Translation |
+:====================+:==========================+
| Neuron firing       | Activation function       |
+---------------------+---------------------------+
| Synaptic strength   | Weighted connections      |
+---------------------+---------------------------+
| Signal integration  | Summation operation       |
+---------------------+---------------------------+
| Distributed memory  | Weight matrices           |
+---------------------+---------------------------+
| Parallel processing | Concurrent computation    |
+---------------------+---------------------------+

: Translating biological features to the computing domain. {#tbl-bio2comp .striped .hover}

The implementation of biological principles in artificial neural systems represents a careful balance between biological fidelity and computational efficiency. At its core, an artificial neuron captures the essential computational properties of its biological counterpart through mathematical operations that can be efficiently executed on digital hardware.

The basic computational unit in artificial neural networks, the artificial neuron, simplifies the complex electrochemical processes of biological neurons into three fundamental operations. First, input signals are weighted, mimicking how biological synapses modulate incoming signals with different strengths. Second, these weighted inputs are summed together, analogous to how a biological neuron integrates incoming signals in its cell body. Finally, the summed input passes through an activation function that determines the neuron's output, similar to how a biological neuron fires based on whether its membrane potential exceeds a threshold.

This mathematical abstraction preserves key computational principles while enabling efficient digital implementation. The weighting of inputs allows the network to learn which connections are important, just as biological neural networks strengthen or weaken synaptic connections through experience. The summation operation captures how biological neurons integrate multiple inputs into a single decision. The activation function introduces nonlinearity essential for learning complex patterns, much like the threshold-based firing of biological neurons.

Memory in artificial neural networks takes a markedly different form from biological systems. While biological memories are distributed across synaptic connections and neural patterns, artificial networks store information in discrete weights and parameters. This architectural difference reflects the constraints of current computing hardware, where memory and processing are physically separated rather than integrated as in biological systems. Despite these implementation differences, artificial neural networks achieve similar functional capabilities in pattern recognition and learning.

The brain's massive parallelism finds a limited analog in modern AI hardware. While biological neural networks process information through billions of neurons operating simultaneously, artificial systems approximate this parallelism through specialized hardware like GPUs and tensor processing units. These devices efficiently compute the matrix operations that form the mathematical foundation of artificial neural networks, achieving parallel processing at a different scale and granularity than biological systems.

#### System Requirements

The translation of biological principles into artificial neural systems creates specific demands on computing infrastructure. These requirements emerge directly from the fundamental differences between biological and artificial implementations of neural processing.

The computational elements we identified in our biological-to-computational translation each create specific demands on the computing infrastructure. @tbl-comp2sys shows how each computational element drives particular system requirements. From this mapping, we can see how the choices made in computational translation directly influence the hardware and system architecture needed for implementation.

+-----------------------+---------------------------------+
| Computational Element | System Requirements             |
+:======================+:================================+
| Activation functions  | Fast nonlinear operation units  |
+-----------------------+---------------------------------+
| Weight operations     | High-bandwidth memory access    |
+-----------------------+---------------------------------+
| Parallel computation  | Specialized parallel processors |
+-----------------------+---------------------------------+
| Weight storage        | Large-scale memory systems      |
+-----------------------+---------------------------------+
| Learning algorithms   | Gradient computation hardware   |
+-----------------------+---------------------------------+

: From computation to system requirements. {#tbl-comp2sys .striped .hover}

The first major requirement stems from the challenge of replicating the brain's parallel processing capabilities. While biological neurons operate naturally in parallel across billions of units, artificial systems must explicitly architect for parallelism. This necessitates specialized processors capable of handling many simultaneous calculations, fundamentally different from traditional sequential computing architectures. Unlike the brain's distributed processing, our artificial systems must coordinate these parallel operations through carefully designed hardware and software structures.

Storage architecture represents another crucial requirement, driven by the fundamental difference in how biological and artificial systems handle memory. In biological systems, memory and processing are intrinsically integratedâ€”synapses both store connection strengths and process signals. Artificial systems, however, must maintain a clear separation between processing units and memory. This creates a need for both high-capacity storage to hold millions or billions of connection weights and high-bandwidth pathways to move this data quickly between storage and processing units. The efficiency of this data movement often becomes a critical bottleneck that biological systems do not face.

The learning process itself imposes distinct requirements on artificial systems. While biological networks modify synaptic strengths through local chemical processes, artificial networks must coordinate weight updates across the entire network. This creates substantial computational and memory demands during trainingâ€”systems must not only store current weights but also maintain space for gradients and intermediate calculations. The requirement to backpropagate error signals, with no real biological analog, further complicates the system architecture.

Energy efficiency emerges as a final critical requirement, highlighting perhaps the starkest contrast between biological and artificial implementations. The human brain's remarkable energy efficiencyâ€”operating on roughly 20 wattsâ€”stands in sharp contrast to the substantial power demands of artificial neural networks. Current systems often require orders of magnitude more energy to implement similar capabilities. This gap drives ongoing research in more efficient hardware architectures and has profound implications for the practical deployment of neural networks, particularly in resource-constrained environments like mobile devices or edge computing systems.

#### Evolution and Impact

The evolution of deep learning systems reflects a complex interplay between algorithmic advances, hardware capabilities, and growing computational demands. This journey began with early artificial neural networks in the 1950s, marked by the introduction of the Perceptron [@rosenblatt1957perceptron]. While groundbreaking in concept, these early systems were severely limited by the computational capabilities of their eraâ€”primarily mainframe computers that lacked both the processing power and memory capacity needed for complex networks.

The development of backpropagation algorithms in the 1980s [@rumelhart1986learning], which we will learn about later, represented a  theoretical breakthrough and povided a systematic way to train multi-layer networks. However, the computational demands of this algorithm far exceeded available hardware capabilities. Training even modest networks could take weeks, making experimentation and practical applications challenging. This mismatch between algorithmic requirements and hardware capabilities contributed to a period of reduced interest in neural networks.

The term "deep learning" gained prominence in the 2000s, coinciding with significant advances in computational power and data accessibility. The field has since experienced exponential growth, as illustrated in @fig-trends. The graph reveals two remarkable trends: computational capabilities measured in the number of Floating Point Operations per Second (FLOPS) initially followed a 1.4x improvement pattern from 1952 to 2010, then accelerated to a 3.4-month doubling cycle from 2012 to 2022. Perhaps more striking is the emergence of large-scale models between 2015 and 2022 (not explicitly shown or easily seen in the figure), which scaled 2 to 3 orders of magnitude faster than the general trend, following an aggressive 10-month doubling cycle.

![Growth of deep learning models. Source: EOOCHS AI](https://epochai.org/assets/images/posts/2022/compute-trends.png){#fig-trends}

#### Key Breakthroughs

The success of deep learning has been driven by parallel advances across three fundamental dimensions: data availability, algorithmic innovations, and computing infrastructure.

These three factorsâ€”data, algorithms, and infrastructureâ€”reinforced each other. As @fig-virtuous-cycle shows, more powerful computing infrastructure enabled processing larger datasets. Larger datasets drove algorithmic innovations. Better algorithms demanded more sophisticated computing systems. This virtuous cycle continues to drive progress in the field today.

![The virtuous cycle enabled by key breakthroughs in each layer.](images/png/virtuous-cycle.png){#fig-virtuous-cycle width=40%}

The data revolution transformed what was possible with neural networks. The rise of the internet and digital devices created unprecedented access to training data. Image sharing platforms provided millions of labeled images. Digital text collections enabled language processing at scale. Sensor networks and IoT devices generated continuous streams of real-world data. This abundance of data provided the raw material needed for neural networks to learn complex patterns effectively.

Algorithmic innovations made it possible to harness this data effectively. New methods for initializing networks and controlling learning rates made training more stable. Techniques for preventing overfitting allowed models to generalize better to new data. Most importantly, researchers discovered that neural network performance scaled predictably with model size, computation, and data quantity, leading to increasingly ambitious architectures.

Computing infrastructure evolved to meet these growing demands. On the hardware side, graphics processing units (GPUs) provided the parallel processing capabilities needed for efficient neural network computation. Specialized AI accelerators like TPUs [@jouppi2017datacenter] pushed performance further. High-bandwidth memory systems and fast interconnects addressed data movement challenges. Equally important were software advancesâ€”frameworks and libraries that made it easier to build and train networks, distributed computing systems that enabled training at scale, and tools for optimizing model deployment.

## Neural Network Foundations

### Basic Architecture

#### Neurons

The Perceptron is the basic unit or node that forms the foundation for more complex structures. It functions by taking multiple inputs, each representing a feature of the object under analysis, such as the characteristics of a home for predicting its price or the attributes of a song to forecast its popularity in music streaming services. These inputs are denoted as $x_1, x_2, ..., x_n$. A perceptron can be configured to perform either regression or classification tasks. For regression, the actual numerical output $\hat{y}$ is used. For classification, the output depends on whether $\hat{y}$ crosses a certain threshold. If $\hat{y}$ exceeds this threshold, the perceptron might output one class (e.g., 'yes'), and if it does not, another class (e.g., 'no').

@fig-perceptron illustrates the fundamental building blocks of a perceptron, which serves as the foundation for more complex neural networks. A perceptron can be thought of as a miniature decision-maker, utilizing its weights, bias, and activation function to process inputs and generate outputs based on learned parameters. This concept forms the basis for understanding more intricate neural network architectures, such as multilayer perceptrons. In these advanced structures, layers of perceptrons work in concert, with each layer's output serving as the input for the subsequent layer. This hierarchical arrangement creates a deep learning model capable of comprehending and modeling complex, abstract patterns within data. By stacking these simple units, neural networks gain the ability to tackle increasingly sophisticated tasks, from image recognition to natural language processing.

![Perceptron. Conceived in the 1950s, perceptrons paved the way for developing more intricate neural networks and have been a fundamental building block in deep learning. Source: Wikimedia - Chrislb.](images/png/Rosenblattperceptron.png){#fig-perceptron}

Each input $x_i$ has a corresponding weight $w_{ij}$, and the perceptron simply multiplies each input by its matching weight. This operation is similar to linear regression, where the intermediate output, $z$, is computed as the sum of the products of inputs and their weights:

$$
z = \sum (x_i \cdot w_{ij})
$$

To this intermediate calculation, a bias term $b$ is added, allowing the model to better fit the data by shifting the linear output function up or down. Thus, the intermediate linear combination computed by the perceptron including the bias becomes:

$$
z = \sum (x_i \cdot w_{ij}) + b
$$

This basic form of a perceptron can only model linear relationships between the input and output. Patterns found in nature are often complex and extend beyond linear relationships. To enable the perceptron to handle non-linear relationships, an activation function is applied to the linear output $z$. 

$$
\hat{y} = \sigma(z)
$$

@fig-nonlinear illustrates an example where data exhibit a nonlinear pattern that could not be adequately modeled with a linear approach. The activation function, such as sigmoid, tanh, or ReLU, transforms the linear input sum into a non-linear output. The primary objective of this function is to introduce non-linearity into the model, enabling it to learn and perform more sophisticated tasks. Thus, the final output of the perceptron, including the activation function, can be expressed as:

![Activation functions enable the modeling of complex non-linear relationships. Source: Medium - Sachin Kaushik.](images/png/nonlinear_patterns.png){#fig-nonlinear}

#### Layers

While a single perceptron can model simple decisions, the power of neural networks comes from combining multiple neurons into layers. A layer is a collection of neurons that process information in parallel. Each neuron in a layer operates independently on the same input but with its own set of weights and bias, allowing the layer to learn different features or patterns from the same input data.

In a typical neural network, we organize these layers hierarchically:

1. **Input Layer**: Receives the raw data features
2. **Hidden Layers**: Process and transform the data through multiple stages
3. **Output Layer**: Produces the final prediction or decision

@fig-layers illustrates this layered architecture. When data flows through these layers, each successive layer transforms the representation of the data, gradually building more complex and abstract features. This hierarchical processing is what gives deep neural networks their remarkable ability to learn complex patterns.

[Need diagram showing layer architecture]

#### Layer Transformations

When data moves from one layer to the next, it undergoes a series of transformations. For a layer with $m$ neurons receiving input from a previous layer with $n$ features, we can express this transformation mathematically as:

$$
\mathbf{z}^{(l)} = \mathbf{W}^{(l)}\mathbf{x}^{(l-1)} + \mathbf{b}^{(l)}
$$

Where:

* $\mathbf{x}^{(l-1)}$ is the input vector from the previous layer

* $\mathbf{W}^{(l)}$ is the weight matrix for the current layer

* $\mathbf{b}^{(l)}$ is the bias vector

* $\mathbf{z}^{(l)}$ is the pre-activation output

I'll draft the Weights and Connections section, building naturally from our previous discussion of neurons and layers:

### Weights and Connections

#### Weight Matrices

While we introduced weights in the context of a single perceptron, in practice neural networks organize weights into matrices to enable efficient computation across entire layers. For a layer with $n$ input features and $m$ neurons, the weights form a matrix $\mathbf{W} \in \mathbb{R}^{n \times m}$. Each column in this matrix represents the weights for a single neuron in the layer.

Let's consider how this extends our previous perceptron equations to handle multiple neurons simultaneously. For a layer of $m$ neurons, instead of computing each neuron's output separately:

$$
z_j = \sum_{i=1}^n (x_i \cdot w_{ij}) + b_j
$$

We can compute all outputs at once using matrix multiplication:

$$
\mathbf{z} = \mathbf{x}^T\mathbf{W} + \mathbf{b}
$$

This matrix organization isn't just mathematical convenienceâ€”it reflects how modern neural networks are implemented for efficiency. Each weight $w_{ij}$ represents the strength of the connection between input feature $i$ and neuron $j$ in the layer.

#### Connection Patterns

In the simplest and most common case, each neuron in a layer is connected to every neuron in the previous layer, forming what we call a "dense" or "fully-connected" layer. This pattern means that each neuron has the opportunity to learn from all available features from the previous layer.

@fig-connections [need to create] illustrates these dense connections between layers. For a network with layers of sizes $(n_1, n_2, n_3)$, the weight matrices would have dimensions:

* Between first and second layer: $\mathbf{W}^{(1)} \in \mathbb{R}^{n_1 \times n_2}$
* Between second and third layer: $\mathbf{W}^{(2)} \in \mathbb{R}^{n_2 \times n_3}$

#### Bias Terms

Each neuron in a layer also has an associated bias term. While weights determine the relative importance of inputs, biases allow neurons to shift their activation functions. This shifting is crucial for learning, as it gives the network flexibility to fit more complex patterns.

For a layer with $m$ neurons, the bias terms form a vector $\mathbf{b} \in \mathbb{R}^m$. When we compute the layer's output, this bias vector is added to the weighted sum of inputs:

$$
\mathbf{z} = \mathbf{x}^T\mathbf{W} + \mathbf{b}
$$

The bias terms effectively allow each neuron to have a different "threshold" for activation, making the network more expressive.

#### Parameter Organization

The organization of weights and biases across a neural network follows a systematic pattern. For a network with $L$ layers, we maintain:

* A weight matrix $\mathbf{W}^{(l)}$ for each layer $l$

* A bias vector $\mathbf{b}^{(l)}$ for each layer $l$f

* Activation functions $f^{(l)}$ for each layer $l$

This gives us the complete layer computation:

$$
\mathbf{h}^{(l)} = f^{(l)}(\mathbf{z}^{(l)}) = f^{(l)}(\mathbf{h}^{(l-1)T}\mathbf{W}^{(l)} + \mathbf{b}^{(l)})
$$

Where $\mathbf{h}^{(l)}$ represents the layer's output after applying the activation function.

### Network Topology

Network topology describes how the basic building blocks we've discussedâ€”neurons, layers, and connectionsâ€”come together to form a complete neural network. We can best understand network topology through a concrete example. Consider the task of recognizing handwritten digits, a classic problem in deep learning using the MNIST[^defn-MNIST] dataset.

[^defn-MNIST]: MNIST (Modified National Institute of Standards and Technology) is a large database of handwritten digits that has been widely used to train and test machine learning systems since its creation in 1998. The dataset consists of 60,000 training images and 10,000 testing images, each being a 28Ã—28 pixel grayscale image of a single handwritten digit from 0 to 9.

#### Basic Structure

The fundamental structure of a neural network consists of three main components: input layer, hidden layers, and output layer. As shown in @fig-mnist-topology-1, a 28Ã—28 pixel grayscale image of a handwritten digit must be processed through these layers to produce a classification output.

::: {layout-nrow=1}

![A neural network topology for classifying MNIST digits, showing how a 28x28 pixel image is processed. The image on the left shows the original digit, with dimensions labeled. The network on the right shows how each pixel connects to the hidden layers, ultimately producing 10 outputs for digit classification.](images/png/topology_28x28.png){#fig-mnist-topology-1}

![Alternative visualization of the MNIST network topology, showing how the 2D image is flattened into a 784-dimensional vector before being processed by the network. This representation emphasizes how spatial data is transformed into a format suitable for neural network processing.](images/png/topology_flatten.png){#fig-mnist-topology-2}

:::

The input layer's width is directly determined by our data format. As shown in @fig-mnist-topology-2, for a 28Ã—28 pixel image, each pixel becomes an input feature, requiring 784 input neurons (28 Ã— 28 = 784). We can think of this either as a 2D grid of pixels or as a flattened vector of 784 values, where each value represents the intensity of one pixel.

The output layer's structure is determined by our task requirements. For digit classification, we use 10 output neurons, one for each possible digit (0-9). When presented with an image, the network produces a value for each output neuron, where higher values indicate greater confidence that the image represents that particular digit.

Between these fixed input and output layers, we have flexibility in designing the hidden layer topology. The choice of hidden layer structureâ€”how many layers to use and how wide to make themâ€”represents one of the fundamental design decisions in neural networks. Additional layers increase the network's depth, allowing it to learn more abstract features through successive transformations. The width of each layer provides capacity for learning different features at each level of abstraction.

These basic topological choices have significant implications for both the network's capabilities and its computational requirements. Each additional layer or neuron increases the number of parameters that must be stored and computed during both training and inference. However, without sufficient depth or width, the network may lack the capacity to learn complex patterns in the data.

#### Design Considerations

The design of neural network topology centers on three fundamental decisions: the number of layers (depth), the size of each layer (width), and how these layers connect. Each choice affects both the network's learning capability and its computational requirements.

Network depth determines the level of abstraction the network can achieve. Each layer transforms its input into a new representation, and stacking multiple layers allows the network to build increasingly complex features. In our MNIST example, a deeper network might first learn to detect edges, then combine these edges into strokes, and finally assemble strokes into complete digit patterns. However, adding layers isn't always beneficialâ€”each additional layer increases computational cost and can make the network harder to train.

The width of each layerâ€”the number of neurons it containsâ€”controls how much information the network can process in parallel at each stage. Wider layers can learn more features simultaneously but require proportionally more parameters and computation. For instance, if a hidden layer is processing edge features in our digit recognition task, its width determines how many different edge patterns it can detect simultaneously.

A very important consideration in topology design is the total parameter count. For a network with layers of size $(n_1, n_2, ..., n_L)$, each pair of adjacent layers $l$ and $l+1$ requires $n_l \times n_{l+1}$ weight parameters, plus $n_{l+1}$ bias parameters. These parameters must be stored in memory and updated during training, making the parameter count a key constraint in practical applications.

When designing networks, we need to balance learning capacity, computational efficiency, and ease of training. While the basic approach connects every neuron to every neuron in the next layer, this isn't always the most effective strategy. Sometimes, using fewer but more strategic connections can achieve better results with less computation. Consider our MNIST example---when humans recognize digits, we don't analyze every pixel independently but look for meaningful patterns like lines and curves. Similarly, we can design our network to focus on local patterns in the image rather than treating each pixel as completely independent.

Another important consideration is how information flows through the network. While the basic flow is from input to output, some network designs include additional paths for information to flow. These alternative paths can make the network easier to train and more effective at learning complex patterns. Think of these as shortcuts that help information flow more directly when needed, similar to how our brain can combine both detailed and general impressions when recognizing objects.

These design decisions have significant practical implications for:

* Memory usage for storing network parameters
* Computational costs during both training and inference
* Training behavior and convergence
* The network's ability to generalize to new examples

#### Common Patterns

Neural networks can be structured with different connection patterns between layers, each offering distinct advantages for learning and computation. Understanding these fundamental patterns provides insight into how networks process information and learn representations from data.

Dense connectivity represents the standard pattern where each neuron connects to every neuron in the subsequent layer. In our MNIST example, connecting our 784-dimensional input layer to a hidden layer of 100 neurons requires 78,400 weight parameters. This full connectivity enables the network to learn arbitrary relationships between inputs and outputs, but the number of parameters scales quadratically with layer width.

Sparse connectivity patterns introduce purposeful restrictions in how neurons connect between layers. Rather than maintaining all possible connections, neurons connect to only a subset of neurons in the adjacent layer. This approach draws inspiration from biological neural systems, where neurons typically form connections with a limited number of other neurons. In visual processing tasks like our MNIST example, neurons might connect only to inputs representing nearby pixels, reflecting the local nature of visual features.

As networks grow deeper, the path from input to output becomes longer, potentially complicating the learning process. Skip connections address this by adding direct paths between non-adjacent layers. These connections provide alternative routes for information flow, supplementing the standard layer-by-layer progression. In our digit recognition example, skip connections might allow later layers to reference both high-level patterns and the original pixel values directly.

These connection patterns have significant implications for both the theoretical capabilities and practical implementation of neural networks. Dense connections maximize learning flexibility at the cost of computational efficiency. Sparse connections can reduce computational requirements while potentially improving the network's ability to learn structured patterns. Skip connections help maintain effective information flow in deeper networks.

Let me draft the Weight Considerations section in the same textbook style:

#### Weight Considerations

The arrangement of weights in a neural network fundamentally determines both its learning capacity and computational requirements. While topology defines the network's structure, the initialization and organization of weights within this structure plays a crucial role in how the network learns and performs.

The number of weights in a network grows with both width and depth. For our MNIST example, consider a network with a 784-dimensional input layer, two hidden layers of 100 neurons each, and a 10-neuron output layer. The first layer requires 78,400 weights (784 Ã— 100), the second layer 10,000 weights (100 Ã— 100), and the output layer 1,000 weights (100 Ã— 10), totaling 89,400 weights. Each of these weights must be stored in memory and updated during learning.

Weight initialization plays a fundamental role in network behavior. When we create a new neural network, these weights must be set to initial values that enable effective learning. Setting all weights to zero would cause all neurons in a layer to behave identically, preventing the network from learning diverse features. Instead, weights are typically initialized randomly, but the scale of these random values matters significantly. Too large or too small initial weights can lead to poor learning dynamics.

The distribution of weights across the network affects how information flows through layers. Consider our digit recognition task: if weights in early layers are too small, important details from the input image might not be preserved for later layers to process. Conversely, if weights are too large, the network might amplify noise in the input, making it harder to identify relevant patterns.

Different network architectures may impose specific constraints on how weights are organized. Some architectures share weights across different parts of the network to encode specific properties, such as the ability to recognize patterns regardless of their position in an image. Other architectures might restrict certain weights to be zero, effectively implementing the sparse connectivity patterns discussed earlier.

### Learning Process

Neural networks learn to perform tasks through a process of training on examples. This process transforms the network from its initial state, where its weights are randomly initialized, to a trained state where the weights encode meaningful patterns from the training data. Understanding this learning process is fundamental to both the theoretical foundations and practical implementations of deep learning systems.

#### Training Overview

The core principle of neural network training is supervised learning from labeled examples. Consider our MNIST digit recognition task: we have a dataset of 60,000 training images, each a 28Ã—28 pixel grayscale image paired with its correct digit label. The network must learn the relationship between these images and their corresponding digits through an iterative process of prediction and weight adjustment.

Training operates as a loop, where each iteration involves processing a subset of training examples called a batch. For each batch, the network performs several key operations:

* Forward computation through the network layers to generate predictions
* Evaluation of prediction accuracy using a loss function
* Computation of weight adjustments based on prediction errors
* Update of network weights to improve future predictions

This process can be expressed mathematically. Given an input image $x$ and its true label $y$, the network computes its prediction:

$$
\hat{y} = f(x; \theta)
$$

where $f$ represents the neural network function and $\theta$ represents all trainable parameters (weights and biases, which we discussed earlier). The network's error is measured by a loss function $L$:

$$
\text{loss} = L(\hat{y}, y)
$$

This error measurement drives the adjustment of network parameters through a process called "backpropagation," which we will examine in detail later.

In practice, training operates on batches of examples rather than individual inputs. For the MNIST dataset, each training iteration might process 32, 64, or 128 images simultaneously. This batch processing serves two purposes: it enables efficient use of modern computing hardware through parallel processing, and it provides more stable parameter updates by averaging errors across multiple examples.

The training cycle continues until the network achieves sufficient accuracy or reaches a predetermined number of iterations. Throughout this process, the loss function serves as a guide, with its minimization indicating improved network performance.

#### Forward Propagation

- How data flows through network layers
- Layer-by-layer computation with MNIST
- Matrix operations and transformations
- Output generation process
- Mathematical representation that will matter for systems
- Concrete example of digit prediction

#### Loss Functions

- Purpose of loss functions
- Common loss functions with equations
- MNIST case: classification loss
- How loss measures network performance
- Mathematical formulation
- Connection to optimization

#### Backward Propagation

- Concept of gradients and error signals
- How errors propagate backwards
- Chain rule intuition (saving full derivation for later)
- Weight update process
- MNIST example: correcting digit predictions
- System implications of gradient flow

#### Optimization Process

- Gradient descent mechanics
- Learning rate importance
- Batch processing fundamentals
- Convergence intuition
- Training loop in practice
- MNIST: putting it all together

### System Implications

- what are the system implications
- compute, memory, etc. 
## Modern Deep Learning Architectures
### MLPs and Practical Architectural Trade-offs
* Simple but Powerful  
* Core Matrix Operations  
* Comparing Architectures for Different Tasks  

### CNNs: Spatial Processing
* How Convolutions Work  
* Breaking Down Convolutions  
* System and Hardware Implications  

### Sequence Models: Processing Time
* Sequential Design Patterns  
* Core Operations  
* Hardware Requirements  

### RNNs: Managing State
* Recurrent Architecture and Feedback Loops  
* Balancing Short-Term and Long-Term Memory  
* Computational and System Challenges  

### Attention Mechanisms: Focusing on the Key Message
* Prioritizing Important Features  
* Reducing Sequential Dependencies  
* Enabling Parallel Processing  

### Modern Language Models
* From Simple to Large-Scale Architectures  
* Scaling Trends and Implications  
* Core Computations and System Requirements  

### Specialized Architectures for Edge and Mobile
* MobileNet and EfficientNet for Constrained Devices  
* Optimizing for Efficiency and Deployment  

## System Demands of Modern Architectures
### Computation Patterns
* Dense vs Sparse Operations  
* Sequential vs Parallel Processing  
* Memory Access Requirements  
* Scaling Characteristics  

### Memory Requirements
* Weight Storage Needs  
* Activation Memory  
* Gradient Storage  
* Memory Hierarchy Usage  

### Training Demands
* Batch Processing  
* Gradient Computation  
* Parameter Updates  
* Stability Considerations  
  * Numerical Stability in Training (e.g., vanishing/exploding gradients)  
  * Techniques like Regularization, Initialization, and Dropout  
* Computational Efficiency  
  * Balancing Compute vs Memory Access  
  * Leveraging Sparsity and Operation Fusion  

### Inference Considerations
* Latency Requirements  
* Throughput Demands  
* Resource Usage  
* Deployment Constraints  

## Common Computational Patterns
### Matrix and Sparse Computations
* Basic Linear Algebra  
* Weight and Activation Sparsity  
* System Benefits and Challenges  

### Memory Access Patterns
* Data Layout Impact  
* Reuse Opportunities  
* Locality Considerations  

### Parallelization Patterns
* Data Parallelism  
* Model Parallelism  
* Pipeline Parallelism  

### Communication Overheads in Distributed Training
* Data Parallelism Synchronization  
* Model Parallelism Communication Costs  
* Tools like Horovod and DeepSpeed  

## System Implications
### Hardware Requirements
* Compute Resources: GPUs, TPUs, and custom accelerators  
* Memory Systems: On-chip vs. off-chip memory, bandwidth, and latency  
* Communication Infrastructure: Multi-GPU interconnects, high-speed networking  

### Software and Framework Stack
* Frameworks: TensorFlow, PyTorch, modular tools  
* Optimization and Profiling Tools: TensorRT, DeepSpeed, and debugging bottlenecks  
* Model Serving Platforms: Real-time vs. batch inference  

### Orchestration and Scalability
* Distributed Systems: Synchronization and workload management  
* Data Pipelines: Preprocessing, caching, and I/O bottlenecks  
* Containerization and Virtualization: Kubernetes, Docker, and scalability  

### Performance Considerations
* Bottleneck Analysis: Compute, memory, and communication trade-offs  
* Resource Utilization: Scheduling and operation fusion  
* Energy Efficiency: Green computing trends and sustainability  

## Case Studies
### Scaling Architectures: Transformers and Large Language Models
* Evolution from Attention Mechanisms to GPT and BERT  
* System challenges in scaling, memory, and deployment  

### Efficiency and Specialization: EfficientNet and Mobile AI
* Optimizing for constrained environments  
* Trade-offs between accuracy and efficiency  

### Distributed Systems: Training at Scale
* Challenges in multi-GPU communication and resource scaling  
* Tools and frameworks like Horovod and DeepSpeed  

## Broader Contexts for Deep Learning Systems
* Historical Perspective  
  * Evolution of hardware-algorithm co-dependence.  
  * Key turning points, like GPUs enabling AlexNet.  
* Interdisciplinary Connections  
  * Systems engineering, physics, and neuroscience insights.  
* Emerging Trends and Future Directions  
  * Neuromorphic computing, quantum AI, and societal implications.  
* The Systems Lens  
  * Viewing deep learning as a multi-layer stack requiring holistic optimization.  

## Looking Ahead
* Transition to workflows, data engineering, and frameworks:  
  * AI Workflow (Chapter 4): Breaking down the lifecycle of AI systems.  
  * Data Engineering (Chapter 5): Preparing the data pipelines that power deep learning.  
  * AI Frameworks (Chapter 6): Tools and abstractions for scalable development.  
  * AI Training (Chapter 7): Advanced techniques for training large models.  
  * Efficient AI (Chapter 8): Building models that balance performance and cost.  
* Preview of system scaling topics in later chapters:  
  * On-device learning (Chapter 12), AI acceleration (Chapter 10), and model robustness (Chapter 17).  

## Conclusion
* Recap of the chapterâ€™s foundational ideas.  
* Reinforce the importance of systems thinking for enabling scalable, efficient, and robust AI.  
