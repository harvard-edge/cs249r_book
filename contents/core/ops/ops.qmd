---
bibliography: ops.bib
---

# ML Operations

![_DALL·E 3 Prompt: Create a detailed, wide rectangular illustration of an AI workflow. The image should showcase the process across six stages, with a flow from left to right: 1. Data collection, with diverse individuals of different genders and descents using a variety of devices like laptops, smartphones, and sensors to gather data. 2. Data processing, displaying a data center with active servers and databases with glowing lights. 3. Model training, represented by a computer screen with code, neural network diagrams, and progress indicators. 4. Model evaluation, featuring people examining data analytics on large monitors. 5. Deployment, where the AI is integrated into robotics, mobile apps, and industrial equipment. 6. Monitoring, showing professionals tracking AI performance metrics on dashboards to check for accuracy and concept drift over time. Each stage should be distinctly marked and the style should be clean, sleek, and modern with a dynamic and informative color scheme._](images/png/cover_ml_ops.png)

## Purpose {.unnumbered}

_How do we operationalize machine learning principles in practice, and enable the continuous evolution of machine learning systems in production?_

Developing machine learning systems does not end with training a performant model. As models are integrated into real-world applications, new demands arise around reliability, continuity, governance, and iteration. Operationalizing machine learning requires principles that help us understand how systems behave over time, including how data shifts, models degrade, and organizational processes adapt. In this context, several foundational questions emerge: How do we manage evolving data distributions? What infrastructure enables continuous delivery and real-time monitoring? How do we coordinate efforts across technical and organizational boundaries? What processes ensure reliability, reproducibility, and compliance under real-world constraints? These concerns are not peripheral, as they are central to constructing sustainable machine learning systems. Addressing them calls for a synthesis of software engineering, systems thinking, and organizational alignment. This shift (from building isolated models to engineering adaptive systems) marks a necessary evolution in how machine learning is developed, deployed, and maintained in practice.

::: {.callout-tip title="Learning Objectives"}

* Define MLOps and explain its purpose in the machine learning lifecycle.
* Describe the key components of an MLOps pipeline.
* Discuss the significance of monitoring and observability in MLOps.
* Identify and describe the unique forms of technical debt that arise in ML systems.
* Describe the roles and responsibilities of key personnel involved in MLOps.
* Analyze the impact of operational maturity on ML system design and organizational structure.

:::

## Overview {#sec-ml-operations-overview-19a9}

Machine Learning Operations (MLOps) is a systematic discipline that integrates machine learning, data science, and software engineering practices to automate and streamline the end-to-end ML lifecycle. This lifecycle encompasses data preparation, model training, evaluation, deployment, monitoring, and ongoing maintenance. The goal of MLOps is to ensure that ML models are developed, deployed, and operated reliably, efficiently, and at scale.

To ground the discussion, consider a conventional ML application involving centralized infrastructure. A ridesharing company may aim to predict real-time rider demand using a machine learning model. The data science team might invest significant time designing and training the model. However, when it comes time to deploy it, the model often needs to be reengineered to align with the engineering team's production requirements. This disconnect can introduce weeks of delay and engineering overhead. MLOps addresses this gap.

By establishing standard protocols, tools, and workflows, MLOps enables models developed during experimentation to transition seamlessly into production. It promotes collaboration across traditionally siloed roles, including data scientists, ML engineers, and DevOps professionals, by defining interfaces and responsibilities. MLOps also supports continuous integration and delivery for ML, allowing teams to retrain, validate, and redeploy models frequently in response to new data or system conditions.

Returning to the ridesharing example, a mature MLOps practice would allow the company to continuously retrain its demand forecasting model as new ridership data becomes available. It would also make it easier to evaluate alternative model architectures, deploy experimental updates, and monitor system performance in production—all without disrupting live operations. This agility is critical for maintaining model relevance in dynamic environments.

Beyond operational efficiency, MLOps brings important benefits for governance and accountability. It standardizes the tracking of model versions, data lineage, and configuration parameters, creating a reproducible and auditable trail of ML artifacts. This is essential in highly regulated industries such as healthcare and finance, where model explainability and provenance are fundamental requirements.

Organizations across sectors are adopting MLOps to increase team productivity, reduce time-to-market, and improve the reliability of ML systems. The adoption of MLOps not only enhances model performance and robustness but also enables a sustainable approach to managing ML systems at scale.

This chapter introduces the core motivations and foundational components of MLOps, traces its historical development from DevOps, and outlines the key challenges and practices that guide its adoption in modern ML system design.

## Historical Context {#sec-ml-operations-historical-context-ad6b}

MLOps has its roots in DevOps, a set of practices that combines software development (Dev) and IT operations (Ops) to shorten the development lifecycle and enable the continuous delivery of high-quality software. Both DevOps and MLOps emphasize automation, collaboration, and iterative improvement. However, while DevOps emerged to address challenges in software deployment and operational management, MLOps evolved in response to the unique complexities of machine learning workflows—especially those involving data-driven components [@breck2020ml]. Understanding this evolution is essential for appreciating the motivations and structure of modern ML systems.

### DevOps {#sec-ml-operations-devops-d15c}

The term DevOps was coined in 2009 by [Patrick Debois](https://www.jedi.be/), a consultant and Agile practitioner who organized the first [DevOpsDays](https://www.devopsdays.org/) conference in Ghent, Belgium. DevOps extended the principles of the [Agile](https://agilemanifesto.org/) movement, that emphasized close collaboration among development teams and rapid, iterative releases, by bringing IT operations into the fold.

In traditional software pipelines, development and operations teams often worked in silos, leading to inefficiencies, delays, and misaligned priorities. DevOps emerged as a response, advocating for shared ownership, infrastructure as code, and the use of automation to streamline deployment pipelines. Tools such as [Jenkins](https://www.jenkins.io/), [Docker](https://www.docker.com/), and [Kubernetes](https://kubernetes.io/) became foundational to implementing continuous integration and continuous delivery (CI/CD)[^fn-cicd] practices.

[^fn-cicd]: **Continuous Integration/Continuous Delivery (CI/CD):** Practices that automate the software delivery process to ensure a seamless and frequent release cycle.

DevOps promotes collaboration through automation and feedback loops, aiming to reduce time-to-release and improve software reliability. It established the cultural and technical groundwork for extending similar principles to the ML domain.

### MLOps {#sec-ml-operations-mlops-3950}

MLOps builds on the DevOps foundation but adapts it to the specific demands of ML system development and deployment. While DevOps focuses on integrating and delivering deterministic software, MLOps must manage non-deterministic, data-dependent workflows. These workflows span data acquisition, preprocessing, model training, evaluation, deployment, and continuous monitoring (see @fig-mlops-diagram).

::: {.callout-note title="Definition of MLOps"}

**Machine Learning Operations (MLOps)** refers to the _engineering discipline_ that manages the _end-to-end lifecycle_ of machine learning systems, from _data and model development_ to _deployment_, _monitoring_, and _maintenance* in production. MLOps addresses _ML-specific challenges_, such as _data and model versioning_, _continuous retraining_, and _behavior under uncertainty_. It emphasizes _collaborative workflows_, _infrastructure automation_, and _governance_ to ensure that systems remain _reliable_, _scalable_, and _auditable_ throughout their operational lifespan.

:::

Several recurring challenges in operationalizing machine learning motivated the emergence of MLOps as a distinct discipline. One major concern is data drift, where shifts in input data distributions over time degrade model accuracy. This necessitates continuous monitoring and automated retraining procedures. Equally critical is reproducibility—ML workflows often lack standardized mechanisms to track code, datasets, configurations, and environments, making it difficult to reproduce past experiments [@schelter2018automating]. The lack of explainability in complex models has further driven demand for tools that increase model transparency and interpretability, particularly in regulated domains.

::: {#fig-mlops-diagram fig-env="figure" fig-pos="htb"}
```{.tikz}
\begin{tikzpicture}[line join=round,font=\usefont{T1}{phv}{m}{n},outer sep=0pt,  radius=2, start angle=-90]
\tikzset{
arr node/.style={sloped, allow upside down, single arrow,
single arrow head extend=+.12cm, thick, minimum height=+.6cm, fill=white},
arr/.style ={  edge node={node[arr node, pos={#1}]{}}},
arr'/.style={insert path={node[arr node, pos={#1}]{}}},
}
\begin{scope}[shift={(0,0)},scale=1.1, every node/.append style={transform shape}]
\draw[line width=7mm, sloped, text=white,GreenD!60]
 (0, 2) edge[preaction={line cap=butt, line width=10mm, draw=white, overlay},
              out=0, in=180, arr=.1, arr=.8] (5, -2)
(5,-2)to[out=0, in=180, arr=.2, arr=.9](10,2)
arc[start angle=90, delta angle=-180][arr'=.5]
(10,-2)edge[preaction={line cap=butt, line width=10mm, draw=white, overlay},out=180, in=0, arr=.1, arr=.8](5,2)
(5,2)to[out=180, in=0, arr=.2, arr=.9](0,-2)
arc[start angle=-90, delta angle=-180][arr'=.5] ;
\end{scope}
\node[align=center,blue!50!black]at(0,0){DESIGN};
\node[align=center,BrownLine!50!black]at(5.5,0){MODEL\\ DEVELOPMENT};
\node[align=center,red]at(11,0){OPERATIONS};
%
\node[align=left,anchor=north,blue!50!black]at(0,-3){$\bullet$ Requirements Engineering\\
$\bullet$ ML Use-Cases Prioritization\\
$\bullet$ Data Availability Check};
\node[align=left,anchor=north,BrownLine!50!black]at(5.75,-3){$\bullet$ Data Engineering\\
$\bullet$ ML Model Engineering\\
$\bullet$ Model Testing \& Validation};
\node[align=left,anchor=north,red]at(11.25,-3){$\bullet$ ML Model Deployment\\
$\bullet$ CI/CD Pipeline\\
$\bullet$ Monitoring \& Triggering};
\end{tikzpicture}
```
How MLOps fits in the over all model design and development life cycle.
:::

Post-deployment, many organizations struggle with monitoring model performance in production, especially in detecting silent failures or changes in user behavior. Additionally, the manual overhead involved in retraining and redeploying models creates friction in experimentation and iteration. Finally, configuring and maintaining ML infrastructure is complex and error-prone, highlighting the need for platforms that offer optimized, modular, and reusable infrastructure. Together, these challenges form the foundation for MLOps practices that focus on automation, collaboration, and lifecycle management.

These challenges introduced the need for a new set of tools and workflows tailored to the ML lifecycle. While DevOps primarily unifies software development and IT operations, MLOps requires coordination across a broader set of stakeholders—data scientists, ML engineers, data engineers, and operations teams.

MLOps introduces specialized practices such as [data versioning](https://dvc.org/), [model versioning](https://dvc.org/), and [model monitoring](https://www.fiddler.ai/) that go beyond the scope of DevOps. It emphasizes scalable experimentation, reproducibility, governance, and responsiveness to evolving data conditions. @tbl-mlops summarizes key similarities and differences between DevOps and MLOps:

+----------------------+--------------------------------------------+-------------------------------------------------------+
| Aspect               | DevOps                                     | MLOps                                                 |
+:=====================+:===========================================+:======================================================+
| Objective            | Streamlining software development          | Optimizing the lifecycle of machine learning models   |
|                      | and operations processes                   |                                                       |
+----------------------+--------------------------------------------+-------------------------------------------------------+
| Methodology          | Continuous Integration and Continuous      | Similar to CI/CD but focuses on machine learning      |
|                      | Delivery (CI/CD) for software development  | workflows                                             |
+----------------------+--------------------------------------------+-------------------------------------------------------+
| Primary Tools        | Version control (Git), CI/CD tools         | Data versioning tools, Model training and deployment  |
|                      | (Jenkins, Travis CI), Configuration        | tools, CI/CD pipelines tailored for ML                |
|                      | management (Ansible, Puppet)               |                                                       |
+----------------------+--------------------------------------------+-------------------------------------------------------+
| Primary Concerns     | Code integration, Testing, Release         | Data management, Model versioning, Experiment         |
|                      | management, Automation, Infrastructure     | tracking, Model deployment, Scalability of ML         |
|                      | as code                                    | workflows                                             |
+----------------------+--------------------------------------------+-------------------------------------------------------+
| Typical Outcomes     | Faster and more reliable software releases,| Efficient management and deployment of machine        |
|                      | Improved collaboration between development | learning models, Enhanced collaboration between       |
|                      | and operations teams                       | data scientists and engineers                         |
+----------------------+--------------------------------------------+-------------------------------------------------------+

: Comparison of DevOps and MLOps. {#tbl-mlops .striped .hover}

These distinctions become clearer when examined through practical examples. One such case study, which focuses on speech recognition, demonstrates the lifecycle of ML deployment and monitoring in action.

## MLOps Key Components {#sec-ml-operations-mlops-key-components-682e}

The core components of MLOps form an integrated framework that supports the full machine learning lifecycle—from initial development through deployment and long-term maintenance in production. This section synthesizes key ideas such as automation, reproducibility, and monitoring introduced earlier in the book, while also introducing critical new practices, including governance, model evaluation, and cross-team collaboration. Each component plays a distinct role in creating scalable, reliable, and maintainable ML systems. Together, they form a layered architecture, as illustrated in Figure @fig-ops-layers, that supports everything from low-level infrastructure to high-level application logic. By understanding how these components interact, practitioners can design systems that are not only performant but also transparent, auditable, and adaptable to changing conditions.

::: {#fig-ops-layers fig-env="figure" fig-pos="htb"}
```{.tikz}
\begin{tikzpicture}[line width=0.75pt,font=\small\usefont{T1}{phv}{m}{n}]
%
\tikzset{%
   Line/.style={line width=1.0pt,black!50},
   Box/.style={align=flush center,
    inner xsep=2pt,
    node distance=0.9,
    draw=BlueLine,
    line width=0.75pt,
    fill=BlueL,
    text width=31mm,
    minimum width=31mm, minimum height=10mm
  },
  Box2/.style={Box,text width=40mm,minimum width=40mm,fill=OrangeL,draw=OrangeLine
  },
Box3/.style={Box, fill=GreenL,draw=GreenLine},
Box31/.style={Box3, node distance=0.5, minimum height=8mm},
Box4/.style={Box, fill=RedL,draw=RedLine,text width=34mm, minimum width=34mm},
Box41/.style={Box4, node distance=0.5, minimum height=8mm},
}
%
\node[Box,text width=37mm, minimum width=37mm](B1){\textbf{ML Models/Applications} (e.g., BERT)};
\node[Box2,right=of B1](B2){\textbf{ML Frameworks/Platforms} (e.g., PyTorch)};
\node[Box3,right=of B2](B3){\textbf{Model Orchestration} (e.g., Ray)};
\node[Box4,right=of B3](B4){\textbf{Infrastructure}\\ (e.g., Kubernetes)};
\node[Box,right=of B4,fill=VioletL2,draw=VioletLine2](B5){\textbf{Hardware}\\ (e.g., a GPU klaster)};
%
\node[Box31,below=of B3](B31){Data Management};
\node[Box31,below=of B31](B32){CI/CD};
\node[Box31,below=of B32](B33){Model Training};
\node[Box31,below=of B33](B34){Model Eval};
\node[Box31,below=of B34](B35){Deployment};
\node[Box31,below=of B35](B36){Model Serving};
%
\node[Box41,below=of B4](B41){Job Scheduling};
\node[Box41,below=of B41](B42){Resource Management};
\node[Box41,below=of B42](B43){Capacity Management};
\node[Box41,below=of B43](B44){Monitoring};
\node[Box41,draw=none,fill=none,below=of B44](B45){};
\scoped[on background layer]
\node[draw=BackLine,inner xsep=11,inner ysep=19,yshift=3mm,fill=BackColor!70,fit=(B3)(B44)(B36),line width=0.75pt](BB1){};
\node[below=3pt of BB1.north, anchor=north]{MLOps};
%
\foreach \y in{3,4}{
\foreach \x in{1,2,3,4}{
\pgfmathtruncatemacro{\newX}{\x + 1}
\draw[-latex,Line](B\y\x)--(B\y\newX);
}}
\foreach \y in{3,4}{
\draw[-latex,Line](B\y)--(B\y1);
}
\draw[-latex,Line](B35)--(B36);
\draw[-latex,Line](B44)--(B45)coordinate(T44);

\node[inner sep=0pt,below=0 of T44,rotate=90,align=center,font=\tiny\usefont{T1}{phv}{m}{n}]{$\bullet$ $\bullet$ $\bullet$};
%
\foreach \y in{1,2,3,4}{
\pgfmathtruncatemacro{\newX}{\y + 1}
\draw[Line](B\y)--(B\newX);
}
\end{tikzpicture}
```
The MLOps stack, including ML Models, Frameworks, Model Orchestration, Infrastructure, and Hardware, illustrates the end-to-end workflow of MLOps.
:::

### Data Infrastructure and Preparation {#sec-ml-operations-data-infrastructure-preparation-5758}

Reliable machine learning systems depend on structured, scalable, and repeatable handling of data. From the moment data is ingested to the point where it informs predictions, each stage must preserve quality, consistency, and traceability. In operational settings, data infrastructure supports not only initial development but also continual retraining, auditing, and serving—requiring systems that formalize the transformation and versioning of data throughout the ML lifecycle.

#### Data Management {#sec-ml-operations-data-management-a3d7}

In earlier chapters, we examined how data is collected, preprocessed, and transformed into features suitable for model training and inference. Within the context of MLOps, these tasks are formalized and scaled into systematic, repeatable processes that ensure data reliability, traceability, and operational efficiency. Data management, in this setting, extends beyond initial preparation to encompass the continuous handling of data artifacts throughout the lifecycle of a machine learning system.

A foundational aspect of MLOps data management is dataset versioning. Machine learning systems often evolve in tandem with the data on which they are trained. Therefore, it is essential to maintain a clear mapping between specific versions of data and corresponding model iterations. Tools such as [DVC](https://dvc.org/) enable teams to version large datasets alongside code repositories managed by [Git](https://git-scm.com/), ensuring that data lineage is preserved and that experiments are reproducible.

Supervised learning pipelines also require consistent and well-managed annotation workflows. Labeling tools such as [Label Studio](https://labelstud.io/) support scalable, team-based annotation with integrated audit trails and version histories. These capabilities are particularly important in production settings, where labeling conventions may evolve over time or require refinement across multiple iterations of a project.

In operational environments, data must also be stored in a manner that supports secure, scalable, and collaborative access. Cloud-based object storage systems such as [Amazon S3](https://aws.amazon.com/s3/) and [Google Cloud Storage](https://cloud.google.com/storage) offer durability and fine-grained access control, making them well-suited for managing both raw and processed data artifacts. These systems frequently serve as the foundation for downstream analytics, model development, and deployment workflows.

To transition from raw data to analysis- or inference-ready formats, MLOps teams construct automated data pipelines. These pipelines perform structured tasks such as data ingestion, schema validation, deduplication, transformation, and loading. Orchestration tools including [Apache Airflow](https://airflow.apache.org/), [Prefect](https://www.prefect.io/), and [dbt](https://www.getdbt.com/) are commonly used to define and manage these workflows. When managed as code, pipelines support versioning, modularity, and integration with CI/CD systems.

An increasingly important element of the MLOps data infrastructure is the feature store[^fn-feature-store]. Feature stores, such as [Feast](https://feast.dev/) and [Tecton](https://www.tecton.ai/), provide a centralized repository for storing and retrieving engineered features. These systems serve both batch and online use cases, ensuring that models access the same feature definitions during training and inference, thereby improving consistency and reducing data leakage.

[^fn-feature-store]: **Feature Store:** A centralized repository for storing, managing, and retrieving feature data used in machine learning models.

Consider a predictive maintenance application in an industrial setting. A continuous stream of sensor data is ingested and joined with historical maintenance logs through a scheduled pipeline managed in Airflow. The resulting features, including rolling averages and statistical aggregates, are stored in a feature store for both retraining and low-latency inference. This pipeline is versioned, monitored, and integrated with the model registry, enabling full traceability from data to deployed model predictions.

Effective data management in MLOps is not limited to ensuring data quality. It also establishes the operational backbone that enables model reproducibility, auditability, and sustained deployment at scale. Without robust data management, the integrity of downstream training, evaluation, and serving processes cannot be maintained.

:::{#vid-datapipe .callout-important title="Data Pipelines"}
::: {.content-visible when-format="html"}
{{< video https://www.youtube.com/watch?v=gz-44N3MMOA&list=PLkDaE6sCZn6GMoA0wbpJLi3t34Gd8l0aK&index=33 >}}
:::

::: {.content-visible when-format="pdf"}
\marginnote{\centering\\\vspace*{-35mm}%
  \parbox{30mm}{\centering\footnotesize%
    \textbf{Watch on YouTube}\\
    Data Pipelines\\[1mm]
  }
  \begingroup
    \hypersetup{urlcolor=black}
    \qrcode[height=15mm]{https://www.youtube.com/watch?v=gz-44N3MMOA&list=PLkDaE6sCZn6GMoA0wbpJLi3t34Gd8l0aK&index=33}
  \endgroup
  \\[1mm]
  \parbox{25mm}{\centering\footnotesize%
    Scan with your phone\\
    to watch the video
  }
}

\faTv{} [Watch on YouTube](https://www.youtube.com/watch?v=gz-44N3MMOA&list=PLkDaE6sCZn6GMoA0wbpJLi3t34Gd8l0aK&index=33)
:::
:::

#### Feature Stores {#sec-ml-operations-feature-stores-2eb1}

Feature stores provide an abstraction layer between data engineering and machine learning. Their primary purpose is to enable consistent, reliable access to engineered features across training and inference workflows. In conventional pipelines, feature engineering logic may be duplicated, manually reimplemented, or diverge across environments. This introduces risks of training-serving skew[^fn-training-serving-skew], data leakage[^fn-data-leakage], and model drift[^fn-model-drift].

[^fn-training-serving-skew]: **Training-serving skew:** A discrepancy between model performance during training and inference, often due to differences in data handling.
[^fn-data-leakage]: **Data leakage:** Occurs when information from outside the training dataset is used to create the model, leading to misleadingly high performance.
[^fn-model-drift]: **Model drift:** The change in model performance over time, caused by evolving underlying data patterns.

Feature stores address these challenges by managing both offline (batch) and online (real-time) feature access in a centralized repository. During training, features are computed and stored in a batch environment—typically in conjunction with historical labels. At inference time, the same transformation logic is applied to fresh data in an online serving system. This architecture ensures that models consume identical features in both contexts, promoting consistency and improving reliability.

In addition to enforcing standardization, feature stores support versioning, metadata management, and feature reuse across teams. For example, a fraud detection model and a credit scoring model may rely on overlapping transaction features, which can be centrally maintained, validated, and shared. This reduces engineering overhead and fosters alignment across use cases.

Feature stores can be tightly integrated with data pipelines and model registries, enabling lineage tracking and traceability. When a feature is updated or deprecated, dependent models can be identified and retrained accordingly. This level of integration enhances the operational maturity of ML systems and supports auditing, debugging, and compliance workflows.

#### Versioning and Lineage {#sec-ml-operations-versioning-lineage-c266}

Versioning is fundamental to reproducibility and traceability in machine learning systems. Unlike traditional software, ML models depend on multiple changing artifacts—data, feature transformations, model weights, and configuration parameters. To manage this complexity, MLOps practices enforce rigorous tracking of versions across all pipeline components.

Data versioning allows teams to snapshot datasets at specific points in time and associate them with particular model runs. This includes both raw data (e.g., input tables or log streams) and processed artifacts (e.g., cleaned datasets or feature sets). By maintaining a direct mapping between model checkpoints and the data used for training, teams can audit decisions, reproduce results, and investigate regressions.

Model versioning involves registering trained models as immutable artifacts, often alongside metadata such as training parameters, evaluation metrics, and environment specifications. These records are typically maintained in a model registry, which provides a structured interface for promoting, deploying, and rolling back model versions. Some registries also support lineage visualization, which traces the full dependency graph from raw data to deployed prediction.

Together, data and model versioning form the lineage layer of an ML system. This layer enables introspection, experimentation, and governance. When a deployed model underperforms, lineage tools help teams answer questions such as:

* Was the input distribution consistent with training data?
* Did the feature definitions change?
* Is the model version aligned with the serving infrastructure?

By making versioning and lineage first-class citizens in the system design, MLOps enables teams to build and maintain reliable, auditable, and evolvable ML workflows at scale.

### Continuous Pipelines and Automation {#sec-ml-operations-continuous-pipelines-automation-89df}

Automation enables machine learning systems to evolve continuously in response to new data, shifting objectives, and operational constraints. Rather than treating development and deployment as isolated phases, automated pipelines allow for synchronized workflows that integrate data preprocessing, training, evaluation, and release. These pipelines underpin scalable experimentation and ensure the repeatability and reliability of model updates in production.

#### CI/CD Pipelines {#sec-ml-operations-cicd-pipelines-f39d}

In conventional software systems, continuous integration and continuous delivery (CI/CD) pipelines are essential for ensuring that code changes can be tested, validated, and deployed efficiently. In the context of machine learning systems, CI/CD pipelines are adapted to handle additional complexities introduced by data dependencies, model training workflows, and artifact versioning[^fn-artifact-versioning]. These pipelines provide a structured mechanism to transition ML models from development into production in a reproducible, scalable, and automated manner.

[^fn-artifact-versioning]: **Artifact Versioning:** Managing versions of software artifacts to track changes over time, essential for rollback and understanding dependencies.

A typical ML CI/CD pipeline consists of several coordinated stages, including: checking out updated code, preprocessing input data, training a candidate model, validating its performance, packaging the model, and deploying it to a serving environment. In some cases, pipelines also include triggers for automatic retraining based on data drift or performance degradation. By codifying these steps, CI/CD pipelines reduce manual intervention, enforce quality checks, and support continuous improvement of deployed systems.

A wide range of tools is available for implementing ML-focused CI/CD workflows. General-purpose CI/CD orchestrators such as [Jenkins](https://www.jenkins.io/), [CircleCI](https://circleci.com/), and [GitHub Actions](https://github.com/features/actions) are commonly used to manage version control events and execution logic. These tools are frequently integrated with domain-specific platforms such as [Kubeflow](https://www.kubeflow.org/), [Metaflow](https://metaflow.org/), and [Prefect](https://www.prefect.io/), which offer higher-level abstractions for managing ML tasks and workflows.

@fig-ops-cicd illustrates a representative CI/CD pipeline for machine learning systems. The process begins with a dataset and feature repository, from which data is ingested and validated. Validated data is then transformed for model training. A retraining trigger, such as a scheduled job or performance threshold, may initiate this process automatically. Once training and hyperparameter tuning are complete, the resulting model undergoes evaluation against predefined criteria. If the model satisfies the required thresholds, it is registered in a model repository along with metadata, performance metrics, and lineage information. Finally, the model is deployed back into the production system, closing the loop and enabling continuous delivery of updated models.

::: {#fig-ops-cicd fig-env="figure" fig-pos="htb"}
```{.tikz}
\begin{tikzpicture}[line join=round,font=\small\usefont{T1}{phv}{m}{n}]
\definecolor{Red}{RGB}{249,56,39}
\definecolor{Blue}{RGB}{0,97,168}
\definecolor{Violet}{RGB}{178,108,186}
\tikzset{%
helvetica/.style={align=flush center, font={\usefont{T1}{phv}{m}{n}\small}},
cyl/.style={cylinder, draw=BrownLine,shape border rotate=90, aspect=1.8,inner ysep=0pt,
    minimum height=20mm,minimum width=21mm, cylinder uses custom fill,
 cylinder body fill=brown!10,cylinder end fill=brown!35},
Line/.style={line width=1.2pt,black!50},
LineB/.style={line width=1.5pt,BlueLine
   },
  Box/.style={align=flush center,
    inner xsep=2pt,
    node distance=0.9,
    draw=BlueLine,
    line width=0.75pt,
    fill=BlueL!80,
    text width=22mm,
    minimum width=22mm, minimum height=10mm
  },
Box2/.style={Box,fill=OrangeL,draw=OrangeLine},
Box3/.style={Box, fill=GreenL,draw=GreenLine},
Box4/.style={Box, fill=RedL,draw=RedLine},
}
\definecolor{CPU}{RGB}{0,120,176}

\node[Box](B1){Data validation};
\node[Box2,right=of B1](B2){Data transformation};
\node[Box3,right=of B2](B3){Model validation};
\node[Box4,right=of B3](B4){Model registration};
\node[Box,above=of B1](B11){Dataset ingestion};
\node[Box2,above=of B2](B21){Model training / tuning};
\node[Box3,above=of B3](B31){Model evaluation};
%fitting
\scoped[on background layer]
\node[draw=BackLine,inner xsep=11,inner ysep=19,yshift=3mm,
           fill=BackColor!70,fit=(B11)(B4),line width=0.75pt](BB1){};
\node[below=3pt of  BB1.north,anchor=north,helvetica]{\textbf{Continuous training pipeline}};

\draw[-latex,Line](B11)--(B1);
\draw[-latex,Line](B1)--(B2);
\draw[-latex,Line](B2)--(B21);
\draw[-latex,Line](B21)--(B31);
\draw[-latex,Line](B31)--(B3);
\draw[-latex,Line](B3)--(B4);
%cylinder left
\begin{scope}[local bounding box = CYL1,shift={($(BB1.west)+(-3.5,0)$)}]
\node (CA1) [cyl] {};
\node[align=center]at (CA1){Dataset \&\\ feature\\repository};
\end{scope}
%cylinder right
\begin{scope}[local bounding box = CYL2,shift={($(BB1.east)+(3.5,0)$)}]
\node (CA1) [cyl] {};
\node[align=center]at (CA1){Dataset \&\\ feature\\repository};
\end{scope}
%cylinder top
\begin{scope}[local bounding box = CYL3,shift={($(BB1.north)+(0,2.9)$)}]
\node (CA1) [cyl] {};
\node[align=center]at (CA1){ML metadata\\\& artifact\\repository};
\end{scope}
% connect cube and fitting
\draw[{Circle[length=4.5pt]}-latex,LineB](CYL1.east)coordinate(CC1)--(CYL1.east-|BB1.west)coordinate(CC2);
\draw[latex-{Circle[length=4.5pt]},LineB](CYL2.west)coordinate(CD1)--(CYL2.west-|BB1.east)coordinate(CD2);
\draw[latex-latex,LineB](CYL3.south)coordinate(CE1)--(CYL3.south|-BB1.north)coordinate(CE2);
%cube left
\begin{scope}[local bounding box=CU1,shift={($(CC1)!0.35!(CC2)+(0,0.6)$)},scale=0.8,every node/.append style={transform shape}]
%cube coordinates
\newcommand{\Depth}{1.5}
\newcommand{\Height}{1.1}
\newcommand{\Width}{1.5}
\coordinate (O2) at (0,0,0);
\coordinate (A2) at (0,\Width,0);
\coordinate (B2) at (0,\Width,\Height);
\coordinate (C2) at (0,0,\Height);
\coordinate (D2) at (\Depth,0,0);
\coordinate (E2) at (\Depth,\Width,0);
\coordinate (F2) at (\Depth,\Width,\Height);
\coordinate (G2) at (\Depth,0,\Height);

\draw[fill=OrangeLine!80] (D2) -- (E2) -- (F2) -- (G2) -- cycle;% Right Face
\draw[fill=OrangeLine!50] (C2) -- (B2) -- (F2) -- (G2) -- (C2);% Front Face
\draw[fill=OrangeLine!20] (A2) -- (B2) -- (F2) -- (E2) -- cycle;% Top Face
%
\node[align=center]at($(B2)!0.5!(G2)$){Dataset\\ \textless$\backslash$\textgreater};
\end{scope}
%cube right
\begin{scope}[local bounding box=CU2,shift={($(CD1)!0.65!(CD2)+(0,0.6)$)}, scale=0.8,every node/.append style={transform shape}]
%cube coordinates
\newcommand{\Depth}{1.5}
\newcommand{\Height}{1.1}
\newcommand{\Width}{1.5}
\coordinate (O2) at (0,0,0);
\coordinate (A2) at (0,\Width,0);
\coordinate (B2) at (0,\Width,\Height);
\coordinate (C2) at (0,0,\Height);
\coordinate (D2) at (\Depth,0,0);
\coordinate (E2) at (\Depth,\Width,0);
\coordinate (F2) at (\Depth,\Width,\Height);
\coordinate (G2) at (\Depth,0,\Height);

\draw[fill=OrangeLine!80] (D2) -- (E2) -- (F2) -- (G2) -- cycle;% Right Face
\draw[fill=OrangeLine!50] (C2) -- (B2) -- (F2) -- (G2) -- (C2);% Front Face
\draw[fill=OrangeLine!20] (A2) -- (B2) -- (F2) -- (E2) -- cycle;% Top Face
%
\node[align=center]at($(B2)!0.5!(G2)$){Trained\\Model\\ \textless$\backslash$\textgreater};
\end{scope}
%cube top
\begin{scope}[local bounding box=CU3,shift={($(CE1)!0.75!(CE2)+(0.7,0)$)},scale=0.7,every node/.append style={transform shape}]
%cube coordinates
\newcommand{\Depth}{2.5}
\newcommand{\Height}{1.1}
\newcommand{\Width}{1.8}
\coordinate (O2) at (0,0,0);
\coordinate (A2) at (0,\Width,0);
\coordinate (B2) at (0,\Width,\Height);
\coordinate (C2) at (0,0,\Height);
\coordinate (D2) at (\Depth,0,0);
\coordinate (E2) at (\Depth,\Width,0);
\coordinate (F2) at (\Depth,\Width,\Height);
\coordinate (G2) at (\Depth,0,\Height);

\draw[fill=OrangeLine!80] (D2) -- (E2) -- (F2) -- (G2) -- cycle;% Right Face
\draw[fill=OrangeLine!50] (C2) -- (B2) -- (F2) -- (G2) -- (C2);% Front Face
\draw[fill=OrangeLine!20] (A2) -- (B2) -- (F2) -- (E2) -- cycle;% Top Face
%
\node[align=center]at($(B2)!0.5!(G2)$){Trained pipeline\\ metadata \\ \& artifacts\\ \textless$\backslash$\textgreater};
\end{scope}
%above fitting
\node[Box,above=of BB1.153,fill=OliveL,draw=OliveLine](RT){Retraining trigger};
\draw[{Circle[length=4.5pt]}-latex,LineB](RT)--(RT|-BB1.north);
%%%
%cubes below center
\begin{scope}[local bounding box=CUS,shift={($(BB1.south west)!0.45!(BB1.south east)+(0,-2.0)$)},scale=0.8,every node/.append style={transform shape}]
%cube coordinates
\newcommand{\Depth}{2.2}
\newcommand{\Height}{0.7}
\newcommand{\Width}{1.6}
\coordinate (O2) at (0,0,0);
\coordinate (A2) at (0,\Width,0);
\coordinate (B2) at (0,\Width,\Height);
\coordinate (C2) at (0,0,\Height);
\coordinate (D2) at (\Depth,0,0);
\coordinate (E2) at (\Depth,\Width,0);
\coordinate (F2) at (\Depth,\Width,\Height);
\coordinate (G2) at (\Depth,0,\Height);
\colorlet{OrangeLine}{Blue}
\draw[fill=OrangeLine!80] (D2) -- (E2) -- (F2) -- (G2) -- cycle;% Right Face
\draw[fill=OrangeLine!50] (C2) -- (B2) -- (F2) -- (G2) -- (C2);% Front Face
\draw[fill=OrangeLine!20] (A2) -- (B2) -- (F2) -- (E2) -- cycle;% Top Face
%
\node[align=center]at($(B2)!0.5!(G2)$){Model\\ training\\ engine};
\end{scope}
%left
\begin{scope}[local bounding box=CUL,shift={($(BB1.south west)!0.20!(BB1.south east)+(0,-2.0)$)},scale=0.8,every node/.append style={transform shape}]
%cube coordinates
\newcommand{\Depth}{2.2}
\newcommand{\Height}{0.7}
\newcommand{\Width}{1.6}
\coordinate (O2) at (0,0,0);
\coordinate (A2) at (0,\Width,0);
\coordinate (B2) at (0,\Width,\Height);
\coordinate (C2) at (0,0,\Height);
\coordinate (D2) at (\Depth,0,0);
\coordinate (E2) at (\Depth,\Width,0);
\coordinate (F2) at (\Depth,\Width,\Height);
\coordinate (G2) at (\Depth,0,\Height);
\colorlet{OrangeLine}{Violet}
\draw[fill=OrangeLine!80] (D2) -- (E2) -- (F2) -- (G2) -- cycle;% Right Face
\draw[fill=OrangeLine!50] (C2) -- (B2) -- (F2) -- (G2) -- (C2);% Front Face
\draw[fill=OrangeLine!20] (A2) -- (B2) -- (F2) -- (E2) -- cycle;% Top Face
%
\node[align=center]at($(B2)!0.5!(G2)$){Model\\processing\\ engine};
\end{scope}
%right
\begin{scope}[local bounding box=CUD,shift={($(BB1.south west)!0.70!(BB1.south east)+(0,-2.0)$)},scale=0.8,every node/.append style={transform shape}]
%cube coordinates
\newcommand{\Depth}{2.2}
\newcommand{\Height}{0.7}
\newcommand{\Width}{1.6}
\coordinate (O2) at (0,0,0);
\coordinate (A2) at (0,\Width,0);
\coordinate (B2) at (0,\Width,\Height);
\coordinate (C2) at (0,0,\Height);
\coordinate (D2) at (\Depth,0,0);
\coordinate (E2) at (\Depth,\Width,0);
\coordinate (F2) at (\Depth,\Width,\Height);
\coordinate (G2) at (\Depth,0,\Height);
\colorlet{OrangeLine}{Red}
\draw[fill=OrangeLine!80] (D2) -- (E2) -- (F2) -- (G2) -- cycle;% Right Face
\draw[fill=OrangeLine!50] (C2) -- (B2) -- (F2) -- (G2) -- (C2);% Front Face
\draw[fill=OrangeLine!20] (A2) -- (B2) -- (F2) -- (E2) -- cycle;% Top Face
%
\node[align=center]at($(B2)!0.5!(G2)$){Model\\evaluation\\ engine};
\end{scope}
%%
\draw[latex-,Line](CUL)--(CUL|-BB1.south);
\draw[latex-,Line](CUS)--(CUS|-BB1.south);
\draw[latex-,Line](CUD)--(CUD|-BB1.south);
\end{tikzpicture}
```
MLOps CI/CD diagram. Source: HarvardX.
:::

As a practical example, consider an image classification model under active development. When a data scientist commits changes to a [GitHub](https://github.com/) repository, a Jenkins pipeline is triggered. The pipeline fetches the latest data, performs preprocessing, and initiates model training. Experiments are tracked using [MLflow](https://mlflow.org/), which logs metrics and stores model artifacts. After passing automated evaluation tests, the model is containerized and deployed to a staging environment using [Kubernetes](https://kubernetes.io/). If the model meets validation criteria in staging, the pipeline orchestrates a [canary deployment](https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments), gradually routing production traffic to the new model while monitoring key metrics for anomalies. In case of performance regressions, the system can automatically revert to a previous model version.

CI/CD pipelines play a central role in enabling scalable, repeatable, and safe deployment of machine learning models. By unifying the disparate stages of the ML workflow under continuous automation, these pipelines support faster iteration, improved reproducibility, and greater resilience in production systems. In mature MLOps environments, CI/CD is not an optional layer, but a foundational capability that transforms ad hoc experimentation into a structured and operationally sound development process.

#### Training Pipelines {#sec-ml-operations-training-pipelines-bd03}

Model training is a central phase in the machine learning lifecycle, where algorithms are optimized to learn patterns from data. In prior chapters, we introduced the fundamentals of model development and training workflows, including architecture selection, hyperparameter tuning, and evaluation. Within an MLOps context, these activities are reframed as part of a reproducible, scalable, and automated pipeline that supports continual experimentation and reliable production deployment.

Modern machine learning frameworks such as [TensorFlow](https://www.tensorflow.org/), [PyTorch](https://pytorch.org/), and [Keras](https://keras.io/) provide modular components for building and training models. These libraries include high-level abstractions for layers, activation functions, loss metrics, and optimizers, enabling practitioners to prototype and iterate efficiently. When embedded into MLOps pipelines, these frameworks serve as the foundation for training processes that can be systematically scaled, tracked, and retrained.

Reproducibility is a key objective of MLOps. Training scripts and configurations are version-controlled using tools like [Git](https://git-scm.com/) and hosted on platforms such as [GitHub](https://github.com/). Interactive development environments, including [Jupyter](https://jupyter.org/) notebooks, are commonly used to encapsulate data ingestion, feature engineering, training routines, and evaluation logic in a unified format. These notebooks can be integrated into automated pipelines, allowing the same logic used for local experimentation to be reused for scheduled retraining in production systems.

Automation further enhances model training by reducing manual effort and standardizing critical steps. MLOps workflows often incorporate techniques such as [hyperparameter tuning](https://cloud.google.com/ai-platform/training/docs/hyperparameter-tuning-overview), [neural architecture search](https://arxiv.org/abs/1808.05377), and [automatic feature selection](https://scikit-learn.org/stable/modules/feature_selection.html) to explore the design space efficiently. These tasks are orchestrated using CI/CD pipelines, which automate data preprocessing, model training, evaluation, registration, and deployment. For instance, a Jenkins pipeline may trigger a retraining job when new labeled data becomes available. The resulting model is evaluated against baseline metrics, and if performance thresholds are met, it is deployed automatically.

The increasing availability of cloud-based infrastructure has further expanded the reach of model training. Cloud providers offer managed services[^fn-managed-services] that provision high-performance computing resources, which include GPU and TPU accelerators, on demand. Depending on the platform, teams may construct their own training workflows or rely on fully managed services such as [Vertex AI Fine Tuning](https://cloud.google.com/vertex-ai/docs/generative-ai/models/tune-models), which support automated adaptation of foundation models to new tasks. Nonetheless, hardware availability, regional access restrictions, and cost constraints remain important considerations when designing cloud-based training systems.

[^fn-managed-services]: In cloud computing, managed services involve third-party providers handling infrastructure, application functionalities, and operations.

As an illustrative example, consider a data scientist developing a convolutional neural network (CNN) for image classification using a PyTorch notebook. The [fastai](https://www.fast.ai/) library is used to simplify model construction and training. The notebook trains the model on a labeled dataset, computes performance metrics, and tunes hyperparameters such as learning rate and architecture depth. Once validated, the training script is version-controlled and incorporated into a retraining pipeline that is periodically triggered based on data updates or model performance monitoring.

Through standardized workflows, versioned environments, and automated orchestration, MLOps enables the model training process to transition from ad hoc experimentation to a robust, repeatable, and scalable system. This not only accelerates development but also ensures that trained models meet production standards for reliability, traceability, and performance.

#### Model Validation {#sec-ml-operations-model-validation-02fd}

Before a machine learning model is deployed into production, it must undergo rigorous evaluation to ensure that it meets predefined performance, robustness, and reliability criteria. While earlier chapters discussed evaluation in the context of model development, MLOps reframes evaluation as a structured and repeatable process for validating operational readiness. It incorporates practices that support pre-deployment assessment, post-deployment monitoring, and automated regression testing.

The evaluation process typically begins with performance testing against a holdout test set—a dataset not used during training or validation. This dataset is sampled from the same distribution as production data and is used to measure generalization. Core metrics such as [accuracy](https://en.wikipedia.org/wiki/Accuracy_and_precision), [area under the curve (AUC)](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve), [precision](https://en.wikipedia.org/wiki/Precision_and_recall), [recall](https://en.wikipedia.org/wiki/Precision_and_recall), and [F1 score](https://en.wikipedia.org/wiki/F1_score) are computed to quantify model performance. These metrics are not only used at a single point in time but also tracked longitudinally to detect degradation, such as that caused by [data drift](https://www.ibm.com/cloud/learn/data-drift), where shifts in input distributions can reduce model accuracy over time (see @fig-data-drift).

::: {#fig-data-drift fig-env="figure" fig-pos="htb"}
```{.tikz}
\begin{tikzpicture}[line join=round,font=\usefont{T1}{phv}{m}{n},outer sep=0pt]

\tikzset{
LineA/.style={line width=0.75pt,black,text=black,-{Triangle[width=0.7*6pt,length=1.5*6pt]}},
styleBox/.style={draw=none, fill=green!60!black!40, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt},
styleBox2/.style={styleBox, fill=orange},
}

\def\cellsize{6mm}
\def\cellheight{8mm}
\def\columns{26}
\def\rows{1}

\foreach \x in {1,2,3,4,6,7,8,9,10,12,13,15,17,18,21,24}{
    \foreach \y in {1,...,\rows}{
        \node[styleBox] (C-\x-\y) at (\x*1.3*\cellsize,-\y*\cellheight) {};
    }
}
\foreach \x in {5,11,14,16,19,20,22,23,25,26}{
    \foreach \y in {1,...,\rows}{
        \node[styleBox2] (C-\x-\y) at (\x*1.3*\cellsize,-\y*\cellheight) {};
    }
}
\node[inner sep=0pt,above right=0.3 and 0of C-1-1.north west]{\textbf{Incoming date}};
\draw[LineA]($(C-1-1.south west)+(0,-0.5)$)--($(C-\columns-1.south east)+(0,-0.5)$)
node[below left=0.2 and 0]{Time};
%box
\coordinate(GL)at($(C-1-1.south west)+(0,-2)$);
\coordinate(DD)at($(C-\columns-1.south east)+(0,-4.5)$);
\path[fill=green!60!black!40](GL)rectangle(DD);
\path[](GL)|-coordinate(DL)(DD);
\path[](DD)|-coordinate(GD)(GL);
\node[inner sep=0pt,above right=0.3 and 0of GL]{\textbf{Feature distribution:} sales\_channel};
%
\path[fill=orange](DL)--(DD)--($(DD)!0.6!(GD)$)coordinate(SR)--cycle;
\node[align=center] at (barycentric cs:DL=1,GL=1,SR=0.1,GD=0.1) {Online store};
\node[align=center] at (barycentric cs:DL=0.2,DD=1,SR=1) {Offline store};
%graph
\coordinate(2GL)at($(C-1-1.south west)+(0,-6)$);
\coordinate(2DD)at($(C-\columns-1.south east)+(0,-8.5)$);
%
\path(2GL)rectangle(2DD);
\path(2GL)|-coordinate(2DL)(2DD);
\path(2DD)|-coordinate(2GD)(2GL);
\node[inner sep=0pt,above right=0.3 and 0of 2GL]{\textbf{Model quality:} accuracy over time};
%
\draw[line width=1pt](2GL)--(2DL)--(2DD);
\draw[line width=2pt,green!50!black!80]($(2GL)!0.2!(2DL)$)to[out=0,in=170]($(2DD)!0.25!(2GD)$);
\end{tikzpicture}
```
Example of data drift over time and how it can impact model performance.
:::

Beyond static evaluation, MLOps encourages controlled deployment strategies that simulate production conditions while minimizing risk. One widely adopted method is [canary testing](https://martinfowler.com/bliki/CanaryRelease.html), in which the new model is deployed to a small fraction of users or queries. During this limited rollout, live performance metrics are monitored to assess system stability and user impact. For instance, an e-commerce platform may deploy a new recommendation model to 5% of web traffic and observe metrics such as click-through rate, latency, and prediction accuracy. Only after the model demonstrates consistent and reliable performance is it promoted to full production.

Cloud-based ML platforms further support model evaluation by enabling experiment logging, request replay, and synthetic test case generation. These capabilities allow teams to evaluate different models under identical conditions, facilitating comparisons and root-cause analysis. Tools such as [Weights and Biases](https://wandb.ai/) automate aspects of this process by capturing training artifacts, recording hyperparameter configurations, and visualizing performance metrics across experiments. These tools integrate directly into training and deployment pipelines, improving transparency and traceability.

While automation is central to MLOps evaluation practices, human oversight remains essential. Automated tests may fail to capture nuanced performance issues, such as poor generalization on rare subpopulations or shifts in user behavior. Therefore, teams often combine quantitative evaluation with qualitative review, particularly for models deployed in high-stakes or regulated environments.

In summary, model evaluation within MLOps is a multi-stage process that bridges offline testing and live system monitoring. It ensures that models not only meet technical benchmarks but also behave predictably and responsibly under real-world conditions. These evaluation practices reduce deployment risk and help maintain the reliability of machine learning systems over time.

### Model Deployment and Serving {#sec-ml-operations-model-deployment-serving-95b7}

Once a model has been trained and validated, it must be integrated into a production environment where it can deliver predictions at scale. This process involves packaging the model with its dependencies, managing versions, and deploying it in a way that aligns with performance, reliability, and governance requirements. Deployment transforms a sta tic artifact into a live system component. Serving ensures that the model is accessible, reliable, and efficient in responding to inference requests. Together, these components form the bridge between model development and real-world impact.

#### Model Deployment {#sec-ml-operations-model-deployment-b947}

Teams need to properly package, test, and track ML models to reliably deploy them to production. MLOps introduces frameworks and procedures for actively versioning, deploying, monitoring, and updating models in sustainable ways.

One common approach to deployment involves containerizing models using tools like [Docker](https://www.docker.com/), which package code, libraries, and dependencies into standardized units. Containers ensure smooth portability across environments, making deployment consistent and predictable. Frameworks like [TensorFlow Serving](https://www.tensorflow.org/tfx/guide/serving) and [BentoML](https://bentoml.org/) help serve predictions from deployed models via performance-optimized APIs. These frameworks handle versioning, scaling, and monitoring.

Before full-scale rollout, teams deploy updated models to staging or QA environments to rigorously test performance. Techniques such as shadow or canary deployments are used to validate new models incrementally. For instance, canary deployments route a small percentage of traffic to the new model while closely monitoring performance. If no issues arise, traffic to the new model gradually increases. Robust rollback procedures are essential to handle unexpected issues, reverting systems to the previous stable model version to ensure minimal disruption. Integration with CI/CD pipelines further automates the deployment and rollback process, enabling efficient iteration cycles.

To maintain lineage and auditability, teams track model artifacts, including scripts, weights, logs, and metrics, using tools like [MLflow](https://mlflow.org/). Model registries, such as [Vertex AI's model registry](https://cloud.google.com/vertex-ai/docs/model-registry/introduction), act as centralized repositories for storing and managing trained models. These registries not only facilitate version comparisons but also often include access to base models, which may be open source, proprietary, or a hybrid (e.g., [LLAMA](https://ai.meta.com/llama/)). Deploying a model from the registry to an inference endpoint is streamlined, handling resource provisioning, model weight downloads, and hosting.

Inference endpoints typically expose the deployed model via REST APIs[^fn-rest-apis] for real-time predictions. Depending on performance requirements, teams can configure resources, such as GPU accelerators, to meet latency and throughput targets. Some providers also offer flexible options like serverless or batch inference, eliminating the need for persistent endpoints and enabling cost-efficient, scalable deployments. For example, [AWS SageMaker Inference](https://docs.aws.amazon.com/sagemaker/latest/dg/deploy-model.html) supports such configurations. By leveraging these tools and practices, teams can deploy ML models resiliently, ensuring smooth transitions between versions, maintaining production stability, and optimizing performance across diverse use cases.

[^fn-rest-apis]: **REST APIs:** Interfaces that allow communication between computer systems over the internet using REST architectural principles.

#### Inference Serving {#sec-ml-operations-inference-serving-46f4}

Once a model has been deployed, the final stage in operationalizing machine learning is to make it accessible to downstream applications or end-users. Serving infrastructure provides the interface between trained models and real-world systems, enabling predictions to be delivered reliably and efficiently. In large-scale settings, such as social media platforms or e-commerce services, serving systems may process tens of trillions of inference queries per day [@wu2019machine]. Meeting such demand requires careful design to balance latency, scalability, and robustness.

To address these challenges, production-grade serving frameworks have emerged. Tools such as [TensorFlow Serving](https://www.tensorflow.org/tfx/guide/serving), [NVIDIA Triton Inference Server](https://developer.nvidia.com/triton-inference-server), and [KServe](https://kserve.github.io/website/latest/) provide standardized mechanisms for deploying, versioning, and scaling machine learning models across heterogeneous infrastructure. These frameworks abstract many of the lower-level concerns, allowing teams to focus on system behavior, integration, and performance targets.

Model serving architectures are typically designed around three broad paradigms:

1. Online Serving, which provides low-latency, real-time predictions for interactive systems such as recommendation engines or fraud detection.
2. Offline Serving, which processes large batches of data asynchronously, typically in scheduled jobs used for reporting or model retraining.
3. Near-Online (Semi-Synchronous) Serving, which offers a balance between latency and throughput, appropriate for scenarios like chatbots or semi-interactive analytics.

Each of these approaches introduces different constraints in terms of availability, responsiveness, and throughput. Serving systems are therefore constructed to meet specific Service Level Agreements (SLAs) and Service Level Objectives (SLOs), which quantify acceptable performance boundaries along dimensions such as latency, error rates, and uptime. Achieving these goals requires a range of optimizations in request handling, scheduling, and resource allocation.

A number of serving system design strategies are commonly employed to meet these requirements. Request scheduling and batching aggregate inference requests to improve throughput and hardware utilization. For instance, Clipper [@crankshaw2017clipper] applies batching and caching to reduce response times in online settings. Model instance selection and routing dynamically assign requests to model variants based on system load or user-defined constraints; INFaaS [@romero2021infaas] illustrates this approach by optimizing accuracy-latency trade-offs across variant models.

1. **Request scheduling and batching**: Efficiently manages incoming ML inference requests, optimizing performance through smart queuing and grouping strategies. Systems like Clipper [@crankshaw2017clipper] introduce low-latency online prediction serving with caching and batching techniques.
2. **Model instance selection and routing**: Intelligent algorithms direct requests to appropriate model versions or instances. INFaaS [@romero2021infaas] explores this by generating model-variants and efficiently navigating the trade-off space based on performance and accuracy requirements.
3. **Load balancing**: Distributes workloads evenly across multiple serving instances. MArk (Model Ark) [@zhang2019mark] demonstrates effective load balancing techniques for ML serving systems.
4. **Model instance autoscaling**: Dynamically adjusts capacity based on demand. Both INFaaS [@romero2021infaas] and MArk [@zhang2019mark] incorporate autoscaling capabilities to handle workload fluctuations efficiently.
5. **Model orchestration**: Manages model execution, enabling parallel processing and strategic resource allocation. AlpaServe [@li2023alpaserve] demonstrates advanced techniques for handling large models and complex serving scenarios.
6. **Execution time prediction**: Systems like Clockwork [@gujarati2020serving] focus on high-performance serving by predicting execution times of individual inferences and efficiently using hardware accelerators.

In more complex inference scenarios, model orchestration coordinates the execution of multi-stage models or distributed components. AlpaServe [@li2023alpaserve] exemplifies this by enabling efficient serving of large foundation models through coordinated resource allocation. Finally, execution time prediction enables systems to anticipate latency for individual requests. Clockwork [@gujarati2020serving] uses this capability to reduce tail latency and improve scheduling efficiency under high load.

While these systems differ in implementation, they collectively illustrate the critical techniques that underpin scalable and responsive ML-as-a-Service infrastructure. @tbl-serving-techniques summarizes these strategies and highlights representative systems that implement them.

+------------------------------+--------------------------------------------------------------------------------+-----------------+
| Technique                    | Description                                                                    | Example System  |
+:=============================+:===============================================================================+:================+
| Request Scheduling & Batching| Groups inference requests to improve throughput and reduce overhead            | Clipper         |
+------------------------------+--------------------------------------------------------------------------------+-----------------+
| Instance Selection & Routing | Dynamically assigns requests to model variants based on constraints            | INFaaS          |
+------------------------------+--------------------------------------------------------------------------------+-----------------+
| Load Balancing               | Distributes traffic across replicas to prevent bottlenecks                     | MArk            |
+------------------------------+--------------------------------------------------------------------------------+-----------------+
| Autoscaling                  | Adjusts model instances to match workload demands                              | INFaaS, MArk    |
+------------------------------+--------------------------------------------------------------------------------+-----------------+
| Model Orchestration          | Coordinates execution across model components or pipelines                     | AlpaServe       |
+------------------------------+--------------------------------------------------------------------------------+-----------------+
| Execution Time Prediction    | Forecasts latency to optimize request scheduling                               | Clockwork       |
+------------------------------+--------------------------------------------------------------------------------+-----------------+

: Serving system techniques and example implementations. {#tbl-serving-techniques .striped .hover}

Together, these strategies form the foundation of robust model serving systems. When effectively integrated, they enable machine learning applications to meet performance targets while maintaining system-level efficiency and scalability.

### Infrastructure and Observability {#sec-ml-operations-infrastructure-observability-dd74}

The operational stability of a machine learning system depends on the robustness of its underlying infrastructure. Compute, storage, and networking resources must be provisioned, configured, and scaled to accommodate training workloads, deployment pipelines, and real-time inference. Beyond infrastructure provisioning, effective observability practices ensure that system behavior can be monitored, interpreted, and acted upon as conditions change.

#### Infrastructure Management {#sec-ml-operations-infrastructure-management-12f7}

Scalable, resilient infrastructure is a foundational requirement for operationalizing machine learning systems. As models move from experimentation to production, MLOps teams must ensure that the underlying computational resources can support continuous integration, large-scale training, automated deployment, and real-time inference. This requires managing infrastructure not as static hardware, but as a dynamic, programmable, and versioned system.

To achieve this, teams adopt the practice of Infrastructure as Code (IaC), which allows infrastructure to be defined, deployed, and maintained using declarative configuration files. Tools such as [Terraform](https://www.terraform.io/), [AWS CloudFormation](https://aws.amazon.com/cloudformation/), and [Ansible](https://www.ansible.com/) support this paradigm by enabling teams to version infrastructure definitions alongside application code. In MLOps settings, Terraform is widely used to provision and manage resources across public cloud platforms such as [AWS](https://aws.amazon.com/), [Google Cloud Platform](https://cloud.google.com/), and [Microsoft Azure](https://azure.microsoft.com/).

Infrastructure management spans the full lifecycle of ML systems. During model training, teams use IaC scripts to allocate compute instances with GPU or TPU accelerators, configure distributed storage, and deploy container clusters. These configurations ensure that data scientists and ML engineers can access reproducible environments with the required computational capacity. Because infrastructure definitions are stored as code, they can be audited, reused, and integrated into CI/CD pipelines to ensure consistency across environments.

Containerization plays a critical role in making ML workloads portable and consistent. Tools like [Docker](https://www.docker.com/) encapsulate models and their dependencies into isolated units, while orchestration systems such as [Kubernetes](https://kubernetes.io/) manage containerized workloads across clusters. These systems enable rapid deployment, resource allocation, and scaling—capabilities that are essential in production environments where workloads can vary dynamically.

To handle changes in workload intensity, including spikes during hyperparameter tuning and surges in prediction traffic, teams rely on cloud elasticity and autoscaling. Cloud platforms support on-demand provisioning and horizontal scaling of infrastructure resources. [Autoscaling mechanisms](https://aws.amazon.com/autoscaling/) automatically adjust compute capacity based on usage metrics, enabling teams to optimize for both performance and cost-efficiency.

Importantly, infrastructure in MLOps is not limited to the cloud. Many deployments span on-premises, cloud, and edge environments, depending on latency, privacy, or regulatory constraints. A robust infrastructure management strategy must accommodate this diversity by offering flexible deployment targets and consistent configuration management across environments.

To illustrate, consider a scenario in which a team uses Terraform to deploy a Kubernetes cluster on Google Cloud Platform. The cluster is configured to host containerized TensorFlow models that serve predictions via HTTP APIs. As user demand increases, Kubernetes automatically scales the number of pods to handle the load. Meanwhile, CI/CD pipelines update the model containers based on retraining cycles, and monitoring tools track cluster performance, latency, and resource utilization. All infrastructure components, ranging from network configurations to compute quotas, are managed as version-controlled code, ensuring reproducibility and auditability.

By adopting Infrastructure as Code, leveraging cloud-native orchestration, and supporting automated scaling, MLOps teams gain the ability to provision and maintain the resources required for machine learning at production scale. This infrastructure layer underpins the entire MLOps stack, enabling reliable training, deployment, and serving workflows.

#### Monitoring Systems {#sec-ml-operations-monitoring-systems-ec8b}

Monitoring is a critical function in MLOps, enabling teams to maintain operational visibility over machine learning systems deployed in production. Once a model is live, it becomes exposed to real-world inputs, evolving data distributions, and shifting user behavior. Without continuous monitoring, it becomes difficult to detect performance degradation, data quality issues, or system failures in a timely manner.

Effective monitoring spans both model behavior and infrastructure performance. On the model side, teams track metrics such as accuracy, precision, recall, and the [confusion matrix](https://scikit-learn.org/stable/auto_examples/model_selection/plot_confusion_matrix.html) using live or sampled predictions. By evaluating these metrics over time, they can detect whether the model's performance remains stable or begins to drift.

One of the primary risks in production ML systems is model drift—a gradual decline in model performance as the input data distribution or the relationship between inputs and outputs changes. Drift manifests in two main forms:

- Concept drift occurs when the underlying relationship between features and targets evolves. For example, during the COVID-19 pandemic, purchasing behavior shifted dramatically, invalidating many previously accurate recommendation models.
- Data drift refers to shifts in the input data distribution itself. In applications such as self-driving cars, this may result from seasonal changes in weather, lighting, or road conditions, all of which affect the model's inputs.

In addition to model-level monitoring, infrastructure-level monitoring tracks indicators such as CPU and GPU utilization, memory and disk consumption, network latency, and service availability. These signals help ensure that the system remains performant and responsive under varying load conditions. Tools such as [Prometheus](https://prometheus.io/), [Grafana](https://grafana.com/), and [Elastic](https://www.elastic.co/) are widely used to collect, aggregate, and visualize operational metrics. These tools often integrate into dashboards that offer real-time and historical views of system behavior.

Proactive alerting mechanisms are configured to notify teams when anomalies or threshold violations occur. For example, a sustained drop in model accuracy may trigger an alert to investigate potential drift, prompting retraining with updated data. Similarly, infrastructure alerts can signal memory saturation or degraded network performance, allowing engineers to take corrective action before failures propagate.

Ultimately, robust monitoring enables teams to detect problems before they escalate, maintain high service availability, and preserve the reliability and trustworthiness of machine learning systems. In the absence of such practices, models may silently degrade or systems may fail under load, undermining the effectiveness of the ML pipeline as a whole.

:::{#vid-monitoring .callout-important title="Model Monitoring"}
::: {.content-visible when-format="html"}
{{< video https://www.youtube.com/watch?v=hq_XyP9y0xg&list=PLkDaE6sCZn6GMoA0wbpJLi3t34Gd8l0aK&index=7 >}}
:::

::: {.content-visible when-format="pdf"}
\marginnote{\centering\\\vspace*{-25mm}%
  \parbox{30mm}{\centering\footnotesize%
    \textbf{Watch on YouTube}\\
    Model Monitoring\\[1mm]
  }
  \begingroup
    \hypersetup{urlcolor=black}
    \qrcode[height=15mm]{https://www.youtube.com/watch?v=hq_XyP9y0xg&list=PLkDaE6sCZn6GMoA0wbpJLi3t34Gd8l0aK&index=7}
  \endgroup
  \\[1mm]
  \parbox{25mm}{\centering\footnotesize%
    Scan with your phone\\
    to watch the video
  }
}

\faTv{} [Watch on YouTube](https://www.youtube.com/watch?v=hq_XyP9y0xg&list=PLkDaE6sCZn6GMoA0wbpJLi3t34Gd8l0aK&index=7)
:::
:::

### Governance and Collaboration {#sec-ml-operations-governance-collaboration-bc3f}

#### Model Governance {#sec-ml-operations-model-governance-4027}

As machine learning systems become increasingly embedded in decision-making processes, governance has emerged as a critical pillar of MLOps. Governance refers to the policies, practices, and tools used to ensure that models are transparent, fair, accountable, and compliant with ethical standards and regulatory requirements. Without proper governance, deployed models may produce biased or opaque decisions, leading to significant legal, reputational, and societal risks.

Governance begins during the model development phase, where teams implement techniques to increase transparency and explainability. For example, methods such as [SHAP](https://github.com/slundberg/shap) and [LIME](https://github.com/marcotcr/lime) offer post hoc explanations of model predictions by identifying which input features were most influential in a particular decision. These techniques allow auditors, developers, and non-technical stakeholders to better understand how and why a model behaves the way it does.

In addition to interpretability, fairness is a central concern in governance. Bias detection tools analyze model outputs across different demographic groups, including those defined by age, gender, or ethnicity, to identify disparities in performance. For instance, a model used for loan approval should not systematically disadvantage certain populations. MLOps teams employ pre-deployment audits on curated, representative datasets to evaluate fairness, robustness, and overall model behavior before a system is put into production.

Governance also extends into the post-deployment phase. As introduced in the previous section on monitoring, teams must track for concept drift, where the statistical relationships between features and labels evolve over time. Such drift can undermine the fairness or accuracy of a model, particularly if the shift disproportionately affects a specific subgroup. By analyzing logs and user feedback, teams can identify recurring failure modes, unexplained model outputs, or emerging disparities in treatment across user segments.

Supporting this lifecycle approach to governance are platforms and toolkits that integrate governance functions into the broader MLOps stack. For example, [Watson OpenScale](https://www.ibm.com/cloud/watson-openscale) provides built-in modules for explainability, bias detection, and monitoring. These tools allow governance policies to be encoded as part of automated pipelines, ensuring that checks are consistently applied throughout development, evaluation, and production.

Ultimately, governance focuses on three core objectives: transparency, fairness, and compliance. Transparency ensures that models are interpretable and auditable. Fairness promotes equitable treatment across user groups. Compliance ensures alignment with legal and organizational policies. Embedding governance practices throughout the MLOps lifecycle transforms machine learning from a technical artifact into a trustworthy system capable of serving societal and organizational goals.

#### Cross-Functional Collaboration {#sec-ml-operations-crossfunctional-collaboration-0f4b}

Machine learning systems are developed and maintained by multidisciplinary teams, including data scientists, ML engineers, software developers, infrastructure specialists, product managers, and compliance officers. As these roles span different domains of expertise, effective communication and collaboration are essential to ensure alignment, efficiency, and system reliability. MLOps fosters this cross-functional integration by introducing shared tools, processes, and artifacts that promote transparency and coordination across the machine learning lifecycle.

Collaboration begins with consistent tracking of experiments, model versions, and metadata. Tools such as [MLflow](https://mlflow.org/) provide a structured environment for logging experiments, capturing parameters, recording evaluation metrics, and managing trained models through a centralized registry. This registry serves as a shared reference point for all team members, enabling reproducibility and easing handoff between roles. Integration with version control systems such as [GitHub](https://github.com/) and [GitLab](https://about.gitlab.com/) further streamlines collaboration by linking code changes with model updates and pipeline triggers.

In addition to tracking infrastructure, teams benefit from platforms that support exploratory collaboration. [Weights & Biases](https://wandb.ai/) is one such platform that allows data scientists to visualize experiment metrics, compare training runs, and share insights with peers. Features such as live dashboards and experiment timelines facilitate discussion and decision-making around model improvements, hyperparameter tuning, or dataset refinements. These collaborative environments reduce friction in model development by making results interpretable and reproducible across the team.

Beyond model tracking, collaboration also depends on shared understanding of data semantics and usage. Establishing common data contexts, by means of glossaries, data dictionaries, schema references, and lineage documentation, ensures that all stakeholders interpret features, labels, and statistics consistently. This is particularly important in large organizations, where data pipelines may evolve independently across teams or departments.

For example, a data scientist working on an anomaly detection model may use Weights & Biases to log experiment results and visualize performance trends. These insights are shared with the broader team to inform feature engineering decisions. Once the model reaches an acceptable performance threshold, it is registered in MLflow along with its metadata and training lineage. This allows an ML engineer to pick up the model for deployment without ambiguity about its provenance or configuration.

By integrating collaborative tools, standardized documentation, and transparent experiment tracking, MLOps removes communication barriers that have traditionally slowed down ML workflows. It enables distributed teams to operate cohesively, accelerating iteration cycles and improving the reliability of deployed systems.

:::{#vid-deploy .callout-important title="Deployment Challenges"}
::: {.content-visible when-format="html"}
{{< video https://www.youtube.com/watch?v=UyEtTyeahus&list=PLkDaE6sCZn6GMoA0wbpJLi3t34Gd8l0aK&index=5 >}}
:::

::: {.content-visible when-format="pdf"}
\marginnote{\centering\\\vspace*{-25mm}%
  \parbox{30mm}{\centering\footnotesize%
    \textbf{Watch on YouTube}\\
    Deployment Challenges\\[1mm]
  }
  \begingroup
    \hypersetup{urlcolor=black}
    \qrcode[height=15mm]{https://www.youtube.com/watch?v=UyEtTyeahus&list=PLkDaE6sCZn6GMoA0wbpJLi3t34Gd8l0aK&index=5}
  \endgroup
  \\[1mm]
  \parbox{25mm}{\centering\footnotesize%
    Scan with your phone\\
    to watch the video
  }
}

\faTv{} [Watch on YouTube](https://www.youtube.com/watch?v=UyEtTyeahus&list=PLkDaE6sCZn6GMoA0wbpJLi3t34Gd8l0aK&index=5)
:::
:::

## Hidden Technical Debt {#sec-ml-operations-hidden-technical-debt-acaf}

As machine learning systems mature and scale, they often accumulate technical debt—the long-term cost of expedient design decisions made during development. Originally proposed in software engineering in the 1990s, the technical debt metaphor compares shortcuts in implementation to financial debt: it may enable short-term velocity, but requires ongoing interest payments in the form of maintenance, refactoring, and systemic risk. While some debt is strategic and manageable, uncontrolled technical debt can inhibit flexibility, slow iteration, and introduce brittleness into production systems.

In machine learning, technical debt takes on new and less visible forms, arising not only from software abstractions but also from data dependencies, model entanglement, feedback loops, and evolving operational environments. The complexity of ML systems, which encompass data ingestion, feature extraction, training pipelines, and deployment infrastructure, makes them especially prone to hidden forms of debt [@sculley2015hidden].

@fig-technical-debt provides a conceptual overview of the relative size and interdependence of components in an ML system. The small black box in the center represents the model code itself—a surprisingly small portion of the overall system. Surrounding it are much larger components: configuration, data collection, and feature engineering. These areas, though often overlooked, are critical to system functionality and are major sources of technical debt when poorly designed or inconsistently maintained.

::: {#fig-technical-debt fig-env="figure" fig-pos="htb"}
```{.tikz}
\scalebox{0.65}{%
\begin{tikzpicture}[line join=round,font=\small\usefont{T1}{phv}{m}{n}]
\definecolor{Siva}{RGB}{161,152,130}
\tikzset{%
planet/.style = {circle, draw=none,
semithick, fill=blue!30,
                    font=\usefont{T1}{phv}{m}{n}\bfseries, ball color=green!70!blue!70,shading angle=-15,
                    text width=27mm, inner sep=1mm,align=center},
satellite/.style = {circle, draw=#1, semithick, fill=#1!30,
                    text width=18mm, inner sep=1pt, align=flush center,minimum size=21mm},%<---
arr/.style = {-{Triangle[length=3mm,width=6mm]}, color=#1,
                    line width=3mm, shorten <=1mm, shorten >=1mm}
}
%planet
\node (p)   [planet]    {ML system};
%satellites
\foreach \i/\j [count=\k] in {red/{Machine Resource Management},
cyan/{Configuration},
purple/{Data Collection},
green/{Data Verification},
orange/{Serving Infrastructure},
yellow/{Monitoring},
Siva/{Feature Extraction},
magenta/{ML Code},
violet/{Analysis Tools},
teal/{Process Management Tools}
}
%connections
{
\node (s\k) [satellite=\i,font=\footnotesize\usefont{T1}{phv}{m}{n}] at (\k*36:3.8) {\j};
\draw[arr=\i] (p) -- (s\k);
}
\end{tikzpicture}}
```
ML system components. Source: @sculley2015hidden
:::

The sections that follow describe key categories of technical debt unique to ML systems. Each subsection highlights common sources, illustrative examples, and potential mitigations. While some forms of debt may be unavoidable during early development, understanding their causes and impact is essential for building robust and maintainable ML systems.

### Boundary Erosion {#sec-ml-operations-boundary-erosion-021d}

In traditional software systems, modularity and abstraction provide clear boundaries between components, allowing changes to be isolated and behavior to remain predictable. Machine learning systems, in contrast, tend to blur these boundaries. The interactions between data pipelines, feature engineering, model training, and downstream consumption often lead to tightly coupled components with poorly defined interfaces.

This erosion of boundaries makes ML systems particularly vulnerable to cascading effects from even minor changes. A seemingly small update to a preprocessing step or feature transformation can propagate through the system in unexpected ways, breaking assumptions made elsewhere in the pipeline. This lack of encapsulation increases the risk of entanglement, where dependencies between components become so intertwined that local modifications require global understanding and coordination.

One manifestation of this problem is known as CACE---“Changing Anything Changes Everything.” When systems are built without strong boundaries, adjusting a feature encoding, model hyperparameter, or data selection criterion can affect downstream behavior in unpredictable ways. This inhibits iteration and makes testing and validation more complex. For example, changing the binning strategy of a numerical feature may cause a previously tuned model to underperform, triggering retraining and downstream evaluation changes.

To mitigate boundary erosion, teams should prioritize architectural practices that support modularity and encapsulation. Designing components with well-defined interfaces allows teams to isolate faults, reason about changes, and reduce the risk of system-wide regressions. For instance, clearly separating data ingestion from feature engineering, and feature engineering from modeling logic, introduces layers that can be independently validated, monitored, and maintained.

Boundary erosion is often invisible in early development but becomes a significant burden as systems scale or require adaptation. Proactive design decisions that preserve abstraction and limit interdependencies are essential to managing complexity and avoiding long-term maintenance costs.

### Correction Cascades {#sec-ml-operations-correction-cascades-1cb9}

As machine learning systems evolve, they often undergo iterative refinement to address performance issues, accommodate new requirements, or adapt to environmental changes. In well-engineered systems, such updates are localized and managed through modular changes. However, in ML systems, even small adjustments can trigger correction cascades—a sequence of dependent fixes that propagate backward and forward through the workflow.

@fig-correction-cascades-flowchart illustrates how these cascades emerge across different stages of the ML lifecycle, from problem definition and data collection to model development and deployment. Each arc represents a corrective action, and the colors indicate different sources of instability, including inadequate domain expertise, brittle real-world interfaces, misaligned incentives, and insufficient documentation. The red arrows represent cascading revisions, while the dotted arrow at the bottom highlights a full system restart—a drastic but sometimes necessary outcome.

::: {#fig-correction-cascades-flowchart fig-env="figure" fig-pos="htb"}
```{.tikz}
\begin{tikzpicture}[line join=round,font=\small\usefont{T1}{phv}{m}{n}]
\definecolor{Green}{RGB}{84,180,53}
\definecolor{Red}{RGB}{249,56,39}
\definecolor{Orange}{RGB}{255,157,35}
\definecolor{Blue}{RGB}{0,97,168}
\definecolor{Violet}{RGB}{178,108,186}

\tikzset{%
Line/.style={line width=1.0pt,black!50,shorten <=6pt,shorten >=8pt},
LineD/.style={line width=2.0pt,black!50,shorten <=6pt,shorten >=8pt},
Text/.style={rotate=60,align=right,anchor=north east,font=\footnotesize\usefont{T1}{phv}{m}{n}},
Text2/.style={align=left,anchor=north west,font=\footnotesize\usefont{T1}{phv}{m}{n},text depth=0.7}
}

\draw[line width=1.5pt,black!30](0,0)coordinate(P)--(10,0)coordinate(K);

 \foreach \i in {0,...,6} {
\path let \n1 = {(\i/6)*10} in coordinate (P\i) at (\n1,0);
\fill[black] (P\i) circle (2pt);
  }

\draw[LineD,Red](P0)to[out=60,in=120](P6);
\draw[LineD,Red](P0)to[out=60,in=125](P5);
\draw[LineD,Blue](P1)to[out=60,in=120](P6);
\draw[LineD,Red](P1)to[out=50,in=125](P6);
\draw[LineD,Blue](P4)to[out=60,in=125](P6);
\draw[LineD,Blue](P3)to[out=60,in=120](P6);
%
\draw[Line,Orange](P1)to[out=44,in=132](P6);
\draw[Line,Green](P1)to[out=38,in=135](P6);
\draw[Line,Orange](P1)to[out=30,in=135](P5);
\draw[Line,Green](P1)to[out=36,in=130](P5);
%
\draw[Line,Orange](P2)to[out=40,in=135](P6);
\draw[Line,Orange](P2)to[out=40,in=135](P5);
%
\draw[draw=none,fill=VioletLine!50]($(P5)+(-0.1,0.15)$)to[bend left=10]($(P5)+(0-0.1,0.61)$)--
                ($(P5)+(-0.25,0.50)$)--($(P5)+(-0.85,1.20)$)to[bend left=20]($(P5)+(-1.38,0.76)$)--
                ($(P5)+(-0.51,0.33)$)to[bend left=10]($(P5)+(-0.64,0.22)$)to[bend left=10]cycle;
\draw[draw=none,fill=VioletLine!50]($(P6)+(-0.1,0.15)$)to[bend left=10]($(P6)+(0-0.1,0.61)$)--
                ($(P6)+(-0.25,0.50)$)--($(P6)+(-0.7,1.30)$)to[bend left=20]($(P6)+(-1.38,0.70)$)--
                ($(P6)+(-0.51,0.33)$)to[bend left=10]($(P6)+(-0.64,0.22)$)to[bend left=10]cycle;
%
\draw[dashed,red,thick,-latex](P1)--++(90:2)to[out=90,in=0](0.8,2.7);
\draw[dashed,red,thick,-latex](P6)--++(90:2)to[out=90,in=0](9.1,2.7);
\node[below=0.1of P0,Text]{Problem\\ Statement};
\node[below=0.1of P1,Text]{Data collection \\and labeling};
\node[below=0.1of P2,Text]{Data analysis\\ and cleaning};
\node[below=0.1of P3,Text]{Model \\selection};
\node[below=0.1of P4,Text]{Model\\ training};
\node[below=0.1of P5,Text]{Model\\ evaluation};
\node[below=0.1of P6,Text]{Model\\ deployment};
%Legend
\node[circle,minimum size=4pt,fill=Blue](L1)at(11.5,2.6){};
\node[above right=0.1 and 0.1of L1,Text2]{Interacting with physical\\  world brittleness};
\node[circle,minimum size=4pt,fill=Red,below =0.5 of L1](L2){};
\node[above right=0.1 and 0.1of L2,Text2]{Inadequate \\application-domain expertise};
\node[circle,minimum size=4pt,fill=Green,below =0.5 of L2](L3){};
\node[above right=0.1 and 0.1of L3,Text2]{Conflicting reward\\ systems};
\node[circle,minimum size=4pt,fill=Orange,below =0.5 of L3](L4){};
\node[above right=0.1 and 0.1of L4,Text2]{Poor cross-organizational\\ documentation};
\draw[-{Triangle[width=8pt,length=8pt]}, line width=3pt,Violet](11.4,-0.85)--++(0:0.8)coordinate(L5);
\node[above right=0.23 and 0of L5,Text2]{Impacts of cascades};
\draw[-{Triangle[width=4pt,length=8pt]}, line width=2pt,Red,dashed](11.4,-1.35)--++(0:0.8)coordinate(L6);
\node[above right=0.23 and 0of L6,Text2]{Abandon / re-start process};
 \end{tikzpicture}
```
Correction cascades flowchart.
:::

One common source of correction cascades is sequential model development—reusing or fine-tuning existing models to accelerate development for new tasks. While this strategy is often efficient, it can introduce hidden dependencies that are difficult to unwind later. Assumptions baked into earlier models become implicit constraints for future models, limiting flexibility and increasing the cost of downstream corrections.

Consider a scenario where a team fine-tunes a customer churn prediction model for a new product. The original model may embed product-specific behaviors or feature encodings that are not valid in the new setting. As performance issues emerge, teams may attempt to patch the model, only to discover that the true problem lies several layers upstream—perhaps in the original feature selection or labeling criteria.

To avoid or reduce the impact of correction cascades, teams must make careful tradeoffs between reuse and redesign. Several factors influence this decision. For small, static datasets, fine-tuning may be appropriate. For large or rapidly evolving datasets, retraining from scratch provides greater control and adaptability. Fine-tuning also requires fewer computational resources, making it attractive in constrained settings. However, modifying foundational components later becomes extremely costly due to these cascading effects.

Therefore, careful consideration should be given to introducing fresh model architectures, even if resource-intensive, to avoid correction cascades down the line. This approach may help mitigate the amplifying effects of issues downstream and reduce technical debt. However, there are still scenarios where sequential model building makes sense, necessitating a thoughtful balance between efficiency, flexibility, and long-term maintainability in the ML development process.

### Undeclared Consumers {#sec-ml-operations-undeclared-consumers-feca}

Machine learning systems often provide predictions or outputs that serve as inputs to other services, pipelines, or downstream models. In traditional software, these connections are typically made explicit through APIs, service contracts, or documented dependencies. In ML systems, however, it is common for model outputs to be consumed by undeclared consumers—downstream components that rely on predictions without being formally tracked or validated.

This lack of visibility introduces a subtle but serious form of technical debt. Because these consumers are not declared or governed by explicit interfaces, updates to the model, including changes in output format, semantics, or feature behavior, can silently break downstream functionality. The original model was not designed with these unknown consumers in mind, so its evolution risks unintended consequences across the broader system.

The situation becomes more problematic when these downstream consumers feed back into the original model's training data. This introduces feedback loops that are difficult to detect and nearly impossible to reason about analytically. For instance, if a model's output is used in a recommendation system and user behavior is influenced by those recommendations, future training data becomes contaminated by earlier predictions. Such loops can distort model behavior, create self-reinforcing biases, and mask performance regressions.

One example might involve a credit scoring model whose outputs are consumed by a downstream eligibility engine. If the eligibility system later influences which applicants are accepted, which, in turn, affects the label distribution in the next training cycle, the model is now shaping the very data on which it will be retrained.

To mitigate the risks associated with undeclared consumers, teams should begin by implementing strict access controls to limit who or what can consume model outputs. Rather than making predictions broadly available, systems should expose outputs only through well-defined interfaces, ensuring that their use can be monitored and audited. In addition, establishing formal interface contracts, which include documented schemas, value ranges, and semantic expectations, helps enforce consistent behavior across components and reduces the likelihood of misinterpretation. Monitoring and logging mechanisms can provide visibility into where and how predictions are used, revealing dependencies that may not have been anticipated during development. Finally, architectural decisions should emphasize system boundaries that encapsulate model behavior, thereby isolating changes and minimizing the risk of downstream entanglement. Together, these practices support a more disciplined and transparent approach to system integration, reducing the likelihood of costly surprises as ML systems evolve.

### Data Dependency Debt {#sec-ml-operations-data-dependency-debt-60e8}

Machine learning systems rely heavily on data pipelines that ingest, transform, and deliver training and inference inputs. Over time, these pipelines often develop implicit and unstable dependencies that become difficult to trace, validate, or manage—leading to what is known as data dependency debt. This form of debt is particularly challenging because it tends to accumulate silently and may only become visible when a downstream model fails unexpectedly due to changes in upstream data.

In traditional software systems, compilers, static analysis tools, and dependency checkers help engineers track and manage code-level dependencies. These tools enable early detection of unused imports, broken interfaces, and type mismatches. However, ML systems typically lack equivalent tooling for analyzing data dependencies, which include everything from feature generation scripts and data joins to external data sources and labeling conventions. Without such tools, changes to even a single feature or schema can ripple across a system without warning.

Two common forms of data dependency debt are unstable inputs and underutilized inputs. Unstable inputs refer to data sources that change over time, whether in content, structure, or availability, leading to inconsistent model behavior. A model trained on one version of a feature may produce unexpected results when that feature's distribution or encoding changes. Underutilized inputs refer to data elements included in training pipelines that have little or no impact on model performance. These features increase complexity, slow down processing, and increase the surface area for bugs, yet provide little return on investment.

One approach to managing unstable dependencies is to implement robust data versioning. By tracking which data snapshot was used for training a given model, teams can reproduce results and isolate regressions. However, versioning also introduces overhead: multiple versions must be stored, managed, and tested for staleness. For underutilized inputs, a common strategy is to run leave-one-feature-out evaluations, where features are systematically removed to assess their contribution to model performance. This analysis can guide decisions about whether to simplify the feature set or deprecate unused data streams.

Addressing data dependency debt requires both architectural discipline and appropriate tooling. ML systems must be designed with traceability in mind—recording not just what data was used, but where it came from, how it was transformed, and how it affected model behavior. For example, consider an e-commerce platform that includes a "days since last login" feature in its churn prediction model. If the meaning of this feature changes, for instance, if a platform redesign results in users being automatically logged in through a companion app, the input distribution will shift, potentially degrading model performance. Without explicit tracking and validation of this data dependency, the issue might go unnoticed until accuracy metrics decline in production. As systems scale, unexamined data dependencies like these become a major source of brittleness and drift. Investing in structured data practices early in the lifecycle, including schema validation, lineage tracking, and dependency testing, can help prevent these issues from compounding over time.

### Feedback Loops {#sec-ml-operations-feedback-loops-d281}

Unlike traditional software systems, machine learning models have the capacity to influence their own future behavior through the data they help generate. This dynamic creates feedback loops, where model predictions shape future inputs, often in subtle and difficult-to-detect ways. When unaddressed, these loops introduce a unique form of technical debt: the inability to analyze and reason about model behavior over time, leading to what is known as feedback loop analysis debt.

Feedback loops in ML systems can be either direct or indirect. A direct feedback loop occurs when a model's outputs directly affect future training data. For example, in an online recommendation system, the items a model suggests may strongly influence user clicks and, consequently, the labeled data used for retraining. If the model consistently promotes a narrow subset of items, it may bias the training set over time, reinforcing its own behavior and reducing exposure to alternative signals.

Indirect or hidden feedback loops arise when two or more systems interact with one another, frequently via real-world processes, without clear visibility into their mutual influence. For instance, consider two separate ML models deployed by a financial institution: one predicts credit risk, and the other recommends credit offers. If the output of the second model implicitly affects the population that is later scored by the first, a feedback loop is created without any explicit connection between the two systems. These loops are especially dangerous because they bypass traditional validation frameworks and may take weeks or months to manifest.

Feedback loops undermine assumptions about data independence and stationarity. They can mask model degradation, introduce long-term bias, and lead to unanticipated performance failures. Because most ML validation is performed offline with static datasets, these dynamic interactions are difficult to detect before deployment.

Several mitigation strategies exist, though none are comprehensive. Careful monitoring of model performance across cohorts and over time can help reveal the emergence of loop-induced drift. Canary deployments[^fn-canary-deployment] allow teams to test new models on a small subset of traffic and observe behavior before full rollout. More fundamentally, architectural practices that reduce coupling between system components, including the isolation of decision-making logic from user-facing outcomes, can help minimize the propagation of influence.

[^fn-canary-deployment]: **Canary deployment:** A strategy to reduce risk by rolling out changes to a small subset of users before full-scale implementation.

Ultimately, feedback loops reflect a deeper challenge in ML system design: models do not operate in isolation, but in dynamic environments where their outputs alter future inputs. Reducing analysis debt[^fn-analysis-debt] requires designing systems with these dynamics in mind and embedding mechanisms to detect and manage self-influencing behavior over time.

[^fn-analysis-debt]: The effort to manage and mitigate increases in complexity and costs in understanding and modifying systems over time.

### Pipeline Debt {#sec-ml-operations-pipeline-debt-2f4c}

As machine learning workflows grow in scope, teams often assemble pipelines that stitch together multiple components—data ingestion, feature extraction, model training, evaluation, and deployment. In the absence of standard interfaces or modular abstractions, these pipelines tend to evolve into ad hoc constructions of custom scripts, manual processes, and undocumented assumptions. Over time, this leads to pipeline debt: a form of technical debt arising from complexity, fragility, and a lack of reusability in ML workflows.

This problem is often described as the emergence of a “pipeline jungle,” where modifications become difficult, and experimentation is constrained by brittle interdependencies. When teams are reluctant to refactor fragile pipelines, they resort to building alternate versions for new use cases or experiments. As these variations accumulate, so do inconsistencies in data processing, metric computation, and configuration management. The result is duplication, reduced efficiency, and a growing risk of errors.

Consider a real-world scenario where a team maintains multiple models that rely on different but overlapping preprocessing pipelines. One model applies text normalization using simple lowercasing, while another uses a custom tokenization library. Over time, discrepancies emerge in behavior, leading to conflicting evaluation metrics and unexpected model drift. As new models are introduced, developers are unsure which pipeline to reuse or modify, and duplications multiply.

Pipeline debt also limits collaboration across teams. Without well-defined interfaces or shared abstractions, it becomes difficult to exchange components or adopt best practices. Team members often need to reverse-engineer pipeline logic, slowing onboarding and increasing the risk of introducing regressions.

The most effective way to manage pipeline debt is to embrace modularity and encapsulation. Well-architected pipelines define clear inputs, outputs, and transformation logic, often expressed through workflow orchestration tools such as [Apache Airflow](https://airflow.apache.org/), [Prefect](https://www.prefect.io/), or [Kubeflow Pipelines](https://www.kubeflow.org/docs/components/pipelines/). These tools help teams formalize processing steps, track lineage, and monitor execution.

In addition, the adoption of shared libraries for feature engineering, transformation functions, and evaluation metrics promotes consistency and reuse. Teams can isolate logic into composable units that can be independently tested, versioned, and integrated across models. This reduces the risk of technical lock-in and enables more agile development as systems evolve.

Ultimately, pipeline debt reflects a breakdown in software engineering rigor applied to ML workflows. Investing in interfaces, documentation, and shared tooling not only improves maintainability but also unlocks faster experimentation and system scalability.

### Configuration Debt {#sec-ml-operations-configuration-debt-ad03}

Configuration is a critical yet often undervalued component of machine learning systems. Tuning parameters such as learning rates, regularization strengths, model architectures, feature processing options, and evaluation thresholds all require deliberate management. However, in practice, configurations are frequently introduced in an ad hoc manner—manually adjusted during experimentation, inconsistently documented, and rarely versioned. This leads to the accumulation of configuration debt: the technical burden resulting from fragile, opaque, and outdated settings that undermine system reliability and reproducibility.

When configuration debt accumulates, several challenges emerge. Fragile configurations may contain implicit assumptions about data distributions, training schedules, or pipeline structure that no longer hold as the system evolves. In the absence of proper documentation, these assumptions become embedded in silent defaults—settings that function in development but fail in production. Teams may hesitate to modify these configurations out of fear of introducing regressions, further entrenching the problem. Additionally, when configurations are not centrally tracked, knowledge about what parameters work well becomes siloed within individuals or specific notebooks, leading to redundant experimentation and slowed iteration.

For example, consider a team deploying a neural network for customer segmentation. During development, one data scientist improves performance by tweaking several architectural parameters, by adding layers, changing activation functions, and adjusting batch sizes, but these changes are stored locally and never committed to the shared configuration repository. Months later, the model is retrained on new data, but the performance degrades unexpectedly. Without a consistent record of previous configurations, the team struggles to identify what changed. The lack of traceability not only delays debugging but also undermines confidence in the reproducibility of prior results.

Mitigating configuration debt requires integrating configuration management into the ML system lifecycle. Teams should adopt structured formats, including YAML, JSON, and domain-specific configuration frameworks, and store them in version-controlled repositories alongside model code. Validating configurations as part of the training and deployment process ensures that unexpected or invalid parameter settings are caught early. Automated tools for hyperparameter optimization and neural architecture search further reduce reliance on manual tuning and help standardize configuration discovery.

Above all, ML systems benefit when configuration is treated not as a side effect of experimentation, but as a first-class system component. Like code, configurations must be tested, documented, and maintained. Doing so enables faster iteration, easier debugging, and more reliable system behavior over time.

### Early-Stage Debt {#sec-ml-operations-earlystage-debt-a7ea}

In the early phases of machine learning development, teams often move quickly to prototype models, experiment with data sources, and explore modeling approaches. During this stage, speed and flexibility are critical, and some level of technical debt is expected and even necessary to support rapid iteration. However, the decisions made in these early stages, particularly when motivated by urgency instead of design, can introduce early-stage debt that becomes increasingly difficult to manage as the system matures.

This form of debt often stems from shortcuts in code organization, data preprocessing, feature engineering, or model packaging. Pipelines may be built without clear abstractions, evaluation scripts may lack reproducibility, and configuration files may be undocumented or fragmented. While such practices may be justified in the exploratory phase, they become liabilities once the system enters production or needs to scale across teams and use cases.

For example, a startup team developing a minimum viable product (MVP) might embed core business logic directly into the model training code—such as applying customer-specific rules or filters during preprocessing. This expedites initial experimentation but creates a brittle system in which modifying the business logic or model behavior requires untangling deeply intertwined code. As the company grows and multiple teams begin working on the system, these decisions limit flexibility, slow iteration, and increase the risk of breaking core functionality during updates.

Despite these risks, not all early-stage debt is harmful. The key distinction lies in whether the system is designed to support evolution. Techniques such as using modular code, isolating configuration from logic, and containerizing experimental environments allow teams to move quickly without sacrificing future maintainability. Abstractions, including shared data access layers and feature transformation modules, can be introduced incrementally as patterns stabilize.

To manage early-stage debt effectively, teams should adopt the principle of flexible foundations: designing for change without over-engineering. This means identifying which components are likely to evolve and introducing appropriate boundaries and interfaces early on. As the system matures, natural inflection points emerge—opportunities to refactor or re-architect without disrupting existing workflows.

Accepting some technical debt in the short term is often a rational tradeoff. The challenge is ensuring that such debt is intentional, tracked, and revisited before it becomes entrenched. By investing in adaptability from the beginning, ML teams can balance early innovation with long-term sustainability.

### Real-World Examples {#sec-ml-operations-realworld-examples-e7df}

Hidden technical debt is not just theoretical—it has played a critical role in shaping the trajectory of real-world machine learning systems. These examples illustrate how unseen dependencies and misaligned assumptions can accumulate quietly, only to become major liabilities over time:

#### YouTube's Recommendation System and Feedback Loops {#sec-ml-operations-youtubes-recommendation-system-feedback-loops-ea46}

YouTube's recommendation engine has faced repeated criticism for promoting sensational or polarizing content. A large part of this stems from feedback loop debt: recommendations influence user behavior, which in turn becomes training data. Over time, this led to unintended content amplification. Mitigating this required substantial architectural overhauls, including cohort-based evaluation, delayed labeling, and more explicit disentanglement between engagement metrics and ranking logic.

#### Zillow's "Zestimate" and Correction Cascades {#sec-ml-operations-zillows-zestimate-correction-cascades-3995}

Zillow's home valuation model (Zestimate) faced significant correction cascades during its iBuying venture. When initial valuation errors propagated into purchasing decisions, retroactive corrections triggered systemic instability that required data revalidation, model redesign, and eventually a full system rollback. The company shut down the iBuying arm in 2021, citing model unpredictability and data feedback effects as core challenges.

#### Tesla Autopilot and Undeclared Consumers {#sec-ml-operations-tesla-autopilot-undeclared-consumers-f584}

In early deployments, Tesla's Autopilot made driving decisions based on models whose outputs were repurposed across subsystems without clear boundaries. Over-the-air updates occasionally introduced silent behavior changes that affected multiple subsystems (e.g., lane centering and braking) in unpredictable ways. This entanglement illustrates undeclared consumer debt and the risks of skipping strict interface governance in ML-enabled safety-critical systems.

#### Facebook's News Feed and Configuration Debt {#sec-ml-operations-facebooks-news-feed-configuration-debt-bb50}

Facebook's News Feed algorithm has undergone numerous iterations, often driven by rapid experimentation. However, the lack of consistent configuration management led to opaque settings that influenced content ranking without clear documentation. As a result, changes to the algorithm's behavior were difficult to trace, and unintended consequences emerged from misaligned configurations. This situation highlights the importance of treating configuration as a first-class citizen in ML systems.

### Managing Hidden Technical Debt {#sec-ml-operations-managing-hidden-technical-debt-18cc}

While the examples discussed highlight the consequences of hidden technical debt in large-scale systems, they also offer valuable lessons for how such debt can be surfaced, controlled, and ultimately reduced. Managing hidden debt requires more than reactive fixes—it demands a deliberate and forward-looking approach to system design, team workflows, and tooling choices.

A foundational principle is to treat data and configuration as integral parts of the system architecture, not as peripheral artifacts. As shown in @fig-technical-debt, the bulk of an ML system lies outside the model code itself—in components like feature engineering, configuration, monitoring, and serving infrastructure. These surrounding layers often harbor the most persistent forms of debt, particularly when changes are made without systematic tracking or validation.

Versioning data transformations, labeling conventions, and training configurations enables teams to reproduce past results, localize regressions, and understand the impact of design choices over time. Tools that enable this, such as [DVC](https://dvc.org/) for data versioning, [Hydra](https://hydra.cc/) for configuration management, and [MLflow](https://mlflow.org/) for experiment tracking, help ensure that the system remains traceable as it evolves. Importantly, version control must extend beyond the model checkpoint to include the data and configuration context in which it was trained and evaluated.

Another key strategy is encapsulation through modular interfaces. The cascading failures seen in tightly coupled systems highlight the importance of defining clear boundaries between components. Without well-specified APIs or contracts, changes in one module can ripple unpredictably through others. By contrast, systems designed around loosely coupled components, in which each module has well-defined responsibilities and limited external assumptions, are far more resilient to change.

Encapsulation also supports dependency awareness, reducing the likelihood of undeclared consumers silently reusing outputs or internal representations. This is especially important in feedback-prone systems, where hidden dependencies can introduce behavioral drift over time. Exposing outputs through audited, documented interfaces makes it easier to reason about their use and to trace downstream effects when models evolve.

Observability and monitoring further strengthen a system's defenses against hidden debt. While static validation may catch errors during development, many forms of ML debt only manifest during deployment, especially in dynamic environments. Monitoring distribution shifts, feature usage patterns, and cohort-specific performance metrics helps detect degradation early, before it impacts users or propagates into future training data. Canary deployments and progressive rollouts are essential tools for limiting risk while allowing systems to evolve.

Teams should also invest in institutional practices that periodically surface and address technical debt. Debt reviews, pipeline audits, and schema validation sprints serve as checkpoints where teams step back from rapid iteration and assess the system's overall health. These reviews create space for refactoring, pruning unused features, consolidating redundant logic, and reasserting boundaries that may have eroded over time.

Finally, the management of technical debt must be aligned with a broader cultural commitment to maintainability. This means prioritizing long-term system integrity over short-term velocity, especially once systems reach maturity or are integrated into critical workflows. It also means recognizing when debt is strategic, which is incurred deliberately to facilitate exploration, and ensuring it is tracked and revisited before it becomes entrenched.

In all cases, managing hidden technical debt is not about eliminating complexity, but about designing systems that can accommodate it without becoming brittle. Through architectural discipline, thoughtful tooling, and a willingness to refactor, ML practitioners can build systems that remain flexible and reliable, even as they scale and evolve.

### Summary {#sec-ml-operations-summary-42a2}

Technical debt in machine learning systems is both pervasive and distinct from debt encountered in traditional software engineering. While the original metaphor of financial debt highlights the tradeoff between speed and long-term cost, the analogy falls short in capturing the full complexity of ML systems. In machine learning, debt often arises not only from code shortcuts but also from entangled data dependencies, poorly understood feedback loops, fragile pipelines, and configuration sprawl. Unlike financial debt, which can be explicitly quantified, ML technical debt is largely hidden, emerging only as systems scale, evolve, or fail.

This chapter has outlined several forms of ML-specific technical debt, each rooted in different aspects of the system lifecycle. Boundary erosion undermines modularity and makes systems difficult to reason about. Correction cascades illustrate how local fixes can ripple through a tightly coupled workflow. Undeclared consumers and feedback loops introduce invisible dependencies that challenge traceability and reproducibility. Data and configuration debt reflect the fragility of inputs and parameters that are poorly managed, while pipeline and change adaptation debt expose the risks of inflexible architectures. Early-stage debt reminds us that even in the exploratory phase, decisions should be made with an eye toward future extensibility.

The common thread across all these debt types is the need for system-level thinking. ML systems are not just code—they are evolving ecosystems of data, models, infrastructure, and teams. Managing technical debt requires architectural discipline, robust tooling, and a culture that values maintainability alongside innovation. It also requires humility: acknowledging that today's solutions may become tomorrow's constraints if not designed with care.

As machine learning becomes increasingly central to production systems, understanding and addressing hidden technical debt is essential. Doing so not only improves reliability and scalability, but also empowers teams to iterate faster, collaborate more effectively, and sustain the long-term evolution of their systems.

## Roles and Responsibilities {#sec-ml-operations-roles-responsibilities-3829}

Operationalizing machine learning systems requires coordinated contributions from professionals with diverse technical and organizational expertise. Unlike traditional software engineering workflows, machine learning introduces additional complexity through its reliance on dynamic data, iterative experimentation, and probabilistic model behavior. As a result, no single role can independently manage the end-to-end machine learning lifecycle. @fig-roles-and-responsibilities provides a high level overview of how these roles relate to each other.

::: {#fig-roles-and-responsibilities fig-env="figure" fig-pos="htb"}
```{.tikz}
\begin{tikzpicture}[line join=round,font=\small\usefont{T1}{phv}{m}{n}]
\definecolor{Siva}{RGB}{161,152,130}
% #1 number of teeths
% #2 radius intern
% #3 radius extern
% #4 angle from start to end of the first arc
% #5 angle to decale the second arc from the first
% #6 inner radius to cut off
\newcommand{\gear}[6]{%
  (0:#2)
  \foreach \i [evaluate=\i as \n using {\i-1)*360/#1}] in {1,...,#1}{%
    arc (\n:\n+#4:#2) {[rounded corners=1.5pt] -- (\n+#4+#5:#3)
    arc (\n+#4+#5:\n+360/#1-#5:#3)} --  (\n+360/#1:#2)
  }%
  (0,0) circle[radius=#6]
}
\tikzset{%
Box/.style={align=flush center,
    inner xsep=2pt,
    node distance=1.4,
    draw=BlueLine,
    line width=0.75pt,
    rounded corners,
    fill=BlueL,
    text width=50mm,
    minimum width=50mm, minimum height=18mm
  },
planet/.style = {circle, draw=none,
semithick, fill=blue!30,
                    font=\usefont{T1}{phv}{m}{n}\bfseries, ball color=cyan!70,shading angle=-15,
                    text width=27mm, inner sep=1mm,align=center}, %<---
satellite/.style = {circle, draw=none, semithick, fill=#1!50,
                    text width=18mm, inner sep=1pt, align=flush center,minimum size=21mm},%<---
LineA/.style = {violet!60,{Circle[line width=1.5pt,fill=white,length=7.5pt]}-,line width=2.0pt,shorten <=-4pt},
Line/.style = {violet!60,line width=2.0pt}
}
\tikzset{pics/light/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[local bounding box=LIGHT,scale=\scalefac, every node/.append style={transform shape}]
 \draw[draw=\drawchannelcolor,fill=\channelcolor,line width=\Linewidth](0,0)to[out=135,in=310](-0.18,0.5) to[out=125,in=230](-0.25,1.55)
  to[out=50,in=130,distance=14](0.89,1.55)  to[out=310,in=55](0.84,0.55)to[out=230,in=50](0.64,0) --cycle;
 \foreach \i in {0.13,0.23,0.33,0.43}{
\node[fill=\channelcolor!30!black,rounded corners=0.5pt,rectangle,minimum width=19,minimum height=2,inner sep=0pt,rotate=4]at(0.30,-\i){};
}
 \draw[draw=none,fill=\channelcolor!30!black,rounded corners=1pt](-0.03,-0.54)--(0.66,-0.5)--(0.43,-0.78)--(0.19,-0.778)--cycle;
 \end{scope}
     }
  }
}

\tikzset{pics/handshake/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[local bounding box=HANDSHAKE,scale=\scalefac, every node/.append style={transform shape}]
\draw[draw=\drawchannelcolor,fill=\channelcolor](0,0)to[out=85,in=230](0.4,0.87)to[out=335,in=140](0.73,0.77)to[out=225,in=50](0.58,0.63)
to[out=235,in=170](0.67,0.38)to[out=340,in=220](0.98,0.46)to[out=40,in=160](1.38,0.59)
to[out=338,in=148](2.58,-0.17)to[out=330,in=318,distance=6](2.43,-0.42)to[out=290,in=330,distance=6](2.16,-0.66)
to[out=270,in=330,distance=5](1.90,-0.86)to[out=270,in=350,distance=5](1.68,-1.04)to[out=165,in=328](1.43,-0.91)
to[out=50,in=60,distance=7](1.26,-0.74)to[out=60,in=55,distance=10](1.044,-0.50)to[out=66,in=60,distance=7](0.77,-0.39)
to[out=66,in=60,distance=7](0.47,-0.3)to[out=145,in=328](0.12,-.04)--cycle;
%above
\draw[draw=\drawchannelcolor,fill=\channelcolor](0.66,0.63)to[out=215,in=210,distance=5](0.85,0.45)to[out=25,in=210,distance=5](1.15,0.64)
to[out=20,in=155](1.55,0.60)to[out=330,in=150](2.57,-0.07)to[out=50,in=190](2.87,0.07)to[out=90,in=320](2.52,0.83)
to[out=240,in=340](2.22,0.74)to[out=160,in=340](1.72,0.94)to[out=160,in=10](1.49,0.98)
to[out=190,in=15](1.05,0.96)to[out=200,in=25] cycle;
%fingers
\node[draw=\drawchannelcolor,fill=\channelcolor,ellipse,minimum width=6,minimum height=10,rotate=-30,inner sep=0pt]at(0.61,-0.39){};
\node[draw=\drawchannelcolor,fill=\channelcolor,,ellipse,minimum width=6.5,minimum height=12,rotate=-27,inner sep=0pt]at(0.87,-0.54){};
\node[draw=\drawchannelcolor,fill=\channelcolor,ellipse,minimum width=6,minimum height=14,rotate=-27,inner sep=0pt]at(1.12,-0.66){};
\node[draw=\drawchannelcolor,fill=\channelcolor,ellipse,minimum width=5,minimum height=9,rotate=-27,inner sep=0pt]at(1.33,-0.85){};
%
\draw[draw=\drawchannelcolor,fill=\channelcolor!50!black](-0.15,-0.09)to[out=155,in=330](-0.53,0.1)to[out=90,in=220](-0.05,1.2)to[out=340,in=150](0.29,0.98)to[out=230,in=90]cycle;
\draw[draw=\drawchannelcolor,fill=\channelcolor!50!black](2.58,0.97)to[out=320,in=90](2.99,-0.08)to[out=20,in=210](3.4,0.11)to[out=90,in=320](2.90,1.19)to[out=210,in=40]cycle;
 \end{scope}
     }
  }
}
\pgfkeys{
  /channel/.cd,
  channelcolor/.store in=\channelcolor,
  drawchannelcolor/.store in=\drawchannelcolor,
  scalefac/.store in=\scalefac,
  Linewidth/.store in=\Linewidth,
  picname/.store in=\picname,
  channelcolor=BrownLine,
  drawchannelcolor=BrownLine,
  scalefac=1,
  Linewidth=1.6pt,
  picname=C
}
% planets
\node[draw=brown!30,line width=5pt,circle,minimum size=184.8]{};
% satellites
\foreach \i [count=\k] in {green!80!black!70!,cyan, brown!50!, orange, magenta!40!}
{
\node (s\k) [satellite=white,draw=none,minimum size=24mm] at (\k*72:3.2) {};
\node [satellite=\i,font=\footnotesize\usefont{T1}{phv}{m}{n}] at (\k*72:3.2) {};
}
%gears
'\begin{scope}[local bounding box=GEARS,shift={($(s1)+(0.3,0.4)$)},scale=1.75, every node/.append style={transform shape}]
%smaller
\begin{scope}[scale=0.1, every node/.append style={transform shape}]
\fill[violet,even odd rule] \gear{10}{1.9}{1.4}{10}{2}{0.6};
\end{scope}
%biger
\begin{scope}[scale=0.15, every node/.append style={transform shape},
shift={(-1.8,-2.08)}]
\fill[violet!90,even odd rule] \gear{10}{1.9}{1.4}{11}{2}{0.6};
\end{scope}
\end{scope}
%Persons
\begin{scope}[shift={($(s4)+(-0.1,0.23)$)},scale=0.65,line width=1.0pt]
\begin{scope}[shift={(0.3,0.3)}]
%person2-back
\coordinate (head-center) at (0,0);
\coordinate (top) at ([yshift=-2mm]head-center);
\coordinate (left) at ([yshift=-10mm,xshift=-7mm]head-center);
\coordinate (right) at ([yshift=-10mm,xshift=7mm]head-center);
\draw[rounded corners=1.5mm,fill=green!60!black!70]
  (top) to [out=-10,in=100]   (right) to [bend left=15]  (left) to [out=80,in=190]  (top);
 \draw[fill=yellow] (head-center) circle (0.35);
\end{scope}
\begin{scope}%person1
\coordinate (head-center) at (0,0);
\coordinate (top) at ([yshift=-2mm]head-center);
\coordinate (left) at ([yshift=-10mm,xshift=-7mm]head-center);
\coordinate (right) at ([yshift=-10mm,xshift=7mm]head-center);
\draw[rounded corners=1.5mm,fill=green!60!black!70]
  (top) to [out=-10,in=100]   (right) to [bend left=15]
  (left) to [out=80,in=190]  (top);
  \draw[fill=yellow] (head-center) circle (0.35);
\end{scope}
\end{scope}
\begin{scope}[shift={($(s2)+(-0.4,-0.45)$)},scale=0.50,every node/.append style={transform shape}]
\draw[line width=2.0pt,RedLine](-0.20,0)--(2,0);
\draw[line width=2.0pt,RedLine](-0.20,0)--(-0.20,2);
\foreach \i/\vi in {0/10,0.5/17,1/9,1.5/5}{
\node[draw, minimum width  =4mm, minimum height = \vi mm, inner sep = 0pt,
      draw = RedLine, fill=RedL!40, line width=1.0pt,anchor=south west](COM)at(\i,0.2){};
}
\end{scope}
%light
\begin{scope}[shift={($(s5)+(-0.17,-0.3)$)},scale=0.60,every node/.append style={transform shape}]
scale=1, every node/.append style={transform shape}]
\pic[shift={(0,0)}] at  (0,0){light={scalefac=1,picname=1,drawchannelcolor=yellow!50!black,channelcolor=yellow!50!, Linewidth=1.0pt}};
 \end{scope}
 %handshake
 \begin{scope}[local bounding box=HANDS,shift={($(s3)+(-0.53,-0.05)$)},
scale=1, every node/.append style={transform shape}]
\pic[shift={(0,0)}] at  (0,0){handshake={scalefac=0.42,drawchannelcolor=none,channelcolor=red!60!black, Linewidth=1.0pt}};
 \end{scope}
 \def\ra{24mm}
\foreach \i [count=\k] in{350,120,140,280,330}{
\pgfmathtruncatemacro{\newX}{\i + 90} %
\draw[Line]
   (s\k)+(\i:0.5*\ra) arc[start angle=\i, end angle=\newX, radius=0.5*\ra];
}
 %
 \draw[LineA](s1.35)--++(-10:1)coordinate(MA);
 \node[Box,anchor=west]at(MA){\textbf{Management}\\ The role of Manager for supporting
              the planning and execution of various Data Science.};
 \draw[LineA](s5.15)--++(10:1)coordinate(ST);
 \node[Box,anchor=west]at(ST){\textbf{Strategy}\\ Designing new strategies by
             understanding the consumers' trends and behaviours.};
\draw[LineA](s4.325)--++(20:1.6)coordinate(OD);
\node[Box,anchor=west]at(OD){\textbf{Other Duties}\\ Duties assigned by the senior
             Data Scientist, Chief Data Officer.};
\draw[LineA](s3.185)--++(160:1.0)coordinate(OD);
\node[Box,anchor=east]at(OD){\textbf{Collaboration}\\ Collaborating with many senior
             people like Data Scientists, Stakeholder, etc...};
\draw[LineA](s2.165)--++(150:1.0)coordinate(OD);
\node[Box,anchor=east]at(OD){\textbf{Analytics}\\ Creates model for solving various data analytics problems.};
\end{tikzpicture}
```
Comparison of model-centric and data-centric AI approaches. Model-centric AI focuses on improving architectures, while data-centric AI emphasizes enhancing dataset quality. Both approaches are complementary in optimizing AI performance.
:::

MLOps provides the structure and practices necessary to align these specialized roles around a shared objective: delivering reliable, scalable, and maintainable machine learning systems in production environments. From designing robust data pipelines to deploying and monitoring models in live systems, effective MLOps depends on collaboration across disciplines including data engineering, statistical modeling, software development, infrastructure management, and project coordination.

### Roles {#sec-ml-operations-roles-3b9a}

@tbl-mlops-roles introduces the key roles that participate in MLOps and outlines their primary responsibilities. Understanding these roles not only clarifies the scope of skills required to support production ML systems but also helps frame the collaborative workflows and handoffs that drive the operational success of machine learning at scale.

+------------------------+-------------------------------------------+----------------------------------------------------------------+-----------------------------------+
| Role                   | Primary Focus                             | Core Responsibilities Summary                                  | MLOps Lifecycle Alignment         |
+:=======================+:==========================================+:===============================================================+:==================================+
| Data Engineer          | Data preparation and infrastructure       | Build and maintain pipelines; ensure quality, structure,       | Data ingestion, transformation    |
|                        |                                           | and lineage of data                                            |                                   |
+------------------------+-------------------------------------------+----------------------------------------------------------------+-----------------------------------+
| Data Scientist         | Model development and experimentation     | Formulate tasks; build and evaluate models; iterate using      | Modeling and evaluation           |
|                        |                                           | feedback and error analysis                                    |                                   |
+------------------------+-------------------------------------------+----------------------------------------------------------------+-----------------------------------+
| ML Engineer            | Production integration and scalability    | Operationalize models; implement serving logic; manage         | Deployment and inference          |
|                        |                                           | performance and retraining                                     |                                   |
+------------------------+-------------------------------------------+----------------------------------------------------------------+-----------------------------------+
| DevOps Engineer        | Infrastructure orchestration and          | Manage compute infrastructure; implement CI/CD; monitor        | Training, deployment, monitoring  |
|                        | automation                                | systems and workflows                                          |                                   |
+------------------------+-------------------------------------------+----------------------------------------------------------------+-----------------------------------+
| Project Manager        | Coordination and delivery oversight       | Align goals; manage schedules and milestones; enable           | Planning and integration          |
|                        |                                           | cross-team execution                                           |                                   |
+------------------------+-------------------------------------------+----------------------------------------------------------------+-----------------------------------+
| Responsible AI         | Ethics, fairness, and governance          | Monitor bias and fairness; enforce transparency and            | Evaluation and governance         |
| Lead                   |                                           | compliance standards                                           |                                   |
+------------------------+-------------------------------------------+----------------------------------------------------------------+-----------------------------------+
| Security & Privacy     | System protection and data integrity      | Secure data and models; implement privacy controls;            | Data handling and compliance      |
| Engineer               |                                           | ensure system resilience                                       |                                   |
+------------------------+-------------------------------------------+----------------------------------------------------------------+-----------------------------------+

: MLOps roles and responsibilities across the machine learning lifecycle. {#tbl-mlops-roles .striped .hover}

#### Data Engineers {#sec-ml-operations-data-engineers-2cf7}

Data engineers are responsible for constructing and maintaining the data infrastructure that underpins machine learning systems. Their primary focus is to ensure that data is reliably collected, processed, and made accessible in formats suitable for analysis, feature extraction, model training, and inference. In the context of MLOps, data engineers play a foundational role by building scalable and reproducible data pipelines that support the end-to-end machine learning lifecycle.

A core responsibility of data engineers is data ingestion—extracting data from diverse operational sources such as transactional databases, web applications, log streams, and sensors. This data is typically transferred to centralized storage systems, such as cloud-based object stores (e.g., Amazon S3, Google Cloud Storage), which provide scalable and durable repositories for both raw and processed datasets. These ingestion workflows are orchestrated using scheduling and workflow tools such as Apache Airflow, Prefect, or dbt [@garg2020practical].

Once ingested, the data must be transformed into structured, analysis-ready formats. This transformation process includes handling missing or malformed values, resolving inconsistencies, performing joins across heterogeneous sources, and computing derived attributes required for downstream tasks. Data engineers implement these transformations through modular pipelines that are version-controlled and designed for fault tolerance and reusability. Structured outputs are often loaded into cloud-based data warehouses such as Snowflake, Redshift, or BigQuery, or stored in feature stores for use in machine learning applications.

In addition to managing data pipelines, data engineers are responsible for provisioning and optimizing the infrastructure that supports data-intensive workflows. This includes configuring distributed storage systems, managing compute clusters, and maintaining metadata catalogs that document data schemas, lineage, and access controls. To ensure reproducibility and governance, data engineers implement dataset versioning, maintain historical snapshots, and enforce data retention and auditing policies.

For example, in a manufacturing application, data engineers may construct an Airflow pipeline that ingests time-series sensor data from programmable logic controllers (PLCs)[^fn-plc] on the factory floor. The raw data is cleaned, joined with product metadata, and aggregated into statistical features such as rolling averages and thresholds. The processed features are stored in a Snowflake data warehouse, where they are consumed by downstream modeling and inference workflows.

[^fn-plc]: **Programmable Logic Controller (PLC):** An industrial computer used to control manufacturing processes, such as robotic devices or assembly lines.

Through their design and maintenance of robust data infrastructure, data engineers enable the consistent and efficient delivery of high-quality data. Their contributions ensure that machine learning systems are built on reliable inputs, supporting reproducibility, scalability, and operational stability across the MLOps pipeline.

To illustrate this responsibility in practice, @lst-data-engineer shows a simplified example of a daily Extract-Transform-Load (ETL) pipeline implemented using Apache Airflow. This workflow automates the ingestion and transformation of raw sensor data, preparing it for downstream machine learning tasks.

::: {.content-visible when-format="html"}
::: {#lst-data-engineer .callout-important title="Code in Practice for a Data Engineer, implementing a daily Extract-Transform-Load (ETL) pipeline using Apache Airflow to process manufacturing sensor data."}
```{.python}

# Airflow DAG for daily ETL from a manufacturing data source
from airflow import DAG
from airflow.operators.python import PythonOperator
from datetime import datetime

def extract_data():
    import pandas as pd
    df = pd.read_csv('/data/raw/plc_logs.csv')  # Simulated
                                                # PLC data
    df.to_parquet('/data/staged/sensor_data.parquet')

def transform_data():
    import pandas as pd
    df = pd.read_parquet('/data/staged/sensor_data.parquet')
    df['rolling_avg'] = (
      df['temperature']
      .rolling(window=10)
      .mean()
    )
    df.to_parquet('/data/processed/features.parquet')

with DAG(
    dag_id='manufacturing_etl_pipeline',
    schedule_interval='@daily',
    start_date=datetime(2023, 1, 1),
    catchup=False
) as dag:
    extract = PythonOperator(
      task_id='extract',
      python_callable=extract_data
    )
    transform = PythonOperator(
    task_id='transform',
    python_callable=transform_data
    )

    extract >> transform
```
:::
:::

::: {.content-visible when-format="pdf"}
```{python}
#| lst-label: lst-data-engineer
#| lst-cap: Code in Practice for a Data Engineer, implementing a daily Extract-Transform-Load (ETL) pipeline using Apache Airflow to process manufacturing sensor data.
#| eval: false

# Airflow DAG for daily ETL from a manufacturing data source
from airflow import DAG
from airflow.operators.python import PythonOperator
from datetime import datetime

def extract_data():
    import pandas as pd
    df = pd.read_csv('/data/raw/plc_logs.csv')  # Simulated
                                                # PLC data
    df.to_parquet('/data/staged/sensor_data.parquet')

def transform_data():
    import pandas as pd
    df = pd.read_parquet('/data/staged/sensor_data.parquet')
    df['rolling_avg'] = (
      df['temperature']
      .rolling(window=10)
      .mean()
    )
    df.to_parquet('/data/processed/features.parquet')

with DAG(
    dag_id='manufacturing_etl_pipeline',
    schedule_interval='@daily',
    start_date=datetime(2023, 1, 1),
    catchup=False
) as dag:
    extract = PythonOperator(
      task_id='extract',
      python_callable=extract_data
    )
    transform = PythonOperator(
    task_id='transform',
    python_callable=transform_data
    )

    extract >> transform
```
:::

#### Data Scientists {#sec-ml-operations-data-scientists-5eaa}

Data scientists are primarily responsible for designing, developing, and evaluating machine learning models. Their role centers on transforming business or operational problems into formal learning tasks, selecting appropriate algorithms, and optimizing model performance through statistical and computational techniques. Within the MLOps lifecycle, data scientists operate at the intersection of exploratory analysis and model development, contributing directly to the creation of predictive or decision-making capabilities.

The process typically begins by collaborating with stakeholders to define the problem space and establish success criteria. This includes formulating the task in machine learning terms, including classification, regression, or forecasting, and identifying suitable evaluation metrics to quantify model performance. These metrics, such as accuracy, precision, recall, area under the curve (AUC), or F1 score, provide objective measures for comparing model alternatives and guiding iterative improvements [@rainio2024evaluation].

Data scientists conduct exploratory data analysis (EDA) to assess data quality, identify patterns, and uncover relationships that inform feature selection and engineering. This stage may involve statistical summaries, visualizations, and hypothesis testing to evaluate the data's suitability for modeling. Based on these findings, relevant features are constructed or selected in collaboration with data engineers to ensure consistency across development and deployment environments.

Model development involves selecting appropriate learning algorithms and constructing architectures suited to the task and data characteristics. Data scientists employ machine learning libraries such as TensorFlow, PyTorch, or scikit-learn to implement and train models. Hyperparameter tuning, regularization strategies, and cross-validation are used to optimize performance on validation datasets while mitigating overfitting. Throughout this process, tools for experiment tracking, including MLflow and Weights & Biases, are often used to log configuration settings, evaluation results, and model artifacts.

Once a candidate model demonstrates acceptable performance, it undergoes further validation through rigorous testing on holdout datasets. In addition to aggregate performance metrics, data scientists perform error analysis to identify failure modes, outliers, or biases that may impact model reliability or fairness. These insights often motivate further iterations on data processing, feature engineering, or model refinement.

Data scientists also participate in post-deployment monitoring and retraining workflows. They assist in analyzing data drift, interpreting shifts in model performance, and incorporating new data to maintain predictive accuracy over time. In collaboration with ML engineers, they define retraining strategies and evaluate the impact of updated models on operational metrics.

For example, in a retail forecasting scenario, a data scientist may develop a sequence model using TensorFlow to predict product demand based on historical sales, product attributes, and seasonal indicators. The model is evaluated using root mean squared error (RMSE) on withheld data, refined through hyperparameter tuning, and handed off to ML engineers for deployment. Following deployment, the data scientist continues to monitor model accuracy and guides retraining using new transactional data.

Through rigorous experimentation and model development, data scientists contribute the core analytical functionality of machine learning systems. Their work transforms raw data into predictive insights and supports the continuous improvement of deployed models through principled evaluation and refinement.

To illustrate these responsibilities in a practical context, @lst-data-scientist presents a minimal example of a sequence model built using TensorFlow. This model is designed to forecast product demand based on historical sales patterns and other input features.

::: {.content-visible when-format="html"}
::: {#lst-data-scientist .callout-important title="Code in Practice for a Data Scientist, implementing a sequence model using TensorFlow to forecast product demand based on historical sales data."}
```{.python}
# TensorFlow model for demand forecasting
import tensorflow as tf
from tensorflow.keras import layers, models

model = models.Sequential([
    layers.Input(shape=(30, 5)),  # 30 time steps, 5 features
    layers.LSTM(64),
    layers.Dense(1)
])

model.compile(optimizer='adam', loss='mse', metrics=['mae'])

# Assume X_train, y_train are preloaded
model.fit(X_train, y_train, validation_split=0.2, epochs=10)

# Save model for handoff
model.save('models/demand_forecast_v1')
```
:::
:::

::: {.content-visible when-format="pdf"}
```{python}
#| lst-label: lst-data-scientist
#| lst-cap: Code in Practice for a Data Scientist, implementing a sequence model using TensorFlow to forecast product demand based on historical sales data.
#| eval: false

# TensorFlow model for demand forecasting
import tensorflow as tf
from tensorflow.keras import layers, models

model = models.Sequential([
    layers.Input(shape=(30, 5)),  # 30 time steps, 5 features
    layers.LSTM(64),
    layers.Dense(1)
])

model.compile(optimizer='adam', loss='mse', metrics=['mae'])

# Assume X_train, y_train are preloaded
model.fit(X_train, y_train, validation_split=0.2, epochs=10)

# Save model for handoff
model.save('models/demand_forecast_v1')
```
:::

#### ML Engineers {#sec-ml-operations-ml-engineers-919d}

Machine learning engineers are responsible for translating experimental models into reliable, scalable systems that can be integrated into real-world applications. Positioned at the intersection of data science and software engineering, ML engineers ensure that models developed in research environments can be deployed, monitored, and maintained within production-grade infrastructure. Their work bridges the gap between prototyping and operationalization, enabling machine learning to deliver sustained value in practice.

A core responsibility of ML engineers is to take trained models and encapsulate them within modular, maintainable components. This often involves refactoring code for robustness, implementing model interfaces, and building application programming interfaces (APIs) that expose model predictions to downstream systems. Frameworks such as Flask and FastAPI are commonly used to construct lightweight, RESTful services[^fn-restful] for model inference. To support portability and environment consistency, models, and their dependencies are typically containerized using Docker and managed within orchestration systems like Kubernetes.

[^fn-restful]: **RESTful Services:** Web services implementing REST (Representational State Transfer) principles for networked applications.

ML engineers also oversee the integration of models into continuous integration and continuous delivery (CI/CD) pipelines. These pipelines automate the retraining, testing, and deployment of models, ensuring that updated models are validated against performance benchmarks before being promoted to production. Practices such as canary deployments, A/B testing, and staged rollouts allow for gradual transitions and reduce the risk of regressions. In the event of model degradation, rollback procedures are used to restore previously validated versions.

Operational efficiency is another key area of focus. ML engineers apply a range of optimization techniques, including model quantization, pruning, and batch serving, to meet latency, throughput, and cost constraints. In systems that support multiple models, they may implement mechanisms for dynamic model selection or concurrent serving. These optimizations are closely coupled with infrastructure provisioning, which often includes the configuration of GPUs or other specialized accelerators.

Post-deployment, ML engineers play a critical role in monitoring model behavior. They configure telemetry systems to track latency, failure rates, and resource usage, and they instrument prediction pipelines with logging and alerting mechanisms. In collaboration with data scientists and DevOps engineers, they respond to changes in system behavior, trigger retraining workflows, and ensure that models continue to meet service-level objectives[^fn-slo].

[^fn-slo]: **Service-Level Objectives (SLOs):** Specific measurable characteristics of the SLAs such as availability, throughput, frequency, response time, or quality.

For example, consider a financial services application where a data science team has developed a fraud detection model using TensorFlow. An ML engineer packages the model for deployment using TensorFlow Serving, configures a REST API for integration with the transaction pipeline, and sets up a CI/CD pipeline in Jenkins to automate updates. They implement logging and monitoring using Prometheus and Grafana, and configure rollback logic to revert to the prior model version if performance deteriorates. This production infrastructure enables the model to operate continuously and reliably under real-world workloads.

Through their focus on software robustness, deployment automation, and operational monitoring, ML engineers play a pivotal role in transitioning machine learning models from experimental artifacts into trusted components of production systems. To illustrate these responsibilities in a practical context, @lst-ml-engineer presents a minimal example of a REST API built with FastAPI for serving a trained TensorFlow model. This service exposes model predictions for use in downstream applications.

::: {.content-visible when-format="html"}
::: {#lst-ml-engineer .callout-important title="Code in Practice for an ML Engineer, wrapping a trained model in a FastAPI endpoint to expose real-time demand predictions in a production environment."}
```{.python}
# FastAPI service to serve a trained TensorFlow model
from fastapi import FastAPI, Request
import tensorflow as tf
import numpy as np

app = FastAPI()
model = tf.keras.models.load_model('models/demand_forecast_v1')

@app.post("/predict")
async def predict(request: Request):
    data = await request.json()
    input_array = np.array(data['input']).reshape(1, 30, 5)
    prediction = model.predict(input_array)
    return {"prediction": float(prediction[0][0])}
```
:::
:::

::: {.content-visible when-format="pdf"}
```{python}
#| lst-label: lst-ml-engineer
#| lst-cap: Code in Practice for an ML Engineer, wrapping a trained model in a FastAPI endpoint to expose real-time demand predictions in a production environment.
#| eval: false

# FastAPI service to serve a trained TensorFlow model
from fastapi import FastAPI, Request
import tensorflow as tf
import numpy as np

app = FastAPI()
model = tf.keras.models.load_model('models/demand_forecast_v1')

@app.post("/predict")
async def predict(request: Request):
    data = await request.json()
    input_array = np.array(data['input']).reshape(1, 30, 5)
    prediction = model.predict(input_array)
    return {"prediction": float(prediction[0][0])}
```
:::

#### DevOps Engineers {#sec-ml-operations-devops-engineers-2f61}

DevOps engineers are responsible for provisioning, managing, and automating the infrastructure that supports the development, deployment, and monitoring of machine learning systems. Originating from the broader discipline of software engineering, the role of the DevOps engineer in MLOps extends traditional responsibilities to accommodate the specific demands of data- and model-driven workflows. Their expertise in cloud computing, automation pipelines, and infrastructure as code (IaC) enables scalable and reliable machine learning operations.

A central task for DevOps engineers is the configuration and orchestration of compute infrastructure used throughout the ML lifecycle. This includes provisioning virtual machines, storage systems, and accelerators such as GPUs and TPUs using IaC tools like Terraform, AWS CloudFormation, or Ansible. Infrastructure is typically containerized using Docker and managed through orchestration platforms such as Kubernetes, which allow teams to deploy, scale, and monitor workloads across distributed environments.

DevOps engineers design and implement CI/CD pipelines tailored to machine learning workflows. These pipelines automate the retraining, testing, and deployment of models in response to code changes or data updates. Tools such as Jenkins, GitHub Actions, or GitLab CI are used to trigger model workflows, while platforms like MLflow and Kubeflow facilitate experiment tracking, model registration, and artifact versioning. By codifying deployment logic, these pipelines reduce manual effort, increase reproducibility, and enable faster iteration cycles.

Monitoring is another critical area of responsibility. DevOps engineers configure telemetry systems to collect metrics related to both model and infrastructure performance. Tools such as Prometheus, Grafana, and the ELK stack (Elasticsearch, Logstash, Kibana) are widely used to build dashboards, set thresholds, and generate alerts. These systems allow teams to detect anomalies in latency, throughput, resource utilization, or prediction behavior and respond proactively to emerging issues.

To ensure compliance and operational discipline, DevOps engineers also implement governance mechanisms that enforce consistency and traceability. This includes versioning of infrastructure configurations, automated validation of deployment artifacts, and auditing of model updates. In collaboration with ML engineers and data scientists, they enable reproducible and auditable model deployments aligned with organizational and regulatory requirements.

For instance, in a financial services application, a DevOps engineer may configure a Kubernetes cluster on AWS to support both model training and online inference. Using Terraform, the infrastructure is defined as code and versioned alongside the application repository. Jenkins is used to automate the deployment of models registered in MLflow, while Prometheus and Grafana provide real-time monitoring of API latency, resource usage, and container health.

By abstracting and automating the infrastructure that underlies ML workflows, DevOps engineers enable scalable experimentation, robust deployment, and continuous monitoring. Their role ensures that machine learning systems can operate reliably under production constraints, with minimal manual intervention and maximal operational efficiency. To illustrate these responsibilities in a practical context, @lst-devops-engineer presents an example of using Terraform to provision a GPU-enabled virtual machine on Google Cloud Platform for model training and inference workloads.

::: {.content-visible when-format="html"}
::: {#lst-devops-engineer .callout-important title="Code in Practice for a DevOps Engineer, provisioning GPU-enabled infrastructure on GCP using Terraform to support model training and serving."}
```{.python}
# Terraform configuration for a GCP instance with GPU support
resource "google_compute_instance" "ml_node" {
  name         = "ml-gpu-node"
  machine_type = "n1-standard-8"
  zone         = "us-central1-a"

  boot_disk {
    initialize_params {
      image = "debian-cloud/debian-11"
    }
  }

  guest_accelerator {
    type  = "nvidia-tesla-t4"
    count = 1
  }

  metadata_startup_script = <<-EOF
    sudo apt-get update
    sudo apt-get install -y docker.io
    sudo docker run --gpus all -p 8501:8501 tensorflow/serving
  EOF

  tags = ["ml-serving"]
}

```
:::
:::

::: {.content-visible when-format="pdf"}
```{python}
#| lst-label: lst-devops-engineer
#| lst-cap: Code in Practice for a DevOps Engineer, provisioning GPU-enabled infrastructure on GCP using Terraform to support model training and serving.
#| eval: false

# Terraform configuration for a GCP instance with GPU support
resource "google_compute_instance" "ml_node" {
  name         = "ml-gpu-node"
  machine_type = "n1-standard-8"
  zone         = "us-central1-a"

  boot_disk {
    initialize_params {
      image = "debian-cloud/debian-11"
    }
  }

  guest_accelerator {
    type  = "nvidia-tesla-t4"
    count = 1
  }

  metadata_startup_script = <<-EOF
    sudo apt-get update
    sudo apt-get install -y docker.io
    sudo docker run --gpus all -p 8501:8501 tensorflow/serving
  EOF

  tags = ["ml-serving"]
}
```
:::

#### Project Managers {#sec-ml-operations-project-managers-439e}

Project managers play a critical role in coordinating the activities, resources, and timelines involved in delivering machine learning systems. While they do not typically develop models or write code, project managers are essential to aligning interdisciplinary teams, tracking progress against objectives, and ensuring that MLOps initiatives are completed on schedule and within scope. Their work enables effective collaboration among data scientists, engineers, product stakeholders, and infrastructure teams, translating business goals into actionable technical plans.

At the outset of a project, project managers work with organizational stakeholders to define goals, success metrics, and constraints. This includes clarifying the business objectives of the machine learning system, identifying key deliverables, estimating timelines, and setting performance benchmarks. These definitions serve as the foundation for resource allocation, task planning, and risk assessment throughout the lifecycle of the project.

Once the project is initiated, project managers are responsible for developing and maintaining a detailed execution plan. This plan outlines major phases of work, such as data collection, model development, infrastructure provisioning, deployment, and monitoring. Dependencies between tasks are identified and managed to ensure smooth handoffs between roles, while milestones and checkpoints are used to assess progress and adjust schedules as necessary.

Throughout execution, project managers facilitate coordination across teams. This includes organizing meetings, tracking deliverables, resolving blockers, and escalating issues when necessary. Documentation, progress reports, and status updates are maintained to provide visibility across the organization and ensure that all stakeholders are informed of project developments. Communication is a central function of the role, serving to reduce misalignment and clarify expectations between technical contributors and business decision-makers.

In addition to managing timelines and coordination, project managers oversee the budgeting and resourcing aspects of MLOps initiatives. This may involve evaluating cloud infrastructure costs, negotiating access to compute resources, and ensuring that appropriate personnel are assigned to each phase of the project. By maintaining visibility into both technical and organizational considerations, project managers help align technical execution with strategic priorities.

For example, consider a company seeking to reduce customer churn using a predictive model. The project manager coordinates with data engineers to define data requirements, with data scientists to prototype and evaluate models, with ML engineers to package and deploy the final model, and with DevOps engineers to provision the necessary infrastructure and monitoring tools. The project manager tracks progress through phases such as data pipeline readiness, baseline model evaluation, deployment to staging, and post-deployment monitoring, adjusting the project plan as needed to respond to emerging challenges.

By orchestrating collaboration across diverse roles and managing the complexity inherent in machine learning initiatives, project managers enable MLOps teams to deliver systems that are both technically robust and aligned with organizational goals. Their contributions ensure that the operationalization of machine learning is not only feasible, but repeatable, accountable, and efficient. To illustrate these responsibilities in a practical context, @lst-project-manager presents a simplified example of a project milestone tracking structure using JSON. This format is commonly used to integrate with tools like JIRA or project dashboards to monitor progress across machine learning initiatives.

::: {.content-visible when-format="html"}
::: {#lst-project-manager .callout-important title="Project milestone tracking in JSON"}
```{.python}
{
  "project": "Churn Prediction",
  "milestones": [
    {
      "name": "Data Pipeline Ready",
      "due": "2025-05-01",
      "status": "Complete"
    },
    {
      "name": "Model Baseline",
      "due": "2025-05-10",
      "status": "In Progress"
    },
    {
      "name": "Staging Deployment",
      "due": "2025-05-15",
      "status": "Pending"
    },
    {
      "name": "Production Launch",
      "due": "2025-05-25",
      "status": "Pending"
    }
  ],
  "risks": [
    {
      "issue": "Delayed cloud quota",
      "mitigation": "Request early from infra team"
    }
  ]
}
```
:::
:::

::: {.content-visible when-format="pdf"}
```{python}
#| lst-label: lst-project-manager
#| lst-cap: Project milestone tracking in JSON
#| eval: false

{
  "project": "Churn Prediction",
  "milestones": [
    {
      "name": "Data Pipeline Ready",
      "due": "2025-05-01",
      "status": "Complete"
    },
    {
      "name": "Model Baseline",
      "due": "2025-05-10",
      "status": "In Progress"
    },
    {
      "name": "Staging Deployment",
      "due": "2025-05-15",
      "status": "Pending"
    },
    {
      "name": "Production Launch",
      "due": "2025-05-25",
      "status": "Pending"
    }
  ],
  "risks": [
    {
      "issue": "Delayed cloud quota",
      "mitigation": "Request early from infra team"
    }
  ]
}
```
:::

#### Responsible AI Lead {#sec-ml-operations-responsible-ai-lead-f2e0}

The Responsible AI Lead is tasked with ensuring that machine learning systems operate in ways that are transparent, fair, accountable, and compliant with ethical and regulatory standards. As machine learning is increasingly embedded in socially impactful domains such as healthcare, finance, and education, the need for systematic governance has grown. This role reflects a growing recognition that technical performance alone is insufficient; ML systems must also align with broader societal values.

At the model development stage, Responsible AI Leads support practices that enhance interpretability and transparency. They work with data scientists and ML engineers to assess which features contribute most to model predictions, evaluate whether certain groups are disproportionately affected, and document model behavior through structured reporting mechanisms. Post hoc explanation methods, such as attribution techniques, are often reviewed in collaboration with this role to support downstream accountability.

Another key responsibility is fairness assessment. This involves defining fairness criteria in collaboration with stakeholders, auditing model outputs for performance disparities across demographic groups, and guiding interventions, including reweighting, re-labeling, or constrained optimization, to mitigate potential harms. These assessments are often incorporated into model validation pipelines to ensure that they are systematically enforced before deployment.

In post-deployment settings, Responsible AI Leads help monitor systems for drift, bias amplification, and unanticipated behavior. They may also oversee the creation of documentation artifacts such as model cards or datasheets for datasets, which serve as tools for transparency and reproducibility. In regulated sectors, this role collaborates with legal and compliance teams to meet audit requirements and ensure that deployed models remain aligned with external mandates.

For example, in a hiring recommendation system, a Responsible AI Lead may oversee an audit that compares model outcomes across gender and ethnicity, guiding the team to adjust the training pipeline to reduce disparities while preserving predictive accuracy. They also ensure that decision rationales are documented and reviewable by both technical and non-technical stakeholders.

The integration of ethical review and governance into the ML development process enables the Responsible AI Lead to support systems that are not only technically robust, but also socially responsible and institutionally accountable. To illustrate these responsibilities in a practical context, @lst-responsible-ai presents an example of using the Aequitas library to audit a model for group-based disparities. This example evaluates statistical parity across demographic groups to assess potential fairness concerns prior to deployment.

::: {.content-visible when-format="html"}
::: {#lst-responsible-ai .callout-important title="Code in Practice for a Responsible AI Lead, conducting a fairness assessment to identify disparities in model outcomes across gender groups using Aequitas."}
```{.python}
# Fairness audit using Aequitas
from aequitas.group import Group
from aequitas.bias import Bias

# Assume df includes model scores, true labels,
# and a 'gender' attribute
g = Group().get_crosstabs(df)
b = Bias().get_disparity_predefined_groups(
    g,original_df=df,
    ref_groups_dict={'gender': 'male'},
    alpha=0.05,
    mask_significant=True
)

print(b[
    ['attribute_name',
     'attribute_value',
     'disparity',
     'statistical_parity']
])

```
:::
:::

::: {.content-visible when-format="pdf"}
```{python}
#| lst-label: lst-responsible-ai
#| lst-cap: Code in Practice for a Responsible AI Lead, conducting a fairness assessment to identify disparities in model outcomes across gender groups using Aequitas.
#| eval: false

# Fairness audit using Aequitas
from aequitas.group import Group
from aequitas.bias import Bias

# Assume df includes model scores, true labels,
# and a 'gender' attribute
g = Group().get_crosstabs(df)
b = Bias().get_disparity_predefined_groups(
    g,original_df=df,
    ref_groups_dict={'gender': 'male'},
    alpha=0.05,
    mask_significant=True
)

print(b[
    ['attribute_name',
     'attribute_value',
     'disparity',
     'statistical_parity']
])

```
:::

#### Security and Privacy Engineer {#sec-ml-operations-security-privacy-engineer-c4a9}

The Security and Privacy Engineer is responsible for safeguarding machine learning systems against adversarial threats and privacy risks. As ML systems increasingly rely on sensitive data and are deployed in high-stakes environments, security and privacy become essential dimensions of system reliability. This role brings expertise in both traditional security engineering and ML-specific threat models, ensuring that systems are resilient to attack and compliant with data protection requirements.

At the data level, Security and Privacy Engineers help enforce access control, encryption, and secure handling of training and inference data. They collaborate with data engineers to apply privacy-preserving techniques, such as data anonymization, secure aggregation, or differential privacy[^fn-differential-privacy], particularly when sensitive personal or proprietary data is used. These mechanisms are designed to reduce the risk of data leakage while retaining the utility needed for model training.

[^fn-differential-privacy]: **Differential Privacy:** A technique that adds randomness to dataset queries to protect individual data privacy while maintaining overall data utility.

In the modeling phase, this role advises on techniques that improve robustness against adversarial manipulation. This may include detecting poisoning attacks during training, mitigating model inversion or membership inference risks, and evaluating the susceptibility of models to adversarial examples. They also assist in designing model architectures and training strategies that balance performance with safety constraints.

During deployment, Security and Privacy Engineers implement controls to protect the model itself, including endpoint hardening, API rate limiting[^fn-api-rate-limiting], and access logging. In settings where models are exposed externally, including public-facing APIs, they may also deploy monitoring systems that detect anomalous access patterns or query-based attacks intended to extract model parameters or training data.

[^fn-api-rate-limiting]: API rate limiting controls the rate at which end users can make API requests, used to protect against abuse.

For instance, in a medical diagnosis system trained on patient data, a Security and Privacy Engineer might implement differential privacy during model training and enforce strict access controls on the model's inference interface. They would also validate that model explanations do not inadvertently expose sensitive information, and monitor post-deployment activity for potential misuse.

Through proactive design and continuous oversight, Security and Privacy Engineers ensure that ML systems uphold confidentiality, integrity, and availability. Their work is especially critical in domains where trust, compliance, and risk mitigation are central to system deployment and long-term operation. To illustrate these responsibilities in a practical context, @lst-security-privacy presents an example of training a model using differential privacy techniques with TensorFlow Privacy. This approach helps protect sensitive information in the training data while preserving model utility.

::: {.content-visible when-format="html"}
::: {#lst-security-privacy .callout-important title="Code in Practice for a Security and Privacy Engineer, applying differential privacy during model training to protect sensitive data while enabling predictive performance."}
```{.python}
# Training a differentially private model with
# TensorFlow Privacy
import tensorflow as tf
from tensorflow_privacy.privacy.optimizers.dp_optimizer_keras \
    import DPKerasAdamOptimizer

# Define a simple model
model = tf.keras.Sequential([
    tf.keras.layers.Dense(
      64,
      activation='relu',
      input_shape=(100,)
    ),
    tf.keras.layers.Dense(10, activation='softmax')
])

# Use a DP-aware optimizer
optimizer = DPKerasAdamOptimizer(
    l2_norm_clip=1.0,
    noise_multiplier=1.1,
    num_microbatches=256,
    learning_rate=0.001
)

model.compile(
    optimizer=optimizer,
    loss='categorical_crossentropy',
    metrics=['accuracy']
)

# Train model on privatized dataset
model.fit(train_data, train_labels, epochs=10, batch_size=256)
```
:::
:::

::: {.content-visible when-format="pdf"}
```{python}
#| lst-label: lst-security-privacy
#| lst-cap: Code in Practice for a Security and Privacy Engineer, applying differential privacy during model training to protect sensitive data while enabling predictive performance.
#| eval: false

# Training a differentially private model with
# TensorFlow Privacy
import tensorflow as tf
from tensorflow_privacy.privacy.optimizers.dp_optimizer_keras \
    import DPKerasAdamOptimizer

# Define a simple model
model = tf.keras.Sequential([
    tf.keras.layers.Dense(
      64,
      activation='relu',
      input_shape=(100,)
    ),
    tf.keras.layers.Dense(10, activation='softmax')
])

# Use a DP-aware optimizer
optimizer = DPKerasAdamOptimizer(
    l2_norm_clip=1.0,
    noise_multiplier=1.1,
    num_microbatches=256,
    learning_rate=0.001
)

model.compile(
    optimizer=optimizer,
    loss='categorical_crossentropy',
    metrics=['accuracy']
)

# Train model on privatized dataset
model.fit(train_data, train_labels, epochs=10, batch_size=256)
```
:::

### Intersections and Handoffs {#sec-ml-operations-intersections-handoffs-fe4a}

While each role in MLOps carries distinct responsibilities, the successful deployment and operation of machine learning systems depends on seamless collaboration across functional boundaries. Machine learning workflows are inherently interdependent, with critical handoff points connecting data acquisition, model development, system integration, and operational monitoring. Understanding these intersections is essential for designing processes that are both efficient and resilient.

One of the earliest and most critical intersections occurs between data engineers and data scientists. Data engineers construct and maintain the pipelines that ingest and transform raw data, while data scientists depend on these pipelines to access clean, structured, and well-documented datasets for analysis and modeling. Misalignment at this stage, including undocumented schema changes or inconsistent feature definitions, can lead to downstream errors that compromise model quality or reproducibility.

Once a model is developed, the handoff to ML engineers requires a careful transition from research artifacts to production-ready components. ML engineers must understand the assumptions and requirements of the model to implement appropriate interfaces, optimize runtime performance, and integrate it into the broader application ecosystem. This step often requires iteration, especially when models developed in experimental environments must be adapted to meet latency, throughput, or resource constraints in production.

As models move toward deployment, DevOps engineers play the role in provisioning infrastructure, managing CI/CD pipelines, and instrumenting monitoring systems. Their collaboration with ML engineers ensures that model deployments are automated, repeatable, and observable. They also coordinate with data scientists to define alerts and thresholds that guide performance monitoring and retraining decisions.

Project managers provide the organizational glue across these technical domains. They ensure that handoffs are anticipated, roles are clearly defined, and dependencies are actively managed. In particular, project managers help maintain continuity by documenting assumptions, tracking milestone readiness, and facilitating communication between teams. This coordination reduces friction and enables iterative development cycles that are both agile and accountable.

For example, in a real-time recommendation system, data engineers maintain the data ingestion pipeline and feature store, data scientists iterate on model architectures using historical clickstream data, ML engineers deploy models as containerized microservices, and DevOps engineers monitor inference latency and availability. Each role contributes to a different layer of the stack, but the overall functionality depends on reliable transitions between each phase of the lifecycle.

These role interactions illustrate that MLOps is not simply a collection of discrete tasks, but a continuous, collaborative process. Designing for clear handoffs, shared tools, and well-defined interfaces is essential for ensuring that machine learning systems can evolve, scale, and perform reliably over time.

### Evolving Roles and Specializations {#sec-ml-operations-evolving-roles-specializations-5d47}

As machine learning systems mature and organizations adopt MLOps practices at scale, the structure and specialization of roles often evolve. In early-stage environments, individual contributors may take on multiple responsibilities—such as a data scientist who also builds data pipelines or manages model deployment. However, as systems grow in complexity and teams expand, responsibilities tend to become more differentiated, giving rise to new roles and more structured organizational patterns.

One emerging trend is the formation of dedicated ML platform teams, which focus on building shared infrastructure and tooling to support experimentation, deployment, and monitoring across multiple projects. These teams often abstract common workflows, including data versioning, model training orchestration, and CI/CD integration, into reusable components or internal platforms. This approach reduces duplication of effort and accelerates development by enabling application teams to focus on domain-specific problems rather than underlying systems engineering.

In parallel, hybrid roles have emerged to bridge gaps between traditional boundaries. For example, full-stack ML engineers[^fn-full-stack-ML-engineer] combine expertise in modeling, software engineering, and infrastructure to own the end-to-end deployment of ML models. Similarly, ML enablement roles, including MLOps engineers and applied ML specialists, focus on helping teams adopt best practices, integrate tooling, and scale workflows efficiently. These roles are especially valuable in organizations with diverse teams that vary in ML maturity or technical specialization.

[^fn-full-stack-ML-engineer]: **Full-stack ML engineer:** A role that encompasses the skills of machine learning, software development, and system operations to handle end-to-end machine learning model lifecycle.

The structure of MLOps teams also varies based on organizational scale, industry, and regulatory requirements. In smaller organizations or startups, teams are often lean and cross-functional, with close collaboration and informal processes. In contrast, larger enterprises may formalize roles and introduce governance frameworks to manage compliance, data security, and model risk. Highly regulated sectors, including finance, healthcare, and defense, often require additional roles focused on validation, auditing, and documentation to meet external reporting obligations.

+------------------------+-----------------------------------------------+--------------------------------------------------+
| Role                   | Key Intersections                             | Evolving Patterns and Specializations            |
+:=======================+:==============================================+:=================================================+
| Data Engineer          | Works with data scientists to define          | Expands into real-time data systems and          |
|                        | features and pipelines                        | feature store platforms                          |
+------------------------+-----------------------------------------------+--------------------------------------------------+
| Data Scientist         | Relies on data engineers for clean inputs;    | Takes on model validation, interpretability,     |
|                        | collaborates with ML engineers                | and ethical considerations                       |
+------------------------+-----------------------------------------------+--------------------------------------------------+
| ML Engineer            | Receives models from data scientists;         | Transitions into platform engineering or         |
|                        | works with DevOps to deploy and monitor       | full-stack ML roles                              |
+------------------------+-----------------------------------------------+--------------------------------------------------+
| DevOps Engineer        | Supports ML engineers with infrastructure,    | Evolves into MLOps platform roles; integrates    |
|                        | CI/CD, and observability                      | governance and security tooling                  |
+------------------------+-----------------------------------------------+--------------------------------------------------+
| Project Manager        | Coordinates across all roles; tracks          | Specializes into ML product management as        |
|                        | progress and communication                    | systems scale                                    |
+------------------------+-----------------------------------------------+--------------------------------------------------+
| Responsible AI Lead    | Collaborates with data scientists and PMs     | Role emerges as systems face regulatory          |
|                        | to evaluate fairness and compliance           | scrutiny or public exposure                      |
+------------------------+-----------------------------------------------+--------------------------------------------------+
| Security & Privacy     | Works with DevOps and ML Engineers to         | Role formalizes as privacy regulations           |
| Engineer               | secure data pipelines and model interfaces    | (e.g., GDPR, HIPAA) apply to ML workflows        |
+------------------------+-----------------------------------------------+--------------------------------------------------+

: Evolution of MLOps roles and responsibilities. {#tbl-mlops-evolution .striped .hover}

Importantly, as @tbl-mlops-evolution indicates, the boundaries between roles are not rigid. Effective MLOps practices rely on shared understanding, documentation, and tools that facilitate communication and coordination across teams. Encouraging interdisciplinary fluency, including enabling data scientists to understand deployment workflows and DevOps engineers to interpret model monitoring metrics, enhances organizational agility and resilience.

As machine learning becomes increasingly central to modern software systems, roles will continue to adapt in response to emerging tools, methodologies, and system architectures. Recognizing the dynamic nature of these responsibilities allows teams to allocate resources effectively, design adaptable workflows, and foster collaboration that is essential for sustained success in production-scale machine learning.

## Operational System Design {#sec-ml-operations-operational-system-design-45b0}

Machine learning systems do not operate in isolation. As they transition from prototype to production, their effectiveness depends not only on the quality of the underlying models, but also on the maturity of the organizational and technical processes that support them. Operational maturity refers to the degree to which ML workflows are automated, reproducible, monitored, and aligned with broader engineering and governance practices. While early-stage efforts may rely on ad hoc scripts and manual interventions, production-scale systems require deliberate design choices that support long-term sustainability, reliability, and adaptability. This section examines how different levels of operational maturity influence system architecture, infrastructure design, and organizational structure, providing a lens through which to interpret the broader MLOps landscape [@kreuzberger2022machine].

### Operational Maturity {#sec-ml-operations-operational-maturity-ce6c}

Operational maturity in machine learning refers to the extent to which an organization can reliably develop, deploy, and manage ML systems in a repeatable and scalable manner. Unlike the maturity of individual models or algorithms, operational maturity reflects systemic capabilities: how well a team or organization integrates infrastructure, automation, monitoring, governance, and collaboration into the ML lifecycle.

Low-maturity environments often rely on manual workflows, loosely coupled components, and ad hoc experimentation. While sufficient for early-stage research or low-risk applications, such systems tend to be brittle, difficult to reproduce, and highly sensitive to data or code changes. As ML systems are deployed at scale, these limitations quickly become barriers to sustained performance, trust, and accountability.

In contrast, high-maturity environments implement modular, versioned, and automated workflows that allow models to be developed, validated, and deployed in a controlled and observable fashion. Data lineage is preserved across transformations; model behavior is continuously monitored and evaluated; and infrastructure is provisioned and managed as code. These practices reduce operational friction, enable faster iteration, and support robust decision-making in production [@zaharia2018accelerating].

Importantly, operational maturity is not solely a function of tool adoption. While technologies such as CI/CD pipelines, model registries, and observability stacks play a role, maturity is fundamentally about system integration and coordination, as in how these components work together to support reliability, reproducibility, and responsiveness under real-world constraints. It is this integration that distinguishes mature ML systems from collections of loosely connected artifacts.

### Maturity Levels {#sec-ml-operations-maturity-levels-7ade}

While operational maturity exists on a continuum, it is useful to distinguish between broad stages that reflect how ML systems evolve from research prototypes to production-grade infrastructure. These stages are not strict categories, but rather indicative of how organizations gradually adopt practices that support reliability, scalability, and observability.

At the lowest level of maturity, ML workflows are ad hoc: experiments are run manually, models are trained on local machines, and deployment involves hand-crafted scripts or manual intervention. Data pipelines may be fragile or undocumented, and there is limited ability to trace how a deployed model was produced. These environments may be sufficient for prototyping, but they are ill-suited for ongoing maintenance or collaboration.

As maturity increases, workflows become more structured and repeatable. Teams begin to adopt version control, automated training pipelines, and centralized model storage. Monitoring and testing frameworks are introduced, and retraining workflows become more systematic. Systems at this level can support limited scale and iteration but still rely heavily on human coordination.

At the highest levels of maturity, ML systems are fully integrated with infrastructure-as-code, continuous delivery pipelines, and automated monitoring. Data lineage, feature reuse, and model validation are encoded into the development process. Governance is embedded throughout the system, allowing for traceability, auditing, and policy enforcement. These environments support large-scale deployment, rapid experimentation, and adaptation to changing data and system conditions.

This progression, summarized in @tbl-maturity-levels, offers a system-level framework for analyzing ML operational practices. It emphasizes architectural cohesion and lifecycle integration over tool selection, guiding the design of scalable and maintainable learning systems.

+--------------------+------------------------------------------------------------------------------------------+--------------------------------------------------------+
| Maturity Level     | System Characteristics                                                                   | Typical Outcomes                                       |
+:===================+:=========================================================================================+:=======================================================+
| Ad Hoc             | Manual data processing, local training, no version control, unclear ownership            | Fragile workflows, difficult to reproduce or debug     |
+--------------------+------------------------------------------------------------------------------------------+--------------------------------------------------------+
| Repeatable         | Automated training pipelines, basic CI/CD, centralized model storage, some monitoring    | Improved reproducibility, limited scalability          |
+--------------------+------------------------------------------------------------------------------------------+--------------------------------------------------------+
| Scalable           | Fully automated workflows, integrated observability, infrastructure-as-code, governance  | High reliability, rapid iteration, production-grade ML |
+--------------------+------------------------------------------------------------------------------------------+--------------------------------------------------------+

: Maturity levels in machine learning operations. {#tbl-maturity-levels .striped .hover}

These maturity levels provide a systems lens through which to evaluate ML operations—not in terms of specific tools adopted, but in how reliably and cohesively a system supports the full machine learning lifecycle. Understanding this progression prepares practitioners to identify design bottlenecks and prioritize investments that support long-term system sustainability.

### System Design Implications {#sec-ml-operations-system-design-implications-06e0}

As machine learning operations mature, the underlying system architecture evolves in response. Operational maturity is not just an organizational concern—it has direct consequences for how ML systems are structured, deployed, and maintained. Each level of maturity introduces new expectations around modularity, automation, monitoring, and fault tolerance, shaping the design space in both technical and procedural terms.

In low-maturity environments, ML systems are often constructed around monolithic scripts and tightly coupled components. Data processing logic may be embedded directly within model code, and configurations are managed informally. These architectures, while expedient for rapid experimentation, lack the separation of concerns needed for maintainability, version control, or safe iteration. As a result, teams frequently encounter regressions, silent failures, and inconsistent performance across environments.

As maturity increases, modular abstractions begin to emerge. Feature engineering is decoupled from model logic, pipelines are defined declaratively, and system boundaries are enforced through APIs and orchestration frameworks. These changes support reproducibility and enable teams to scale development across multiple contributors or applications. Infrastructure becomes programmable through configuration files, and model artifacts are promoted through standardized deployment stages. This architectural discipline allows systems to evolve predictably, even as requirements shift or data distributions change.

At high levels of maturity, ML systems exhibit properties commonly found in production-grade software systems: stateless services, contract-driven interfaces, environment isolation, and observable execution. Design patterns such as feature stores, model registries, and infrastructure-as-code become foundational. Crucially, system behavior is not inferred from static assumptions, but monitored in real time and adapted as needed. This enables feedback-driven development and supports closed-loop systems where data, models, and infrastructure co-evolve.

In each case, operational maturity is not an external constraint but an architectural force: it governs how complexity is managed, how change is absorbed, and how the system can scale in the face of threats to service uptime (see @fig-uptime-iceberg). Design decisions that disregard these constraints may function under ideal conditions, but fail under real-world pressures such as latency requirements, drift, outages, or regulatory audits. Understanding this relationship between maturity and design is essential for building resilient machine learning systems that sustain performance over time.

::: {#fig-uptime-iceberg fig-env="figure" fig-pos="htb"}
```{.tikz}
\begin{tikzpicture}[line join=round,font=\usefont{T1}{phv}{m}{n}\small]

\tikzset{Line/.style={line width=1.5pt,BlueD},
 mysnake/.style={postaction={line width=2.5pt,BlueD,draw,decorate,
 decoration={snake,amplitude=1.8pt,segment length=18pt}}},
pics/flag/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[local bounding box=FLAG,scale=\scalefac, every node/.append style={transform shape}]
\draw[draw=\drawchannelcolor,fill=\channelcolor](0.15,1.07)to[out=30,in=220](1.51,1.07)to(1.51,2.02)
           to[out=210,in=40](0.15,2.04)--cycle;
\draw[draw=none,fill=\channelcolor](0.05,0)rectangle (-0.05,2.1);
\fill[fill=\channelcolor](0,2.1)circle(3pt);
\end{scope}
     }
  }
}
\pgfkeys{
  /channel/.cd,
  channelcolor/.store in=\channelcolor,
  drawchannelcolor/.store in=\drawchannelcolor,
  scalefac/.store in=\scalefac,
  Linewidth/.store in=\Linewidth,
  picname/.store in=\picname,
  channelcolor=BrownLine,
  drawchannelcolor=BrownLine,
  scalefac=1,
  Linewidth=1.6pt,
  picname=C
}
\colorlet{BlueD}{GreenD}

\begin{scope}[local bounding box=FLAG1,shift={($(0,0)+(0,0)$)},
scale=1, every node/.append style={transform shape}]
\pic[shift={(0,0)}] at  (0,0){flag={scalefac=0.45,picname=1,drawchannelcolor=none,channelcolor=GreenD, Linewidth=1.0pt}};
 \end{scope}
%
\path[top color=GreenD!60,bottom color=GreenD](-1.69,-1.69)--(-2,-2)--(-2.5,-2.06)--(-3.1,-3.0)--(-4,-3.84)--(-3.72,-4.33) --(-3.95,-4.5)
 --(-2.85,-5.92)--(-3,-6.059)--(-1.84,-7.341)-- (1.9,-7.341)--(3.58,-5.45)--(3.35,-4.56)--(3.91,-3.5)--(3.5,-3.18)
 --(2.82,-2.11)--(2.25,-2.05)--(1.85,-1.69)--cycle;
  \draw[Line](-1.13,-1.14)--(-2,-2)--(-2.5,-2.06)--(-3.1,-3.0)--(-4,-3.84)--(-3.72,-4.33) --(-3.95,-4.5)
 --(-2.85,-5.92)--(-3,-6.059)--(-1.84,-7.341)-- (1.9,-7.341)--(3.58,-5.45)--(3.35,-4.56)--(3.91,-3.5)--(3.5,-3.18)
 --(2.82,-2.11)--(2.25,-2.05)--(1.2,-1.14);
 \node[draw=none,rectangle,minimum width=140mm,inner sep=0pt, minimum height=2mm](TA)at(0,-1.7){};
\path[mysnake](TA.west)--(TA.east);
\draw[Line](0,0)--(-0.6,-0.63);
\draw[Line](-0.45,-0.65)--(-0.84,-0.60)--(-1.26,-1.41);
\draw[Line](0,0)--(0.57,-0.55);
 \draw[Line](0.45,-0.61)--(0.84,-0.37)--(1.38,-1.51);
 %
\node[BlueD]at(0,-1.2){UPTIME};
\node[white]at(1.2,-2.4){MODEL ACCURACY};
\node[white]at(-1.34,-2.75){DATA DRIFT};
\node[white]at(2.1,-3.35){CONCEPT DRIFT};
\node[white]at(-1.85,-3.75){BROKEN PIPELINES};
\node[white]at(-0.05,-4.5){SCHEMA CHANGE};
\node[white]at(1.8,-5.2){MODEL BIAS};
\node[white]at(-1.5,-5.4){DATA OUTAGE};
\node[white,align=center]at(0.15,-6.4){UNDERPERFORMING\\ SEGMENTS};
%
\node[BlueD]at(-5,-2.65){Data health};
\node[BlueD]at(5,-2.6){Model health};
\node[BlueD]at(2.8,0.1){Service health};
\end{tikzpicture}
```
How ML service uptime is supported by an "iceberg" of underlying components to monitor.
:::

### Patterns and Anti-Patterns {#sec-ml-operations-patterns-antipatterns-8466}

The structure of the teams involved in building and maintaining machine learning systems plays a significant role in determining operational outcomes. As ML systems grow in complexity and scale, organizational patterns must evolve to reflect the interdependence between data, modeling, infrastructure, and governance. While there is no single ideal structure, certain patterns consistently support operational maturity, whereas others tend to hinder it.

In mature environments, organizational design emphasizes clear ownership, cross-functional collaboration, and interface discipline between roles. For instance, platform teams may take responsibility for shared infrastructure, tooling, and CI/CD pipelines, while domain teams focus on model development and business alignment. This separation of concerns enables reuse, standardization, and parallel development. Interfaces between teams, including feature definitions, data schemas, and deployment targets, are well-defined and versioned, reducing friction and ambiguity.

One effective pattern is the creation of a centralized MLOps team that provides shared services to multiple model development groups. This team maintains tooling for model training, validation, deployment, and monitoring, and may operate as an internal platform provider. Such structures promote consistency, reduce duplicated effort, and accelerate onboarding for new projects. Alternatively, some organizations adopt a federated model, embedding MLOps engineers within product teams while maintaining a central architectural function to guide system-wide integration.

In contrast, anti-patterns often emerge when responsibilities are fragmented or poorly aligned. One common failure mode is the tool-first approach, in which teams adopt infrastructure or automation tools without first defining the processes and roles that should govern their use. This can result in fragile pipelines, unclear handoffs, and duplicated effort. Another anti-pattern is siloed experimentation, where data scientists operate in isolation from production engineers, leading to models that are difficult to deploy, monitor, or retrain effectively.

Organizational drift is another subtle challenge. As teams scale, undocumented workflows and informal agreements may become entrenched, increasing the cost of coordination and reducing transparency. Without deliberate system design and process review, even previously functional structures can accumulate technical and organizational debt.

Ultimately, organizational maturity must co-evolve with system complexity. Teams must establish communication patterns, role definitions, and accountability structures that reinforce the principles of modularity, automation, and observability. Operational excellence in machine learning is not just a matter of technical capability—it is the product of coordinated, intentional systems thinking across human and computational boundaries.

### Contextualizing MLOps {#sec-ml-operations-contextualizing-mlops-3863}

The operational maturity of a machine learning system is not an abstract ideal; it is realized in concrete systems with physical, organizational, and regulatory constraints. While the preceding sections have outlined best practices for mature MLOps, which include CI/CD, monitoring, infrastructure provisioning, and governance, these practices are rarely deployed in pristine, unconstrained environments. In reality, every ML system operates within a specific context that shapes how MLOps workflows are implemented, prioritized, and adapted.

System constraints may arise from the physical environment in which a model is deployed, such as limitations in compute, memory, or power. These are common in edge and embedded systems, where models must run under strict latency and resource constraints. Connectivity limitations, such as intermittent network access or bandwidth caps, further complicate model updates, monitoring, and telemetry collection. In high-assurance domains, including healthcare, finance, and industrial control systems, governance, traceability, and fail-safety may take precedence over throughput or latency. These factors do not simply influence system performance; they fundamentally alter how MLOps pipelines must be designed and maintained.

For instance, a standard CI/CD pipeline for retraining and deployment may be infeasible in environments where direct access to the model host is not possible. In such cases, teams must implement alternative delivery mechanisms, such as over-the-air updates, that account for reliability, rollback capability, and compatibility across heterogeneous devices. Similarly, monitoring practices that assume full visibility into runtime behavior may need to be reimagined using indirect signals, coarse-grained telemetry, or on-device anomaly detection. Even the simple task of collecting training data may be limited by privacy concerns, device-level storage constraints, or legal restrictions on data movement.

These adaptations should not be interpreted as deviations from maturity, but rather as expressions of maturity under constraint. A well-engineered ML system accounts for the realities of its operating environment and revises its operational practices accordingly. This is the essence of systems thinking in MLOps: applying general principles while designing for specificity.

As we turn to the chapters ahead, we will encounter several of these contextual factors, including on-device learning, privacy preservation, safety and robustness, and sustainability. Each presents not just a technical challenge but a system-level constraint that reshapes how machine learning is practiced and maintained at scale. Understanding MLOps in context is therefore not optional—it is foundational to building ML systems that are viable, trustworthy, and effective in the real world.

### Looking Ahead {#sec-ml-operations-looking-ahead-24bb}

As this chapter has shown, the deployment and maintenance of machine learning systems require more than technical correctness at the model level. They demand architectural coherence,[^fn-architectural-coherence] organizational alignment, and operational maturity. The progression from ad hoc experimentation to scalable, auditable systems reflects a broader shift: machine learning is no longer confined to research environments—it is a core component of production infrastructure.

[^fn-architectural-coherence]: Refers to the logical, consistent, and scalable design and integration of various system components.

Understanding the maturity of an ML system helps clarify what challenges are likely to emerge and what forms of investment are needed to address them. Early-stage systems benefit from process discipline and modular abstraction; mature systems require automation, governance, and resilience. Design choices made at each stage influence the pace of experimentation, the robustness of deployed models, and the ability to integrate evolving requirements—technical, organizational, and regulatory.

This systems-oriented view of MLOps also sets the stage for the next phase of this book. The remaining chapters examine specific application contexts and operational concerns, including on-device inference, privacy, robustness, and sustainability, that depend on the foundational capabilities developed in this chapter. These topics represent not merely extensions of model performance, but domains in which operational maturity directly enables feasibility, safety, and long-term value.

Operational maturity is therefore not the end of the machine learning system lifecycle—it is the foundation upon which production-grade, responsible, and adaptive systems are built. The following chapters explore what it takes to build such systems under domain-specific constraints, further expanding the scope of what it means to engineer machine learning at scale.

## Case Studies {#sec-ml-operations-case-studies-145a}

To ground the principles of MLOps in practice, we examine two illustrative case studies that demonstrate the operationalization of machine learning in real-world systems. These examples highlight how operational maturity, robust system design, and cross-functional collaboration enable the successful deployment and maintenance of ML applications.

The first case study analyzes the Oura Ring, which is a consumer wearable device that employs embedded machine learning to monitor sleep and physiological signals. This example illustrates MLOps practices in resource-constrained environments, where models must operate efficiently on edge devices while maintaining reliability and accuracy. The second case study explores ClinAIOps, a specialized framework for deploying AI systems in clinical settings. By examining its application to continuous therapeutic monitoring (CTM), we see how MLOps principles can be adapted to domains with strict regulatory requirements and complex human-in-the-loop workflows.

Through these cases, we gain practical insights into how organizations navigate technical, operational, and domain-specific challenges in productionizing machine learning systems. Each example reinforces core MLOps concepts while revealing unique considerations that arise in different application contexts.

### Oura Ring Case Study {#sec-ml-operations-oura-ring-case-study-cf68}

#### Context and Motivation {#sec-ml-operations-context-motivation-fb76}

The Oura Ring is a consumer-grade wearable device designed to monitor sleep, activity, and physiological recovery through embedded sensing and computation. By measuring signals such as motion, heart rate, and body temperature, the device estimates sleep stages and delivers personalized feedback to users. Unlike traditional cloud-based systems, much of the Oura Ring's data processing and inference occurs directly on the device, making it a practical example of embedded machine learning in production.

The central objective for the development team was to improve the device's accuracy in classifying sleep stages, aligning its predictions more closely with those obtained through polysomnography (PSG)[^fn-psg]—the clinical gold standard for sleep monitoring. Initial evaluations revealed a 62% correlation between the Oura Ring's predictions and PSG-derived labels, in contrast to the 82–83% correlation observed between expert human scorers. This discrepancy highlighted both the promise and limitations of the initial model, prompting a systematic effort to re-evaluate data collection, preprocessing, and model development workflows. As such, the case illustrates the importance of robust MLOps practices, particularly when operating under the constraints of embedded systems.

[^fn-psg]: **Polysomnography (PSG):** A clinical study or test used to diagnose sleep disorders; involves EEG and other physiologic sensors.

#### Data Acquisition and Preprocessing {#sec-ml-operations-data-acquisition-preprocessing-82fc}

To overcome the performance limitations of the initial model, the Oura team focused on constructing a robust, diverse dataset grounded in clinical standards. They designed a large-scale sleep study involving 106 participants from three continents, including Asia, Europe, and North America, capturing broad demographic variability across age, gender, and lifestyle. During the study, each participant wore the Oura Ring while simultaneously undergoing polysomnography (PSG), the clinical gold standard for sleep staging. This pairing enabled the creation of a high-fidelity labeled dataset aligning wearable sensor data with validated sleep annotations.

In total, the study yielded 440 nights of data and over 3,400 hours of time-synchronized recordings. This dataset captured not only physiological diversity but also variability in environmental and behavioral factors, which is critical for generalizing model performance across a real-world user base.

To manage the complexity and scale of this dataset, the team implemented automated data pipelines for ingestion, cleaning, and preprocessing. Physiological signals, comprising heart rate, motion, and body temperature, were extracted and validated using structured workflows. Leveraging the Edge Impulse platform[^fn-edge-impulse], they consolidated raw inputs from multiple sources, resolved temporal misalignments, and structured the data for downstream model development. These workflows significantly reduced the need for manual intervention, highlighting how MLOps principles such as pipeline automation, data versioning, and reproducible preprocessing are essential in embedded ML settings.

[^fn-edge-impulse]: **Edge Impulse:** A development platform for embedded machine learning, enabling data collection, model training, and deployment on edge devices.

### Model Development and Evaluation {#sec-ml-operations-model-development-evaluation-d905}

With a high-quality, clinically labeled dataset in place, the Oura team advanced to the development and evaluation of machine learning models designed to classify sleep stages. Recognizing the operational constraints of wearable devices, model design prioritized efficiency and interpretability alongside predictive accuracy. Rather than employing complex architectures typical of server-scale deployments, the team selected models that could operate within the ring's limited memory and compute budget.

Two model configurations were explored. The first used only accelerometer data, representing a lightweight architecture optimized for minimal energy consumption and low-latency inference. The second model incorporated additional physiological inputs, including heart rate variability and body temperature, enabling the capture of autonomic nervous system activity and circadian rhythms—factors known to correlate with sleep stage transitions.

To evaluate performance, the team applied five-fold cross-validation and benchmarked the models against the gold-standard PSG annotations. Through iterative tuning of hyperparameters and refinement of input features, the enhanced models achieved a correlation accuracy of 79%, significantly surpassing the original system's 62% correlation and approaching the clinical benchmark of 82–83%.

These performance gains did not result solely from architectural innovation. Instead, they reflect the broader impact of a systematic MLOps approach—one that integrated rigorous data collection, reproducible training pipelines, and disciplined evaluation practices. This phase underscores the importance of aligning model development with both application constraints and system-level reliability, particularly in embedded ML environments where deployment feasibility is as critical as accuracy.

### Deployment and Iteration {#sec-ml-operations-deployment-iteration-0b43}

Following model validation, the Oura team transitioned to deploying the trained models onto the ring's embedded hardware. Deployment in this context required careful accommodation of strict constraints on memory, compute, and power. The lightweight model, which relied solely on accelerometer input, was particularly well-suited for real-time inference on-device, delivering low-latency predictions with minimal energy usage. In contrast, the more comprehensive model, which utilized additional physiological signals, including heart rate variability and temperature, was deployed selectively, where higher predictive fidelity was required and system resources permitted.

To facilitate reliable and scalable deployment, the team developed a modular toolchain for converting trained models into optimized formats suitable for embedded execution. This process included model compression techniques such as quantization and pruning, which reduced model size while preserving accuracy. Models were packaged with their preprocessing routines and deployed using over-the-air (OTA) update mechanisms, ensuring consistency across devices in the field.

Instrumentation was built into the deployment pipeline to support post-deployment observability. The system collected operational telemetry, including runtime performance metrics, device-specific conditions, and samples of model predictions. This monitoring infrastructure enabled the identification of drift, edge cases, and emerging patterns in real-world usage, closing the feedback loop between deployment and further development.

This stage illustrates key practices of MLOps in embedded systems: resource-aware model packaging, OTA deployment infrastructure, and continuous performance monitoring. It reinforces the importance of designing systems for adaptability and iteration, ensuring that ML models remain accurate and reliable under real-world operating conditions.

### Lessons from MLOps Practice {#sec-ml-operations-lessons-mlops-practice-61c9}

The Oura Ring case study illustrates several essential principles for managing machine learning systems in real-world, resource-constrained environments. First, it highlights the foundational role of data quality and labeling. While model architecture and training pipelines are important, the success of the system was driven by a disciplined approach to data acquisition, annotation, and preprocessing. This affirms the importance of data-centric practices in MLOps workflows.

Second, the deployment strategy demonstrates the need for system-aware model design. Rather than relying on a single large model, the team developed tiered models optimized for different deployment contexts. This modularity enabled tradeoffs between accuracy and efficiency to be managed at runtime, a key consideration for on-device and embedded inference.

Third, the case emphasizes the value of operational feedback loops. Instrumentation for logging and monitoring allowed the team to track system behavior post-deployment, identify shortcomings, and guide further iterations. This reinforces the role of observability and feedback as core components of the MLOps lifecycle.

Finally, the success of the Oura project was not due to a single team or phase of work but emerged from coordinated collaboration across data engineers, ML researchers, embedded systems developers, and operations personnel. The ability to move seamlessly from data acquisition to deployment reflects the maturity of the MLOps practices involved.

Taken together, this case exemplifies how MLOps is not merely a set of tools or techniques but a mindset for integrating ML into end-to-end systems that are reliable, scalable, and adaptive in production settings.

### ClinAIOps Case Study {#sec-ml-operations-clinaiops-case-study-fd5c}

The deployment of machine learning systems in healthcare presents both a significant opportunity and a unique challenge. While traditional MLOps frameworks offer structured practices for managing model development, deployment, and monitoring, they often fall short in domains that require extensive human oversight, domain-specific evaluation, and ethical governance. Medical health monitoring, especially through continuous therapeutic monitoring (CTM), is one such domain where MLOps must evolve to meet the demands of real-world clinical integration.

CTM leverages wearable sensors and devices to collect rich streams of physiological and behavioral data from patients in real time. These data streams offer clinicians the potential to tailor treatments more dynamically, shifting from reactive care to proactive, personalized interventions. Recent advances in embedded ML have made this increasingly feasible. For example, wearable biosensors can automate insulin dosing for diabetes management [@psoma2023wearable], ECG-equipped wristbands can inform blood thinner adjustments for atrial fibrillation [@attia2018noninvasive; @guo2019mobile], and gait-monitoring accelerometers can trigger early interventions to prevent mobility decline in older adults [@liu2022monitoring]. By closing the loop between sensing and therapeutic response, CTM systems powered by embedded ML are redefining how care is delivered beyond the clinical setting.

However, the mere deployment of ML models is insufficient to realize these benefits. AI systems must be integrated into clinical workflows, aligned with regulatory requirements, and designed to augment rather than replace human decision-making. The traditional MLOps paradigm, which focuses on automating pipelines for model development and serving, does not adequately account for the complex sociotechnical landscape of healthcare, where patient safety, clinician judgment, and ethical constraints must be prioritized.

This case study explores ClinAIOps, a framework proposed for operationalizing AI in clinical environments [@chen2023framework]. Unlike conventional MLOps, ClinAIOps introduces mechanisms for multi-stakeholder coordination through structured feedback loops that connect patients, clinicians, and AI systems. The framework is designed to facilitate adaptive decision-making, ensure transparency and oversight, and support continuous improvement of both models and care protocols.

Before presenting a real-world application example, it is helpful to examine the limitations of traditional MLOps in clinical settings:

- MLOps focuses primarily on the model lifecycle (e.g., training, deployment, monitoring), whereas healthcare requires coordination among diverse human actors, such as patients, clinicians, and care teams.
- Traditional MLOps emphasizes automation and system reliability, but clinical decision-making hinges on personalized care, interpretability, and shared accountability.
- The ethical, regulatory, and safety implications of AI-driven healthcare demand governance frameworks that go beyond technical monitoring.
- Clinical validation requires not just performance metrics but evidence of safety, efficacy, and alignment with care standards.
- Health data is highly sensitive, and systems must comply with strict privacy and security regulations—considerations that traditional MLOps frameworks do not fully address.

In light of these gaps, ClinAIOps presents an alternative: a framework for embedding ML into healthcare in a way that balances technical rigor with clinical utility, operational reliability with ethical responsibility. The remainder of this case study introduces the ClinAIOps framework and its feedback loops, followed by a detailed walkthrough of a hypertension management example that illustrates how AI can be effectively integrated into routine clinical practice.

#### Feedback Loops {#sec-ml-operations-feedback-loops-be69}

At the core of the ClinAIOps framework are three interlocking feedback loops that enable the safe, effective, and adaptive integration of machine learning into clinical practice. As illustrated in @fig-clinaiops, these loops are designed to coordinate inputs from patients, clinicians, and AI systems, facilitating data-driven decision-making while preserving human accountability and clinical oversight.

::: {#fig-clinaiops fig-env="figure" fig-pos="htb"}
```{.tikz}
\scalebox{0.8}{%
\begin{tikzpicture}[line join=round,font=\small\usefont{T1}{phv}{m}{n}]
%radius
\def\ra{53mm}
\newcommand{\gear}[6]{%
  (0:#2)
  \foreach \i [evaluate=\i as \n using {\i-1)*360/#1}] in {1,...,#1}{%
    arc (\n:\n+#4:#2) {[rounded corners=1.5pt] -- (\n+#4+#5:#3)
    arc (\n+#4+#5:\n+360/#1-#5:#3)} --  (\n+360/#1:#2)
  }%
  (0,0) circle[radius=#6];
  \scoped[on background layer]
}

\tikzset{
  man/.pic={
  \pgfkeys{/man/.cd, #1}
     % tie
    \draw[draw=\tiecolor,fill=\tiecolor] (0.0,-1.1)--(0.16,-0.87)--(0.09,-0.46)--(0.13,-0.37)--(0.0,-0.28)--(-0.13,-0.37)--(-0.09,-0.46)--(-0.16,-0.87)--cycle;
    % ears
    \draw[fill=black,draw=none] (0.74,0.95) to[out=20,in=80](0.86,0.80) to[out=250,in=330](0.65,0.65) to[out=70,in=260] cycle;
    \draw[fill=black,draw=none] (-0.76,0.96) to[out=170,in=110](-0.85,0.80) to[out=290,in=190](-0.65,0.65) to[out=110,in=290] cycle;

    % head
    \draw[fill=black,draw=none] (0,0) to[out=180,in=290](-0.72,0.84) to[out=110,in=190](-0.56,1.67)
               to[out=70,in=110](0.68,1.58) to[out=320,in=80](0.72,0.84) to[out=250,in=0] cycle;
    % face
    \draw[fill=white,draw=none] (0,0.11) to[out=175,in=290](-0.53,0.65) to[out=110,in=265](-0.61,1.22)
                      to[out=80,in=235](-0.50,1.45) to[out=340,in=215](0.50,1.47)
                      to[out=310,in=85](0.60,0.92) to[out=260,in=2] cycle;
    \draw[fill=black,draw=none] (-0.50,1.45) to[out=315,in=195](0.40,1.25) to[out=340,in=10](0.37,1.32)
                      to[out=190,in=310](-0.40,1.49) -- cycle;
    % neck
    \draw[line width=1.5pt] (-0.62,-0.2) to[out=50,in=290] (-0.5,0.42);
    \draw[line width=1.5pt] (0.62,-0.2) to[out=130,in=250] (0.5,0.42);
    % body
    \draw[draw=\bodycolor,fill=\bodycolor] (0.0,-1.0) to[out=150,in=290](-0.48,-0.14) to[out=200,in=50](-1.28,-0.44)
                   to[out=240,in=80](-1.55,-2.06) -- (1.55,-2.06)
                   to[out=100,in=300](1.28,-0.44) to[out=130,in=340](0.49,-0.14)
                   to[out=245,in=30] cycle;
    % right stet
    \draw[line width=2pt,\stetcolor] (0.8,-0.21) to[bend left=7](0.78,-0.64)
         to[out=350,in=80](0.98,-1.35) to[out=250,in=330](0.72,-1.60);
    \draw[line width=2pt,\stetcolor] (0.43,-1.53) to[out=180,in=240](0.3,-1.15)
         to[out=60,in=170](0.78,-0.64);
    % left stet
    \draw[line width=2pt,\stetcolor] (-0.75,-0.21) to[bend right=20](-0.65,-1.45);
    \node[fill=\stetcolor,circle,minimum size=5pt] at (-0.65,-1.45) {};
    % eyes
    \node[circle,fill=black,inner sep=2pt] at (0.28,0.94) {};
    \node[circle,fill=black,inner sep=2pt] at (-0.28,0.94) {};
     % mouth
    \draw[line width=1.0pt] (-0.25,0.5) to[bend right=40](0.25,0.5);
  },
}
\pgfkeys{
  /man/.cd,
  tiecolor/.store in=\tiecolor,
  bodycolor/.store in=\bodycolor,
  stetcolor/.store in=\stetcolor,
  tiecolor=red,      % derfault tie color
  bodycolor=blue!30  % derfault body color
  stetcolor=green  % derfault stet color
}

\begin{scope}[local bounding box=PAC,
shift={($(90: 0.5*\ra)+(0,0.3)$)},
scale=0.5, every node/.append style={transform shape}]
\pic[scale=1] {man={tiecolor=red!50!yellow, bodycolor=green!50!blue,stetcolor=green!50!blue}};
\end{scope}

\begin{scope}[local bounding box=DOC,
shift={($(210: 0.5*\ra)+(-0.4,0.1)$)},
scale=0.5, every node/.append style={transform shape}]
\pic at (0,0) {man={tiecolor=red, bodycolor=VioletLine2,stetcolor=yellow}};
\end{scope}

\begin{scope}[local bounding box=GEAR,
shift={($(330: 0.5*\ra)+(0.5,0)$)},
scale=0.7, every node/.append style={transform shape}]
\fill[draw=none,fill=green!50!red,even odd rule] \gear{14}{1.2}{1.4}{10}{2}{0.9}coordinate(2GER1);
\end{scope}

\definecolor{CPU}{RGB}{0,120,176}
\begin{scope}[local bounding box = CPU,scale=0.3, every node/.append style={transform shape},
shift={($(GEAR)+(0,0)$)}]
\node[fill=CPU,minimum width=66, minimum height=66,
            rounded corners=2,outer sep=2pt] (C1) {};
\node[fill=white,minimum width=54, minimum height=54] (C2) {};
\node[fill=CPU!40,minimum width=44, minimum height=44,align=center,inner sep=0pt] (C3) {\huge AI};

\foreach \x/\y in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{
\node[fill=CPU,minimum width=3, minimum height=12,
           inner sep=0pt,anchor=south](GO\y)at($(C1.north west)!\x!(C1.north east)$){};
}
\foreach \x/\y in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{
\node[fill=CPU,minimum width=3, minimum height=12,
           inner sep=0pt,anchor=north](DO\y)at($(C1.south west)!\x!(C1.south east)$){};
}
\foreach \x/\y in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{
\node[fill=CPU,minimum width=12, minimum height=3,
           inner sep=0pt,anchor=east](LE\y)at($(C1.north west)!\x!(C1.south west)$){};
}
\foreach \x/\y in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{
\node[fill=CPU,minimum width=12, minimum height=3,
           inner sep=0pt,anchor=west](DE\y)at($(C1.north east)!\x!(C1.south east)$){};
}
\end{scope}
\draw[{Triangle[width=12pt,length=8pt]}-, line width=5pt,violet!80] (355:0.5*\ra)
                arc[radius=0.5*\ra, start angle=-5, end angle= 67]node[left,pos=0.3,
                align=center,font=\footnotesize\usefont{T1}{phv}{m}{n},text=black]{Continuous \\monitoring data\\ and health report};
\draw[{Triangle[width=12pt,length=8pt]}-, line width=5pt,CPU] (110:0.5*\ra)
arc[radius=0.5*\ra, start angle=110, end angle= 181]node[right=0.3,pos=0.66,
                align=center,font=\footnotesize\usefont{T1}{phv}{m}{n},text=black]{Therapy\\ regimen};
\draw[{Triangle[width=12pt,length=8pt]}-, line width=5pt,red!70] (233:0.5*\ra)
arc[radius=0.5*\ra, start angle=233, end angle= 311]node[above=0.4,pos=0.5,
                align=center,font=\footnotesize\usefont{T1}{phv}{m}{n},text=black]{
Alerts for therapy\\ modifications and\\ monitor summaries};
%%biger circle
%radius
\def\ra{68mm}
\draw[-{Triangle[width=12pt,length=8pt]}, line width=5pt,violet!40] (353:0.5*\ra)
                arc[radius=0.5*\ra, start angle=-7, end angle= 77]node[right=0.21,pos=0.5,
                align=center,font=\footnotesize\usefont{T1}{phv}{m}{n},text=black]{Alerts for\\ clinician-approved\\
                therapy updates};
\draw[-{Triangle[width=12pt,length=8pt]}, line width=5pt,CPU!40] (105:0.5*\ra)
arc[radius=0.5*\ra, start angle=105, end angle= 185]node[left=0.2,pos=0.5,
                align=center,font=\footnotesize\usefont{T1}{phv}{m}{n},text=black]{Health challenges\\ and goals};
\draw[-{Triangle[width=12pt,length=8pt]}, line width=5pt,red!40] (232:0.5*\ra)
arc[radius=0.5*\ra, start angle=232, end angle= 305]node[below=0.11,pos=0.5,
                align=center,font=\footnotesize\usefont{T1}{phv}{m}{n},text=black]{
Limits and approvals \\of therapy regimens};
%
\node[below=0.1of PAC]{\textbf{Patient}};
\node[below=0.1of DOC]{\textbf{Doctor}};
\node[below=0.48of CPU]{\textbf{AI developer}};
\end{tikzpicture}}
```
ClinAIOps cycle. Source: @chen2023framework.
:::

In this model, the patient is central—contributing real-world physiological data, reporting outcomes, and serving as the primary beneficiary of optimized care. The clinician interprets this data in context, provides clinical judgment, and oversees treatment adjustments. Meanwhile, the AI system continuously analyzes incoming signals, surfaces actionable insights, and learns from feedback to improve its recommendations.

Each feedback loop plays a distinct yet interconnected role:

- The **Patient-AI loop** captures and interprets real-time physiological data, generating tailored treatment suggestions.
- The **Clinician-AI loop** ensures that AI-generated recommendations are reviewed, vetted, and refined under professional supervision.
- The **Patient-Clinician loop** supports shared decision-making, empowering patients and clinicians to collaboratively set goals and interpret data trends.

Together, these loops enable adaptive personalization of care. They help calibrate AI system behavior to the evolving needs of each patient, maintain clinician control over treatment decisions, and promote continuous model improvement based on real-world feedback. By embedding AI within these structured interactions, instead of isolating it as a standalone tool, ClinAIOps provides a blueprint for responsible and effective AI integration into clinical workflows.

##### Patient-AI Loop {#sec-ml-operations-patientai-loop-dbdc}

The patient–AI loop enables personalized and timely therapy optimization by leveraging continuous physiological data collected through wearable devices. Patients are equipped with sensors such as smartwatches, skin patches, or specialized biosensors that passively capture health-related signals in real-world conditions. For instance, a patient managing diabetes may wear a continuous glucose monitor, while individuals with cardiovascular conditions may use ECG-enabled wearables[^fn-ECG] to track cardiac rhythms.

[^fn-ECG]: **Electrocardiogram (ECG):** A test that records the electrical activity of the heart over a period of time using electrodes placed on the skin.

The AI system continuously analyzes these data streams in conjunction with relevant clinical context drawn from the patient's electronic medical records, including diagnoses, lab values, prescribed medications, and demographic information. Using this holistic view, the AI model generates individualized recommendations for treatment adjustments—such as modifying dosage levels, altering administration timing, or flagging anomalous trends for review.

To ensure both responsiveness and safety, treatment suggestions are tiered. Minor adjustments that fall within clinician-defined safety thresholds may be acted upon directly by the patient, empowering self-management while reducing clinical burden. More significant changes require review and approval by a healthcare provider. This structure maintains human oversight while enabling high-frequency, data-driven adaptation of therapies.

By enabling real-time, tailored interventions, including automatic insulin dosing adjustments based on glucose trends, this loop exemplifies how machine learning can close the feedback gap between sensing and treatment, allowing for dynamic, context-aware care outside of traditional clinical settings.

##### Clinician-AI Loop {#sec-ml-operations-clinicianai-loop-3c88}

The clinician–AI loop introduces a critical layer of human oversight into the process of AI-assisted therapeutic decision-making. In this loop, the AI system generates treatment recommendations and presents them to the clinician along with concise, interpretable summaries of the underlying patient data. These summaries may include longitudinal trends, sensor-derived metrics, and contextual factors extracted from the electronic health record[^fn-electronic-health-record].

[^fn-electronic-health-record]: **Electronic Health Record (EHR):** A digital system that stores patient health information, used across treatment settings.

For example, an AI model might recommend a reduction in antihypertensive medication dosage for a patient whose blood pressure has remained consistently below target thresholds. The clinician reviews the recommendation in the context of the patient's broader clinical profile and may choose to accept, reject, or modify the proposed change. This feedback, in turn, contributes to the continuous refinement of the model, improving its alignment with clinical practice.

Crucially, clinicians also define the operational boundaries within which the AI system can autonomously issue recommendations. These constraints ensure that only low-risk adjustments are automated, while more significant decisions require human approval. This preserves clinical accountability, supports patient safety, and enhances trust in AI-supported workflows.

The clinician–AI loop exemplifies a hybrid model of care in which AI augments rather than replaces human expertise. By enabling efficient review and oversight of algorithmic outputs, it facilitates the integration of machine intelligence into clinical practice while preserving the role of the clinician as the final decision-maker.

##### Patient-Clinician Loop {#sec-ml-operations-patientclinician-loop-80a8}

The patient–clinician loop enhances the quality of clinical interactions by shifting the focus from routine data collection to higher-level interpretation and shared decision-making. With AI systems handling data aggregation and basic trend analysis, clinicians are freed to engage more meaningfully with patients—reviewing patterns, contextualizing insights, and setting personalized health goals.

For example, in managing diabetes, a clinician may use AI-summarized data to guide a discussion on dietary habits and physical activity, tailoring recommendations to the patient's specific glycemic trends. Rather than adhering to fixed follow-up intervals, visit frequency can be adjusted dynamically based on patient progress and stability, ensuring that care delivery remains responsive and efficient.

This feedback loop positions the clinician not merely as a prescriber but as a coach and advisor, interpreting data through the lens of patient preferences, lifestyle, and clinical judgment. It reinforces the therapeutic alliance[^fn-therapeutic-alliance] by fostering collaboration and mutual understanding—key elements in personalized and patient-centered care.

[^fn-therapeutic-alliance]: The partnership formed between a clinician and a patient that enhances treatment effectiveness.

#### Hypertension Case Example {#sec-ml-operations-hypertension-case-example-f5aa}

To concretize the principles of ClinAIOps, consider the management of hypertension—a condition affecting nearly half of adults in the United States (48.1%, or approximately 119.9 million individuals, according to the Centers for Disease Control and Prevention). Effective hypertension control often requires individualized, ongoing adjustments to therapy, making it an ideal candidate for continuous therapeutic monitoring.

ClinAIOps offers a structured framework for managing hypertension by integrating wearable sensing technologies, AI-driven recommendations, and clinician oversight into a cohesive feedback system. In this context, wearable devices equipped with photoplethysmography (PPG) and electrocardiography (ECG) sensors passively capture cardiovascular data, which can be analyzed in near-real-time to inform treatment adjustments. These inputs are augmented by behavioral data (e.g., physical activity) and medication adherence logs, forming the basis for an adaptive and responsive treatment regimen.

The following subsections detail how the patient–AI, clinician–AI, and patient–clinician loops apply in this setting, illustrating the practical implementation of ClinAIOps for a widespread and clinically significant condition.

##### Data Collection {#sec-ml-operations-data-collection-d1e8}

In a ClinAIOps-based hypertension management system, data collection is centered on continuous, multimodal physiological monitoring. Wrist-worn devices equipped with photoplethysmography (PPG) and electrocardiography (ECG) sensors provide noninvasive estimates of blood pressure [@zhang2017highly]. These wearables also include accelerometers to capture physical activity patterns, enabling contextual interpretation of blood pressure fluctuations in relation to movement and exertion.

Complementary data inputs include self-reported logs of antihypertensive medication intake, specifying dosage and timing, as well as demographic attributes and clinical history extracted from the patient's electronic health record. Together, these heterogeneous data streams form a rich, temporally aligned dataset that captures both physiological states and behavioral factors influencing blood pressure regulation.

By integrating real-world sensor data with longitudinal clinical information, this comprehensive data foundation enables the development of personalized, context-aware models for adaptive hypertension management.

##### AI Model {#sec-ml-operations-ai-model-e44f}

The AI component in a ClinAIOps-driven hypertension management system is designed to operate directly on the device or in close proximity to the patient, enabling near real-time analysis and decision support. The model ingests continuous streams of blood pressure estimates, circadian rhythm indicators, physical activity levels, and medication adherence patterns to generate individualized therapeutic recommendations.

Using machine learning techniques, the model infers optimal medication dosing and timing strategies to maintain target blood pressure levels. Minor dosage adjustments that fall within predefined safety thresholds can be communicated directly to the patient, while recommendations involving more substantial modifications are routed to the supervising clinician for review and approval.

Importantly, the model supports continual refinement through a feedback mechanism that incorporates clinician decisions and patient outcomes. By integrating this observational data into subsequent training iterations, the system incrementally improves its predictive accuracy and clinical utility. The overarching objective is to enable fully personalized, adaptive blood pressure management that evolves in response to each patient's physiological and behavioral profile.

##### Patient-AI Loop {#sec-ml-operations-patientai-loop-85ba}

The patient-AI loop facilitates timely, personalized medication adjustments by delivering AI-generated recommendations directly to the patient through a wearable device or associated mobile application. When the model identifies a minor dosage modification that falls within a pre-approved safety envelope, the patient may act on the suggestion independently, enabling a form of autonomous, yet bounded, therapeutic self-management.

For recommendations involving significant changes to the prescribed regimen, the system defers to clinician oversight, ensuring medical accountability and compliance with regulatory standards. This loop empowers patients to engage actively in their care while maintaining a safeguard for clinical appropriateness.

By enabling personalized, data-driven feedback on a daily basis, the patient-AI loop supports improved adherence and therapeutic outcomes. It operationalizes a key principle of ClinAIOps, by closing the loop between continuous monitoring and adaptive intervention, while preserving the patient's role as an active agent in the treatment process.

##### Clinician-AI Loop {#sec-ml-operations-clinicianai-loop-b45b}

The clinician-AI loop ensures medical oversight by placing healthcare providers at the center of the decision-making process. Clinicians receive structured summaries of the patient's longitudinal blood pressure patterns, visualizations of adherence behaviors, and relevant contextual data aggregated from wearable sensors and electronic health records. These insights support efficient and informed review of the AI system's recommended medication adjustments.

Before reaching the patient, the clinician evaluates each proposed dosage change, choosing to approve, modify, or reject the recommendation based on their professional judgment and understanding of the patient's broader clinical profile. Furthermore, clinicians define the operational boundaries within which the AI may act autonomously, specifying thresholds for dosage changes that can be enacted without direct review.

When the system detects blood pressure trends indicative of clinical risk, including persistent hypotension or a hypertensive crisis[^fn-hypertensive-crisis], it generates alerts for immediate clinician intervention. These capabilities preserve the clinician's authority over treatment while enhancing their ability to manage patient care proactively and at scale.

[^fn-hypertensive-crisis]: **Hypertensive Crisis:** A severe increase in blood pressure that can lead to stroke, heart attack, or other critical conditions.

This loop exemplifies the principles of accountability, safety, and human-in-the-loop[^fn-human-in-the-loop] governance, ensuring that AI functions as a supportive tool rather than an autonomous agent in therapeutic decision-making.

[^fn-human-in-the-loop]: A model of operation in which human decision-makers are involved directly in the AI decision-making pathway.

##### Patient-Clinician Loop {#sec-ml-operations-patientclinician-loop-8bc1}

As illustrated in @fig-interactive-loop, the patient-clinician loop emphasizes collaboration, context, and continuity in care. Rather than devoting in-person visits to basic data collection or medication reconciliation, clinicians engage with patients to interpret high-level trends derived from continuous monitoring. These discussions focus on modifiable factors such as diet, physical activity, sleep quality, and stress management, enabling a more holistic approach to blood pressure control.

::: {#fig-interactive-loop fig-env="figure" fig-pos="htb"}
```{.tikz}
\begin{tikzpicture}[line join=round,font=\small\usefont{T1}{phv}{m}{n}]
%radius
\newcommand{\gear}[6]{%
  (0:#2)
  \foreach \i [evaluate=\i as \n using {\i-1)*360/#1}] in {1,...,#1}{%
    arc (\n:\n+#4:#2) {[rounded corners=1.5pt] -- (\n+#4+#5:#3)
    arc (\n+#4+#5:\n+360/#1-#5:#3)} --  (\n+360/#1:#2)
  }%
  (0,0) circle[radius=#6];
  \scoped[on background layer]
  %\pic (a) at (0,0.2) {pers={scalefac=1.3,headcolor=BlueLine,bodyycolor=BlueLine}};
}

\tikzset{
  helvetica/.style={align=flush center, font={\usefont{T1}{phv}{m}{n}\small}},
  man/.pic={
  \pgfkeys{/man/.cd, #1}
     % tie
    \draw[draw=\tiecolor,fill=\tiecolor] (0.0,-1.1)--(0.16,-0.87)--(0.09,-0.46)--(0.13,-0.37)--(0.0,-0.28)--(-0.13,-0.37)--(-0.09,-0.46)--(-0.16,-0.87)--cycle;
    % ears
    \draw[fill=black,draw=none] (0.74,0.95) to[out=20,in=80](0.86,0.80) to[out=250,in=330](0.65,0.65) to[out=70,in=260] cycle;
    \draw[fill=black,draw=none] (-0.76,0.96) to[out=170,in=110](-0.85,0.80) to[out=290,in=190](-0.65,0.65) to[out=110,in=290] cycle;

    % head
    \draw[fill=black,draw=none] (0,0) to[out=180,in=290](-0.72,0.84) to[out=110,in=190](-0.56,1.67)
             to[out=70,in=110](0.68,1.58) to[out=320,in=80](0.72,0.84) to[out=250,in=0] cycle;
    % face
    \draw[fill=white,draw=none] (0,0.11) to[out=175,in=290](-0.53,0.65) to[out=110,in=265](-0.61,1.22)
                      to[out=80,in=235](-0.50,1.45) to[out=340,in=215](0.50,1.47)
                      to[out=310,in=85](0.60,0.92) to[out=260,in=2] cycle;
    \draw[fill=black,draw=none] (-0.50,1.45) to[out=315,in=195](0.40,1.25) to[out=340,in=10](0.37,1.32)to[out=190,in=310](-0.40,1.49) -- cycle;
    % neck
    \draw[line width=1.5pt] (-0.62,-0.2) to[out=50,in=290] (-0.5,0.42);
    \draw[line width=1.5pt] (0.62,-0.2) to[out=130,in=250] (0.5,0.42);
    % body
    \draw[draw=\bodycolor,fill=\bodycolor] (0.0,-1.0) to[out=150,in=290](-0.48,-0.14) to[out=200,in=50](-1.28,-0.44)
                   to[out=240,in=80](-1.55,-2.06) -- (1.55,-2.06)
                   to[out=100,in=300](1.28,-0.44) to[out=130,in=340](0.49,-0.14)
                   to[out=245,in=30] cycle;
    % right stet
    \draw[line width=2pt,\stetcolor] (0.8,-0.21) to[bend left=7](0.78,-0.64)
         to[out=350,in=80](0.98,-1.35) to[out=250,in=330](0.72,-1.60);
    \draw[line width=2pt,\stetcolor] (0.43,-1.53) to[out=180,in=240](0.3,-1.15)
         to[out=60,in=170](0.78,-0.64);
    % left stet
    \draw[line width=2pt,\stetcolor] (-0.75,-0.21) to[bend right=20](-0.65,-1.45);
    \node[fill=\stetcolor,circle,minimum size=5pt] at (-0.65,-1.45) {};
    % eyes
    \node[circle,fill=black,inner sep=2pt] at (0.28,0.94) {};
    \node[circle,fill=black,inner sep=2pt] at (-0.28,0.94) {};
     % mouth
    \draw[line width=1.0pt] (-0.25,0.5) to[bend right=40](0.25,0.5);
  },
}
\pgfkeys{
  /man/.cd,
  tiecolor/.store in=\tiecolor,
  bodycolor/.store in=\bodycolor,
  stetcolor/.store in=\stetcolor,
  tiecolor=red,      % derfault tie color
  bodycolor=blue!30  % derfault body color
  stetcolor=green  % derfault stet color
}
\definecolor{CPU}{RGB}{0,120,176}

%left patient-AI
\begin{scope}[local bounding box=PAC1,
%shift={($(90: 0.5*\ra)+(0,0.3)$)},
scale=0.5, every node/.append style={transform shape}]
\pic[scale=1] {man={tiecolor=red!50!yellow, bodycolor=green!50!blue,stetcolor=green!50!blue}};
\end{scope}
%%%%
%AI left
\begin{scope}[local bounding box=AI1,shift={($(PAC1)+(3.0,-0.1)$)}]]
\begin{scope}[local bounding box=GEAR,
%shift={($(330: 0.5*\ra)+(0.5,0)$)},
scale=0.7, every node/.append style={transform shape}]
\fill[draw=none,fill=green!50!red,even odd rule] \gear{14}{1.2}{1.4}{10}{2}{0.9}coordinate(2GER1);
\end{scope}
\begin{scope}[local bounding box = CPU,scale=0.3, every node/.append style={transform shape},
shift={($(GEAR)+(0,0)$)}]
\node[fill=CPU,minimum width=66, minimum height=66,
            rounded corners=2,outer sep=2pt] (C1) {};
\node[fill=white,minimum width=54, minimum height=54] (C2) {};
\node[fill=CPU!40,minimum width=44, minimum height=44,align=center,inner sep=0pt] (C3) {\Huge AI};

\foreach \x/\y in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{
\node[fill=CPU,minimum width=4, minimum height=12,
           inner sep=0pt,anchor=south](GO\y)at($(C1.north west)!\x!(C1.north east)$){};
}
\foreach \x/\y in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{
\node[fill=CPU,minimum width=4, minimum height=12,
           inner sep=0pt,anchor=north](DO\y)at($(C1.south west)!\x!(C1.south east)$){};
}
\foreach \x/\y in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{
\node[fill=CPU,minimum width=12, minimum height=4,
           inner sep=0pt,anchor=east](LE\y)at($(C1.north west)!\x!(C1.south west)$){};
}
\foreach \x/\y in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{
\node[fill=CPU,minimum width=12, minimum height=4,
           inner sep=0pt,anchor=west](DE\y)at($(C1.north east)!\x!(C1.south east)$){};
}
\end{scope}
\end{scope}
%circle1 left
\begin{scope}[local bounding box=CIRC1,
shift={($(PAC1)!0.45!(AI1)+(0,0.3)$)},
scale=0.5, every node/.append style={transform shape}]
\def\ra{15mm}
\draw[latex-, line width=1.25pt,red] (10:0.5*\ra) arc[radius=0.5*\ra, start angle=10, end angle= 170];
\draw[latex-, line width=1.25pt,CPU] (190:0.5*\ra)arc[radius=0.5*\ra, start angle=190, end angle= 350];
\end{scope}
%%%%%%%%%%%%%%%
%right Doctor-AI
%%%%%%%%%%%%%
\begin{scope}[local bounding box=DOC1,shift={($(PAC1)+(11.5,0)$)},
scale=0.5, every node/.append style={transform shape}]
\pic at (0,0) {man={tiecolor=red, bodycolor=VioletLine2,stetcolor=yellow}};
\end{scope}
%%%%
%AI left
\begin{scope}[local bounding box=AI2,shift={($(DOC1)+(3.0,-0.1)$)}]]
\begin{scope}[local bounding box=GEAR,
%shift={($(330: 0.5*\ra)+(0.5,0)$)},
scale=0.7, every node/.append style={transform shape}]
\fill[draw=none,fill=green!50!red,even odd rule] \gear{14}{1.2}{1.4}{10}{2}{0.9}coordinate(2GER1);
\end{scope}
\begin{scope}[local bounding box = CPU,scale=0.3, every node/.append style={transform shape},
shift={($(GEAR)+(0,0)$)}]
\node[fill=CPU,minimum width=66, minimum height=66,
            rounded corners=2,outer sep=2pt] (C1) {};
\node[fill=white,minimum width=54, minimum height=54] (C2) {};
\node[fill=CPU!40,minimum width=44, minimum height=44,align=center,inner sep=0pt] (C3) {\Huge AI};

\foreach \x/\y in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{
\node[fill=CPU,minimum width=4, minimum height=12,
           inner sep=0pt,anchor=south](GO\y)at($(C1.north west)!\x!(C1.north east)$){};
}
\foreach \x/\y in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{
\node[fill=CPU,minimum width=4, minimum height=12,
           inner sep=0pt,anchor=north](DO\y)at($(C1.south west)!\x!(C1.south east)$){};
}
\foreach \x/\y in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{
\node[fill=CPU,minimum width=12, minimum height=4,
           inner sep=0pt,anchor=east](LE\y)at($(C1.north west)!\x!(C1.south west)$){};
}
\foreach \x/\y in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{
\node[fill=CPU,minimum width=12, minimum height=4,
           inner sep=0pt,anchor=west](DE\y)at($(C1.north east)!\x!(C1.south east)$){};
}
\end{scope}
\end{scope}
%circle2 right
\begin{scope}[local bounding box=CIRC2,
shift={($(DOC1)!0.45!(AI2)+(0,0.3)$)},
scale=0.5, every node/.append style={transform shape}]
\def\ra{15mm}
\draw[latex-, line width=1.25pt,red] (10:0.5*\ra) arc[radius=0.5*\ra, start angle=10, end angle= 170];
\draw[latex-, line width=1.25pt,CPU] (190:0.5*\ra)arc[radius=0.5*\ra, start angle=190, end angle= 350];
\end{scope}
%%%%%%%%%%%%%%%
%below Patient-Doctor
%%%%%%%%%%%%%
\begin{scope}[local bounding box=PAC3,shift={($(PAC1)+(5.9,-3.3)$)},
scale=0.5, every node/.append style={transform shape}]
\pic[scale=1] {man={tiecolor=red!50!yellow, bodycolor=green!50!blue,stetcolor=green!50!blue}};
\end{scope}
%%%%
\begin{scope}[local bounding box=DOC2,shift={($(PAC3)+(3.0,-0)$)},
scale=0.5, every node/.append style={transform shape}]
\pic at (0,0) {man={tiecolor=red, bodycolor=VioletLine2,stetcolor=yellow}};
\end{scope}
%circle3 down
\begin{scope}[local bounding box=CIRC2,
shift={($(PAC3)!0.45!(DOC2)+(0,0.3)$)},
scale=0.5, every node/.append style={transform shape}]
\def\ra{15mm}
\draw[latex-, line width=1.25pt,red] (10:0.5*\ra) arc[radius=0.5*\ra, start angle=10, end angle= 170];
\draw[latex-, line width=1.25pt,CPU] (190:0.5*\ra)arc[radius=0.5*\ra, start angle=190, end angle= 350];
\end{scope}
%
%fitting
\scoped[on background layer]
\node[draw=BackLine,inner xsep=4,inner ysep=10,yshift=-2mm,
           fill=BackColor!50,fit=(PAC1)(AI1),line width=0.75pt](BB1){};
\node[above=0.5pt of  BB1.south,anchor=south,helvetica]{\textbf{Patient-AI loop}};
\scoped[on background layer]
\node[draw=BackLine,inner xsep=4,inner ysep=10,yshift=-2mm,
           fill=BackColor!50,fit=(DOC1)(AI2),line width=0.75pt](BB2){};
\node[above=0.5pt of  BB2.south,anchor=south,helvetica]{\textbf{Clinicial-AI loop}};
\scoped[on background layer]
\node[draw=BackLine,inner xsep=4,inner ysep=10,yshift=-2mm,
           fill=BackColor!50,fit=(DOC2)(PAC3),line width=0.75pt](BB3){};
\node[above=0.5pt of  BB3.south,anchor=south,helvetica]{\textbf{Patient-clinicial loop}};
%
\node[align=flush right,left=0.1 of BB1.west, text width=30mm]{The patient wears a passive continuous blood-pressure monitor, and reports antihypertensive administrations.};
 \node[align=flush left,right=0.1 of BB1.east, text width=28mm]{AI generates
                 recommendation for antihypertensive dose titrations.};
\node[align=flush right,left=0.1 of BB2.west, text width=26mm]{The clinician sets and updates the AI's limits for the titration of the antihypertensive dose.};
 \node[align=flush left,right=0.1 of BB2.east, text width=30mm]{The AI alerts of severe hypertension or hypotension, prompting follow-up or emergency medical services.};
%
\node[align=flush right,left=0.1 of BB3.west, text width=38mm]{The patient discusses the AI-generated summary of their blood-pressure trend, and the effectiveness of the therapy.};
 \node[align=flush left,right=0.1 of BB3.east, text width=35mm]{The clinician checks for adverse events and identifies patient-specific modifiers (such as diet and exercise).};
\end{tikzpicture}
```
ClinAIOps interactive loop. Source: @chen2023framework.
:::

The dynamic nature of continuous data allows for flexible scheduling of appointments based on clinical need rather than fixed intervals. For example, patients exhibiting stable blood pressure trends may be seen less frequently, while those experiencing variability may receive more immediate follow-up. This adaptive cadence enhances resource efficiency while preserving care quality.

By offloading routine monitoring and dose titration to AI-assisted systems, clinicians are better positioned to offer personalized counseling and targeted interventions. The result is a more meaningful patient-clinician relationship that supports shared decision-making and long-term wellness. This loop exemplifies how ClinAIOps frameworks can shift clinical interactions from transactional to transformational—supporting proactive care, patient empowerment, and improved health outcomes.

#### MLOps vs. ClinAIOps Comparison {#sec-ml-operations-mlops-vs-clinaiops-comparison-a9dc}

The hypertension case study illustrates why traditional MLOps frameworks are often insufficient for high-stakes, real-world domains such as clinical healthcare. While conventional MLOps excels at managing the technical lifecycle of machine learning models, including training, deployment, and monitoring, it generally lacks the constructs necessary for coordinating human decision-making, managing clinical workflows, and safeguarding ethical accountability.

In contrast, the ClinAIOps framework extends beyond technical infrastructure to support complex sociotechnical systems[^fn-sociotechnical]. Rather than treating the model as the final decision-maker, ClinAIOps embeds machine learning into a broader context where clinicians, patients, and systems stakeholders collaboratively shape treatment decisions.

[^fn-sociotechnical]: **Sociotechnical System:** An approach considering both social and technical aspects of organizational structures, prioritizing human well-being and system performance.

Several limitations of a traditional MLOps approach become apparent when applied to a clinical setting like hypertension management:

* **Data availability and feedback**: Traditional pipelines rely on pre-collected datasets. ClinAIOps enables ongoing data acquisition and iterative feedback from clinicians and patients.
* **Trust and interpretability**: MLOps may lack transparency mechanisms for end users. ClinAIOps maintains clinician oversight, ensuring recommendations remain actionable and trustworthy.
* **Behavioral and motivational factors**: MLOps focuses on model outputs. ClinAIOps recognizes the need for patient coaching, adherence support, and personalized engagement.
* **Safety and liability**: MLOps does not account for medical risk. ClinAIOps retains human accountability and provides structured boundaries for autonomous decisions.
* **Workflow integration**: Traditional systems may exist in silos. ClinAIOps aligns incentives and communication across stakeholders to ensure clinical adoption.

As shown in @tbl-clinical_ops, the key distinction lies in how ClinAIOps integrates technical systems with human oversight, ethical principles, and care delivery processes. Rather than replacing clinicians, the framework augments their capabilities while preserving their central role in therapeutic decision-making.

+------------------------+---------------------------------------------+----------------------------------------------+
|                        | Traditional MLOps                           | ClinAIOps                                    |
+:=======================+:============================================+:=============================================+
| Focus                  | ML model development and deployment         | Coordinating human and AI decision-making    |
+------------------------+---------------------------------------------+----------------------------------------------+
| Stakeholders           | Data scientists, IT engineers               | Patients, clinicians, AI developers          |
+------------------------+---------------------------------------------+----------------------------------------------+
| Feedback loops         | Model retraining, monitoring                | Patient-AI, clinician-AI, patient-clinician  |
+------------------------+---------------------------------------------+----------------------------------------------+
| Objective              | Operationalize ML deployments               | Optimize patient health outcomes             |
+------------------------+---------------------------------------------+----------------------------------------------+
| Processes              | Automated pipelines and infrastructure      | Integrates clinical workflows and oversight  |
+------------------------+---------------------------------------------+----------------------------------------------+
| Data considerations    | Building training datasets                  | Privacy, ethics, protected health information|
+------------------------+---------------------------------------------+----------------------------------------------+
| Model validation       | Testing model performance metrics           | Clinical evaluation of recommendations       |
+------------------------+---------------------------------------------+----------------------------------------------+
| Implementation         | Focuses on technical integration            | Aligns incentives of human stakeholders      |
+------------------------+---------------------------------------------+----------------------------------------------+

: Comparison of MLOps versus AI operations for clinical use. {#tbl-clinical_ops .striped .hover}

Successfully deploying AI in complex domains such as healthcare requires more than developing and operationalizing performant machine learning models. As demonstrated by the hypertension case, effective integration depends on aligning AI systems with clinical workflows, human expertise, and patient needs. Technical performance alone is insufficient—deployment must account for ethical oversight, stakeholder coordination, and continuous adaptation to dynamic clinical contexts.

The ClinAIOps framework addresses these requirements by introducing structured, multi-stakeholder feedback loops that connect patients, clinicians, and AI developers. These loops enable human oversight, reinforce accountability, and ensure that AI systems adapt to evolving health data and patient responses. Rather than replacing human decision-makers, AI is positioned as an augmentation layer—enhancing the precision, personalization, and scalability of care.

By embedding AI within collaborative clinical ecosystems, frameworks like ClinAIOps create the foundation for trustworthy, responsive, and effective machine learning systems in high-stakes environments. This perspective reframes AI not as an isolated technical artifact, but as a component of a broader sociotechnical system designed to advance health outcomes and healthcare delivery.

## Conclusion {#sec-ml-operations-conclusion-33b6}

The operationalization of machine learning is a complex, systems-oriented endeavor that extends far beyond training and deploying models. MLOps provides the methodological and infrastructural foundation for managing the full lifecycle of ML systems—from data collection and preprocessing to deployment, monitoring, and continuous refinement. By drawing on principles from software engineering, DevOps, and data science, MLOps offers the practices needed to achieve scalability, reliability, and resilience in real-world environments.

This chapter has examined the core components of MLOps, highlighting key challenges such as data quality, reproducibility, infrastructure automation, and organizational coordination. We have emphasized the importance of operational maturity, where model-centric development evolves into system-level engineering supported by robust processes, tooling, and feedback loops. Through detailed case studies in domains such as wearable computing and healthcare, we have seen how MLOps must adapt to specific operational contexts, technical constraints, and stakeholder ecosystems.

As we transition to subsequent chapters, we shift our focus toward emerging frontiers in operational practice, including on-device learning, privacy and security, responsible AI, and sustainable systems. Each of these domains introduces unique constraints that further shape how machine learning must be engineered and maintained in practice. These topics build on the foundation laid by MLOps, extending it into specialized operational regimes.

Ultimately, operational excellence in machine learning is not a fixed endpoint but a continuous journey. It requires cross-disciplinary collaboration, rigorous engineering, and a commitment to long-term impact. By approaching ML systems through the lens of MLOps, which are grounded in systems thinking and guided by ethical and societal considerations, we can build solutions that are not only technically sound but also trustworthy, maintainable, and meaningful in their real-world applications.

As the chapters ahead explore these evolving dimensions of machine learning systems, the central lesson remains clear: building models is only the beginning. The enduring challenge and opportunity lies in building systems that are adaptive, responsible, and effective in the face of complexity, uncertainty, and change.

## Resources {#sec-ml-operations-resources-7b73}

:::{.callout-note collapse="false" title="Slides"}

* [MLOps, DevOps, and AIOps.](https://docs.google.com/presentation/d/1vsC8WpmvVRgMTpzTltAhEGzcVohMkatMZBqm3-P8TUY/edit?usp=drive_link)

* [MLOps overview.](https://docs.google.com/presentation/d/1GVduKipd0ughTpqsHupGqAPW70h0xNOOpaIeSqLOc1M/edit?usp=drive_link)

* [Tiny MLOps.](https://docs.google.com/presentation/d/1MNjVOcx5f5Nfe3ElDqTxutezcGXm4yI8PkjWOuQYHhk/edit?usp=drive_link)

* [MLOps: a use case.](https://docs.google.com/presentation/d/1449rzplaL0lOPoKh0mrpds3KPPoOHWdR5LIZdd7aXhA/edit#slide=id.g2ddfdf6e85f_0_0)

* [MLOps: Key Activities and Lifecycle.](https://docs.google.com/presentation/d/1vGCffLgemxTwTIo7vUea5CibOV7y3vY3pkJdee-y5eA/edit#slide=id.g2de2d5f2ac0_0_0)

* [ML Lifecycle.](https://docs.google.com/presentation/d/1FW8Q1Yj5g_jbArFANfncbLQj36uV2vfV8pjoqaD6gjM/edit#slide=id.g94db9f9f78_0_2)

* [Scaling TinyML: Challenges and Opportunities.](https://docs.google.com/presentation/d/1VxwhVztoTk3eG04FD9fFNpj2lVrVjYYPJi3jBz0O_mo/edit?resourcekey=0-bV7CCIPr7SxZf2p61oB_CA#slide=id.g94db9f9f78_0_2)

* Training Operationalization:
  * [Training Ops: CI/CD trigger.](https://docs.google.com/presentation/d/1YyRY6lOzdC7NjutJSvl_VXYu29qwHKqx0y98zAUCJCU/edit?resourcekey=0-PTh1FxqkQyhOO0bKKHBldQ#slide=id.g94db9f9f78_0_2)

  * [Continuous Integration.](https://docs.google.com/presentation/d/1poGgYTH44X0dVGwG9FGIyVwot4EET_jJOt-4kgcQawo/edit?usp=drive_link)

  * [Continuous Deployment.](https://docs.google.com/presentation/d/1nxbIluROAOl5cN6Ug4Dm-mHh1Fwm5aEng_S5iLfiCqo/edit?usp=drive_link&resourcekey=0-xFOl8i7ea2vNtiilXz8CaQ)

  * [Production Deployment.](https://docs.google.com/presentation/d/1m8KkCZRnbJCCTWsmcwMt9EJhYLoaVG_Wm7zUE2bQkZI/edit?usp=drive_link)

  * [Production Deployment: Online Experimentation.](https://docs.google.com/presentation/d/1elFEK61X5Kc-5UV_4AEtRvCT7l1TqTdABmJV8uAYykY/edit?usp=drive_link)

  * [Training Ops Impact on MLOps.](https://docs.google.com/presentation/d/1-6QL2rq0ahGVz8BL1M1BT0lR-HDxsHady9lGTN93wLc/edit?usp=drive_link&resourcekey=0-sRqqoa7pX9IkDDSwe2MLyw)

* Model Deployment:
  * [Scaling ML Into Production Deployment.](https://docs.google.com/presentation/d/12sf-PvSxDIlCQCXULWy4jLY_2fIq-jpRojRsmeMGq6k/edit?resourcekey=0-knPSQ5h4ffhgeV6CXvwlSg#slide=id.gf209f12c63_0_314)

  * [Containers for Scaling ML Deployment.](https://docs.google.com/presentation/d/1YXE4cAWMwL79Vqr_8TJi-LsQD9GFdiyBqY--HcoBpKg/edit?usp=drive_link&resourcekey=0-yajtiQTx2SdJ6BCVG0Bfng)

  * [Challenges for Scaling TinyML Deployment: Part 1.](https://docs.google.com/presentation/d/1mw5FFERf5r-q8R7iyNf6kx2MMcwNOTBd5WwFOj8Zs20/edit?resourcekey=0-u80KeJio3iIWco00crGD9g#slide=id.gdc4defd718_0_0)

  * [Challenges for Scaling TinyML Deployment: Part 2.](https://docs.google.com/presentation/d/1NB63wTHoEPGSn--KqFu1vjHx3Ild9AOhpBbflJP-k7I/edit?usp=drive_link&resourcekey=0-MsEi1Lba2dpl0G-bzakHJQ)

  * [Model Deployment Impact on MLOps.](https://docs.google.com/presentation/d/1A0pfm55s03dFbYKKFRV-x7pRCm_2-VpoIM0O9kW0TAA/edit?usp=drive_link&resourcekey=0--O2AFFmVzAmz5KO0mJeVHA)

:::

:::{.callout-important collapse="false" title="Videos"}

* @vid-datapipe

* @vid-monitoring

* @vid-deploy

:::

:::{.callout-caution collapse="false" title="Exercises"}

* Coming soon.
:::

