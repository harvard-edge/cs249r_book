"""
Export command for TinyTorch CLI: exports notebook code to Python package using nbdev.
"""

import subprocess
import sys
from argparse import ArgumentParser, Namespace
from pathlib import Path
from typing import Optional, Dict
from rich.panel import Panel
from rich.text import Text
import logging

logger = logging.getLogger(__name__)

from .base import BaseCommand
from .export_utils import (
    add_autogenerated_warnings,
    convert_all_modules,
    convert_py_to_notebook,
    discover_modules,
    ensure_writable_target,
    get_export_target,
    validate_notebook_integrity,
)
from ..core.modules import get_next_module, get_total_modules

class ExportCommand(BaseCommand):

    @property
    def name(self) -> str:
        return "export"

    @property
    def description(self) -> str:
        return "Export notebook code to Python package"

    def add_arguments(self, parser: ArgumentParser) -> None:
        parser.add_argument("modules", nargs="*", help="Export specific modules (e.g., 01_tensor 02_activations)")
        parser.add_argument("--all", action="store_true", help="Export all modules")
        parser.add_argument("--from-release", action="store_true", help="Export from release directory (student version) instead of source")
        parser.add_argument("--test-checkpoint", action="store_true", help="Run checkpoint test after successful export")

    def _get_export_target(self, module_path: Path) -> str:
        return get_export_target(module_path)

    def _discover_modules(self) -> list:
        return discover_modules()

    def _show_next_steps(self, completed_module: str) -> None:
        """Show next steps after successful module completion."""
        console = self.console

        # Get next module suggestion (auto-discovered from filesystem)
        next_info = get_next_module(completed_module)

        if next_info:
            next_num, next_folder, next_display = next_info
            console.print(f"\n[bold cyan]üéØ Continue Your Journey[/bold cyan]")
            console.print(f"[bold]Next Module:[/bold] {next_folder}")
            console.print(f"[dim]{next_display}[/dim]")
            console.print(f"\n[green]Ready to continue? Run:[/green]")
            console.print(f"[dim]  tito module start {next_num}[/dim]")
        else:
            # No next module - they've completed all!
            console.print(f"\n[bold green]üèÜ Congratulations![/bold green]")
            console.print(f"[green]You've completed all TinyTorch modules![/green]")
            console.print(f"[dim]Run 'tito checkpoint status' to see your full progress[/dim]")

        # General next steps
        console.print(f"\n[bold]Continue your ML systems journey:[/bold]")
        console.print(f"[dim]  tito checkpoint status    - View overall progress[/dim]")
        console.print(f"[dim]  tito checkpoint timeline  - Visual progress timeline[/dim]")

    def _add_autogenerated_warnings(self, console):
        add_autogenerated_warnings(console)

    def _show_export_details(self, console, module_name: Optional[str] = None):
        """Show detailed export information including where each module exports to."""
        exports_text = Text()
        exports_text.append("üì¶ Export Details:\n", style="bold cyan")

        if module_name:
            # Single module export
            module_path = Path(f"modules/{module_name}")
            export_target = self._get_export_target(module_path)
            if export_target != "unknown":
                target_file = export_target.replace('.', '/') + '.py'
                exports_text.append(f"  üîÑ {module_name} ‚Üí tinytorch/{target_file}\n", style="green")

                # Extract the short name for display
                short_name = module_name[3:] if module_name.startswith(tuple(f"{i:02d}_" for i in range(100))) else module_name
                exports_text.append(f"     Source: modules/{module_name}/{short_name}.py\n", style="dim")
                exports_text.append(f"     Target: tinytorch/{target_file}\n", style="dim")
            else:
                exports_text.append(f"  ‚ùì {module_name} ‚Üí export target not found\n", style="yellow")
        else:
            # All modules export
            modules = self._discover_modules()
            for module_name in modules:
                module_path = Path(f"modules/{module_name}")
                export_target = self._get_export_target(module_path)
                if export_target != "unknown":
                    target_file = export_target.replace('.', '/') + '.py'
                    exports_text.append(f"  üîÑ {module_name} ‚Üí tinytorch/{target_file}\n", style="green")

        # Show what was actually created
        exports_text.append("\nüìÅ Generated Files:\n", style="bold cyan")
        tinytorch_path = Path("tinytorch")
        if tinytorch_path.exists():
            for py_file in tinytorch_path.rglob("*.py"):
                if py_file.name != "__init__.py" and py_file.stat().st_size > 100:  # Non-empty files
                    rel_path = py_file.relative_to(tinytorch_path)
                    exports_text.append(f"  ‚úÖ tinytorch/{rel_path}\n", style="green")

        exports_text.append("\nüí° Next steps:\n", style="bold yellow")
        exports_text.append("  ‚Ä¢ Run: tito test --all\n", style="white")
        exports_text.append("  ‚Ä¢ Or: tito test <module_name>\n", style="white")
        exports_text.append("  ‚Ä¢ Or: tito export <module> --test-checkpoint\n", style="white")

        console.print(Panel(exports_text, title="Export Summary", border_style="bright_green"))

    def _validate_notebook_integrity(self, notebook_path: Path) -> Dict:
        return validate_notebook_integrity(notebook_path)

    def _convert_py_to_notebook(self, module_path: Path) -> bool:
        return convert_py_to_notebook(module_path, self.venv_path, self.console)

    def _convert_all_modules(self) -> list:
        return convert_all_modules(self.venv_path, self.console)

    def run(self, args: Namespace) -> int:
        console = self.console
        logger.info("Starting export command")

        # Determine what to export
        if hasattr(args, 'modules') and args.modules:
            logger.info(f"Exporting specific modules: {args.modules}")
            # Export multiple specific modules
            modules_to_export = args.modules

            console.print(Panel(f"üîÑ Exporting Modules: {', '.join(modules_to_export)}",
                               title="Complete Export Workflow", border_style="bright_cyan"))

            exported_notebooks = []

            # Process each module
            for module_name in modules_to_export:
                logger.debug(f"Processing module: {module_name}")
                module_path = Path(f"src/{module_name}")
                if not module_path.exists():
                    console.print(Panel(f"[red]‚ùå Module '{module_name}' not found in src/[/red]",
                                      title="Module Not Found", border_style="red"))

                    # Show available modules
                    available_modules = self._discover_modules()
                    if available_modules:
                        help_text = Text()
                        help_text.append("Available modules:\n", style="bold yellow")
                        for module in available_modules:
                            help_text.append(f"  ‚Ä¢ {module}\n", style="white")
                        console.print(Panel(help_text, title="Available Modules", border_style="yellow"))

                    return 1

                # Always convert Python file to notebook (Python file is source of truth)
                # Notebook will be created in modules/ directory with SHORT name (e.g., tensor.ipynb)
                short_name = module_name.split("_", 1)[1] if "_" in module_name else module_name
                notebook_file = Path("modules") / module_name / f"{short_name}.ipynb"

                console.print(f"üìù Converting {module_name} Python file to notebook...")
                if not self._convert_py_to_notebook(module_path):
                    logger.error(f"Failed to convert .py file to notebook for {module_name}")
                    return 1
                exported_notebooks.append(str(notebook_file))

            logger.info(f"Exporting {len(exported_notebooks)} notebooks to tinytorch package")

            # Export all notebooks
            success_count = 0
            for notebook_path_str in exported_notebooks:
                try:
                    notebook_path = Path(notebook_path_str)
                    notebook_name = notebook_path.name
                    console.print(f"[dim]üîÑ Exporting {notebook_name} to tinytorch package...[/dim]")

                    # --- FIX: Ensure target file is writable before exporting ---
                    module_path = notebook_path.parent
                    export_target = self._get_export_target(module_path)
                    if export_target != "unknown":
                        ensure_writable_target(export_target)

                    cmd = ["nbdev_export", "--path", notebook_path_str]
                    console.print(f"[dim]‚öôÔ∏è  Running: nbdev_export --path {notebook_name}[/dim]")

                    result = subprocess.run(cmd, capture_output=True, text=True, cwd=Path.cwd())
                    if result.returncode == 0:
                        success_count += 1
                        console.print(f"‚úÖ Exported: {notebook_name}")
                        if result.stdout.strip():
                            console.print(f"[dim]üìù {result.stdout.strip()}[/dim]")
                    else:
                        console.print(f"‚ùå Failed to export: {notebook_name}")
                        console.print(f"   Return code: {result.returncode}")
                        if result.stderr.strip():
                            console.print(f"   Error: {result.stderr.strip()}")
                        if result.stdout.strip():
                            console.print(f"   Output: {result.stdout.strip()}")
                except Exception as e:
                    console.print(f"‚ùå Error exporting {Path(notebook_path).name}: {e}")

            if success_count == len(exported_notebooks):
                logger.info("All notebooks exported successfully")
                # ALWAYS add auto-generated warnings immediately after export
                self._add_autogenerated_warnings(console)

                # üõ°Ô∏è AUTOMATIC PROTECTION: Enable protection after export
                self._auto_enable_protection(console)

                console.print(Panel(f"[green]‚úÖ Successfully exported {success_count}/{len(exported_notebooks)} modules to tinytorch package![/green]",
                              title="Export Success", border_style="green"))
                return 0
            else:
                logger.warning(f"Exported {success_count}/{len(exported_notebooks)} modules. Some exports failed.")
                console.print(Panel(f"[yellow]‚ö†Ô∏è Exported {success_count}/{len(exported_notebooks)} modules. Some exports failed.[/yellow]",
                              title="Partial Success", border_style="yellow"))
                return 1
        elif hasattr(args, 'all') and args.all:
            logger.info("Exporting all modules")
            console.print(Panel("üîÑ Exporting All Modules to Package",
                               title="Complete Export Workflow", border_style="bright_cyan"))

            # Step 1: Convert all .py files to .ipynb
            console.print("üìù Converting all Python files to notebooks...")
            converted = self._convert_all_modules()
            if not converted:
                logger.error("No modules converted. Check if jupytext is installed and .py files exist.")
                console.print(Panel("[red]‚ùå No modules converted. Check if jupytext is installed and .py files exist.[/red]",
                                  title="Conversion Error", border_style="red"))
                return 1

            console.print(f"‚úÖ Converted {len(converted)} modules: {', '.join(converted)}")
            console.print("üîÑ Exporting all notebook code to tinytorch package...")

            # Step 2: Use nbdev_export for all modules
            cmd = ["nbdev_export"]
        else:
            logger.error("Must specify either module names or --all")
            console.print(Panel("[red]‚ùå Must specify either module names or --all[/red]\n\n"
                              "[dim]Examples:[/dim]\n"
                              "[dim]  tito module export 01_tensor[/dim]\n"
                              "[dim]  tito module export 01_tensor 02_activations[/dim]\n"
                              "[dim]  tito module export --all[/dim]",
                              title="Missing Arguments", border_style="red"))
            return 1

        try:
            result = subprocess.run(cmd, capture_output=True, text=True, cwd=Path.cwd())

            if result.returncode == 0:
                logger.info("Export command completed successfully")
                # ALWAYS add auto-generated warnings immediately after export
                self._add_autogenerated_warnings(console)

                # üõ°Ô∏è AUTOMATIC PROTECTION: Enable protection after export
                self._auto_enable_protection(console)

                console.print(Panel("[green]‚úÖ Successfully exported notebook code to tinytorch package![/green]",
                                  title="Export Success", border_style="green"))

                # Show detailed export information
                module_names = args.modules if hasattr(args, 'modules') and args.modules else None
                if module_names and len(module_names) == 1:
                    self._show_export_details(console, module_names[0])
                else:
                    self._show_export_details(console, None)

            else:
                logger.error(f"Export failed with return code {result.returncode}")
                error_msg = result.stderr.strip() if result.stderr else "Unknown error"
                console.print(Panel(f"[red]‚ùå Export failed:\n{error_msg}[/red]",
                                  title="Export Error", border_style="red"))

                # Helpful error guidance
                help_text = Text()
                help_text.append("üí° Common issues:\n", style="bold yellow")
                help_text.append("  ‚Ä¢ Missing #| default_exp directive in notebook\n", style="white")
                help_text.append("  ‚Ä¢ Syntax errors in exported code\n", style="white")
                help_text.append("  ‚Ä¢ Missing settings.ini configuration\n", style="white")
                help_text.append("\nüîß Run 'tito system health' for detailed diagnosis", style="cyan")

                console.print(Panel(help_text, title="Troubleshooting", border_style="yellow"))

            return result.returncode

        except FileNotFoundError:
            logger.exception("nbdev not found. Install with: pip install nbdev")
            return 1
        except Exception as e:
            logger.exception(f"Unexpected error during export: {e}")
            return 1

    def _auto_enable_protection(self, console):
        """üõ°Ô∏è Automatically enable basic file protection after export.

        NOTE: Auto-protection is disabled to prevent permission issues during development.
        Students who want protection can run 'tito protect --enable' manually.
        """
        # Disabled - causes permission errors on subsequent exports
        # Students can manually enable protection with 'tito protect --enable'
        pass
