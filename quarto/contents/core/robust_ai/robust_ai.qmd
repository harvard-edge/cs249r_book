---
bibliography: robust_ai.bib
quiz: robust_ai_quizzes.json
concepts: robust_ai_concepts.yml
glossary: robust_ai_glossary.json
crossrefs: robust_ai_xrefs.json
---

# Robust AI {#sec-robust-ai}

::: {layout-narrow}
::: {.column-margin}
_DALL·E 3 Prompt: Create an image featuring an advanced AI system symbolized by an intricate, glowing neural network, deeply nested within a series of progressively larger and more fortified shields. Each shield layer represents a layer of defense, showcasing the system's robustness against external threats and internal errors. The neural network, at the heart of this fortress of shields, radiates with connections that signify the AI's capacity for learning and adaptation. This visual metaphor emphasizes not only the technological sophistication of the AI but also its resilience and security, set against the backdrop of a state-of-the-art, secure server room filled with the latest in technological advancements. The image aims to convey the concept of ultimate protection and resilience in the field of artificial intelligence._
:::

\noindent
![](./images/png/cover_robust_ai.png)

:::

## Purpose {.unnumbered}

_How do we develop fault-tolerant and resilient machine learning systems for real-world deployment?_

Machine learning systems in real-world applications require fault-tolerant execution across diverse operational conditions. These systems face multiple challenges degrading their capabilities, including hardware anomalies, adversarial attacks, and unpredictable real-world data distributions that diverge from training assumptions. These vulnerabilities require AI systems to prioritize robustness and trustworthiness throughout design and deployment phases. Building resilient machine learning systems requires safe and effective operation in dynamic and uncertain environments. Understanding robustness principles enables engineers to design systems withstanding hardware failures, resisting malicious attacks, and adapting to distribution shifts. This capability enables deploying ML systems in safety-critical applications where failures can have severe consequences, from autonomous vehicles to medical diagnosis systems operating in unpredictable real-world conditions.

::: {.callout-tip title="Learning Objectives"}

- Classify hardware faults affecting ML systems into transient, permanent, and intermittent categories with their distinctive characteristics

- Analyze how bit flips, memory errors, and component failures propagate through neural network computations to degrade model performance

- Compare detection mechanisms for hardware faults including BIST, error detection codes, and redundancy voting systems

- Design fault tolerance strategies combining hardware-level protection with software-implemented monitoring for ML deployments

- Evaluate adversarial attack vectors including gradient-based, optimization-based, and transfer-based techniques on neural networks

- Implement defense strategies against data poisoning attacks through anomaly detection, sanitization, and robust training methods

- Assess distribution shift impacts on model accuracy using monitoring techniques and statistical drift detection methods

- Integrate robustness principles across the complete ML pipeline from data ingestion through model deployment and monitoring

:::

## Introduction to Robust AI Systems {#sec-robust-ai-introduction-robust-ai-systems-4671}

When traditional software fails, it often does so loudly: a server crashes, an application throws an error, users receive clear failure messages. When a machine learning system fails, it often fails silently. A self-driving car's perception system doesn't crash; it simply misclassifies a truck as the sky. A demand forecasting model doesn't error out; it just starts making wildly inaccurate predictions. A medical diagnosis system doesn't shut down; it quietly provides incorrect classifications that could endanger patient lives. This 'silent failure' mode makes robustness a unique and critical challenge in AI systems. Engineers must defend not just against bugs in code, but against a world that refuses to conform to training data.

This silent failure challenge is amplified as ML systems expand across diverse deployment contexts, from cloud-based services to edge devices and embedded systems, where hardware and software faults have pronounced impacts on performance and reliability. The increasing complexity of these systems and their deployment in safety-critical applications[^fn-safety-critical] makes robust and fault-tolerant designs essential for maintaining system integrity.

[^fn-safety-critical]: **Safety-Critical Applications**: Systems where failure could result in loss of life, significant property damage, or environmental harm. Examples include nuclear power plants, aircraft control systems, and medical devices, domains where ML deployment requires the highest reliability standards.

Building on the adaptive deployment challenges introduced in @sec-ondevice-learning and the security vulnerabilities examined in @sec-security-privacy, we now turn to comprehensive system reliability. ML systems operate across diverse domains where systemic failures, including hardware and software faults, malicious inputs such as adversarial attacks and data poisoning, and environmental shifts, can have severe consequences ranging from economic disruption to life-threatening situations.

To address these risks, researchers and engineers must develop advanced techniques for fault detection, isolation, and recovery that go beyond security measures alone. While @sec-security-privacy established how to protect against deliberate attacks, ensuring reliable operation requires addressing the full spectrum of potential failures, both intentional and unintentional, that can compromise system behavior.

This imperative for fault tolerance establishes what we define as Robust AI:

::: {.callout-definition title="Robust AI"}

***Resilient AI*** describes machine learning systems designed to maintain _performance_ and _reliability_ despite _system errors_, _malicious inputs_, and _environmental changes_ through systematic _fault detection_, _mitigation_, and _recovery_.
:::

This chapter examines robustness challenges through our unified three-category framework, building upon adaptive deployment challenges from @sec-ondevice-learning and security vulnerabilities from @sec-security-privacy. Our systematic approach ensures comprehensive system reliability before operational deployment.

**Positioning Within the Narrative Arc:** While @sec-ondevice-learning established adaptive deployment challenges in resource-constrained environments, and @sec-security-privacy addressed the vulnerabilities these adaptations create, this chapter ensures system-wide reliability across all failure modes: intentional attacks, unintentional faults, and natural variations. This comprehensive reliability framework becomes essential for the operational workflows detailed in @sec-ml-operations.

The first category, systemic hardware failures, presents significant challenges across computing systems (@sec-ml-systems). Whether transient[^fn-transient-vs-permanent], permanent, or intermittent, these faults can corrupt computations and degrade system performance. The impact ranges from temporary glitches to complete component failures, requiring robust detection and mitigation strategies to maintain reliable operation. This hardware-centric perspective extends beyond the algorithmic optimizations of other chapters to address physical layer vulnerabilities.

[^fn-transient-vs-permanent]: **Transient vs Permanent Faults**: Transient faults are temporary disruptions (lasting microseconds to seconds) often caused by cosmic rays or electromagnetic interference, while permanent faults cause lasting damage requiring component replacement. Transient faults are 1000$\times$ more common than permanent faults in modern systems [@baumann2005soft].

Malicious manipulation represents our second category, where we examine adversarial robustness from an engineering perspective rather than the security-first approach of @sec-security-privacy. While that chapter addresses authentication, access control, and privacy preservation, we focus on maintaining model performance when under attack. Adversarial attacks, data poisoning attempts, and prompt injection vulnerabilities can cause models to misclassify inputs or produce unreliable outputs, requiring specialized defensive mechanisms distinct from traditional security measures.

Complementing these deliberate threats, environmental changes introduce our third category of robustness challenges. Unlike the operational monitoring discussed in @sec-ml-operations, we examine how models maintain accuracy as data distributions shift naturally over time. Bugs, design flaws, and implementation errors within algorithms, libraries, and frameworks can propagate through the system, creating systemic vulnerabilities[^fn-systemic-vulnerabilities] that transcend individual component failures. This systems-level view of robustness encompasses the entire ML pipeline from data ingestion through inference.

[^fn-systemic-vulnerabilities]: **Systemic Vulnerabilities**: Weaknesses that affect entire system architectures rather than individual components. Unlike isolated bugs, these can cascade across multiple layers, potentially compromising thousands of interconnected services simultaneously.

The specific approaches to achieving robustness vary significantly based on deployment context and system constraints. While @sec-efficient-ai establishes efficiency principles for optimization, large-scale cloud computing environments typically emphasize fault tolerance through redundancy and sophisticated error detection mechanisms. Edge devices from @sec-ondevice-learning must address robustness challenges within strict computational, memory, and energy limitations, requiring specialized hardening strategies appropriate for resource-constrained environments. These constraints require careful optimization and targeted hardening strategies[^fn-hardening-strategies] appropriate for resource-constrained environments.

[^fn-hardening-strategies]: **Hardening Strategies**: Techniques to increase system resilience against faults and attacks, including redundancy, input validation, and fail-safe mechanisms. Edge systems often use selective hardening, protecting only critical components due to resource constraints.

Despite these contextual differences, the essential characteristics of a robust ML system include fault tolerance, error resilience, and sustained performance. By understanding and addressing these multifaceted challenges, engineers can develop reliable ML systems capable of operating effectively in real-world environments.

Robust AI systems inevitably require additional computational resources compared to basic implementations, creating direct tensions with the sustainability principles established in @sec-sustainable-ai. Error correction mechanisms consume 12-25% additional memory bandwidth, redundant processing increases energy consumption by 2-3$\times$, and continuous monitoring adds 5-15% computational overhead. These robustness measures also generate additional heat, exacerbating thermal management challenges that constrain deployment density and require enhanced cooling infrastructure. Understanding these sustainability trade-offs enables engineers to make informed decisions about where robustness investments provide the greatest value while minimizing environmental impact.

This chapter systematically examines these multidimensional robustness challenges, exploring detection and mitigation techniques across hardware, algorithmic, and environmental domains. Building on the deployment strategies from edge systems (@sec-ondevice-learning) and resource efficiency principles from @sec-sustainable-ai, we develop comprehensive approaches that address fault tolerance requirements across all computing environments while considering energy and thermal constraints. The systematic examination of robustness challenges provided here establishes the foundation for building reliable AI systems that maintain performance and safety in real-world deployments, transforming robustness from an afterthought into a core design principle for production machine learning systems.

## Real-World Robustness Failures {#sec-robust-ai-realworld-robustness-failures-c119}

Understanding the importance of robustness in machine learning systems requires examining how faults manifest in practice. Real-world case studies illustrate the consequences of hardware and software faults across cloud, edge, and embedded environments. These examples highlight the critical need for fault-tolerant design, rigorous testing, and robust system architectures to ensure reliable operation in diverse deployment scenarios.

### Cloud Infrastructure Failures {#sec-robust-ai-cloud-infrastructure-failures-1c8c}

In February 2017, Amazon Web Services (AWS) experienced [a significant outage](https://aws.amazon.com/message/41926/) due to human error during routine maintenance. An engineer inadvertently entered an incorrect command, resulting in the shutdown of multiple servers across the US-East-1 region. This 4-hour outage disrupted over 150 AWS services, affecting approximately 54% of all internet traffic according to initial estimates and causing estimated losses of $150 million across affected businesses. Amazon's AI-powered assistant, Alexa, serving over 40 million devices globally, became completely unresponsive during the outage. Voice recognition requests that normally process in 200-500&nbsp;ms failed entirely, demonstrating the cascading impact of infrastructure failures on ML services. This incident underscores the impact of human error on cloud-based ML systems and the importance of robust maintenance protocols and failsafe mechanisms[^fn-failsafe-mechanisms].

[^fn-failsafe-mechanisms]: **Failsafe Mechanisms**: Systems designed to automatically shift to a safe state when a fault occurs. Examples include circuit breakers that prevent cascading failures and graceful degradation that maintains core functionality when components fail.

In another case [@dixit2021silent], Facebook encountered a silent data corruption (SDC)[^fn-silent-data-corruption] issue in its distributed querying infrastructure, illustrated in @fig-sdc-example. SDC refers to undetected errors during computation or data transfer that propagate silently through system layers. Facebook's system processed SQL-like queries across datasets and supported a compression application designed to reduce data storage footprints. Files were compressed when not in use and decompressed upon read requests. A size check was performed before decompression to ensure the file was valid. However, an unexpected fault occasionally returned a file size of zero for valid files, leading to decompression failures and missing entries in the output database. The issue appeared sporadically, with some computations returning correct file sizes, making it particularly difficult to diagnose.

[^fn-silent-data-corruption]: **Silent Data Corruption (SDC)**: Hardware or software errors that corrupt data without triggering error detection mechanisms. Studies show SDC affects 1 in every 1,000-10,000 computations in large-scale systems [@dixit2021silent], making it a major reliability concern.

[^fn-asil-standards]: **ASIL (Automotive Safety Integrity Levels)**: Safety standards defined in ISO 26262 that classify automotive systems based on risk levels from ASIL A (lowest) to ASIL D (highest). Safety-critical automotive ML systems like autonomous driving must meet ASIL C or D requirements, demanding 99.999% reliability and comprehensive fault tolerance mechanisms including redundant sensors, fail-safe behaviors, and rigorous validation protocols.

::: {#fig-sdc-example fig-env="figure" fig-pos="htb"}
```{.tikz}
\begin{tikzpicture}[line join=round,font=\usefont{T1}{phv}{m}{n}\footnotesize]
\tikzset{%
helvetica/.style={align=flush center,font=\small\usefont{T1}{phv}{m}{n}},
Line/.style={line width=1.0pt,black!50,text=black},
cube/.style={cylinder, draw,shape border rotate=90, aspect=1.8,inner ysep=0pt,
    minimum height=34mm,minimum width=25mm, cylinder uses custom fill,
    cylinder body fill=black!07,cylinder end fill=black!25},
Box/.style={,
    inner xsep=2pt,
    node distance=1.1,
    draw=GreenLine,
    line width=0.75pt,
    font=\usefont{T1}{phv}{m}{n}\small,
    align=flush center,
    fill=GreenL,
    text width=29mm,
    minimum width=29mm, minimum height=10mm
  },
Box2/.style={helvetica,
    inner xsep=2pt,
    node distance=0.8,
    draw=VioletLine,
    line width=0.75pt,
    font=\usefont{T1}{phv}{m}{n}\small,
     align=flush center,
    fill=VioletL2,
    text width=32mm,
    minimum width=32mm, minimum height=8mm
  },
}
\definecolor{CPU}{RGB}{0,120,176}
%%%
\node[Box](B2){Scale math.pow()};
\node[Box,above=of B2](B1){Decompress file size calculation};

\begin{scope}[local bounding box = CPU,shift={($(B2)+(0,-2.6)$)},
                          scale=0.7, every node/.append style={transform shape}]
\node[fill=CPU,minimum width=56, minimum height=56,
            rounded corners=8,outer sep=2pt] (C1) {};
\node[fill=white,minimum width=44, minimum height=44] (C2) {};
\node[fill=CPU!40,minimum width=39, minimum height=39,
            align=center,inner sep=0pt,font=\usefont{T1}{phv}{m}{n}
            \fontsize{8pt}{9}\selectfont] (C3) {Defective\\CPU};

\foreach \x/\y in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{
\node[fill=CPU,minimum width=3, minimum height=12,
           inner sep=0pt,anchor=south](GO\y)at($(C1.north west)!\x!(C1.north east)$){};
}
\foreach \x/\y in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{
\node[fill=CPU,minimum width=3, minimum height=12,
           inner sep=0pt,anchor=north](DO\y)at($(C1.south west)!\x!(C1.south east)$){};
}
\foreach \x/\y in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{
\node[fill=CPU,minimum width=12, minimum height=3,
           inner sep=0pt,anchor=east](LE\y)at($(C1.north west)!\x!(C1.south west)$){};
}
\foreach \x/\y in {0.11/1,0.26/2,0.41/3,0.56/4,0.71/5,0.85/6}{
\node[fill=CPU,minimum width=12, minimum height=3,
           inner sep=0pt,anchor=west](DE\y)at($(C1.north east)!\x!(C1.south east)$){};
}
\end{scope}
%%
\begin{scope}[local bounding box = CY1,shift={($(B2)+(5,-0.1)$)}]
\node (CA1) [cube] {};
\node (CA2) [cube,minimum height=10pt, fill=CPU!60]at($(CA1.bottom)!0.1!(CA1.top)$) {};
\node (CA3) [cube,minimum height=10pt,fill=red!80]at($(CA2.bottom)+(0,2.6mm)$){};
\node (CA4) [cube,minimum height=10pt,fill=red!80]at($(CA3.bottom)+(0,2.6mm)$){};
\node (CA5) [cube,minimum height=10pt, fill=CPU!60]at($(CA1.bottom)!0.65!(CA1.top)$) {};
\node[align=center]at (CA1){Spark shuffle and\\ merge database};
\end{scope}
%%
\begin{scope}[local bounding box = CY2,shift={($(B2)+(-5,-0.1)$)}]
\node (LCA1) [cube] {};
\node[align=center]at (LCA1){Spark pre-shuffle \\ data store\\(compressed)};
\end{scope}
\node[single arrow, draw=black,thick, fill=VioletL,
      minimum width = 15pt, single arrow head extend=3pt,rotate=270,
      minimum height=7mm]at($(B2)!0.52!(B1)$) {};
\node[single arrow, draw=black,thick, fill=VioletL,
      minimum width = 15pt, single arrow head extend=3pt,rotate=270,
      minimum height=7mm]at($(B2)!0.39!(CPU)$) {};
%
\coordinate(DES)at($(DE1)!0.5!(DE6)$);
\coordinate(LEV)at($(LE1)!0.5!(LE6)$);
\node[single arrow, draw=black,thick, fill=VioletL, inner sep=1pt,
      minimum width = 14pt, single arrow head extend=2pt,anchor=east,
      minimum height=18mm](LS)at($(LEV)+(-0.5,0)$) {};
\node[single arrow, draw=black,thick, fill=VioletL, inner sep=1pt,
      minimum width = 14pt, single arrow head extend=2pt,anchor=west,
      minimum height=18mm](DS)at($(DES)+(0.5,0)$) {};
%
%fitting
\scoped[on background layer]
\node[draw=violet,inner xsep=6.5mm,inner ysep=6.5mm,outer sep=0pt,
yshift=2mm,fill=none,fit=(CPU)(B1),line width=2.5pt](BB1){};
\node[below=3pt of  BB1.north,anchor=north,helvetica]{Shuffle and merge};
%%%
\node[Box2,below left=0.5 of LS](N2){\textbf{2.} Compute (1.1)\textsuperscript{53}};
\node[Box2,below right=0.5 of DS,fill=BlueL,draw=BlueLine](R3){\textbf{3.} Result = 0};
\node[Box2,below right=0.3 and -2.5 of R3,text width=43mm](N3){\textbf{3.} Expected Result = 156.24};
%
\node[Box2,above= of CY2](N1){\textbf{1.} Compute file size for decompression};
\node[Box2,above= of CY1](N4){\textbf{4.} Write file to database if size $>$ 0};
\node[Box2,below right= 0.2 and -1.15of CY1](N5){\textbf{5.} Missing rows in DB};
%
\draw[Line,-latex](N5)|-(CA3.before bottom);
\draw[Line,-latex](N5.50)|-(CA4.6);
\draw[Line](N3.20)|-(R3);
\draw[Line,-latex](LCA1.top)|-(B1);
\draw[Line,latex-](CA1.top)|-(B1);
\end{tikzpicture}
```
**Silent Data Corruption**: Unexpected Faults Can Return Incorrect File Sizes, Leading to Data Loss During Decompression and Propagating Errors Through Distributed Querying Systems Despite Apparent Operational Success. This Example From Facebook Emphasizes the Challenge of Undetected Errors, silent Data Corruption, and the Importance of Robust Error Detection Mechanisms in Large-Scale Data Processing Pipelines. Source: [Facebook](https://arxiv.org/PDF/2102.11245).
:::

This case illustrates how silent data corruption can propagate across multiple layers of the application stack, resulting in data loss and application failures in large-scale distributed systems. Left unaddressed, such errors can degrade ML system performance, particularly affecting training processes (@sec-ai-training). For example, corrupted training data or inconsistencies in data pipelines due to SDC may compromise model accuracy and reliability. The prevalence of such issues is confirmed by similar challenges reported across other major companies. As shown in @fig-sdc-jeffdean, [Jeff Dean](https://en.wikipedia.org/wiki/Jeff_Dean), Chief Scientist at Google DeepMind and Google Research, highlighted these issues in AI hypercomputers[^fn-ai-hypercomputers] during a keynote at [MLSys 2024](https://mlsys.org/) [@dean2024mlsys].

[^fn-ai-hypercomputers]: **AI Hypercomputers**: Massive computing systems specifically designed for AI workloads, featuring thousands of specialized processors (TPUs/GPUs) interconnected with high-bandwidth networks. Google's latest systems contain over 100,000 accelerators working in parallel.

![**Silent Data Corruption**: Modern AI Systems, Particularly Those Employing Large-Scale Data Processing Like Spark, Are Vulnerable to Silent Data Corruption (SDC), Subtle Errors Accumulating During Data Transfer and Storage. SDC Manifests in a Shuffle and Merge Database, Highlighting Corrupted Data Blocks (Red) Amidst Healthy Data (Blue/Gray) and Emphasizing the Challenge of Detecting These Errors in Distributed Systems Using the Figure. Source: Jeff Dean at MLSys 2024, Keynote (Google).](./images/jpg/sdc-google-jeff-dean.jpeg){#fig-sdc-jeffdean}

### Edge Device Vulnerabilities {#sec-robust-ai-edge-device-vulnerabilities-ddfe}

Moving from centralized cloud environments to distributed edge deployments, self-driving vehicles provide prominent examples of how faults can critically affect ML systems in the edge computing domain[^fn-edge-computing]. These vehicles depend on machine learning for perception, decision-making, and control, making them particularly vulnerable to both hardware and software faults.

[^fn-edge-computing]: **Edge Computing**: Processing data near its source rather than in centralized cloud servers, reducing latency from ~100&nbsp;ms to <10&nbsp;ms. Critical for autonomous vehicles where millisecond delays can mean the difference between collision avoidance and catastrophic failure.

![**Autopilot Perception Failure**: This Crash Provides the Critical Safety Risks of Relying on Machine Learning for Perception in Autonomous Systems, Where Failures to Correctly Classify Objects Can Lead to Catastrophic Outcomes. The Incident Underscores the Need for Robust Validation, Redundancy, and Failsafe Mechanisms in Self-Driving Vehicle Designs to Mitigate the Impact of Imperfect AI Models. Source: BBC News.](./images/jpg/tesla_example.jpg){#fig-tesla-example fig-pos='htb'}

In May 2016, a fatal crash occurred when a Tesla Model S operating in Autopilot mode[^fn-autopilot] collided with a white semi-trailer truck. The system, relying on computer vision and ML algorithms, failed to distinguish the trailer against a bright sky, leading to a high-speed impact. The driver, reportedly distracted at the time, did not intervene, as shown in @fig-tesla-example. This incident raised serious concerns about the reliability of AI-based perception systems and emphasized the need for robust failsafe mechanisms in autonomous vehicles.

[^fn-autopilot]: **Autopilot**: Tesla's driver assistance system that provides semi-autonomous capabilities like steering, braking, and acceleration while requiring active driver supervision.

Reinforcing these concerns, a similar case occurred in March 2018, when an Uber self-driving test vehicle [struck](https://money.cnn.com/2018/03/19/technology/uber-autonomous-car-fatal-crash/index.html?iid=EL) and killed a pedestrian in Tempe, Arizona. The accident was attributed to a flaw in the vehicle's object recognition software, which failed to classify the pedestrian as an obstacle requiring avoidance.

### Embedded System Constraints {#sec-robust-ai-embedded-system-constraints-ec7a}

Extending beyond edge computing to even more constrained environments, embedded systems[^fn-embedded-systems] operate in resource-constrained and often safety-critical environments. As AI capabilities are increasingly integrated into these systems, the complexity and consequences of faults grow significantly.

[^fn-embedded-systems]: **Embedded Systems**: Computer systems designed for specific control functions within larger systems, often with real-time constraints. Range from 8-bit microcontrollers with kilobytes of memory to complex systems-on-chip, typically operating for years without human intervention.

One example comes from space exploration. In 1999, NASA's Mars Polar Lander mission experienced [a catastrophic failure](https://spaceref.com/uncategorized/nasa-reveals-probable-cause-of-mars-polar-lander-and-deep-space-2-mission-failures/) due to a software error in its touchdown detection system (@fig-nasa-example). The lander's software misinterpreted the vibrations from the deployment of its landing legs as a successful touchdown, prematurely shutting off its engines and causing a crash. This incident demonstrates the importance of rigorous software validation and robust system design, particularly for remote missions where recovery is impossible. As AI becomes more integral to space systems, ensuring robustness and reliability becomes necessary for mission success.

![**Touchdown Detection Failure**: Erroneous Sensor Readings During the Mars Polar Lander Mission Triggered a Premature Engine Shutdown, Demonstrating the Critical Need for Robust Failure Modes and Rigorous Validation of Embedded Systems, particularly Those Operating in Inaccessible Environments. This Incident Underscores How Software Errors Can Lead to Catastrophic Consequences in Safety-Critical Applications and Emphasizes the Growing Importance of Reliable AI Integration in Complex Systems. Source: Slashgear.](./images/png/nasa_example.png){#fig-nasa-example fig-pos='htb'}

The consequences of embedded system failures extend beyond space exploration to commercial aviation. In 2015, a Boeing 787 Dreamliner experienced a complete electrical shutdown mid-flight due to a software bug in its generator control units. This failure highlights the critical importance of safety-critical systems[^fn-asil-standards] meeting stringent reliability requirements. The failure stemmed from a scenario in which powering up all four generator control units simultaneously after 248 days of continuous power (approximately 8 months), caused them to enter failsafe mode, disabling all AC electrical power.

> _"If the four main generator control units (associated with the engine-mounted generators) were powered up at the same time, after 248 days of continuous power, all four GCUs will go into failsafe mode at the same time, resulting in a loss of all AC electrical power regardless of flight phase." — [Federal Aviation Administration directive](https://s3.amazonaws.com/public-inspection.federalregister.gov/2015-10066.pdf) (2015)_

As AI is increasingly applied in aviation, including tasks such as autonomous flight control and predictive maintenance, the robustness of embedded systems affects passenger safety.

The stakes become even higher when we consider implantable medical devices. For instance, a smart [pacemaker](https://www.bbc.com/future/article/20221011-how-space-weather-causes-computer-errors) that experiences a fault or unexpected behavior due to software or hardware failure could place a patient's life at risk. As AI systems take on perception, decision-making, and control roles in such applications, new sources of vulnerability emerge, including data-related errors, model uncertainty[^fn-model-uncertainty], and unpredictable behaviors in rare edge cases. The opaque nature of some AI models complicates fault diagnosis and recovery.

These real-world failure scenarios underscore the critical need for systematic approaches to robustness evaluation and mitigation. Each failure—whether the AWS outage affecting millions of voice interactions, autonomous vehicle perception errors leading to fatal crashes, or spacecraft software bugs causing mission loss—reveals common patterns that inform robust system design.

[^fn-model-uncertainty]: **Model Uncertainty**: The inadequacy of a machine learning model to capture the full complexity of the underlying data-generating process.

Building on these concrete examples of system failures across deployment environments, we now establish a unified framework for understanding and addressing robustness challenges systematically.

## A Unified Framework for Robust AI {#sec-robust-ai-unified-framework-robust-ai-b25d}

The real-world failures examined above share common characteristics despite their diverse causes and contexts. Whether examining AWS outages that disable voice assistants, autonomous vehicle perception failures, or spacecraft software errors, these incidents reveal patterns that inform systematic approaches to building robust AI systems.

### Building on Previous Concepts {#sec-robust-ai-building-previous-concepts-ef4a}

Before establishing our robustness framework, we connect these challenges to foundational concepts from earlier chapters. Hardware acceleration architectures (@sec-ai-acceleration) established how GPU memory hierarchies, interconnect fabrics, and specialized compute units create complex fault propagation paths that robustness systems must address. The security frameworks from @sec-security-privacy introduced threat modeling principles that directly inform our understanding of adversarial attacks and defensive strategies. Operational monitoring systems from @sec-ml-operations provide the infrastructure foundation for detecting and responding to robustness threats in production environments.

These earlier concepts converge in robust AI systems where GPU memory errors can corrupt model weights, adversarial inputs exploit learned vulnerabilities, and operational monitoring must detect anomalies across hardware, algorithmic, and environmental dimensions. The efficiency optimizations from @sec-efficient-ai become critical constraints when implementing redundancy and error correction mechanisms within acceptable performance budgets.

### From ML Performance to System Reliability {#sec-robust-ai-ml-performance-system-reliability-7d42}

To understand these failure patterns systematically, we must bridge the gap between ML system performance concepts familiar from earlier chapters and the reliability engineering principles essential for robust deployment. In traditional ML development (@sec-ml-systems), we focus on metrics like model accuracy, inference latency, and throughput. However, real-world deployment introduces an additional dimension: the reliability of the underlying computational substrate that executes our models.

Consider how hardware reliability directly impacts ML performance: a single bit flip in a critical neural network weight can degrade ResNet-50 classification accuracy from 76.0% (top-1) to 11% on ImageNet, while memory subsystem failures during training corrupt gradient updates and prevent model convergence. Modern transformer models (such as GPT-3 with 175&nbsp;B parameters) execute 10^15 floating-point operations per inference, creating over one million opportunities for hardware faults during a single forward pass. GPU memory systems operating at up to 900 GB/s bandwidth (e.g., V100 HBM2) process 10^11 bits per second, where base error rates of 10^-17 errors per bit translate to multiple potential faults per hour of operation.

This connection between hardware reliability and ML performance requires us to adopt concepts from reliability engineering[^fn-reliability-engineering], including fault models that describe how failures occur, error detection mechanisms that identify problems before they impact results, and recovery strategies that restore system operation. These reliability concepts complement the performance optimization techniques covered in @sec-efficient-ai by ensuring that optimized systems continue to operate correctly under real-world conditions.

[^fn-reliability-engineering]: **Reliability Engineering**: An engineering discipline focused on ensuring systems perform their intended function without failure over specified time periods. Originated in aerospace and nuclear industries where failures have catastrophic consequences, now essential for AI systems in safety-critical applications.

Building on this conceptual bridge, we establish a unified framework for understanding robustness challenges across all dimensions of ML systems. This framework provides the conceptual foundation for understanding how different types of faults, whether originating from hardware, adversarial inputs, or software defects, share common characteristics and can be addressed through systematic approaches.

### The Three Pillars of Robust AI {#sec-robust-ai-three-pillars-robust-ai-2626}

Robust AI systems must address three primary categories of challenges that can compromise system reliability and performance. @fig-three-pillars-framework illustrates this three-pillar framework, showing how system-level faults, input-level attacks, and environmental shifts each represent distinct but interconnected threats to ML system robustness:

::: {#fig-three-pillars-framework fig-env="figure" fig-pos="h"}
```{.tikz}
\begin{tikzpicture}[line join=round,font=\usefont{T1}{phv}{m}{n}\small]
\tikzset{
  Box/.style={align=center,outer sep=0pt,
    inner xsep=6pt,    inner ysep=7pt,
    node distance=1,
    draw=GreenLine,
    line width=0.75pt,
    fill=GreenL!60,
    text width=33mm,
    minimum width=33mm, minimum height=30mm,anchor=north
  },
   Box11/.style={Box, fill=GreenD,draw=GreenD,minimum height=10mm,text=white,font=\usefont{T1}{phv}{m}{n}\bfseries,inner ysep=2pt},
   Box2/.style={Box, fill=BlueL!60,draw=BlueLine},
   Box22/.style={Box, fill=BlueLine,draw=BlueLine,minimum height=10mm,text=white,font=\usefont{T1}{phv}{m}{n}\bfseries,inner ysep=2pt},
   Box3/.style={Box, fill=RedL!60,draw=RedLine},
   Box33/.style={Box, fill=RedLine,draw=RedLine,minimum height=10mm,text=white,font=\usefont{T1}{phv}{m}{n}\bfseries,inner ysep=2pt},
   Box4/.style={Box, draw=OrangeLine, fill=OrangeL!60,  text width=138mm,minimum width=138mm, minimum height=10mm},
Line/.style={BrownLine!40, line width=2.0pt,shorten <=1pt,shorten >=2pt},
LineA/.style={violet!50,line width=1.0pt,{-{Triangle[width=1.1*4pt,length=1.5*6pt]}},shorten <=1pt,shorten >=1pt},
ALine/.style={black!50, line width=1.1pt,{{Triangle[width=0.9*6pt,length=1.2*6pt]}-}},
Larrow/.style={fill=violet!50, single arrow,  inner sep=2pt, single arrow head extend=3pt,
            single arrow head indent=0pt,minimum height=10mm, minimum width=3pt}
}

\node[Box4](B0){Robust AI System};
\node[Box11,below=0.7 of B0.south west,anchor=north west](B11){System-Level \\ Faults};
\node[Box22,below=0.7 of B0.south,anchor=north](B22){Input-Level\\ Attacks};
\node[Box33,below=0.7 of B0.south east,anchor=north east](B33){Environmental\\ Shifts};

\node[Box,below=0pt of B11.south,anchor=north,text depth = 30mm,align=left](B1){\parskip=3pt%
$\blacktriangleright$ Bit Flips

$\blacktriangleright$ Component\\ \hphantom{$\blacktriangleright$ }Wear-out

$\blacktriangleright$ Memory Errors

$\blacktriangleright$ Power Failures

$\blacktriangleright$ Temperature\\ \hphantom{$\blacktriangleright$ }Extremes
};
\node[Box2,below=0pt of B22.south,anchor=north, text depth = 30mm,align=left](B2){\parskip=3pt%
$\blacktriangleright$ Adversarial\\ \hphantom{$\blacktriangleright$ }Attacks

$\blacktriangleright$ Data Poisoning

$\blacktriangleright$ Prompt Injection

$\blacktriangleright$  Input \\  \hphantom{$\blacktriangleright$ }Manipulation
};
\node[Box3,below=0pt of B33.south,anchor=north, text depth = 30mm,align=left](B3){\parskip=3pt%
$\blacktriangleright$  Data Drift

$\blacktriangleright$ Concept Drift

$\blacktriangleright$ Domain Shift

$\blacktriangleright$ Distribution\\ \hphantom{$\blacktriangleright$ }Changes

$\blacktriangleright$  Context \\ \hphantom{$\blacktriangleright$ }Evolution
};

\draw[GreenD,line width=3pt](B1.south west)--(B11.north west);
\draw[BlueLine,line width=3pt](B2.south west)--(B22.north west);
\draw[RedLine,line width=3pt](B3.south west)--(B33.north west);
\foreach \i/\col in {1/GreenD,2/BlueLine,3/RedLine}{
\draw[Line,\col!50](B0)--(B\i\i.north);
}
\end{tikzpicture}
```
**Three Pillars Framework**: The three core categories of robustness challenges that AI systems must address to ensure reliable operation in real-world deployments. A robust AI system is built upon effectively handling these three challenge areas.
:::

System-level faults encompass all failures originating from the underlying computing infrastructure. These include transient hardware errors from cosmic radiation, permanent component degradation, and intermittent faults that appear sporadically. System-level faults affect the physical substrate upon which ML computations execute, potentially corrupting calculations, memory access patterns, or communication between components.

Input-level attacks comprise deliberate attempts to manipulate model behavior through carefully crafted inputs or training data. Adversarial attacks exploit model vulnerabilities by adding imperceptible perturbations to inputs, while data poisoning corrupts the training process itself. These threats target the information processing pipeline, subverting the model's learned representations and decision boundaries.

Environmental shifts represent the natural evolution of real-world conditions that can degrade model performance over time. Distribution shifts, concept drift, and changing operational contexts challenge the core assumptions underlying model training. Unlike deliberate attacks, these shifts reflect the dynamic nature of deployment environments and the inherent limitations of static training paradigms.

### Common Robustness Principles {#sec-robust-ai-common-robustness-principles-cb22}

These three categories of challenges stem from different sources but share several key characteristics that inform our approach to building resilient systems:

Detection and monitoring form the foundation of any robustness strategy. Hardware monitoring systems typically sample metrics at 1-10 Hz frequencies, detecting temperature anomalies (±5°C from baseline), voltage fluctuations (±5% from nominal), and memory error rates exceeding 10^-12 errors per bit per hour. Adversarial input detection leverages statistical tests with p-value thresholds of 0.01-0.05, achieving 85-95% detection rates with false positive rates below 2%. Distribution monitoring using MMD tests processes 1,000-10,000 samples per evaluation, detecting shifts with Cohen's d > 0.3 within 95% confidence intervals.

Building on this detection capability, graceful degradation ensures that systems maintain core functionality even when operating under stress. Rather than catastrophic failure, robust systems should exhibit predictable performance reduction that preserves critical capabilities. ECC memory systems recover from single-bit errors with 99.9% success rates while adding 12.5% bandwidth overhead. Model quantization from FP32 to INT8 reduces memory requirements by 75% and inference time by 2-4$\times$, trading 1-3% accuracy for continued operation under resource constraints. Ensemble fallback systems maintain 85-90% of peak performance when primary models fail, with switchover latency under 10&nbsp;ms.

Adaptive response enables systems to adjust their behavior based on detected threats or changing conditions. Adaptation might involve activating error correction mechanisms, applying input preprocessing techniques, or dynamically adjusting model parameters. The key principle is that robustness is not static but requires ongoing adjustment to maintain effectiveness.

These principles extend beyond fault recovery to encompass comprehensive performance adaptation strategies that appear throughout ML system design. Detection strategies form the foundation for monitoring systems, graceful degradation guides fallback mechanisms when components fail, and adaptive response enables systems to evolve with changing conditions.

### Integration Across the ML Pipeline {#sec-robust-ai-integration-across-ml-pipeline-8286}

Robustness cannot be achieved through isolated techniques applied to individual components. Instead, it requires systematic integration across the entire ML pipeline, from data collection through deployment and monitoring. This integrated approach recognizes that vulnerabilities in one component can compromise the entire system, regardless of protective measures implemented elsewhere.

With this unified foundation established, the detection and mitigation strategies we explore in subsequent sections, whether for hardware faults, adversarial attacks, or software errors, all build upon these common principles while addressing the specific characteristics of each threat category. Understanding these shared foundations enables the development of more effective and efficient approaches to building robust AI systems.

The following sections examine each pillar systematically, providing the conceptual foundation necessary to understand specialized tools and frameworks used for robustness evaluation and improvement.

## Hardware Faults {#sec-robust-ai-hardware-faults-cf22}

Having established our unified framework, we now examine each pillar in detail, beginning with system-level faults. Hardware faults represent the foundational layer of robustness challenges because all ML computations ultimately execute on physical hardware that can fail in various ways.

### Hardware Fault Impact on ML Systems {#sec-robust-ai-hardware-fault-impact-ml-systems-b5f7}

Understanding why hardware reliability particularly matters for machine learning workloads requires examining several key factors. ML systems differ from traditional applications in several ways that amplify the impact of hardware faults:

- **Computational Intensity**: Modern ML workloads perform millions of operations per second, creating many opportunities for faults to corrupt results
- **Long-Running Training**: Training jobs may run for days or weeks, increasing the probability of encountering hardware faults
- **Parameter Sensitivity**: Small corruptions in model weights can cause large changes in output predictions
- **Distributed Dependencies**: Large-scale training depends on coordination across many processors, where single-point failures can disrupt entire workflows

Building on these ML-specific considerations, hardware faults fall into three main categories based on their temporal characteristics and persistence, each presenting distinct challenges for ML system reliability.

To illustrate the direct impact of hardware faults on neural networks, consider a single bit-flip in a weight matrix. If a critical weight in a ResNet-50 model flips from `0.5` to `-0.5` due to a transient fault affecting the sign bit in the IEEE 754 floating-point representation, it changes the sign of a feature map, causing a cascade of errors through subsequent layers. Research has shown that a single, targeted bit-flip in a key layer can drop ImageNet accuracy from 76% to less than 10% [@reagen2018ares]. This demonstrates why hardware reliability directly affects model performance, not merely infrastructure stability. Unlike traditional software where a single bit error might cause a crash or incorrect calculation, in neural networks it can silently corrupt the learned representations that determine system behavior.

Transient faults are temporary disruptions caused by external factors such as cosmic rays or electromagnetic interference. These non-recurring events, exemplified by bit flips in memory, cause incorrect computations without permanent hardware damage. For ML systems, transient faults can corrupt gradient updates during training or alter model weights during inference, leading to temporary but potentially significant performance degradation.

Permanent faults represent irreversible damage from physical defects or component wear-out, such as stuck-at faults or device failures that require hardware replacement. These faults are particularly problematic for long-running ML training jobs, where hardware failure can result in days or weeks of lost computation and require complete job restart from the most recent checkpoint.

Intermittent faults appear and disappear sporadically due to unstable conditions like loose connections or aging components, making them particularly challenging to diagnose and reproduce. These faults can cause non-deterministic behavior in ML systems, leading to inconsistent results that compromise model validation and reproducibility.

Understanding this fault taxonomy provides the foundation for designing fault-tolerant ML systems that can detect, mitigate, and recover from hardware failures across different operational environments. The impact of these faults on ML systems extends beyond traditional computing applications due to the computational intensity, distributed nature, and long-running characteristics of modern AI workloads.

### Transient Faults {#sec-robust-ai-transient-faults-1455}

Beginning our detailed examination with the most common category, transient faults in hardware can manifest in various forms, each with its own unique characteristics and causes. These faults are temporary in nature and do not result in permanent damage to the hardware components.

#### Transient Fault Properties {#sec-robust-ai-transient-fault-properties-318c}

Transient faults are characterized by their short duration and non-permanent nature. They do not persist or leave any lasting impact on the hardware. However, they can still lead to incorrect computations, data corruption, or system misbehavior if not properly handled. A classic example is shown in @fig-bit-flip, where a single bit in memory unexpectedly changes state, potentially altering critical data or computations.

These manifestations encompass several distinct categories. Common transient fault types include Single Event Upsets (SEUs)[^fn-single-event-upsets] from cosmic rays and ionizing radiation, voltage fluctuations [@reddi2013resilient] from power supply instability, Electromagnetic Interference (EMI)[^fn-electromagnetic-interference] from external electromagnetic fields, Electrostatic Discharge (ESD) from sudden static electricity flow, crosstalk[^fn-crosstalk] from unintended signal coupling, ground bounce from simultaneous switching of multiple outputs, timing violations from signal timing constraint breaches, and soft errors in combinational logic [@mukherjee2005soft]. Understanding these fault types enables designing robust hardware systems that can mitigate their impact and ensure reliable operation.

[^fn-single-event-upsets]: **Single Event Upsets (SEUs)**: Radiation-induced bit flips in memory or logic caused by cosmic rays or alpha particles. Modern DRAM exhibits error rates of approximately 1 per 10^17 bits accessed, occurring roughly once per gigabit per month at sea level [@baumann2005soft]. For AI systems processing large datasets, a 1&nbsp;TB model checkpoint experiences an expected 80 bit flips during a single read operation, making error detection essential for reliable ML training.

[^fn-electromagnetic-interference]: **Electromagnetic Interference (EMI)**: Disturbance caused by external electromagnetic sources that can disrupt electronic circuits. Common sources include cell phones, WiFi, and nearby switching power supplies, requiring careful shielding in sensitive systems.

[^fn-crosstalk]: **Crosstalk**: Unwanted signal coupling between adjacent conductors due to parasitic capacitance and inductance. Becomes increasingly problematic as circuit densities increase, potentially causing timing violations and data corruption.

#### Fault Analysis and Performance Impact {#sec-robust-ai-fault-analysis-performance-impact-fa37}

Modern ML systems require precise understanding of fault rates and their performance implications to make informed engineering decisions. The quantitative analysis of transient faults reveals significant patterns that inform robust system design.

Advanced semiconductor processes exhibit dramatically higher soft error rates. Modern 7&nbsp;nm processes experience approximately 1000$\times$ higher soft error rates compared to 65&nbsp;nm nodes due to reduced node capacitance and charge collection efficiency [@baumann2005soft]. For ML accelerators fabricated on cutting-edge processes, this translates to base error rates of approximately 1 error per 10^14 operations, requiring systematic error detection and correction strategies.

These theoretical fault rates translate into practical reliability metrics that vary significantly with deployment environment and workload characteristics. Typical AI accelerators demonstrate Mean Time Between Failures (MTBF)[^fn-mtbf] values that differ substantially across deployment contexts:

[^fn-mtbf]: **Mean Time Between Failures (MTBF)**: A reliability metric measuring the average operational time between system failures. Formalized by the U.S. military in the 1960s (MIL-HDBK-217, 1965) building on 1950s reliability theory, MTBF calculations assume exponential failure distributions during the useful life period. For AI systems, MTBF analysis guides checkpoint frequency - a system with 50,000-hour MTBF should checkpoint every 1-2 hours to minimize recovery overhead while maintaining <1% performance impact from fault tolerance.

- **Cloud AI accelerators** (Tesla V100, A100): MTBF of 50,000-100,000 hours under controlled data center conditions
- **Edge AI processors** (NVIDIA Jetson, Intel Movidius): MTBF of 20,000-40,000 hours in uncontrolled environments
- **Mobile AI chips** (Apple Neural Engine, Qualcomm Hexagon): MTBF of 30,000-60,000 hours with thermal and power constraints

These MTBF values compound significantly in distributed training scenarios. A cluster of 1,000 accelerators with individual MTBF of 50,000 hours experiences an expected failure every 50 hours, necessitating robust checkpointing and recovery mechanisms.

Beyond understanding failure rates, system designers must account for protection costs. Hardware fault tolerance mechanisms introduce measurable performance and energy penalties that must be considered in system design. @tbl-fault-tolerance-overhead quantifies these trade-offs across different protection mechanisms:

+-------------------------------+-----------------+---------------------+-------------------+
| **Protection Mechanism**      | **Performance** | **Energy Overhead** | **Area Overhead** |
|                               | **Overhead**    |                     |                   |
+:==============================+================:+====================:+==================:+
| **Single-bit ECC**            | 2-5%            | 3-7%                | 12-15%            |
+-------------------------------+-----------------+---------------------+-------------------+
| **Double-bit ECC**            | 5-12%           | 8-15%               | 25-30%            |
+-------------------------------+-----------------+---------------------+-------------------+
| **Triple Modular Redundancy** | 200-300%        | 200-300%            | 200-300%          |
+-------------------------------+-----------------+---------------------+-------------------+
| **Checkpoint/Restart**        | 10-25%          | 15-30%              | 5-10%             |
+-------------------------------+-----------------+---------------------+-------------------+

: **Fault Tolerance Overhead Analysis**: Quantitative impact of different protection mechanisms on system performance, energy consumption, and hardware area requirements. These overheads must be balanced against fault rates and recovery costs to optimize system reliability per unit resource. {#tbl-fault-tolerance-overhead}

These overhead values have particularly significant impact on memory bandwidth utilization, a critical constraint in ML workloads. ECC memory[^fn-ecc-memory] reduces effective bandwidth by 12.5% due to additional storage requirements (8 ECC bits per 64 data bits). Memory scrubbing operations for error detection consume additional 5-15% of available bandwidth depending on scrubbing frequency and memory configuration.

[^fn-ecc-memory]: **Error-Correcting Code (ECC) Memory**: Memory technology that automatically detects and corrects bit errors using redundant information. Developed at IBM in the 1960s, ECC memory adds 8 bits of error correction data per 64 bits of user data, enabling single-bit error correction and double-bit error detection. Critical for AI systems where memory errors can corrupt model weights - a single-bit flip in a key parameter can degrade accuracy by 10-50% depending on the affected layer.

These bandwidth overheads have direct performance implications. For typical transformer training workloads that are memory bandwidth-bound, these bandwidth reductions directly translate to proportional training time increases. A model requiring 900 GB/s of memory bandwidth with ECC protection effectively receives only 787 GB/s, extending training time by approximately 14%.

#### Memory Hierarchy and Bandwidth Impact {#sec-robust-ai-memory-hierarchy-bandwidth-impact-7525}

Memory subsystems represent the most vulnerability-prone components in modern ML systems, with fault tolerance mechanisms significantly impacting both bandwidth utilization and overall system performance. Understanding memory hierarchy robustness requires analyzing the interplay between different memory technologies, their error characteristics, and the bandwidth implications of protection mechanisms.

This complexity stems from the diverse characteristics of memory technologies, which exhibit distinct fault patterns and protection requirements. @tbl-memory-bandwidth-protection shows how ECC protection affects memory bandwidth across different technologies:

- **DRAM**: Base error rate of 1 per 10^17 bits, dominated by single-bit soft errors. Requires refresh-based error detection and correction.
- **HBM (High Bandwidth Memory)**: 10$\times$ higher error rates due to 3D stacking effects and thermal density. Advanced ECC required for reliable operation.
- **SRAM (Cache)**: Lower soft error rates (1 per 10^19 bits) but higher vulnerability to voltage variations and process variations.
- **NVM (Non-Volatile Memory)**: Emerging technologies like 3D XPoint with unique error patterns requiring specialized protection schemes[^fn-nvm-technologies].

[^fn-nvm-technologies]: **Non-Volatile Memory (NVM) Technologies**: Storage-class memory that bridges DRAM and traditional storage, including Intel's 3D XPoint (Optane) and emerging resistive RAM technologies. Introduced commercially in 2017, NVM provides 1000$\times$ faster access than SSDs while maintaining data persistence, enabling new ML system architectures where models can remain memory-resident across power cycles.

- **GDDR**: Optimized for bandwidth over reliability, typically 2-3$\times$ higher error rates than standard DRAM.

The choice of memory technology and protection mechanism directly affects available bandwidth for ML workloads:

+-----------------------+--------------------+------------------+----------------------+
| **Memory Technology** | **Base Bandwidth** | **ECC Overhead** | **Effective**        |
|                       | **(GB/s)**         | **(%)**          | **Bandwidth (GB/s)** |
+======================:+===================:+=================:+=====================:+
| **DDR4-3200**         | 51.2               | 12.5%            | 44.8                 |
+-----------------------+--------------------+------------------+----------------------+
| **HBM2**              | 900                | 12.5%            | 787                  |
+-----------------------+--------------------+------------------+----------------------+
| **HBM3**              | 1,600              | 12.5%            | 1,400                |
+-----------------------+--------------------+------------------+----------------------+
| **GDDR6X**            | 760                | Typically none   | 760                  |
+-----------------------+--------------------+------------------+----------------------+

: **Memory Bandwidth Protection Analysis**: Impact of ECC protection on effective memory bandwidth across different memory technologies used in ML accelerators. The bandwidth overhead directly affects training throughput for memory-bound workloads. {#tbl-memory-bandwidth-protection}

Modern memory systems implement continuous background error detection through memory scrubbing, which periodically reads and rewrites memory locations to detect and correct accumulating soft errors. This background activity consumes memory bandwidth and creates interference with ML workloads:

- **Scrubbing Rate**: Typical 24-hour full memory scan consumes 2-5% of total bandwidth
- **Priority Arbitration**: ML memory requests must compete with scrubbing operations, increasing latency variance by 10-15%
- **Thermal Impact**: Scrubbing increases memory power consumption by 3-8%, affecting thermal design and cooling requirements

Advanced ML systems implement hierarchical protection schemes that balance performance and reliability across the memory hierarchy:

1. **L1/L2 Cache**: Parity protection with immediate detection and replay capability
2. **L3 Cache**: Single-bit ECC with error logging and gradual cache line retirement
3. **Main Memory**: Double-bit ECC with advanced syndrome analysis and predictive failure detection
4. **Persistent Storage**: Reed-Solomon codes with distributed redundancy across multiple devices

Modern AI accelerators integrate memory protection with compute pipeline design to minimize performance impact:

- **Error Detection Pipelining**: Memory ECC checking overlapped with arithmetic operations to hide protection latency
- **Adaptive Protection Levels**: Dynamic adjustment of protection strength based on workload criticality and error rate monitoring
- **Bandwidth Allocation Policies**: Quality-of-service mechanisms that prioritize critical ML memory traffic over background protection operations

::: {#fig-bit-flip fig-env="figure" fig-pos="htb"}
```{.tikz}
\scalebox{0.8}{%
\begin{tikzpicture}[line join=round,font=\usefont{T1}{phv}{m}{n}\small]
\tikzset{%
helvetica/.style={align=flush center,font=\small\usefont{T1}{phv}{m}{n}},
cell/.style={draw=BrownLine,line width=0.5pt, minimum size=\cellsize,
    minimum height=\cellheight}
}
\def\columns{6}
\def\rows{1}
\def\cellsize{9mm}
\def\cellheight{9mm}
\colorlet{BrownL}{BrownL!30}

\begin{scope}[local bounding box=M1,shift={(0,0)}]
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \def\br{MG}
\node[draw=BrownLine, fill=BrownL, minimum width=\cellsize,
                    minimum height=\cellheight,
                    line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {1};
    }
}
\end{scope}

\begin{scope}[local bounding box=M2,shift={(0,-2)}]
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \def\br{MD}
\node[draw=BrownLine, fill=BrownL, minimum width=\cellsize,
                    minimum height=\cellheight,
                    line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {1};
    }
}
\end{scope}
\foreach \x in {2,3,6}{,
\node[cell,fill=BrownL]at(cell-\x-1MG){0};
}
\foreach \x in {2,6}{,
\node[cell,fill=BrownL]at(cell-\x-1MD){0};
}

\node[cell,fill=BrownL,line width=2pt](BF)at(cell-3-1MD){1};
\node[above=3pt of BF]{\textbf{Bit-Flip}};
\node[right=0.3 of cell-6-1MD,font=\usefont{T1}{phv}{m}{n}\tiny](DT){$\bullet$ $\bullet$ $\bullet$};
\node[right=0.3 of cell-6-1MG,font=\usefont{T1}{phv}{m}{n}\tiny](GT){$\bullet$ $\bullet$ $\bullet$};
\node[right=0.3 of GT]{Memory before};
\node[right=0.3 of DT]{Memory after};
\end{tikzpicture}}
```
**Bit-Flip Error**: Transient faults can alter individual bits in memory, corrupting data or program instructions and potentially causing system malfunctions. These single-bit errors exemplify the vulnerability of hardware to transient faults like those induced by radiation or electromagnetic interference.
:::

#### Transient Fault Origins {#sec-robust-ai-transient-fault-origins-2226}

External environmental factors represent the most significant source of the transient fault types described above. As illustrated in @fig-transient-fault, cosmic rays, high-energy particles from outer space, strike sensitive hardware areas like memory cells or transistors, inducing charge disturbances that alter stored or transmitted data. [Electromagnetic interference (EMI)](https://www.trentonsystems.com/en-us/resource-hub/blog/what-is-electromagnetic-interference) from nearby devices creates voltage spikes or glitches that temporarily disrupt normal operation. Electrostatic discharge (ESD) events create temporary voltage surges that affect sensitive electronic components.

![**Transient Fault Mechanism**: Cosmic rays and electromagnetic interference induce bit flips within hardware by altering electrical charges in memory cells and transistors, potentially corrupting data and causing system errors. Understanding these fault sources is critical for building robust ai systems that can tolerate unpredictable hardware behavior. Source: [NTT](HTTPS://group.ntt/en/newsrelease/2018/11/22/181122a.HTML).](./images/png/transient_fault.png){#fig-transient-fault}

Complementing these external environmental factors, power and signal integrity issues constitute another major category of transient fault causes, affecting hardware systems (@sec-ai-acceleration). Voltage fluctuations due to power supply noise or instability [@reddi2013resilient] can cause logic circuits to operate outside their specified voltage ranges, leading to incorrect computations. Ground bounce, triggered by simultaneous switching of multiple outputs, creates temporary voltage variations in the ground reference that can affect signal integrity. Crosstalk, caused by unintended signal coupling between adjacent conductors, can induce noise that temporarily corrupts data or control signals, impacting training processes (@sec-ai-training).

Timing and logic vulnerabilities create additional pathways for transient faults. Timing violations occur when signals fail to meet setup or hold time requirements due to process variations, temperature changes, or voltage fluctuations. These violations can cause incorrect data capture in sequential elements. Soft errors in combinational logic can affect circuit outputs even without memory involvement, particularly in deep logic paths where noise margins are reduced [@mukherjee2005soft].

#### Transient Fault Propagation {#sec-robust-ai-transient-fault-propagation-4bee}

Building on these underlying causes, transient faults can manifest through different mechanisms depending on the affected hardware component. In memory devices like DRAM or SRAM, transient faults often lead to bit flips, where a single bit changes its value from 0 to 1 or vice versa. This can corrupt the stored data or instructions. In logic circuits, transient faults can cause glitches[^fn-glitches] or voltage spikes propagating through the combinational logic[^fn-combinationallogic], resulting in incorrect outputs or control signals. Graphics Processing Units (GPUs)[^fn-gpu-fault-rates] used extensively in ML workloads exhibit significantly higher error rates than traditional CPUs, with studies showing GPU error rates 10-1000$\times$ higher than CPU errors due to their parallel architecture, higher transistor density, and aggressive voltage/frequency scaling. This disparity makes GPU-accelerated AI systems particularly vulnerable to transient faults during training and inference operations. Transient faults can also affect communication channels, causing bit errors or packet losses during data transmission. In distributed AI training systems, network partitions[^fn-network-partitions] occur with measurable frequency - studies of large-scale clusters report partition events affecting 1-10% of nodes daily, with recovery times ranging from seconds to hours depending on the partition type and detection mechanisms.

[^fn-glitches]: **Glitches**: Momentary deviation in voltage, current, or signal, often causing incorrect operation.

[^fn-combinationallogic]: **Combinational logic**: Digital logic, wherein the output depends only on the current input states, not any past states.

[^fn-gpu-fault-rates]: **GPU Fault Characteristics**: Graphics processors experience dramatically higher error rates than CPUs due to thousands of simpler cores operating at higher frequencies with aggressive power optimization. NVIDIA's V100 contains 5,120 CUDA cores versus 24-48 cores in server CPUs, creating 100$\times$ more potential failure points. Additionally, GPU memory (HBM2) operates at up to 1.6 TB/s bandwidth in the V100 with minimal error correction, making AI training particularly vulnerable to silent data corruption.

[^fn-network-partitions]: **Network Partitions**: Temporary loss of communication between groups of nodes in a distributed system, violating network connectivity assumptions. First studied systematically by Lamport in 1978, partitions affect large-scale ML training where thousands of nodes must synchronize gradients. Modern solutions include gradient compression, asynchronous updates, and Byzantine-fault-tolerant protocols that maintain training progress despite 10-30% node failures. These network disruptions can cause training job failures, parameter synchronization issues, and data inconsistencies that require robust distributed coordination protocols to maintain system reliability.

#### Transient Fault Effects on ML {#sec-robust-ai-transient-fault-effects-ml-a01d}

A common example of a transient fault is a bit flip in the main memory. If an important data structure or critical instruction is stored in the affected memory location, it can lead to incorrect computations or program misbehavior. For instance, a bit flip in the memory storing a loop counter can cause the loop to execute indefinitely or terminate prematurely. Transient faults in control registers or flag bits can alter the flow of program execution, leading to unexpected jumps or incorrect branch decisions. In communication systems, transient faults can corrupt transmitted data packets, resulting in retransmissions or data loss.

These general impacts become particularly pronounced in ML systems, where transient faults can have significant implications during the training phase [@he2023understanding]. ML training involves iterative computations and updates to model parameters based on large datasets. If a transient fault occurs in the memory storing the model weights or gradients[^fn-gradients], it can lead to incorrect updates and compromise the convergence and accuracy of the training process. For example, a bit flip in the weight matrix of a neural network can cause the model to learn incorrect patterns or associations, leading to degraded performance [@wan2021analyzing]. Transient faults in the data pipeline, such as corruption of training samples or labels, can also introduce noise and affect the quality of the learned model.

[^fn-gradients]: **Gradients and Convergence**: Core training concepts where gradients are mathematical derivatives indicating how to adjust model parameters, and convergence refers to the training process reaching a stable, optimal solution. These fundamental concepts are covered in detail in @sec-ai-training.

As shown in @fig-sdc-training-fault, a real-world example from Google's production fleet highlights how an SDC anomaly caused a significant deviation in the gradient norm, a measure of the magnitude of updates to the model parameters. Such deviations can disrupt the optimization process, leading to slower convergence or failure to reach an optimal solution.

![**Gradient Norm Deviation**: Transient hardware faults, such as single data corruption (SDC), disrupt optimization by causing abrupt changes in gradient norms during model training, potentially leading to convergence issues or inaccurate models. Real-world data from Google’s production fleet confirms that SDC anomalies manifest as visible spikes in gradient norm over time, indicating a disruption to the expected parameter update process. Source: jeff dean, mlsys 2024 keynote (Google).](./images/jpg/google_sdc_jeff_dean_anomaly.jpg){#fig-sdc-training-fault}

During the inference phase, transient faults can impact the reliability and trustworthiness of ML predictions. If a transient fault occurs in the memory storing the trained model parameters or during the computation of inference results, it can lead to incorrect or inconsistent predictions. For instance, a bit flip in the activation values of a neural network can alter the final classification or regression output [@mahmoud2020pytorchfi]. In safety-critical applications[^fn-safety-critical], these faults can have severe consequences, resulting in incorrect decisions or actions that may compromise safety or lead to system failures [@li2017understanding; @jha2019ml].

These vulnerabilities are particularly amplified in resource-constrained environments like TinyML, where limited computational and memory resources exacerbate their impact. One prominent example is Binarized Neural Networks (BNNs) [@courbariaux2016binarized], which represent network weights in single-bit precision to achieve computational efficiency and faster inference times. While this binary representation is advantageous for resource-constrained systems, it also makes BNNs particularly fragile to bit-flip errors. For instance, prior work [@Aygun2021BSBNN] has shown that a two-hidden-layer BNN architecture for a simple task such as MNIST classification suffers performance degradation from 98% test accuracy to 70% when random bit-flipping soft errors are inserted through model weights with a 10% probability. To address these vulnerabilities, techniques like flip-aware training and emerging approaches such as [stochastic computing](https://en.wikipedia.org/wiki/Stochastic_computing)[^fn-stochastic-computing] are being explored to enhance fault tolerance.

[^fn-stochastic-computing]: **Stochastic Computing**: A collection of techniques using random bits and logic operations to perform arithmetic and data processing, promising better fault tolerance.

### Permanent Faults {#sec-robust-ai-permanent-faults-7dfb}

Transitioning from temporary disruptions to persistent issues, permanent faults are hardware defects that persist and cause irreversible damage to the affected components. These faults are characterized by their persistent nature and require repair or replacement of the faulty hardware to restore normal system functionality.

#### Permanent Fault Properties {#sec-robust-ai-permanent-fault-properties-08c5}

Permanent faults cause persistent and irreversible malfunctions in hardware components. The faulty component remains non-operational until it is repaired or replaced. These faults are consistent and reproducible, meaning the faulty behavior is observed every time the affected component is used. They can impact processors, memory modules, storage devices, or interconnects, potentially leading to system crashes, data corruption, or complete system failure.

To illustrate the serious implications of permanent faults, a notable example is the [Intel FDIV bug](https://en.wikipedia.org/wiki/Pentium_FDIV_bug), discovered in 1994. This flaw affected the floating-point division (FDIV) units of certain Intel Pentium processors, causing incorrect results for specific division operations and leading to inaccurate calculations.

The FDIV bug occurred due to an error in the lookup table[^fn-lookup-table] used by the division unit. In rare cases, the processor would fetch an incorrect value, resulting in a slightly less precise result than expected. For instance, @fig-permanent-fault shows a fraction 4195835/3145727 plotted on a Pentium processor with the FDIV fault. The triangular regions highlight where erroneous calculations occurred. Ideally, all correct values would round to 1.3338, but the faulty results showed 1.3337, indicating a mistake in the 5th digit.

[^fn-lookup-table]: **Lookup Table**: A data structure used to replace a runtime computation with a simpler array indexing operation.

Although the error was small, it could compound across many operations, affecting results in precision-critical applications such as scientific simulations, financial calculations, and computer-aided design. The bug ultimately led to incorrect outcomes in these domains and underscored the severe consequences permanent faults can have.

![**FDIV Error Regions**: The triangular areas indicate where the pentium processor’s faulty division unit produced incorrect results when calculating 4195835/3145727; ideally, all values should round to 1.3338, but the bug caused a slight inaccuracy in the fifth digit. Source: byte magazine.](./images/png/permanent_fault.png){#fig-permanent-fault width=70%}

The FDIV bug serves as a cautionary tale for ML systems. In such systems, permanent faults in hardware components can result in incorrect computations, impacting model accuracy and reliability. For example, if an ML system relies on a processor with a faulty floating-point unit, similar to the FDIV bug, it could introduce persistent errors during training or inference. These errors may propagate through the model, leading to inaccurate predictions or skewed learning outcomes.

This is especially critical in safety-sensitive applications[^fn-safety-critical] explored in @sec-ai-good, where the consequences of incorrect computations can be severe. ML practitioners must be aware of these risks and incorporate fault-tolerant techniques, including hardware redundancy, error detection and correction, and robust algorithm design, to mitigate them. Thorough hardware validation and testing can help identify and resolve permanent faults before they affect system performance and reliability.

#### Permanent Fault Origins {#sec-robust-ai-permanent-fault-origins-187d}

Permanent faults can arise from two primary sources: manufacturing defects and wear-out mechanisms.

The first category, [Manufacturing defects](https://www.sciencedirect.com/science/article/pii/B9780128181058000206), comprises flaws introduced during the fabrication process, including improper etching, incorrect doping, or contamination. These defects may result in non-functional or partially functional components. In contrast, [wear-out mechanisms](https://semiengineering.com/what-causes-semiconductor-aging/) occur over time due to prolonged use and operational stress. Phenomena like electromigration[^fn-electromigration], oxide breakdown[^fn-oxide-breakdown], and thermal stress[^fn-thermal-stress] degrade component integrity, eventually leading to permanent failure.

[^fn-electromigration]: **Electromigration**: The movement of metal atoms in a conductor under the influence of an electric field.

[^fn-oxide-breakdown]: **Oxide Breakdown**: The failure of an oxide layer in a transistor due to excessive electric field stress.

[^fn-thermal-stress]: **Thermal Stress**: Degradation caused by repeated cycling through high and low temperatures. Modern AI accelerators commonly experience thermal throttling under sustained workloads, leading to performance degradation of 20-60% as processors reduce clock speeds to prevent overheating. This throttling directly impacts ML training times and inference throughput, making thermal management critical for maintaining consistent AI system performance in production environments.

#### Permanent Fault Propagation {#sec-robust-ai-permanent-fault-propagation-b770}

Permanent faults manifest through several mechanisms, depending on their nature and location. A common example is the stuck-at fault [@seong2010safer], where a signal or memory cell becomes permanently fixed at either 0 or 1, regardless of the intended input, as shown in @fig-stuck-fault. This type of fault can occur in logic gates, memory cells, or interconnects and typically results in incorrect computations or persistent data corruption.

::: {#fig-stuck-fault fig-env="figure" fig-pos="htb"}
```{.tikz}
\begin{tikzpicture}[line join=round,font=\usefont{T1}{phv}{m}{n}\small]
\useasboundingbox(-2,2.5) rectangle (15.7,-4.7);
\tikzset{%
helvetica/.style={align=flush center,font=\small\usefont{T1}{phv}{m}{n}},
Line/.style={line width=1.0pt,black!50,text=black},
DLine/.style={draw=OrangeLine!40, line width=1mm, -{Triangle[length=3mm, bend]},
shorten >=1.1mm, shorten <=1.15mm},
}
\colorlet{VioletL}{GreenL!60}
\begin{scope}[scale=1.75, every node/.append style={transform shape},
local bounding box=D1,shift={(0,0)}]
\def\di{D1}
\draw[line width=1pt,fill=VioletL](0,0)--(0,0.76)to[out=357,in=3,distance=25]cycle;
\fill[draw=black,fill=white,line width=1.5pt](0.72,0.38)circle(2pt);
\coordinate(G\di)at(0,0.58);
\coordinate(D\di)at(0,0.18);
\coordinate(IZ\di)at(0.8,0.38);
\end{scope}
\begin{scope}[scale=1.75, every node/.append style={transform shape},
local bounding box=D2,shift={(0,-2)}]
\def\di{D2}
\draw[line width=1pt,fill=VioletL](0,0)--(0,0.76)to[out=357,in=3,distance=25](0,0);
\fill[draw=black,fill=white,line width=1.5pt](0.72,0.38)circle(2pt);
\coordinate(G\di)at(0,0.58);
\coordinate(D\di)at(0,0.18);
\coordinate(IZ\di)at(0.8,0.38);
\end{scope}

\begin{scope}[scale=1.75, every node/.append style={transform shape},
local bounding box=D3,shift={(4,-1)}]
\def\di{D3}
\draw[line width=1pt,fill=VioletL](0,0)--(0,0.76)to[out=357,in=3,distance=25](0,0);
\fill[draw=black,fill=white,line width=1.5pt](0.72,0.38)circle(2pt);
\coordinate(G\di)at(0,0.58);
\coordinate(D\di)at(0,0.18);
\coordinate(IZ\di)at(0.8,0.38);
\end{scope}
\begin{scope}[scale=1.75, every node/.append style={transform shape},
local bounding box=D4,shift={(7,-2)}]
\def\di{D4}
\draw[line width=1pt,fill=VioletL](0,0)--(0,0.76)to[out=357,in=3,distance=25](0,0);
\fill[draw=black,fill=white,line width=1.5pt](0.72,0.38)circle(2pt);
\coordinate(G\di)at(0,0.58);
\coordinate(D\di)at(0,0.18);
\coordinate(IZ\di)at(0.8,0.38);
\end{scope}
%lines
\draw[Line](IZD2)--node[above,pos=0.3](IIZD2){SAO \textcolor{black}{SA1}}++(0:3)|-
node[below,pos=0.91](ULDD4){SAO \textcolor{red}{SA1}}(DD4);
\draw[Line](IZD1)--node[above,pos=0.5](IIZD1){SAO \textcolor{red}{SA1}}++(0:2)|-(GD3);
\draw[Line](IZD3)--node[above,pos=0.9](IIZD3){SAO \textcolor{red}{SA1}}++(0:1)|-(GD4);
\draw[Line](DD3)--node[above,pos=0.3](ULDD3){SAO \textcolor{red}{SA1}}++(180:3.6)|-(IZD2);
\draw[Line](GD1)--node[above,pos=0.5](ULGD1){SAO \textcolor{red}{SA1}}++(180:2);
\draw[Line](DD1)--node[above,pos=0.5](ULDD1){SAO \textcolor{red}{SA1}}++(180:2);
\draw[Line](GD2)--node[above,pos=0.5](ULGD2){SAO \textcolor{red}{SA1}}++(180:2);
\draw[Line](DD2)--node[above,pos=0.5](ULDD2){SAO \textcolor{red}{SA1}}++(180:2);
\draw[Line](IZD4)--node[above,pos=0.5](IIZD4){SAO \textcolor{black}{SA1}}++(0:2);
%
\draw[DLine,distance=40](ULGD1)to[out=50,in=120](IIZD1);
\draw[DLine,distance=44](ULDD1)to[out=-50,in=-110](IIZD1);
\draw[DLine,distance=40](ULGD2)to[out=50,in=120](IIZD2);
\draw[DLine,distance=44](ULDD2)to[out=-50,in=-110](IIZD2);
\draw[DLine,distance=50](ULDD3)to[out=-50,in=-120](IIZD3);
\draw[DLine,distance=50](ULDD4)to[out=-50,in=-100](IIZD4);
\draw[DLine,distance=63](IIZD3)to[out=50,in=90](IIZD4);
\draw[DLine,distance=80](IIZD1)to[out=50,in=90](IIZD3);
\end{tikzpicture}
```
**Stuck-at Fault Model**: Digital circuits can experience permanent faults where a signal line becomes fixed at a logical 0 or 1, regardless of input; this figure represents a simplified depiction of a stuck-at-0 fault, where a signal is persistently low, potentially leading to incorrect computations or system failures. *Source: [accendo reliability](HTTPS://accendoreliability.com/digital-circuits-stuck-fault-model/)*
:::

Other mechanisms include device failures, in which hardware components such as transistors or memory cells cease functioning entirely due to manufacturing defects or degradation over time. Bridging faults, which occur when two or more signal lines are unintentionally connected, can introduce short circuits or incorrect logic behaviors that are difficult to isolate.

In more subtle cases, delay faults can arise when the propagation time of a signal exceeds the allowed timing constraints. The logical values may be correct, but the violation of timing expectations can still result in erroneous behavior. Similarly, interconnect faults, including open circuits caused by broken connections, high-resistance paths that impede current flow, and increased capacitance that distorts signal transitions, can significantly degrade circuit performance and reliability.

Memory subsystems are particularly vulnerable to permanent faults. Transition faults can prevent a memory cell from successfully changing its state, while coupling faults result from unwanted interference between adjacent cells, leading to unintentional state changes. Neighborhood pattern sensitive faults occur when the state of a memory cell is incorrectly influenced by the data stored in nearby cells, reflecting a more complex interaction between circuit layout and logic behavior.

Permanent faults can also occur in critical infrastructure components such as the power supply network or clock distribution system. Failures in these subsystems can affect circuit-wide functionality, introduce timing errors, or cause widespread operational instability.

Taken together, these mechanisms illustrate the varied and often complex ways in which permanent faults can undermine the behavior of computing systems. For ML applications in particular, where correctness and consistency are vital, understanding these fault modes is essential for developing resilient hardware and software solutions.

#### Permanent Fault Effects on ML {#sec-robust-ai-permanent-fault-effects-ml-b9fd}

Permanent faults can severely disrupt the behavior and reliability of computing systems. For example, a stuck-at fault in a processor's arithmetic logic unit (ALU) can produce persistent computational errors, leading to incorrect program behavior or crashes. In memory modules, such faults may corrupt stored data, while in storage devices, they can result in bad sectors or total data loss. Interconnect faults may interfere with data transmission, leading to system hangs or corruption.

For ML systems, these faults pose significant risks in both training and inference phases. As with transient faults (Section X.X.X), permanent faults during training cause similar gradient calculation errors and parameter corruption, but persist until hardware replacement, requiring more comprehensive recovery strategies [@he2023understanding]. Unlike transient faults that may only temporarily disrupt training, permanent faults in storage can compromise entire training datasets or saved models, affecting long-term consistency and reliability.

In the inference phase, faults can distort prediction results or lead to runtime failures. For instance, errors in the hardware storing model weights might lead to outdated or corrupted models being used, while processor faults could yield incorrect outputs [@zhang2018analyzing].

Mitigating permanent faults requires comprehensive fault-tolerant design combining hardware redundancy and error-correcting codes [@kim2015bamboo] with software approaches like checkpoint and restart mechanisms[^fn-checkpoint-restart] [@egwutuoha2013survey].

[^fn-checkpoint-restart]: **Checkpoint and Restart Mechanisms**: Techniques that periodically save a program's state so it can resume from the last saved state after a failure.

Regular monitoring, testing, and maintenance help detect and replace failing components before critical errors occur.

### Intermittent Faults {#sec-robust-ai-intermittent-faults-35e9}

Intermittent faults are hardware faults that occur sporadically and unpredictably in a system. An example is illustrated in @fig-intermittent-fault, where cracks in the material can introduce increased resistance in circuitry. These faults are particularly challenging to detect and diagnose because they appear and disappear intermittently, making it difficult to reproduce and isolate the root cause. Depending on their frequency and location, intermittent faults can lead to system instability, data corruption, and performance degradation.

![**Intermittent Fault Mechanism**: Increased resistance from cracks between copper bumps and package solder represents a common source of intermittent faults, disrupting signal transmission and potentially causing unpredictable system behavior. Microscopic material defects like these highlight the vulnerability of hardware to latent failures that are difficult to detect during testing but can manifest during operation. Source: [constantinescu](HTTPS://ieeexplore.ieee.org/document/4925824).](./images/png/intermittent_fault.png){#fig-intermittent-fault width=85%}

#### Intermittent Fault Properties {#sec-robust-ai-intermittent-fault-properties-9373}

Intermittent faults are defined by their sporadic and non-deterministic behavior. They occur irregularly and may manifest for short durations, disappearing without a consistent pattern. Unlike permanent faults, they do not appear every time the affected component is used, which makes them particularly difficult to detect and reproduce. These faults can affect a variety of hardware components, including processors, memory modules, storage devices, and interconnects. As a result, they may lead to transient errors, unpredictable system behavior, or data corruption.

Their impact on system reliability can be significant. For instance, an intermittent fault in a processor’s control logic may disrupt the normal execution path, causing irregular program flow or unexpected system hangs. In memory modules, such faults can alter stored values inconsistently, leading to errors that are difficult to trace. Storage devices affected by intermittent faults may suffer from sporadic read/write errors or data loss, while intermittent faults in communication channels can cause data corruption, packet loss, or unstable connectivity. Over time, these failures can accumulate, degrading system performance and reliability [@rashid2014characterizing].

#### Intermittent Fault Origins {#sec-robust-ai-intermittent-fault-origins-678d}

The causes of intermittent faults are diverse, ranging from physical degradation to environmental influences. One common cause is the aging and wear-out of electronic components. As hardware endures prolonged operation, thermal cycling, and mechanical stress, it may develop cracks, fractures, or fatigue that introduce intermittent faults. For instance, solder joints in ball grid arrays (BGAs) or flip-chip packages can degrade over time, leading to intermittent open circuits or short circuits.

Manufacturing defects and process variations can also introduce marginal components that behave reliably under most circumstances but fail intermittently under stress or extreme conditions. For example, @fig-intermittent-fault-dram shows a residue-induced intermittent fault in a DRAM chip that leads to sporadic failures.

![**DRAM Residue Fault**: Intermittent failures in DRAM chips commonly arise from microscopic residue accumulation, creating unreliable electrical connections. Physical defects can induce sporadic errors, highlighting the need for fault-tolerant system design and hardware testing via this figure. *Source: [hynix semiconductor](HTTPS://ieeexplore.ieee.org/document/4925824)*](./images/png/intermittent_fault_dram.png){#fig-intermittent-fault-dram width=70%}

Environmental factors such as thermal cycling, humidity, mechanical vibrations, or electrostatic discharge can exacerbate these weaknesses and trigger faults that would not otherwise appear. Loose or degrading physical connections, including those found in connectors or printed circuit boards, are also common sources of intermittent failures, particularly in systems exposed to movement or temperature variation.

#### Intermittent Fault Propagation {#sec-robust-ai-intermittent-fault-propagation-f85c}

Intermittent faults can manifest through various physical and logical mechanisms depending on their root causes. One such mechanism is the intermittent open or short circuit, where physical discontinuities or partial connections cause signal paths to behave unpredictably. These faults may momentarily disrupt signal integrity, leading to glitches or unexpected logic transitions.

Another common mechanism is the intermittent delay fault [@zhang2018thundervolt], where signal propagation times fluctuate due to marginal timing conditions, resulting in synchronization issues and incorrect computations. In memory cells or registers, intermittent faults can appear as transient bit flips or soft errors, corrupting data in ways that are difficult to detect or reproduce. Because these faults are often condition-dependent, they may only emerge under specific thermal, voltage, or workload conditions, adding further complexity to their diagnosis.

#### Intermittent Fault Effects on ML {#sec-robust-ai-intermittent-fault-effects-ml-28e7}

Intermittent faults pose significant challenges for ML systems by undermining computational consistency and model reliability. During the training phase, such faults in processing units or memory can cause sporadic errors in the computation of gradients, weight updates, or loss values. These errors may not be persistent but can accumulate across iterations, degrading convergence and leading to unstable or suboptimal models. Intermittent faults in storage may corrupt input data or saved model checkpoints, further affecting the training pipeline [@he2023understanding].

In the inference phase, intermittent faults may result in inconsistent or erroneous predictions. Processing errors or memory corruption can distort activations, outputs, or intermediate representations of the model, particularly when faults affect model parameters or input data. Intermittent faults in data pipelines, such as unreliable sensors or storage systems, can introduce subtle input errors that degrade model robustness and output accuracy. In high-stakes applications like autonomous driving or medical diagnosis, these inconsistencies can result in dangerous decisions or failed operations.

Mitigating the effects of intermittent faults in ML systems requires a multi-layered approach [@rashid2012intermittent]. At the hardware level, robust design practices, environmental controls, and the use of higher-quality or more reliable components can reduce susceptibility to fault conditions. Redundancy and error detection mechanisms can help identify and recover from transient manifestations of intermittent faults.

At the software level, techniques such as runtime monitoring, anomaly detection, and adaptive control strategies can provide resilience, integrating with the framework capabilities detailed in @sec-ai-frameworks and deployment strategies from @sec-ml-operations. Data validation checks, outlier detection, model ensembling, and runtime model adaptation are examples of fault-tolerant methods that can be integrated into ML pipelines to improve reliability in the presence of sporadic errors.

Designing ML systems that can gracefully handle intermittent faults maintains their accuracy, consistency, and dependability. This involves proactive fault detection, regular system monitoring, and ongoing maintenance to ensure early identification and remediation of issues. By embedding resilience into both the architecture and operational workflow detailed in @sec-ml-operations, ML systems can remain robust even in environments prone to sporadic hardware failures.

Effective fault tolerance extends beyond detection to encompass adaptive performance management under varying system conditions. Comprehensive resource management strategies, including load balancing and dynamic scaling under fault conditions, are covered in @sec-ml-operations. For resource-constrained scenarios, adaptive model complexity reduction techniques, such as dynamic quantization and selective pruning in response to thermal or power constraints, are detailed in @sec-model-optimizations and @sec-efficient-ai.

### Hardware Fault Detection and Mitigation {#sec-robust-ai-hardware-fault-detection-mitigation-8f7f}

Fault detection techniques, including hardware-level and software-level approaches, and effective mitigation strategies enhance the resilience of ML systems. Resilient ML system design considerations, case studies, and research in fault-tolerant ML systems provide insights into building robust systems.

Robust fault mitigation requires coordinated adaptation across the entire ML system stack. While the focus here is on fault detection and basic recovery mechanisms, comprehensive performance adaptation strategies are implemented through dynamic resource management (@sec-ml-operations), fault-tolerant distributed training approaches (@sec-ai-training), and adaptive model optimization techniques that maintain performance under resource constraints (@sec-model-optimizations, @sec-efficient-ai). These adaptation strategies ensure that ML systems not only detect and recover from faults but also maintain optimal performance through intelligent resource allocation and model complexity adjustment. The future paradigms for more robust architectures that address fundamental vulnerabilities are explored in @sec-agi-systems.

#### Hardware Fault Detection Methods {#sec-robust-ai-hardware-fault-detection-methods-ea71}

Fault detection techniques identify and localize hardware faults in ML systems, building on the performance measurement principles from @sec-benchmarking-ai. These techniques can be broadly categorized into hardware-level and software-level approaches, each offering unique capabilities and advantages.

##### Hardware-Level Detection {#sec-robust-ai-hardwarelevel-detection-9a56}

Hardware-level fault detection techniques are implemented at the physical level of the system and aim to identify faults in the underlying hardware components. Several hardware techniques exist, which can be categorized into the following groups.

###### Built-in self-test (BIST) Mechanisms {#sec-robust-ai-builtin-selftest-bist-mechanisms-ee55}

BIST is a powerful technique for detecting faults in hardware components [@bushnell2002built]. It involves incorporating additional hardware circuitry into the system for self-testing and fault detection. BIST can be applied to various components, such as processors, memory modules, or application-specific integrated circuits (ASICs). For example, BIST can be implemented in a processor using scan chains[^fn-scan-chains], which are dedicated paths that allow access to internal registers and logic for testing purposes.

[^fn-scan-chains]: **Scan Chains**: Dedicated paths incorporated within a processor that grant access to internal registers and logic for testing.

During the BIST process, predefined test patterns are applied to the processor's internal circuitry, and the responses are compared against expected values. Any discrepancies indicate the presence of faults. Intel's Xeon processors, for instance, include BIST mechanisms to test the CPU cores, cache memory, and other critical components during system startup.

::: {#fig-parity fig-env="figure" fig-pos="htb"}
```{.tikz}
\scalebox{0.8}{%
\begin{tikzpicture}[line join=round,font=\usefont{T1}{phv}{m}{n}\large]
\tikzset{%
helvetica/.style={align=flush center,font=\small\usefont{T1}{phv}{m}{n}},
cell/.style={draw=none,line width=0.5pt, minimum width=8,inner xsep=0pt,
    align=center,node distance=0,minimum height=22}
}
\definecolor{bluegraph}{RGB}{0,102,204}
\begin{scope}[local bounding box=M1,shift={(0,0)}]
\def\ma{M1}
\node[cell](B1\ma){0};
\node[cell,right=of B1\ma](B2\ma){1};
\node[cell,right=of B2\ma](B3\ma){0};
\node[cell,right=of B3\ma](B4\ma){0};
\node[cell,right=of B4\ma](B5\ma){0};
\node[cell,right=of B5\ma](B6\ma){1};
\node[cell,right=of B6\ma](B7\ma){0};
\end{scope}
\begin{scope}[local bounding box=M2,shift={(2.6,0)}]
\def\ma{M2}
\node[cell](B1\ma){0};
\node[cell,right=of B1\ma](B2\ma){1};
\node[cell,right=of B2\ma](B3\ma){0};
\node[cell,right=of B3\ma](B4\ma){0};
\node[cell,right=of B4\ma](B5\ma){0};
\node[cell,right=of B5\ma](B6\ma){1};
\node[cell,right=of B6\ma](B7\ma){0};
\node[cell,right=of B7\ma,fill=red](B8\ma){\textcolor{white}{0}};
\end{scope}
\begin{scope}[local bounding box=M3,shift={(5.5,0)}]
\def\ma{M3}
\node[cell](B1\ma){0};
\node[cell,right=of B1\ma](B2\ma){1};
\node[cell,right=of B2\ma](B3\ma){0};
\node[cell,right=of B3\ma](B4\ma){0};
\node[cell,right=of B4\ma](B5\ma){0};
\node[cell,right=of B5\ma](B6\ma){1};
\node[cell,right=of B6\ma](B7\ma){0};
\node[cell,right=of B7\ma,fill=red](B8\ma){\textcolor{white}{1}};
\end{scope}
%%%below
\begin{scope}[local bounding box=M4,shift={(0,-1)}]
\def\ma{M4}
\node[cell](B1\ma){1};
\node[cell,right=of B1\ma](B2\ma){0};
\node[cell,right=of B2\ma](B3\ma){0};
\node[cell,right=of B3\ma](B4\ma){0};
\node[cell,right=of B4\ma](B5\ma){0};
\node[cell,right=of B5\ma](B6\ma){0};
\node[cell,right=of B6\ma](B7\ma){0};
\end{scope}
\begin{scope}[local bounding box=M5,shift={(2.6,-1)}]
\def\ma{M5}
\node[cell](B1\ma){1};
\node[cell,right=of B1\ma](B2\ma){0};
\node[cell,right=of B2\ma](B3\ma){0};
\node[cell,right=of B3\ma](B4\ma){0};
\node[cell,right=of B4\ma](B5\ma){0};
\node[cell,right=of B5\ma](B6\ma){0};
\node[cell,right=of B6\ma](B7\ma){0};
\node[cell,right=of B7\ma,fill=red](B8\ma){\textcolor{white}{1}};
\end{scope}
\begin{scope}[local bounding box=M6,shift={(5.5,-1)}]
\def\ma{M6}
\node[cell](B1\ma){1};
\node[cell,right=of B1\ma](B2\ma){0};
\node[cell,right=of B2\ma](B3\ma){0};
\node[cell,right=of B3\ma](B4\ma){0};
\node[cell,right=of B4\ma](B5\ma){0};
\node[cell,right=of B5\ma](B6\ma){1};
\node[cell,right=of B6\ma](B7\ma){0};
\node[cell,right=of B7\ma,fill=red](B8\ma){\textcolor{white}{0}};
\end{scope}
\node[above=0.5 of $(B1M1)!0.5!(B7M1)$,align=center,text depth=0.7,
font=\usefont{T1}{phv}{m}{n}\small](SS){sequence of\\ seven bits};
\node[above=0.5 of $(B1M2)!0.5!(B8M2)$,align=center,text depth=0.7,
font=\usefont{T1}{phv}{m}{n}\small](WE){with eighth\\ even parity bit};
\node[above=0.5 of $(B1M3)!0.5!(B8M3)$,align=center,text depth=0.7,
font=\usefont{T1}{phv}{m}{n}\small](WO){with eighth\\ odd parity bit};
\node[above=0.6 of $(SS)!0.5!(WO)$,align=center,text depth=0.7,
font=\usefont{T1}{phv}{m}{n}\small,bluegraph](PBE){Parity bit examples};
%
\draw[thick,shorten >=-15,shorten <=-15]($(B1M1)!0.5!(B1M4)$)coordinate(X0)--
($(B8M3)!0.5!(B8M6)$)coordinate(X1);
\draw[thick,shorten >=-15,shorten <=-15]([yshift=2pt]B1M1.north west)--
([yshift=2pt]B8M3.north east);
%
\draw[thick,shorten >=-15,shorten <=-10]($(B7M4)!0.5!(B1M5)$)--++(90:1.8);
\draw[thick,shorten >=-15,shorten <=-10]($(B8M5)!0.5!(B1M6)$)--++(90:1.8);
%fitting
\scoped[on background layer]
\node[draw=BackLine,inner xsep=25,inner ysep=27,yshift=-8mm,
           fill=BackColor!20,fit=(PBE)(X0)(X1),line width=0.75pt](BB1){};
\node[above=2pt of  BB1.south east,anchor=south east,
            font=\usefont{T1}{phv}{m}{n}\footnotesize,black!30]{ComputerHope.com};
%
\end{tikzpicture}}
```
**Parity Bit Error Detection**: This figure provides a simple error detection scheme where an extra bit (the parity bit) ensures the total number of 1s in a data sequence is either even or odd. The second sequence includes a flipped bit, triggering the parity check and indicating a data corruption event during transmission or storage. Source: computer hope.
:::

###### Error Detection Codes {#sec-robust-ai-error-detection-codes-2774}

Error detection codes are widely used to detect data storage and transmission errors [@hamming1950error][^fn-hamming1950error]. These codes add redundant bits to the original data, allowing the detection of bit errors. Example: Parity checks are a simple form of error detection code shown in @fig-parity[^fn-parity]. In a single-bit parity scheme, an extra bit is appended to each data word, making the number of 1s in the word even (even parity) or odd (odd parity).

[^fn-hamming1950error]: **Hamming (1950)**: R. W. Hamming's seminal paper introduced error detection and correction codes, significantly advancing digital communication reliability.

[^fn-parity]: **Parity Checks**: In parity checks, an extra bit accounts for the total number of 1s in a data word, enabling basic error detection.

When reading the data, the parity is checked, and if it doesn't match the expected value, an error is detected. More advanced error detection codes, such as cyclic redundancy checks (CRC)[^fn-crc], calculate a checksum based on the data and append it to the message.

[^fn-crc]: **Cyclic Redundancy Check (CRC)**: Error detection algorithm developed by W. Wesley Peterson in 1961, widely used in digital communications and storage. CRC computes a polynomial checksum that can detect up to 99.9% of transmission errors with minimal computational overhead. Essential for ML data pipelines where corrupted training data can silently degrade model performance - modern distributed training systems use CRC-32 to validate gradient updates across thousands of nodes. The checksum is recalculated at the receiving end and compared with the transmitted checksum to detect errors. Error-correcting code (ECC) memory modules, commonly used in servers and critical systems, employ advanced error detection and correction codes to detect and correct single-bit or multi-bit errors in memory.

###### Hardware redundancy and voting mechanisms {#sec-robust-ai-hardware-redundancy-voting-mechanisms-b837}

Hardware redundancy involves duplicating critical components and comparing their outputs to detect and mask faults [@sheaffer2007hardware]. Voting mechanisms, such as double modular redundancy (DMR)[^fn-dmr] or triple modular redundancy (TMR)[^fn-tmr], employ multiple instances of a component and compare their outputs to identify and mask faulty behavior [@arifeen2020approximate].

[^fn-dmr]: **Double Modular Redundancy (DMR)**: A fault-tolerance process in which computations are duplicated to identify and correct errors.

[^fn-tmr]: **Triple Modular Redundancy (TMR)**: A fault-tolerance process where three instances of a computation are performed to identify and correct errors.

In a DMR or TMR system, two or three identical instances of a hardware component, such as a processor or a sensor, perform the same computation in parallel. The outputs of these instances are fed into a voting circuit, which compares the results and selects the majority value as the final output. If one of the instances produces an incorrect result due to a fault, the voting mechanism masks the error and maintains the correct output. TMR is commonly used in aerospace and aviation systems, where high reliability is critical. For instance, the Boeing 777 aircraft employs TMR in its primary flight computer system to ensure the availability and correctness of flight control functions [@yeh1996triple].

Tesla's self-driving computers, on the other hand, employ a DMR architecture to ensure the safety and reliability of critical functions such as perception, decision-making, and vehicle control, as shown in @fig-tesla-dmr. In Tesla's implementation, two identical hardware units, often called "redundant computers" or "redundant control units," perform the same computations in parallel. Each unit independently processes sensor data, executes algorithms, and generates control commands for the vehicle's actuators, such as steering, acceleration, and braking [@bannon2019computer].

![**Dual Modular Redundancy**: Tesla’s full self-driving computer employs a DMR architecture, replicating critical computations across two independent system-on-chips (socs) to mitigate hardware faults and ensure continuous operation. This redundancy enables the system to mask errors: if one soc fails, the other continues functioning, maintaining safety-critical functions like perception and control. *Source: [Tesla](HTTPS://old.hotchips.org/hc31/HC31_2.3_tesla_hotchips_ppt_final_0817.PDF)*](./images/png/tesla_dmr.png){#fig-tesla-dmr}

The outputs of these two redundant units are continuously compared to detect any discrepancies or faults. If the outputs match, the system assumes that both units function correctly, and the control commands are sent to the vehicle's actuators. However, if a mismatch occurs between the outputs, the system identifies a potential fault in one of the units and takes appropriate action to ensure safe operation.

DMR in Tesla's self-driving computer provides an extra safety and fault tolerance layer. By having two independent units performing the same computations, the system can detect and mitigate faults that may occur in one of the units. This redundancy helps prevent single points of failure and ensures that critical functions remain operational despite hardware faults.

The system may employ additional mechanisms to determine which unit is faulty in a mismatch. This can involve using diagnostic algorithms, comparing the outputs with data from other sensors or subsystems, or analyzing the consistency of the outputs over time. Once the faulty unit is identified, the system can isolate it and continue operating using the output from the non-faulty unit.

Tesla also incorporates redundancy mechanisms beyond DMR. For example, they use redundant power supplies, steering and braking systems, and diverse sensor suites[^fn-sensor-fusion] (e.g., cameras, radar, and ultrasonic sensors) to provide multiple layers of fault tolerance.

[^fn-sensor-fusion]: **Sensor Fusion**: Integration of data from multiple sensor types to create more accurate and reliable perception than any single sensor. Pioneered in military applications in the 1980s, sensor fusion combines cameras (visual spectrum), LiDAR (depth/distance), radar (weather-resistant), and ultrasonic (short-range) sensors. Tesla's approach processes 8 cameras, 12 ultrasonic sensors, and forward radar simultaneously, generating 40&nbsp;GB of sensor data per hour to enable robust autonomous decision-making. These redundancies collectively contribute to the overall safety and reliability of the self-driving system.

While DMR provides fault detection and some level of fault tolerance, TMR may provide a different level of fault masking. In DMR, if both units experience simultaneous faults or the fault affects the comparison mechanism, the system may be unable to identify the fault. Therefore, Tesla's SDCs rely on a combination of DMR and other redundancy mechanisms to achieve a high level of fault tolerance.

The use of DMR in Tesla's self-driving computer highlights the importance of hardware redundancy in applications requiring high reliability. By employing redundant computing units and comparing their outputs, the system can detect and mitigate faults, enhancing the overall safety and reliability of the self-driving functionality.

Another approach to hardware redundancy is the use of hot spares[^fn-hot-spares], as employed by Google in its data centers to address SDC during ML training. Unlike DMR and TMR, which rely on parallel processing and voting mechanisms to detect and mask faults, hot spares provide fault tolerance by maintaining backup hardware units that can seamlessly take over computations when a fault is detected. As illustrated in @fig-sdc-controller, during normal ML training, multiple synchronous training workers process data in parallel. However, if a worker becomes defective and causes SDC, an SDC checker automatically identifies the issues. Upon detecting the SDC, the SDC checker moves the training to a hot spare and sends the defective machine for repair. This redundancy safeguards the continuity and reliability of ML training, effectively minimizing downtime and preserving data integrity.

[^fn-hot-spares]: **Hot Spares**: In a system redundancy design, these are the backup components kept ready to instantaneously replace failing components without disrupting the operation.

::: {#fig-sdc-controller fig-env="figure" fig-pos="htb"}
```{.tikz}
\begin{tikzpicture}[line width=0.75pt,font=\small\usefont{T1}{phv}{m}{n}]
\definecolor{Green}{RGB}{84,180,53}
\definecolor{Red}{RGB}{249,56,39}
\definecolor{Blue}{RGB}{0,97,168}
\definecolor{Siva}{RGB}{161,152,130}
%
\tikzset{%
helvetica/.style={align=flush center,font=\small\usefont{T1}{phv}{m}{n}},
 Line/.style={line width=2.0pt,black!50,rounded corners=7,-latex},
main/.style={circle, minimum size=5mm, line width=0.7mm,draw=red,keep name},
keep name/.style={prefix after command={\pgfextra{\let\fixname\tikzlastnode}}},
    red box/.style={
      append after command={
        node [rotate=-50,
          fit=(\fixname) ,
          fill=red,
          text width=1.3mm,
          inner sep=-\pgflinewidth,
          rectangle
        ] {}
      }
    }
}
\tikzset{
  Box/.style={helvetica,
    inner xsep=2pt,
    node distance=0.7,
    draw=Green,
    rounded corners,
    fill=Green,
    minimum width=11mm, minimum height=6mm
  },
 Text/.style={%
    inner sep=2pt,
    draw=none,
    line width=0.75pt,
    fill=TextColor,
    helvetica,
    align=flush center,
    minimum width=10mm, minimum height=6mm
  },
}
\begin{scope}[local bounding box=M1,shift={(0,0)}]
\foreach \x in {1,2,3}{
    \foreach \y in {1,2,3}{
    \def\br{M1}
        \node[Box](R\y\x\br) at (1.3*\x,-0.8*\y) {};
    }
}
\node[Box,draw=Blue,fill=Blue]at(R32M1){};
\node[Box,draw=Siva,fill=Siva]at(R33M1){};
\node[below=0.2 of R32M1]{Normal training state};
\end{scope}

\begin{scope}[local bounding box=M1,shift={(4.5,0)}]
\foreach \x in {1,2,3}{
    \foreach \y in {1,2,3}{
    \def\br{M2}
        \node[Box](R\y\x\br) at (1.3*\x,-0.8*\y) {};
    }
}
\node[Box,draw=Blue,fill=Blue]at(R32M2){};
\node[Box,draw=Siva,fill=Siva]at(R33M2){};
\node[below=0.2 of R32M2,align=center,
            red](DM){Defective machine\\ causes SDC};
\node [main,red box] (c) at (R23M2){};
\draw[Line,red](R23M2)--++(0:1)|-(DM);
\end{scope}

\begin{scope}[local bounding box=M1,shift={(9.0,0)}]
\foreach \x in {1,2,3}{
    \foreach \y in {1,2,3}{
    \def\br{M3}
        \node[Box](R\y\x\br) at (1.3*\x,-0.8*\y) {};
    }
}
\node[Box,draw=Blue,fill=Blue]at(R32M3){};
\node[Box,draw=Blue,fill=none,line width=2pt]at(R23M3){};
\node[Box,draw=Siva,fill=Siva]at(R33M3){};
\node[below=0.2 of R32M3,align=center,
            Blue](SD){SDC checker\\ automatically\\ identifies SDC};
\node [main,red box] (c) at (R23M3){};
\draw[Line,Blue](R23M3)--++(0:1)|-(SD);
\end{scope}

\begin{scope}[local bounding box=M1,shift={(13.5,0)}]
\foreach \x in {1,2,3}{
    \foreach \y in {1,2,3}{
    \def\br{M4}
        \node[Box](R\y\x\br) at (1.3*\x,-0.8*\y) {};
    }
}
\node[Box,draw=Blue,fill=Blue]at(R32M4){};
\node[Box,draw=red,fill=white,line width=2pt]at(R23M4){};
\node[Box,draw=Blue,fill=Green,line width=2pt]at(R33M4){};
\node[below=0.2 of R32M4,align=center,
            Blue](SD1){SDC checker moves\\ training to hot spare\\
            and sends defective\\ machine for repair};
\node [main,red box] (c) at (R23M4){};
\draw[Line,Blue](R33M4)--++(0:1)|-(SD1);
\end{scope}

\begin{scope}[local bounding box=LE,shift={(3.5,0.4)}]
\node[Box,draw=Green,fill=Green](ZE){};
\node[right=2pt of ZE,font=\small\usefont{T1}{phv}{m}{n}
             \footnotesize](L1){Synchronous Training Worker};
\node[Box,draw=Blue,fill=Blue,right=of L1](PL){};
\node[right=2pt of PL,font=\small\usefont{T1}{phv}{m}{n}
             \footnotesize](L2){SDC checker};
%
\node[Box,draw=Siva,fill=Siva,right=of L2](SI){};
\node[right=2pt of SI,font=\small\usefont{T1}{phv}{m}{n}
             \footnotesize](L3){Hot spare};
\scoped[on background layer]
\node[draw=BackLine,inner xsep=10,inner ysep=6,yshift=0mm,
           fill=BackColor!60,fit=(ZE)(L3),line width=0.75pt](BB1){};
\end{scope}
\end{tikzpicture}
```
**Hot Spare Redundancy**: Google’s data centers utilize hot spare cores to maintain uninterrupted ML training despite hardware failures, seamlessly transitioning workloads from defective machines to backup resources. This approach contrasts with parallel redundancy techniques like DMR/TMR by providing a reactive fault tolerance mechanism that minimizes downtime and preserves data integrity during ML training. Source: jeff dean, mlsys 2024 keynote (Google).
:::

###### Watchdog timers {#sec-robust-ai-watchdog-timers-9e44}

Watchdog timers are hardware components that monitor the execution of critical tasks or processes [@pont2002using]. They are commonly used to detect and recover from software or hardware faults that cause a system to become unresponsive or stuck in an infinite loop. In an embedded system, a watchdog timer can be configured to monitor the execution of the main control loop, as illustrated in @fig-watchdog. The software periodically resets the watchdog timer to indicate that it functions correctly. Suppose the software fails to reset the timer within a specified time limit (timeout period). In that case, the watchdog timer assumes that the system has encountered a fault and triggers a predefined recovery action, such as resetting the system or switching to a backup component. Watchdog timers are widely used in automotive electronics, industrial control systems, and other safety-critical applications to ensure the timely detection and recovery from faults.

::: {#fig-watchdog fig-env="figure" fig-pos="htb"}
```{.tikz}
\begin{tikzpicture}[line join=round,font=\usefont{T1}{phv}{m}{n}\small]
\tikzset{%
LineA/.style={black!50, line width=1.1pt,{-{Triangle[width=0.9*6pt,length=1.2*6pt]}}},
ALine/.style={black!50, line width=1.1pt,{{Triangle[width=0.9*6pt,length=1.2*6pt]}-}},
Line/.style={black!50, line width = 1.1pt},
Larrow/.style={fill=orange, single arrow,  inner sep=2pt, single arrow head extend=3pt,
            single arrow head indent=0pt,minimum height=20mm, minimum width=3pt},
Box/.style={inner xsep=3pt,inner ysep=2pt,
    node distance=1.5,
    draw=RedLine,
    line width=0.75pt,
    fill=RedL!60,
    align=flush center,
    minimum width=26mm,
    minimum height=27mm
  },
Box2/.style={Box,draw=BlueLine,fill=BlueL!99},
Box3/.style={Box,draw=OrangeLine,fill=OrangeL!50,anchor=north west,minimum width=27mm,minimum height=68mm},
}

\tikzset{pics/battery/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[local bounding box=BATTERY,scale=\scalefac, every node/.append style={transform shape}]
\node[draw=\drawcolor,fill=\filllcolor,minimum width=56pt,minimum height=38pt,inner sep=0pt,line width=\Linewidth](BAT\picname){};
\draw[draw=\drawcolor,line width=\Linewidth,fill=black](BAT\picname.135)--++(0,5pt)-|
node[pos=0.25,inner sep=0pt,outer sep=0pt](KAT\picname){}(BAT\picname.115);
\draw[draw=\drawcolor,line width=\Linewidth,fill=black](BAT\picname.45)--++(0,5pt)-|
node[pos=0.25,inner sep=0pt,outer sep=0pt](ANO\picname){}(BAT\picname.65);
\end{scope}
     }
  }
}

%MCU pic style
\tikzset{pics/mcu/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[local bounding box=MCU,scale=\scalefac, every node/.append style={transform shape}]
\draw[draw=\drawcolor,fill=\filllcolor](-1.85,2.21)coordinate(MCUNW\picname)--(1.9,1.9)coordinate(MCUNE\picname)--
(1.9,-1.53)coordinate(MCUSE\picname)--(-1.85,-1.53)coordinate(MCUSW\picname)--cycle;
\fill[black](-0.34,0.71)circle(2.5pt);
\fill[black](-1.23,0.71)circle(2.5pt);
\draw[fill=black] (-1.25,0)to[bend right=95](-0.2,0.05)--cycle;
\end{scope}
     }
  }
}
%WDT pic style
\tikzset{pics/wdt/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[local bounding box=WDT,scale=\scalefac, every node/.append style={transform shape}]
\draw[draw=\drawcolor,fill=\filllcolor](-0.29,1.3)--(-0.08,1.99)--(0.43,1.3)--(0.85,1.9)--(1.1,1.3)--(1.3,1.3)coordinate(WDTNE\picname)--
(1.3,-1.3)coordinate(WDTSE\picname)--(-1.25,-1.3)coordinate(WDTSW\picname)--(-1.25,-1.05)to[out=180,in=270,distance=12](-1.75,-0.6)
to[out=310,in=180](-1.25,-0.85)--(-1.25,1.3)coordinate(WDTNW\picname)--cycle;
\fill[black](0.33,0.3)circle(2.5pt);
\fill[black](0.93,0.3)circle(2.5pt);
\draw[fill=black] (0.68,-0.13) ellipse (7pt and 3pt);
\end{scope}
     }
  }
}
%CONDENSER pic style
\tikzset{pics/condenser/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[local bounding box=CONDENSER,scale=\scalefac, every node/.append style={transform shape}]
\node[fill=white,minimum width=10pt,minimum height=2.5pt,inner sep=0pt](COND\picname){};
\draw[draw=\drawcolor,line width=\Linewidth](COND\picname.north west)--(COND\picname.north east);
\draw[draw=\drawcolor,line width=\Linewidth](COND\picname.south west)--(COND\picname.south east);
\end{scope}
     }
  }
}
 %GROUNDING pic style
\tikzset{pics/grounding/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[local bounding box=,scale=\scalefac, every node/.append style={transform shape}]
\draw[draw=\drawcolor,line width=\Linewidth](-0.25,0)coordinate(LGRO)--coordinate(SGRO\picname)(0.25,0)coordinate(DGRO);
\foreach \i in{0.1,0.3,0.5,0.7,0.9}{
\draw[draw=\drawcolor,line width=0.7pt]($(LGRO)!\i!(DGRO)$)--++(250:5pt);
}
\end{scope}
     }
  }
}
 %RESISTOR pic style
\tikzset{pics/resistor/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[local bounding box=RESISTOR,scale=\scalefac, every node/.append style={transform shape}]
\draw[draw=\drawcolor,line width=\Linewidth](0,0.155)coordinate(GO\picname)--(0.25,0.1)--
(-0.25,-0.02)--(0.25,-0.13)--(-0.25,-0.26)--(0.25,-0.4)--(-0.25,-0.5)--(0.0,-0.56)coordinate(DO\picname);
\end{scope}
     }
  }
}
\pgfkeys{
  /channel/.cd,
  filllcirclecolor/.store in=\filllcirclecolor,
  filllcolor/.store in=\filllcolor,
  drawcolor/.store in=\drawcolor,
  drawcircle/.store in=\drawcircle,
  scalefac/.store in=\scalefac,
  Linewidth/.store in=\Linewidth,
  picname/.store in=\picname,
  filllcolor=BrownLine,
  filllcirclecolor=violet!20,
  drawcolor=black,
  drawcircle=violet,
  scalefac=1,
  Linewidth=0.5pt,
  picname=C
}

%WDT
\pic[shift={(0,0)}] at  (3.0,-1.7){wdt={scalefac=1,picname=1, filllcolor=BlueL!99,drawcolor=BlueLine}};
%MCU
\pic[shift={(0,0)}] at  (8.7,-1.5){mcu={scalefac=1,picname=1, filllcolor=OrangeL!50,drawcolor=OrangeLine}};
\node[below=5pt of $(WDTSW1)!0.5!(WDTSE1)$](WTT1){\textbf{Watchdog Timer}};
\node[below=5pt of $(MCUSW1)!0.5!(MCUSE1)$](MCUT1){\textbf{MCU}};
\node[]at($(WDTNW1)!0.2!(WDTSE1)$)(WDT1){\normalsize\textbf{WDT}};
\node[]at($(MCUNE1)!0.2!(MCUSW1)$)(MCU1){\normalsize\textbf{MCU}};
\path[red]
  let \p1 = ($(WDTNE1)!0.5!(WDTSE1)$),
      \p2 = ($(MCUNW1)!0.2!(MCUSW1)$)
  in
  (\p1) -- coordinate(SR)(\x2,\y1);   % ≡  (M1 -| M2)
\node[Larrow]at(SR){};
\node[above=3pt of SR]{Watches};

%Battery
\pic[shift={(0,0)}] at  (-11.75,-3.89){battery={picname=1, drawcolor=black,filllcolor=white,Linewidth=1.25pt}};
\node[align=center]at(BAT1){12 V\\ Battery};
\draw[Line](ANO1)--++(90:0.6)-|($(BAT1.south east)+(0.6,0)$)coordinate(G0);
\draw[Line](KAT1)--++(90:4.2)--++(2,0)coordinate(LDOS);
\node[Box](LDO)at(LDOS){\normalsize\textbf{LDO}};
\node[Box,below right=-2.1 and 2.83 of LDO](VD){\normalsize\textbf{VD}};
\node[Box2,below left=0.73 and -0.21 of VD](WDT){\normalsize\textbf{WDT}};
\draw[Line](LDO.40)-|coordinate(PT1)(WDT);
\draw[Line](LDO.40)-|coordinate(T2)(VD);
%resistors
\coordinate(T1)at($(LDO.40)!0.55!(PT1)$);
\path[Line](T1)--++(0,-0.2)coordinate(R1);
\pic[shift={(0,-0.35)}] at  (R1){resistor={scalefac=0.8,picname=1, drawcolor=black, Linewidth=1.15pt}};
\pic[shift={(0,-1.82)}] at  (R1){resistor={scalefac=0.8,picname=2, drawcolor=black, Linewidth=1.15pt}};
\draw[Line](T1)--(GO1);
\draw[Line](DO1)--++(0,-0.35)coordinate(T3)|-(T3-|LDO.east);
\draw[Line](T3)--(GO2);
%grounding LDO & VD & WDT
\draw[Line](LDO.south)--++(0,-0.9)coordinate(G1);
\path[red](G1)-|coordinate(G2)(DO2);
\path[red](G1)-|coordinate(G3)(VD);
\path[red](VD.west)--++(-0.5,0)coordinate(G44)|-coordinate(G4)(G1);
%
\draw[Line](DO2)--(G2);
\draw[Line](VD.west)-|(G4);
\draw[Line](VD)--(G3);
%
\path[red](G0)-|coordinate(G5)(WDT);
\path[red](WDT.west)--++(-0.5,0)coordinate(G66)|-coordinate(G6)(G0);
\foreach \i in{0,1,2,3,4,5,6}{
\pic[shift={(0,0)}] at  (G\i){grounding={scalefac=1,picname=1, drawcolor=black, Linewidth=1.25pt}};
}
\draw[Line](WDT.west)-|(G6);
\draw[Line](WDT)--(G5);
%condensers
\pic[shift={(0,0)}] at  ($(G66)!0.5!(G6)$){condenser={scalefac=1,picname=1, drawcolor=black, Linewidth=1.1pt}};
\pic[shift={(0,0)}] at  ($(G44)!0.5!(G4)$){condenser={scalefac=1,picname=1, drawcolor=black, Linewidth=1.1pt}};
%MCU
\path[red](LDO.north east)--++(6,0)coordinate(M1);
\node[Box3](MCU)at(M1){\normalsize\textbf{MCU}};
\draw[LineA](T2)--(T2-|MCU.west);
\draw[LineA](VD)--(VD-|MCU.west);
\draw[LineA](WDT.330)--(WDT.330-|MCU.west);
\draw[ALine](WDT.30)--(WDT.30-|MCU.west);
\draw[ALine](WDT)--(WDT-|MCU.west);
%circles
\foreach \i in{1,2,3}{
\fill[](T\i)circle(2.5pt);
}
%fitting
\scoped[on background layer]
\node[draw=GreenD,inner xsep=5mm,inner ysep=8mm,yshift=3mm,
fill=green!5,fit=(BAT1)(MCU)(MCUSE1),line width=0.5pt](BB2){};
\node[below=5pt of BB2.160,anchor=north west]{\normalsize \textbf{e.g. Circuits peripheral to the MCU and WDT (in an automotive environment)}};
\scoped[on background layer]
\node[draw=black,inner xsep=5mm,inner ysep=15mm,yshift=9.8mm,xshift=-2mm,
fill=white,fit=(WTT1)(MCUNE1),line width=0.5pt](BB1){};
\node[below=10pt of BB1.90,anchor=north,align=center]{\normalsize \textbf{The WDT takes the role of 'watchdog' and}\\
\textbf{watches over MCU operation at all times.}};
\end{tikzpicture}
```
**Watchdog Timer Operation**: Embedded systems utilize watchdog timers to detect and recover from software or hardware faults by periodically resetting a timeout counter; failure to reset within the allotted time triggers a system reset or recovery action, ensuring continued operation. Source: [ablic](https://www.ablic.com/en/semicon/products/automotive/automotive-watchdog-timer/intro/)
:::

##### Software-Level Detection {#sec-robust-ai-softwarelevel-detection-b9b3}

Software-level fault detection techniques rely on software algorithms and monitoring mechanisms to identify system faults. These techniques can be implemented at various levels of the software stack, including the operating system, middleware, or application level.

###### Runtime monitoring and anomaly detection {#sec-robust-ai-runtime-monitoring-anomaly-detection-b39f}

Runtime monitoring involves continuously observing the behavior of the system and its components during execution [@francalanza2017foundation], extending the operational monitoring practices from @sec-ml-operations. It helps detect anomalies, errors, or unexpected behavior that may indicate the presence of faults. For example, consider an ML-based image classification system deployed in a self-driving car. Runtime monitoring can be implemented to track the classification model's performance and behavior [@mahmoud2021issre].

Anomaly detection algorithms can be applied to the model's predictions or intermediate layer activations, such as statistical outlier detection or machine learning-based approaches (e.g., One-Class SVM or Autoencoders) [@chandola2009anomaly]. @fig-ad shows example of anomaly detection. Suppose the monitoring system detects a significant deviation from the expected patterns, such as a sudden drop in classification accuracy or out-of-distribution samples. In that case, it can raise an alert indicating a potential fault in the model or the input data pipeline. This early detection allows for timely intervention and fault mitigation strategies to be applied.

::: {#fig-ad fig-env="figure" fig-pos="htb"}
```{.tikz}
\scalebox{0.8}{%
\begin{tikzpicture}[line width=0.75pt,font=\usefont{T1}{phv}{m}{n}\small]
\definecolor{Red}{RGB}{249,56,39}
\definecolor{Blue}{RGB}{0,97,168}
%
\tikzset{%
helvetica/.style={align=flush center,font=\small\usefont{T1}{phv}{m}{n}},
Line/.style={line width=2.0pt,black!50,rounded corners=7,-latex},
}

\begin{scope}[local bounding box=TL,shift={(0,0)}]
\colorlet{Red}{black!40}
\colorlet{Blue}{black!40}

\foreach \x/\y[count=\n from 1] in{
1.01/0.33,0.36/0.94,0.54/1.42,0.57/2.62,
1.71/2.45,2.51/2.53,2.73/1.90,2.67/1.67,2.25/0.72}{
\fill[Red](\x,\y)circle (2.5pt)coordinate(TC\n);
}
\foreach \x/\y[count=\n from 1] in{%
1.93/0.69,1.51/0.69,1.26/0.94,1.02/1.04,1.28/1.20,
0.93/1.36,0.91/1.68,1.02/1.93,1.32/1.92,1.62/1.86,
1.14/2.21,1.41/2.38,1.69/2.21,2.11/2.21,1.93/1.97,
1.97/1.61,1.43/1.61,1.62/1.37,1.68/1.03,2.11/0.94,
1.97/1.19,2.35/1.12,2.29/1.36,2.49/1.44,2.17/1.74,
2.36/1.86  }{
\fill[Blue](\x,\y)circle (2.5pt)coordinate(TP\n);
}
%fitting
\scoped[on background layer]
\node[draw=VioletLine,inner xsep=19,inner ysep=10,yshift= 0mm,
           fill=VioletL2!20,fit=(TC1)(TC4)(TP24)(TC3),line width=0.75pt](BB1){};
\node[below=4pt of  BB1.south,anchor=north]{System Data};
\end{scope}
\begin{scope}[local bounding box=TD,shift={(7,0)}]
\foreach \x/\y[count=\n from 1] in{
1.01/0.33,0.36/0.94,0.54/1.42,0.57/2.62,
1.71/2.45,2.51/2.53,2.73/1.90,2.67/1.67,2.25/0.72}{
\fill[Red](\x,\y)circle (2.5pt)coordinate(TC\n);
}
\foreach \x/\y[count=\n from 1] in{%
1.93/0.69,1.51/0.69,1.26/0.94,1.02/1.04,1.28/1.20,
0.93/1.36,0.91/1.68,1.02/1.93,1.32/1.92,1.62/1.86,
1.14/2.21,1.41/2.38,1.69/2.21,2.11/2.21,1.93/1.97,
1.97/1.61,1.43/1.61,1.62/1.37,1.68/1.03,2.11/0.94,
1.97/1.19,2.35/1.12,2.29/1.36,2.49/1.44,2.17/1.74,
2.36/1.86  }{
\fill[Blue](\x,\y)circle (2.5pt)coordinate(TP\n);
}
%fitting
\scoped[on background layer]
\node[draw=VioletLine,inner xsep=19,inner ysep=10,yshift= 0mm,
           fill=VioletL2!20,fit=(TC1)(TC4)(TP24)(TC3),line width=0.75pt](BB2){};
\node[below=4pt of  BB2.south,anchor=north]{Anomalies Detected};
\end{scope}
%legend
\begin{scope}[local bounding box=LE,shift={(2.0,3.4)}]
\fill[black!40](0,0)circle (5pt)coordinate(SI);
\node[right=6pt of SI,font=\small\usefont{T1}{phv}{m}{n}
             \footnotesize,text depth=-0.6](L1){Unlabeled Data};
\fill[Blue]($(L1.east)+(0.5,0)$)circle (5pt)coordinate(PL);
\node[right=6pt of PL,font=\small\usefont{T1}{phv}{m}{n}
             \footnotesize,text depth=-0.6](L2){Normal};
\fill[Red]($(L2.east)+(0.5,0)$)circle (5pt)coordinate(PL);
\node[right=6pt of PL,font=\small\usefont{T1}{phv}{m}{n}
             \footnotesize,text depth=-0.6](L3){Anomaly};

\node[single arrow, draw=black,thick, fill=VioletL, inner sep=1pt,
      minimum width = 18pt, single arrow head extend=2pt,
      minimum height=24mm](LS)at($(BB1)!0.5!(BB2)$) {};
\node[below=0.1 of LS,align=center]{Anomaly\\ Detection SVM};
\end{scope}
\end{tikzpicture}}
```
**Anomaly Detection With SVM**: Support vector machines identify deviations from normal system behavior by mapping log data into a high-dimensional space and defining boundaries around expected values, enabling the detection of potential faults. Unsupervised anomaly detection techniques, like the one shown, are particularly valuable when labeled fault data is scarce, allowing systems to learn patterns from unlabeled operational data. Source: [Google](HTTPS://www.Google.com/url?sa=i&url=HTTP%3A%2F%2fresearch.Google%2fblog%2funsupervised-and-semi-supervised-)
:::

###### Consistency checks and data validation {#sec-robust-ai-consistency-checks-data-validation-1d53}

Consistency checks and data validation techniques ensure data integrity and correctness at different processing stages in an ML system [@lindholm2019data]. These checks help detect data corruption, inconsistencies, or errors that may propagate and affect the system's behavior. Example: In a distributed ML system where multiple nodes collaborate to train a model, consistency checks can be implemented to validate the integrity of the shared model parameters. Each node can compute a checksum or hash of the model parameters before and after the training iteration, as shown in @fig-ad. Any inconsistencies or data corruption can be detected by comparing the checksums across nodes. Range checks can be applied to the input data and model outputs to ensure they fall within expected bounds. For instance, if an autonomous vehicle's perception system detects an object with unrealistic dimensions or velocities, it can indicate a fault in the sensor data or the perception algorithms [@wan2023vpp].

###### Heartbeat and timeout mechanisms {#sec-robust-ai-heartbeat-timeout-mechanisms-0d6b}

Heartbeat mechanisms and timeouts are commonly used to detect faults in distributed systems and ensure the liveness and responsiveness of components [@kawazoe1997heartbeat]. These are quite similar to the watchdog timers found in hardware. For example, in a distributed ML system, where multiple nodes collaborate to perform tasks such as data preprocessing, model training, or inference, heartbeat mechanisms can be implemented to monitor the health and availability of each node. Each node periodically sends a heartbeat message to a central coordinator or its peer nodes, indicating its status and availability. Suppose a node fails to send a heartbeat within a specified timeout period, as shown in @fig-heartbeat. In that case, it is considered faulty, and appropriate actions can be taken, such as redistributing the workload or initiating a failover mechanism. Given that network partitions affect 1-10% of nodes daily in large distributed training clusters, these heartbeat systems must distinguish between node failures and network connectivity issues to avoid unnecessary failover operations that could disrupt training progress. Timeouts can also be used to detect and handle hanging or unresponsive components. For example, if a data loading process exceeds a predefined timeout threshold, it may indicate a fault in the data pipeline, and the system can take corrective measures.

::: {#fig-heartbeat fig-env="figure" fig-pos="htb"}
```{.tikz}
\scalebox{0.8}{%
\begin{tikzpicture}[line join=round,font=\usefont{T1}{phv}{m}{n}\footnotesize]
\definecolor{Green}{RGB}{5,130,88}
\tikzset{%
helvetica/.style={align=flush center,font=\small\usefont{T1}{phv}{m}{n}},
Line/.style={line width=1.0pt,black!50,text=black},
DLine/.style={draw=RedLine!30, line width=1mm, -{Triangle[length=3mm, bend]},
shorten >=1.1mm, shorten <=1.15mm},
Box/.style={circle,
    inner xsep=2pt,
    node distance=3.0,
    draw=GreenLine,
    line width=0.75pt,
    font=\usefont{T1}{phv}{m}{n}\small,
    align=flush center,
    fill=GreenL,
    minimum size=19mm
  },
}
\node[Box](B1){Node 1};
\node[Box,right= of B1](B2){Node 2};
\node[Box, right=of B2](B3){Node 3};
\draw[Line,-latex](B1.15)--node[fill=BlueL,sloped,pos=0.3]{Ack}(B2.165);
\draw[Line,-latex](B2.195)--node[fill=OliveL,sloped,pos=0.3]{Ack}(B1.345);
\draw[Line,-latex](B3)--node[fill=VioletL,sloped,pos=0.5]{Ack}(B2);
%
\draw[DLine,distance=35](B2.120)to[out=120,in=60]
             node[fill=BlueL,sloped,pos=0.5]{Heartbeat}(B1.60);
\draw[DLine,distance=35](B1.300)to[out=300,in=240]
             node[fill=OliveL,sloped,pos=0.5]{Heartbeat}(B2.240);
\draw[DLine,distance=35](B2.60)to[out=60,in=120]
             node[fill=VioletL,sloped,pos=0.5]{Heartbeat}(B3.120);
%
\coordinate(L)at($(B1.west)+(0,-2.2)$);
\path[red](L)-|coordinate(D)(B3.east);
\draw[Green,line width=1pt](L)--node[pos=0.9](SR){}(D);
\node[below=2pt of $(L)!0.2!(D)$]{What are Heartbeat Messages?};
%GeeksforGeeks logo
\begin{scope}[scale=0.4, every node/.append style={transform shape},
local bounding box=D1,shift={($(SR)+(0,0.4)$)}]
\fill[white] (-2.2,-1.1) rectangle (0.4,0.3);
\draw[Green,line width=2pt] (0,0) arc[start angle=50, end angle=350, radius=0.5]--++(180:1.03);
\begin{scope}[xscale=-1]
\draw[Green,line width=2pt] (1.8,0) arc[start angle=50, end angle=350, radius=0.5]--++(180:1.03);
\end{scope}
\end{scope}
\end{tikzpicture}}
```
**Heartbeat and Timeout**: Distributed Systems Employ Periodic Heartbeat Messages to Detect Node Failures; A Lack of Response Within a Defined Timeout Indicates a Fault, Triggering Corrective Actions Like Workload Redistribution or Failover. This Mechanism, Analogous to Watchdog Timers, Ensures System Robustness and Continuous Operation Despite Component Failures. Source: [geeksforgeeks](HTTPS://www.geeksforgeeks.org/what-are-heartbeat-messages/).
:::

<!-- @fig-Reed-Solomon Heartbeat messages in distributed systems. Source: [GeeksforGeeks]%(https://www.geeksforgeeks.org/what-are-heartbeat-messages/) -->

###### Software-implemented fault tolerance (SIFT) techniques {#sec-robust-ai-softwareimplemented-fault-tolerance-sift-techniques-92d6}

SIFT techniques introduce redundancy and fault detection mechanisms at the software level to improve the reliability and fault tolerance of the system [@reis2005swift]. Example: N-version programming is a SIFT technique where multiple functionally equivalent software component versions are developed independently by different teams. This can be applied to critical components such as the model inference engine in an ML system. Multiple versions of the inference engine can be executed in parallel, and their outputs can be compared for consistency. It is considered the correct result if most versions produce the same output. A discrepancy indicates a potential fault in one or more versions, triggering appropriate error-handling mechanisms. Another example is using software-based error correction codes, such as Reed-Solomon codes [@plank1997tutorial], to detect and correct errors in data storage or transmission, as shown in @fig-Reed-Solomon. These codes add redundancy to the data, enabling detecting and correcting certain errors and enhancing the system's fault tolerance.

::: {#fig-Reed-Solomon fig-env="figure" fig-pos="htb"}
```{.tikz}
\scalebox{0.85}{%
\begin{tikzpicture}[line join=round,font=\usefont{T1}{phv}{m}{n}\small]
\tikzset{%
  Box/.style={inner sep=0pt, outer sep=0pt,
    draw=VioletLine,
    line width=0.75pt,
    fill=VioletL!40
  },
}
\node [Box,fit={(0,0) (4,0.85)}, label=center:{DATA}](D) {};
\node [Box,fit={(4,0) (8,0.85)}, label=center:{PARITY}](P) {};
\node[below=2pt of D]{K};
\node[below=2pt of P]{2t};
\node[above=4pt of $(P.north)!0.5!(D.north)$]{Representation on \textit{n}-bits solomon codes};
\draw[VioletLine,thick,decoration={brace,amplitude=6pt,mirror},decorate]
             ([yshift=-7mm,xshift=0mm]D.south west)--
              node [midway,below=3mm,text=black] {\textit{n}-bits}([yshift=-7mm,
                          xshift=0mm]P.south east);
\end{tikzpicture}}
```
**Heartbeat Monitoring**: Redundant Node Connections and Periodic Heartbeat Messages Detect and Isolate Failing Components in Distributed Systems, Ensuring Continued Operation Despite Hardware Faults. These Mechanisms Enable Fault Tolerance by Allowing Nodes to Identify Unresponsive Peers and Reroute Communication Accordingly. Source: [geeksforgeeks](HTTPS://www.geeksforgeeks.org/what-is-reed-solomon-code/).
:::

### Hardware Fault Summary {#sec-robust-ai-hardware-fault-summary-b40c}

@tbl-fault_types provides a comparative analysis of transient, permanent, and intermittent faults. It outlines the primary characteristics or dimensions that distinguish these fault types. Here, we summarize the relevant dimensions we examined and explore the nuances that differentiate transient, permanent, and intermittent faults in greater detail.

While hardware faults represent one dimension of system vulnerability, they rarely occur in isolation. The physical failures we have examined often interact with and expose weaknesses in the algorithmic components of AI systems. This interconnection becomes particularly evident when we consider how adversaries might exploit model vulnerabilities through carefully crafted inputs—the focus of our next section on Input-Level Attacks.

+-------------------+------------------------------+------------------------------+---------------------------------------------+
| **Dimension**     | **Transient Faults**         | **Permanent Faults**         | **Intermittent Faults**                     |
+:==================+:=============================+:=============================+:============================================+
| **Duration**      | Short-lived, temporary       | Persistent, remains until    | Sporadic, appears and disappears            |
|                   |                              | repair or replacement        | intermittently                              |
+-------------------+------------------------------+------------------------------+---------------------------------------------+
| **Persistence**   | Disappears after the fault   | Consistently present until   | Recurs irregularly, not always present      |
|                   | condition passes             | addressed                    |                                             |
+-------------------+------------------------------+------------------------------+---------------------------------------------+
| **Causes**        | External factors (e.g.,      | Hardware defects, physical   | Unstable hardware conditions, loose         |
|                   | electromagnetic interference | damage, wear-out             | connections, aging components               |
|                   | cosmic rays)                 |                              |                                             |
+-------------------+------------------------------+------------------------------+---------------------------------------------+
| **Manifestation** | Bit flips, glitches,         | Stuck-at faults, broken      | Occasional bit flips, intermittent signal   |
|                   | temporary data corruption    | components, complete device  | issues, sporadic malfunctions               |
|                   |                              | failures                     |                                             |
+-------------------+------------------------------+------------------------------+---------------------------------------------+
| **Impact on ML**  | Introduces temporary errors  | Causes consistent errors or  | Leads to sporadic and unpredictable errors, |
+-------------------+------------------------------+------------------------------+---------------------------------------------+
| **Systems**       | or noise in computations     | failures, affecting          | challenging to diagnose and mitigate        |
|                   |                              | reliability                  |                                             |
+-------------------+------------------------------+------------------------------+---------------------------------------------+
| **Detection**     | Error detection codes,       | Built-in self-tests, error   | Monitoring for anomalies, analyzing error   |
|                   | comparison with expected     | detection codes, consistency | patterns and correlations                   |
|                   | values                       | checks                       |                                             |
+-------------------+------------------------------+------------------------------+---------------------------------------------+
| **Mitigation**    | Error correction codes,      | Hardware repair or           | Robust design, environmental control,       |
|                   | redundancy, checkpoint and   | replacement, component       | runtime  monitoring, fault-tolerant         |
|                   | restart                      | redundancy, failover         | techniques                                  |
|                   |                              | mechanisms                   |                                             |
+-------------------+------------------------------+------------------------------+---------------------------------------------+

: **Fault Characteristics**: Transient, permanent, and intermittent faults differ by duration, persistence, and recurrence, impacting system reliability and requiring distinct mitigation strategies for robust AI deployments. Understanding these distinctions guides the design of fault-tolerant systems capable of handling diverse hardware failures during operation. {#tbl-fault_types}

## Intentional Input Manipulation {#sec-robust-ai-intentional-input-manipulation-6b2a}

Input-level attacks represent a different threat model from unintentional hardware failures. Unlike random bit flips and component failures, these attacks involve deliberate manipulation of data to compromise system behavior. These sophisticated attempts manipulate ML model behavior through carefully crafted inputs or corrupted training data. These attack vectors can amplify the impact of hardware faults, for instance, when adversaries craft inputs specifically designed to trigger edge cases in fault-compromised hardware.

### Adversarial Attacks {#sec-robust-ai-adversarial-attacks-bb75}

#### Conceptual Foundation {#sec-robust-ai-conceptual-foundation-20b5}

At its core, an adversarial attack is surprisingly simple: add tiny, calculated changes to an input that fool a model while remaining invisible to humans. Imagine adjusting a few pixels in a photo of a cat, changes so subtle you cannot see them, yet the model suddenly classifies it as a toaster with 99% confidence. This counterintuitive vulnerability stems from how neural networks process information differently than humans do.

To understand the underlying mechanism through analogy, consider a person who has learned to identify cats by looking primarily for pointy ears. An adversarial attack is like showing this person a picture of a dog, but carefully drawing tiny, almost invisible pointy ears on top of the dog's floppy ears. Because the person's algorithm is overly reliant on the pointy ear feature, they confidently misclassify the dog as a cat. This is how adversarial attacks work: they find the specific, often superficial, features a model relies on and exploit them, even if the changes are meaningless to a human observer.

ML models learn statistical patterns rather than semantic understanding. They operate in high-dimensional spaces where decision boundaries can be surprisingly fragile. Small movements in this space, imperceptible in the input domain, can cross these boundaries and trigger misclassification.

#### Technical Mechanisms {#sec-robust-ai-technical-mechanisms-98ce}

Adversarial attacks exploit ML models' sensitivity to small input perturbations that are imperceptible to humans but cause dramatic changes in model outputs. These attacks reveal vulnerabilities in how models learn decision boundaries and generalize from training data. The mathematical foundation relies on the model's gradient information to identify the most effective perturbation directions.

**Fast Gradient Sign Method (FGSM)** [@goodfellow2014explaining] represents one of the earliest and most influential adversarial attack techniques. FGSM generates adversarial examples by adding small perturbations in the direction of the gradient with respect to the loss function, effectively "pushing" inputs toward misclassification boundaries. For ImageNet classifiers, FGSM attacks with ε = 8/255 (barely perceptible perturbations) can reduce accuracy from 76% to under 10%, demonstrating the fragility of deep networks to small input modifications.

Projected Gradient Descent (PGD) attacks [@madry2017towards] extend FGSM by iteratively applying small perturbations and projecting back to the allowed perturbation space. PGD attacks with 40 iterations and step size α = 2/255 achieve nearly 100% attack success rates against undefended models, dropping CIFAR-10 accuracy from 95% to under 5%. These attacks are considered among the strongest first-order adversaries and serve as benchmarks for evaluating defensive mechanisms.

Physical-world attacks pose particular challenges for deployed AI systems. Research has demonstrated that adversarial examples can be printed, photographed, or displayed on screens while maintaining their attack effectiveness [@kurakin2016adversarial]. Stop sign attacks achieve 87% misclassification rates when physical patches are placed on traffic signs, causing autonomous vehicle classifiers to interpret "STOP" signs as "Speed Limit 45" with potentially catastrophic consequences. Laboratory studies show that adversarial examples maintain effectiveness across different lighting conditions (2,000-10,000 lux), viewing angles (±30 degrees), and camera distances (2-15 meters).

### Data Poisoning Attacks {#sec-robust-ai-data-poisoning-attacks-8487}

Data poisoning attacks target the training phase by injecting malicious samples into training datasets, causing models to learn incorrect associations or exhibit specific behaviors on targeted inputs. These attacks are particularly concerning in scenarios where training data is collected from untrusted sources or through crowdsourcing.

Label flipping attacks modify the labels of training examples to introduce incorrect associations. Research demonstrates that flipping just 3% of labels in CIFAR-10 reduces target class accuracy from 92% to 11%, while overall model accuracy drops only 2-4%, making detection difficult. For ImageNet, corrupting 0.5% of labels (6,500 images) can cause targeted misclassification rates above 90% for specific classes while maintaining 94% clean accuracy.

Backdoor attacks inject training samples with specific trigger patterns that cause models to exhibit attacker-controlled behavior when the trigger is present in test inputs [@gu2017badnets]. Studies show that inserting backdoor triggers in just 1% of training data achieves 99.5% attack success rates on trigger-bearing test inputs. The model performs normally on clean inputs but consistently misclassifies inputs containing the backdoor trigger, with clean accuracy typically dropping less than 1%.

Gradient-based poisoning crafts training samples that appear benign but cause gradient updates during training to move the model toward attacker objectives [@shafahi2018poison]. These attacks require precise optimization but can be devastating: poisoning 50 crafted images in CIFAR-10 (0.1% of training data) achieves target misclassification rates above 70%. The computational cost is significant, requiring 15-20$\times$ more training time to generate optimal poisoning samples, but the attack remains undetectable through visual inspection.

### Detection and Mitigation Strategies {#sec-robust-ai-detection-mitigation-strategies-8dbe}

Robust AI systems employ multiple defense mechanisms against input-level attacks, following the detection, graceful degradation, and adaptive response principles established in our unified framework.

Input sanitization applies preprocessing techniques to remove or reduce adversarial perturbations before they reach the model. JPEG compression with quality factor 75% neutralizes 60-80% of adversarial examples while reducing clean accuracy by only 1-2%. Image denoising with Gaussian filters (σ = 0.5) blocks 45% of FGSM attacks but requires careful tuning to avoid degrading legitimate inputs. Geometric transformations like random rotations (±15°) and scaling (0.9-1.1$\times$) provide 30-50% defense effectiveness with minimal clean accuracy loss.

Adversarial training [@madry2017towards] incorporates adversarial examples into the training process, teaching models to maintain correct predictions in the presence of adversarial perturbations. PGD adversarial training on CIFAR-10 achieves 87% robust accuracy against ε = 8/255 attacks compared to 0% for undefended models, though clean accuracy drops from 95% to 84%. Training time increases 6-10$\times$ due to adversarial example generation during each epoch, requiring specialized hardware acceleration for practical implementation.

Certified defenses provide mathematical guarantees about model robustness within specified perturbation bounds [@cohen2019certified]. Randomized smoothing achieves 67% certified accuracy on ImageNet for ℓ2 perturbations with σ = 0.5, compared to 76% clean accuracy. The certification radius increases to ε = 1.0 for 54% of test inputs, providing provable robustness guarantees. However, inference time increases 100-1000$\times$ due to Monte Carlo sampling requirements (typically 1,000 samples per prediction).

Ensemble methods leverage multiple models or detection mechanisms to identify and filter adversarial inputs [@tramèr2017ensemble]. Ensembles of 5 independently trained models achieve 94% detection rates for adversarial examples using prediction entropy thresholds (τ = 1.5), with false positive rates below 2% on clean data. Computational overhead scales linearly with ensemble size, requiring $5\times$ inference time and memory for the 5-model ensemble, making real-time deployment challenging.

While input-level attacks represent intentional attempts to compromise model behavior, AI systems must also contend with natural variations in their operational environments that can be equally disruptive. These environmental challenges emerge organically from the evolving nature of real-world deployments.

## Environmental Shifts {#sec-robust-ai-environmental-shifts-a2cf}

The third pillar of robust AI addresses the natural evolution of real-world conditions that can degrade model performance over time. Unlike the deliberate manipulations of input-level attacks or the random failures of hardware faults, environmental shifts reflect the inherent challenge of deploying static models in dynamic environments where data distributions, user behavior, and operational contexts continuously evolve. These shifts can interact synergistically with other vulnerability types. For example, a model experiencing distribution shift becomes more susceptible to adversarial attacks, while hardware errors may manifest differently under changed environmental conditions.

### Distribution Shift and Concept Drift {#sec-robust-ai-distribution-shift-concept-drift-55e2}

#### Intuitive Understanding {#sec-robust-ai-intuitive-understanding-8a8d}

Consider a medical diagnosis model trained on X-ray images from a modern hospital. When deployed in a rural clinic with older equipment, the model's accuracy plummets not because the underlying medical conditions have changed, but because the image characteristics differ. This exemplifies distribution shift: the world the model encounters differs from the world it learned from.

Distribution shifts occur naturally as environments evolve. User preferences change seasonally, language evolves with new slang, and economic patterns shift with market conditions. Unlike adversarial attacks that require malicious intent, these shifts emerge organically from the dynamic nature of real-world systems.

#### Technical Categories {#sec-robust-ai-technical-categories-cc06}

Covariate shift occurs when the input distribution changes while the relationship between inputs and outputs remains constant [@quinonero2009dataset]. Autonomous vehicle perception models trained on daytime images (luminance 1,000-100,000 lux) experience 15-30% accuracy degradation when deployed in nighttime conditions (0.1-10 lux), despite unchanged object recognition tasks. Weather conditions introduce additional covariate shift: rain reduces object detection mAP by 12%, snow by 18%, and fog by 25% compared to clear conditions.

Concept drift represents changes in the underlying relationship between inputs and outputs over time [@widmer1996learning]. Credit card fraud detection systems experience concept drift with 6-month correlation decay rates of 0.2-0.4, requiring model retraining every 90-120 days to maintain performance above 85% precision. E-commerce recommendation systems show 15-20% accuracy degradation over 3-6 months due to seasonal preference changes and evolving user behavior patterns.

Label shift affects the distribution of output classes without changing the input-output relationship [@lipton2018detecting]. COVID-19 caused dramatic label shift in medical imaging: pneumonia prevalence increased from 12% to 35% in some hospital systems, requiring recalibration of diagnostic thresholds. Seasonal label shift in agriculture monitoring shows crop disease prevalence varying by 40-60% between growing seasons, necessitating adaptive decision boundaries for accurate yield prediction.

### Monitoring and Adaptation Strategies {#sec-robust-ai-monitoring-adaptation-strategies-f305}

Effective response to environmental shifts requires continuous monitoring of deployment conditions and adaptive mechanisms that maintain model performance as conditions change.

Statistical distance metrics quantify the degree of distribution shift by measuring differences between training and deployment data distributions. Maximum Mean Discrepancy (MMD) with RBF kernels (γ = 1.0) provides detection sensitivity of 0.85 for shifts with Cohen's d > 0.5, processing 10,000 samples in 150&nbsp;ms on modern hardware. Kolmogorov-Smirnov tests achieve 95% detection rates for univariate shifts with 1,000+ samples, but scale poorly to high-dimensional data. Population Stability Index (PSI) thresholds of 0.1-0.25 indicate significant shift requiring model investigation.

Online learning enables models to continuously adapt to new data while maintaining performance on previously learned patterns [@shalev2012online]. Stochastic Gradient Descent with learning rates η = 0.001-0.01 achieves convergence within 100-500 samples for concept drift adaptation. Memory overhead typically requires 2-5&nbsp;MB for maintaining sufficient historical context, while computation adds 15-25% inference latency for real-time adaptation. Techniques like Elastic Weight Consolidation prevent catastrophic forgetting with regularization coefficients λ = 400-40,000.

Model ensembles and selection maintain multiple models specialized for different environmental conditions, dynamically selecting the most appropriate model based on detected environmental characteristics [@ross2013model]. Ensemble systems with 3-7 models achieve 8-15% better accuracy than single models under distribution shift, with selection overhead of 2-5&nbsp;ms per prediction. Dynamic weighting based on recent performance (sliding windows of 500-2,000 samples) provides optimal adaptation to gradual drift.

Federated learning enables distributed adaptation across multiple deployment environments while preserving privacy. FL systems with 50-1,000 participants achieve convergence in 10-50 communication rounds, each requiring 10-100&nbsp;MB of parameter transmission depending on model size. Local training typically requires 5-20 epochs per round, with communication costs dominating when bandwidth falls below 1 Mbps. Differential privacy (ε = 1.0-8.0) adds noise but maintains model utility above 90% for most applications.

## Robustness Evaluation Tools {#sec-robust-ai-robustness-evaluation-tools-6b64}

Having examined the three pillars of robust AI—hardware faults, input-level attacks, and environmental shifts—students now have the conceptual foundation to understand specialized tools and frameworks for robustness evaluation and improvement. These tools implement the detection, graceful degradation, and adaptive response principles across all three threat categories.

Hardware fault injection tools like PyTorchFI and TensorFI enable systematic testing of ML model resilience to the transient, permanent, and intermittent faults described earlier. Adversarial attack libraries implement FGSM, PGD, and certified defense techniques for evaluating input-level robustness. Distribution monitoring frameworks provide the statistical distance metrics and drift detection capabilities essential for environmental shift management.

Modern robustness tools integrate directly with popular ML frameworks (PyTorch, TensorFlow, Keras), enabling seamless incorporation of robustness evaluation into development workflows established in @sec-ml-operations. The comprehensive examination of these tools and their practical applications appears in @sec-robust-ai-fault-injection-tools-frameworks-fc07, providing detailed implementation guidance for building robust AI systems.

## Input-Level Attacks and Model Robustness {#sec-robust-ai-inputlevel-attacks-model-robustness-d6ea}

While hardware faults represent unintentional disruptions to the underlying computing infrastructure, model robustness concerns extend to deliberate attacks targeting the AI system's decision-making processes and natural variations in operational environments. The transition from hardware reliability to model robustness reflects a shift from protecting the physical substrate of computation to defending the learned representations and decision boundaries that define model behavior.

This shift requires a change in perspective. Hardware faults typically manifest as corrupted calculations, memory errors, or communication failures that propagate through the system in predictable ways guided by the underlying computational graph. In contrast, model robustness challenges exploit or expose core limitations in the model's understanding of its problem domain. Adversarial attacks craft inputs specifically designed to trigger misclassifications, data poisoning corrupts the training process itself, and distribution shifts reveal the brittleness of models when deployed beyond their training assumptions.

Following our three-category robustness framework from @sec-robust-ai-unified-framework-robust-ai-b25d, different challenge types require complementary defense strategies. While hardware fault mitigation often relies on redundancy, error detection codes, and graceful degradation, model robustness demands techniques like adversarial training, input sanitization, domain adaptation, and continuous monitoring of model behavior in deployment.

The importance of this dual perspective becomes clear when we consider that real-world AI systems face compound threats where hardware faults and model vulnerabilities can interact in complex ways. A hardware fault that corrupts model weights might create new adversarial vulnerabilities, while adversarial attacks might trigger error conditions that resemble hardware faults. Our unified framework from @sec-robust-ai-unified-framework-robust-ai-b25d provides the conceptual foundation for addressing these interconnected challenges systematically.

### Adversarial Attacks {#sec-robust-ai-adversarial-attacks-481c}

Adversarial attacks represent counterintuitive vulnerabilities in modern machine learning systems. These attacks exploit core characteristics of how neural networks learn and represent information, revealing extreme model sensitivity to carefully crafted modifications that remain imperceptible to human observers. These attacks often involve adding small, carefully designed perturbations to input data, which can cause the model to misclassify it, as shown in @fig-adversarial-attack-noise-example.

![**Adversarial Perturbation**: Subtle, Intentionally Crafted Noise Can Cause Neural Networks to Misclassify Images With High Confidence, Exposing a Vulnerability in Model Robustness. These Perturbations, Imperceptible to Humans, Alter the Input in a Way That Maximizes Prediction Error, Highlighting the Need for Defenses Against Adversarial Attacks. Source: Sutanto (2019).](./images/png/adversarial_attack_detection.png){#fig-adversarial-attack-noise-example fig-pos="htb"}

#### Understanding the Vulnerability {#sec-robust-ai-understanding-vulnerability-de4c}

Understanding why these attacks are so effective requires examining how they expose core limitations in neural network architectures. The existence of adversarial examples reveals a core mismatch between human and machine perception[^fn-human-vs-machine-perception].

[^fn-human-vs-machine-perception]: **Human vs Machine Perception**: Fundamental difference in how humans and neural networks process visual information. Human vision emphasizes object invariance and semantic understanding, while machine vision learns statistical patterns from training data, creating brittle decision boundaries vulnerable to imperceptible perturbations. First highlighted by Szegedy et al. in 2013, this gap reveals how small perturbations can dramatically change model predictions while leaving semantic content unchanged from human perspective.

This vulnerability stems from several characteristics of neural network learning[^fn-nn-learning]. High-dimensional input spaces[^fn-curse-of-dimensionality] provide numerous dimensions that attackers can exploit simultaneously.

[^fn-nn-learning]: **Neural Network Learning Mechanisms**: The fundamental processes by which neural networks learn patterns from data, including gradient-based optimization, decision boundary formation, and high-dimensional feature representation. These core concepts are introduced comprehensively in @sec-dl-primer.

[^fn-curse-of-dimensionality]: **Curse of Dimensionality in Adversarial Settings**: In high-dimensional spaces (e.g., 224×224×3 = 150,528 dimensions for ImageNet images), tiny perturbations accumulate significantly. With ε=0.01 per dimension, total perturbation magnitude can reach √150,528 × 0.01 ≈ 3.88, enough to alter model predictions while remaining imperceptible to humans who process images holistically. Non-linear decision boundaries create complex separations that make models sensitive to precise input modifications.

This deep understanding of why adversarial examples exist is crucial for developing effective defenses. The vulnerability reflects core properties of how neural networks represent and process information in high-dimensional spaces, rather than being merely a software bug or training artifact. The theoretical foundations explaining why neural networks[^fn-nn-theory] are inherently vulnerable to adversarial perturbations are comprehensively detailed in @sec-dl-primer.

[^fn-nn-theory]: **Neural Network Theoretical Foundations**: The mathematical and algorithmic principles underlying how neural networks process information, learn representations, and make predictions in high-dimensional spaces. Complete theoretical coverage is provided in @sec-dl-primer.

#### Attack Categories and Mechanisms {#sec-robust-ai-attack-categories-mechanisms-fed5}

Adversarial attacks can be organized into several categories based on their approach to crafting perturbations and the information available to the attacker. Each category exploits different aspects of model vulnerability and requires distinct defensive considerations.

##### Gradient-based Attacks {#sec-robust-ai-gradientbased-attacks-7a6f}

The most direct and widely studied category comprises gradient-based attacks, which exploit a core aspect of neural network training: the same gradient information used to train models can be weaponized to attack them. These attacks represent the most direct approach to adversarial example generation by leveraging the model's own learning mechanism against itself.

**Conceptual Foundation**

The key insight behind gradient-based attacks is that neural networks compute gradients to understand how changes to their inputs affect their outputs. During training, gradients guide weight updates to minimize prediction errors. For attacks, these same gradients reveal which input modifications would maximize prediction errors—essentially running the training process in reverse.

To illustrate this concept, consider an image classification model that correctly identifies a cat in a photo. The gradient with respect to the input image shows how sensitive the model's prediction is to changes in each pixel. An attacker can use this gradient information to determine the most effective way to modify specific pixels to change the model's prediction, perhaps causing it to misclassify the cat as a dog while keeping the changes imperceptible to human observers.

**Fast Gradient Sign Method (FGSM)**

The Fast Gradient Sign Method[^fn-fgsm] exemplifies the elegance and danger of gradient-based attacks[^fn-gradient-based-attacks]. FGSM takes the conceptually simple approach of moving in the direction that most rapidly increases the model's prediction error.

[^fn-fgsm]: **Fast Gradient Sign Method (FGSM)**: The first practical adversarial attack method, proposed by Goodfellow et al. in 2014. Generates adversarial examples in a single step by moving in the direction of the gradient's sign, making it computationally efficient but often less effective than iterative methods.

[^fn-gradient-based-attacks]: **Gradient-Based Attacks**: Adversarial techniques that use the model's gradients to craft perturbations. Discovered by Ian Goodfellow in 2014, these attacks revealed that neural networks are vulnerable to imperceptible input modifications, spurring an entire research field in adversarial machine learning.

The underlying mathematical formulation captures this intuitive process:

$$
x_{\text{adv}} = x + \epsilon \cdot \text{sign}\big(\nabla_x J(\theta, x, y)\big)
$$

Where the components represent:

- $x$: the original input (e.g., an image of a cat)
- $x_{\text{adv}}$: the adversarial example that will fool the model
- $\nabla_x J(\theta, x, y)$: the gradient showing which input changes most increase prediction error
- $\text{sign}(\cdot)$: extracts only the direction of change, ignoring magnitude differences
- $\epsilon$: controls perturbation strength (typically 0.01-0.3 for normalized inputs)
- $J(\theta, x, y)$: the loss function measuring prediction error

The gradient $\nabla_x J(\theta, x, y)$ quantifies how the loss function changes with respect to each input feature, indicating which input modifications would most effectively increase the model's prediction error. The $\text{sign}(\cdot)$ function extracts the direction of steepest ascent, while the perturbation magnitude $\epsilon$ controls the strength of the modification applied to each input dimension.

This approach generates adversarial examples by taking a single step in the direction that increases the loss most rapidly, as illustrated in @fig-gradient-attack.

![**Adversarial Perturbations**: Gradient-based attacks generate subtle, intentionally crafted input noise – with magnitude controlled by $\epsilon$ – that maximizes the loss function $j(\theta, x, y)$ and causes misclassification by the model. These perturbations, imperceptible to humans, exploit model vulnerabilities by moving the input $x$ across the decision boundary. Source: [ivezic](HTTPS://defence.AI/AI-security/gradient-based-attacks/)](./images/png/gradient_attack.png){#fig-gradient-attack}

Building on this foundation, the Projected Gradient Descent (PGD) attack [@kurakin2016adversarial] extends FGSM by iteratively applying the gradient update step, allowing for more refined and powerful adversarial examples. PGD projects each perturbation step back into a constrained norm ball around the original input, ensuring that the adversarial example remains within a specified distortion limit. This makes PGD a stronger white-box attack and a benchmark for evaluating model robustness.

The Jacobian-based Saliency Map Attack (JSMA) [@papernot2016jsma] is another gradient-based approach that identifies the most influential input features and perturbs them to create adversarial examples. By constructing a saliency map based on the Jacobian of the model's outputs with respect to inputs, JSMA selectively alters a small number of input dimensions that are most likely to influence the target class. This makes JSMA more precise and targeted than FGSM or PGD, often requiring fewer perturbations to fool the model.

Gradient-based attacks are particularly effective in white-box settings[^fn-white-box-attacks], where the attacker has access to the model's architecture and gradients. Their efficiency and relative simplicity have made them popular tools for both attacking and evaluating model robustness in research.

[^fn-white-box-attacks]: **White-Box Attacks**: Adversarial attacks where the attacker has complete knowledge of the target model, including architecture, weights, and training data. More powerful than black-box attacks but less realistic in practice, as attackers rarely have full model access.

##### Optimization-based Attacks {#sec-robust-ai-optimizationbased-attacks-f018}

While gradient-based methods offer speed and simplicity, optimization-based attacks formulate the generation of adversarial examples as a more sophisticated optimization problem. The Carlini and Wagner (C&W) attack [@carlini2017towards][^fn-carlini-wagner] is a prominent example in this category. It finds the smallest perturbation that can cause misclassification while maintaining the perceptual similarity to the original input. The C&W attack employs an iterative optimization process to minimize the perturbation while maximizing the model's prediction error. It uses a customized loss function with a confidence term to generate more confident misclassifications.

[^fn-carlini-wagner]: **Carlini and Wagner (C&W) Attack**: Developed in 2017, this sophisticated attack method finds minimal perturbations by solving an optimization problem with carefully designed loss functions. Often considered the strongest white-box attack, it successfully breaks many defensive mechanisms that stop simpler attacks.

C&W attacks are especially difficult to detect because the perturbations are typically imperceptible to humans, and they often bypass many existing defenses. The attack can be formulated under various norm constraints (e.g., L2, L∞) depending on the desired properties of the adversarial perturbation.

Extending this optimization framework, the Elastic Net Attack to DNNs (EAD) incorporates elastic net regularization (a combination of L1 and L2 penalties) to generate adversarial examples with sparse perturbations. This can lead to minimal and localized changes in the input, which are harder to identify and filter. EAD is particularly useful in settings where perturbations need to be constrained in both magnitude and spatial extent.

These attacks are more computationally intensive than gradient-based methods but offer finer control over the adversarial example's properties, often requiring specialized optimization techniques detailed in @sec-model-optimizations. They are often used in high-stakes domains where stealth and precision are critical.

##### Transfer-based Attacks {#sec-robust-ai-transferbased-attacks-9896}

Moving from direct optimization to exploiting model similarities, transfer-based attacks exploit the transferability property[^fn-transferability] of adversarial examples. Transferability refers to the phenomenon where adversarial examples crafted for one ML model can often fool other models, even if they have different architectures or were trained on different datasets. This enables attackers to generate adversarial examples using a surrogate model and then transfer them to the target model without requiring direct access to its parameters or gradients.

[^fn-transferability]: **Transferability**: A surprising property discovered in 2015 showing that adversarial examples often transfer between different neural networks. Success rates typically range from 30-70% across models, enabling practical black-box attacks without direct model access.

This transferability property underlies the feasibility of black-box attacks, where the adversary cannot query gradients but can still fool a model by crafting attacks on a publicly available or similar substitute model. Transfer-based attacks are particularly relevant in practical threat scenarios, such as attacking commercial ML APIs, where the attacker can observe inputs and outputs but not internal computations.

Attack success often depends on factors like similarity between models, alignment in training data, and the regularization techniques used. Techniques like input diversity (random resizing, cropping) and momentum during optimization can be used to increase transferability.

##### Physical-world Attacks {#sec-robust-ai-physicalworld-attacks-97a0}

Physical-world attacks bring adversarial examples into real-world scenarios. These attacks involve creating physical objects or manipulations that can deceive ML models when captured by sensors or cameras. Adversarial patches, for example, are small, carefully designed patterns that can be placed on objects to fool object detection or classification models. These patches are designed to work under varying lighting conditions, viewing angles, and distances, making them robust in real-world environments.

When attached to real-world objects, such as a stop sign or a piece of clothing, these patches can cause models to misclassify or fail to detect the objects accurately. Notably, the effectiveness of these attacks persists even after being printed out and viewed through a camera lens, bridging the digital and physical divide in adversarial ML.

Adversarial objects, such as 3D-printed sculptures or modified road signs, can also be crafted to deceive ML systems in physical environments. For example, a 3D turtle object was shown to be consistently classified as a rifle by an image classifier, even when viewed from different angles. These attacks underscore the risks facing AI systems deployed in physical spaces, such as autonomous vehicles, drones, and surveillance systems, raising critical considerations for responsible AI deployment covered in @sec-responsible-ai.

Research into physical-world attacks also includes efforts to develop universal adversarial perturbations, perturbations that can fool a wide range of inputs and models. These threats raise serious questions about safety, robustness, and generalization in AI systems.

##### Summary {#sec-robust-ai-summary-a932}

@tbl-attack_types provides a concise overview of the different categories of adversarial attacks, including gradient-based attacks (FGSM, PGD, JSMA), optimization-based attacks (C&W, EAD), transfer-based attacks, and physical-world attacks (adversarial patches and objects). Each attack is briefly described, highlighting its key characteristics and mechanisms.

The mechanisms of adversarial attacks reveal the intricate interplay between the ML model's decision boundaries, the input data, and the attacker's objectives. By carefully manipulating the input data, attackers can exploit the model's sensitivities and blind spots, leading to incorrect predictions. The success of adversarial attacks highlights the need for a deeper understanding of ML models' robustness and generalization properties.

+------------------------+-------------------------------------------+-----------------------------------------------------------------------------------------------------------+
| **Attack Category**    | **Attack Name**                           | **Description**                                                                                           |
+:=======================+:==========================================+:==========================================================================================================+
| **Gradient-based**     | Fast Gradient Sign Method (FGSM)          | Perturbs input data by adding small noise in the gradient direction to maximize prediction error.         |
|                        | Projected Gradient Descent (PGD)          | Extends FGSM by iteratively applying the gradient update step for more refined adversarial examples.      |
|                        | Jacobian-based Saliency Map Attack (JSMA) | Identifies influential input features and perturbs them to create adversarial examples.                   |
+------------------------+-------------------------------------------+-----------------------------------------------------------------------------------------------------------+
| **Optimization-based** | Carlini and Wagner (C&W) Attack           | Finds the smallest perturbation that causes misclassification while maintaining perceptual similarity.    |
|                        | Elastic Net Attack to DNNs (EAD)          | Incorporates elastic net regularization to generate adversarial examples with sparse perturbations.       |
+------------------------+-------------------------------------------+-----------------------------------------------------------------------------------------------------------+
| **Transfer-based**     | Transferability-based Attacks             | Exploits the transferability of adversarial examples across different models, enabling black-box attacks. |
+------------------------+-------------------------------------------+-----------------------------------------------------------------------------------------------------------+
| **Physical-world**     | Adversarial Patches                       | Small, carefully designed patches placed on objects to fool object detection or classification models.    |
|                        | Adversarial Objects                       | Physical objects (e.g., 3D-printed sculptures, modified road signs) crafted to deceive ML systems in      |
|                        |                                           | real-world scenarios.                                                                                     |
+------------------------+-------------------------------------------+-----------------------------------------------------------------------------------------------------------+

: **Adversarial Attack Categories**: Machine learning model robustness relies on defending against attacks that intentionally perturb input data to cause misclassification; this table categorizes these attacks by their underlying mechanism, including gradient-based, optimization-based, transfer-based, and physical-world approaches, each exploiting different model vulnerabilities. Understanding these categories is crucial for developing effective defense strategies and evaluating model security. {#tbl-attack_types}

Defending against adversarial attacks requires the multifaceted defense strategies detailed in @sec-robust-ai-defense-strategies-cb2d, including adversarial training, defensive distillation, input preprocessing, and ensemble methods.

As adversarial machine learning evolves, researchers explore new attack mechanisms and develop more sophisticated defenses. The arms race between attackers and defenders drives constant innovation and vigilance in securing ML systems against adversarial threats. Understanding attack mechanisms is crucial for developing robust and reliable ML models that can withstand evolving adversarial examples.

#### Impact on ML {#sec-robust-ai-impact-ml-7c6f}

The impact of adversarial attacks on ML systems extends far beyond simple misclassification, as demonstrated in @fig-adversarial-googlenet. These vulnerabilities create systemic risks across deployment domains.

![**Adversarial Perturbations**: Subtle, intentionally crafted noise added to an image can cause a trained deep neural network (googlenet) to misclassify it, even though the perturbed image remains visually indistinguishable to humans. This vulnerability underscores the lack of robustness in many machine learning models and motivates research into adversarial training and defense mechanisms. Source: goodfellow et al., 2014.](./images/png/adversarial_googlenet.png){#fig-adversarial-googlenet}

One striking example of the impact of adversarial attacks was demonstrated by researchers in 2017. They experimented with small black and white stickers on stop signs [@eykholt2018robust]. To the human eye, these stickers did not obscure the sign or prevent its interpretability. However, when images of the sticker-modified stop signs were fed into standard traffic sign classification ML models, a shocking result emerged. The models misclassified the stop signs as speed limit signs over 85% of the time.

This demonstration shed light on the alarming potential of simple adversarial stickers to trick ML systems into misreading critical road signs. The implications of such attacks in the real world are significant, particularly in the context of autonomous vehicles. If deployed on actual roads, these adversarial stickers could cause self-driving cars to misinterpret stop signs as speed limits, leading to dangerous situations, as shown in @fig-graffiti. Researchers warned that this could result in rolling stops or unintended acceleration into intersections, endangering public safety.

Microsoft's Tay chatbot provides a stark example of how adversarial users can exploit lack of robustness safeguards in deployed AI systems. Within 24 hours of launch, coordinated users manipulated Tay's learning mechanisms to generate inappropriate and offensive content. The system lacked content filtering, user input validation, and behavioral monitoring safeguards that could have detected and prevented the exploitation. This incident highlights the critical need for comprehensive input validation, content filtering systems, and continuous behavioral monitoring in deployed AI systems, particularly those that learn from user interactions.

![**Adversarial Perturbation**: Subtle, physically realizable modifications to input data can cause machine learning models to make incorrect predictions, even when imperceptible to humans. This example shows how small stickers on a stop sign caused a traffic sign classifier to misidentify it as a 45 mph speed limit sign with over 85% accuracy, highlighting the vulnerability of ML systems to adversarial attacks. Source: [eykholt](https://arxiv.org/abs/1707.08945)](./images/png/graffiti.png){#fig-graffiti}

This demonstration illustrates how adversarial examples exploit fundamental vulnerabilities in ML pattern recognition. The attack's simplicity—minor input modifications invisible to humans causing dramatic prediction changes—reveals deep architectural limitations rather than superficial bugs.

Beyond performance degradation, adversarial vulnerabilities create cascading systemic risks. In healthcare, attacks on medical imaging could enable misdiagnosis [@tsai2023adversarial]. Financial systems face manipulation of trading algorithms leading to economic losses. These vulnerabilities fundamentally undermine model trustworthiness by exposing reliance on superficial patterns rather than robust concept understanding [@fursov2021adversarial].

Defending against adversarial attacks often requires additional computational resources and can impact the overall system performance. Techniques like adversarial training, where models are trained on adversarial examples to improve robustness, can significantly increase training time and computational requirements [@bai2021recent]. Runtime detection and mitigation mechanisms, such as input preprocessing [@addepalli2020towards] or prediction consistency checks, introduce latency and affect the real-time performance of ML systems.

The presence of adversarial vulnerabilities also complicates the deployment and maintenance of ML systems. System designers and operators must consider the potential for adversarial attacks and incorporate appropriate defenses and monitoring mechanisms. Regular updates and retraining of models become necessary to adapt to new adversarial techniques and maintain system security and performance over time.

These vulnerabilities highlight the urgent need for the comprehensive defense strategies examined in @sec-robust-ai-input-attack-detection-defense-19d3.

### Data Poisoning {#sec-robust-ai-data-poisoning-4b55}

Data poisoning presents a critical challenge to the integrity and reliability of machine learning systems. By introducing carefully crafted malicious data into the training pipeline, adversaries can subtly manipulate model behavior in ways that are difficult to detect through standard validation procedures.

A key distinction from adversarial attacks emerges in their timing and targeting. While adversarial attacks happen *after* a model is trained (adding noise to test inputs), data poisoning happens *before* training (contaminating the training data itself). This difference is analogous to fooling a trained student during an exam versus giving a student wrong information while they're learning. Both can cause incorrect answers, but they exploit different vulnerabilities at different stages:

- Adversarial attacks target deployed models, affecting inference, and can be detected by monitoring outputs
- Data poisoning targets training data, affecting learning, and is much harder to detect because the model honestly learned wrong patterns

Unlike adversarial examples, which target models at inference time, poisoning attacks exploit upstream components of the system, such as data collection, labeling, or ingestion. As ML systems are increasingly deployed in automated and high-stakes environments, understanding how poisoning occurs and how it propagates through the system is essential for developing effective defenses.

#### Data Poisoning Properties {#sec-robust-ai-data-poisoning-properties-2258}

Data poisoning[^fn-data-poisoning] is an attack in which the training data is deliberately manipulated to compromise the performance or behavior of a machine learning model, as described in [@biggio2012poisoning] and illustrated in @fig-dirty-label-example. Attackers may alter existing training samples, introduce malicious examples, or interfere with the data collection pipeline. The result is a model that learns biased, inaccurate, or exploitable patterns.

[^fn-data-poisoning]: **Data Poisoning**: Attack method first formalized by Biggio et al. in 2012, where adversaries inject malicious samples into training data to compromise model behavior. Unlike adversarial examples that target inference, poisoning attacks the learning process itself, making them harder to detect and defend against.

![**Data Poisoning Examples**: Mismatched image-text pairs represent a common data poisoning attack, where manipulated training data causes models to misclassify inputs. These adversarial examples can compromise model integrity and introduce vulnerabilities in real-world applications. Source: [@shan2023prompt].](./images/png/dirty_label_example.png){#fig-dirty-label-example}

In most cases, data poisoning unfolds in three stages. In the injection stage, the attacker introduces poisoned samples into the training dataset. These samples may be altered versions of existing data or entirely new instances designed to blend in with clean examples. While they appear benign on the surface, these inputs are engineered to influence model behavior in subtle but deliberate ways. The attacker may target specific classes, insert malicious triggers, or craft outliers intended to distort the decision boundary.

During the training phase, the machine learning model incorporates the poisoned data and learns spurious or misleading patterns. These learned associations may bias the model toward incorrect classifications, introduce vulnerabilities, or embed backdoors. Because the poisoned data is often statistically similar to clean data, the corruption process typically goes unnoticed during standard model training and evaluation.

Finally, in the deployment stage, the attacker leverages the compromised model for malicious purposes. This could involve triggering specific behaviors, including the misclassification of an input that contains a hidden pattern, or simply exploiting the model’s degraded accuracy in production. In real-world systems, such attacks can be difficult to trace back to training data, especially if the system’s behavior appears erratic only in edge cases or under adversarial conditions.

The consequences of such manipulation are especially severe in high-stakes domains like healthcare, where even small disruptions to training data can lead to dangerous misdiagnoses or loss of trust in AI-based systems [@marulli2022sensitivity].

Four main categories of poisoning attacks have been identified in the literature [@oprea2022poisoning]. In availability attacks, a substantial portion of the training data is poisoned with the aim of degrading overall model performance. A classic example involves flipping labels, for instance, systematically changing instances with true label $y = 1$ to $y = 0$ in a binary classification task. These attacks render the model unreliable across a wide range of inputs, effectively making it unusable.

In contrast, targeted poisoning attacks aim to compromise only specific classes or instances. Here, the attacker modifies just enough data to cause a small set of inputs to be misclassified, while overall accuracy remains relatively stable. This subtlety makes targeted attacks especially hard to detect.

Backdoor poisoning[^fn-backdoor-attacks] introduces hidden triggers into training data, subtle patterns or features that the model learns to associate with a particular output. When the trigger appears at inference time, the model is manipulated into producing a predetermined response. These attacks are often effective even if the trigger pattern is imperceptible to human observers.

[^fn-backdoor-attacks]: **Backdoor Attacks**: Introduced by Gu et al. in 2017, these attacks embed hidden triggers in training data that activate malicious behavior when specific patterns appear at inference time. Success rates can exceed 99% while maintaining normal accuracy on clean inputs, making them particularly dangerous.

Subpopulation poisoning focuses on compromising a specific subset of the data population. While similar in intent to targeted attacks, subpopulation poisoning applies availability-style degradation to a localized group, for example, a particular demographic or feature cluster, while leaving the rest of the model’s performance intact. This distinction makes such attacks both highly effective and especially dangerous in fairness-sensitive applications.

A common thread across these poisoning strategies is their subtlety. Manipulated samples are typically indistinguishable from clean data, making them difficult to identify through casual inspection or standard data validation. These manipulations might involve small changes to numeric values, slight label inconsistencies, or embedded visual patterns, each designed to blend into the data distribution while still affecting model behavior.

Such attacks may be carried out by internal actors, like data engineers or annotators with privileged access, or by external adversaries who exploit weak points in the data collection pipeline. In crowdsourced environments or open data collection scenarios, poisoning can be as simple as injecting malicious samples into a shared dataset or influencing user-generated content.

Crucially, poisoning attacks often target the early stages of the ML pipeline, such as collection and preprocessing, where there may be limited oversight. If data is pulled from unverified sources or lacks strong validation protocols, attackers can slip in poisoned data that appears statistically normal. The absence of integrity checks, robust outlier detection, or lineage tracking only heightens the risk.

The goal of these attacks is to corrupt the learning process itself. A model trained on poisoned data may learn spurious correlations, overfit to false signals, or become vulnerable to highly specific exploit conditions. Whether the result is a degraded model or one with a hidden exploit path, the trustworthiness and safety of the system are severely compromised.

#### Data Poisoning Attack Methods {#sec-robust-ai-data-poisoning-attack-methods-d168}

Data poisoning can be implemented through a variety of mechanisms, depending on the attacker’s access to the system and understanding of the data pipeline. These mechanisms reflect different strategies for how the training data can be corrupted to achieve malicious outcomes.

One of the most direct approaches involves modifying the labels of training data. In this method, an attacker selects a subset of training samples and alters their labels, flipping $y = 1$ to $y = 0$ or reassigning categories in multi-class settings. As shown in @fig-distribution-shift-example, even small-scale label inconsistencies can lead to significant distributional shifts and learning disruptions.

::: {#fig-distribution-shift-example fig-env="figure" fig-pos="htb"}
```{.tikz}
\begin{tikzpicture}[line join=round,font=\usefont{T1}{phv}{m}{n}\small]
\tikzset{
LineA/.style={violet!80!black!50,line width=3pt,shorten <=2pt,shorten >=2pt,{{Triangle[width=1.1*6pt,length=0.8*6pt]}-}},
Line/.style={violet!80!black!50,line width=2pt,shorten <=2pt,shorten >=10pt}
}
%Gear
% #1 number of teeth
% #2 radius intern
% #3 radius extern
% #4 angle from start to end of the first arc
% #5 angle to decale the second arc from the first
% #6 inner radius to cut off
\newcommand{\gear}[6]{%
  (0:#2)
  \foreach \i [evaluate=\i as \n using {(\i-1)*360/#1}] in {1,...,#1}{%
    arc (\n:\n+#4:#2) {[rounded corners=1.5pt] -- (\n+#4+#5:#3)
    arc (\n+#4+#5:\n+360/#1-#5:#3)} --  (\n+360/#1:#2)
  }%
  (0,0) circle[radius=#6];
}
%Skull
\tikzset{pics/skull/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[local bounding box=SKULL,scale=\scalefac, every node/.append style={transform shape}]
\fill[fill=\filllcolor](-0.225,-0.05)to[out=110,in=230](-0.215,0.2)to[out=50,in=180](0,0.315)
to[out=0,in=130](0.218,0.2)to[out=310,in=70](0.227,-0.05) to[out=320,in=40](0.21,-0.15)
to[out=210,in=80](0.14,-0.23) to[out=260,in=20](0.04,-0.285) to[out=200,in=340](-0.07,-0.28)
to[out=170,in=290](-0.135,-0.23) to[out=110,in=340](-0.21,-0.15) to[out=140,in=250]cycle;
%eyes
\fill[fill=white](-0.17,-0.02)to[out=70,in=110](-0.029,-0.02)to[out=280,in=0](-0.129,-0.11)to[out=190,in=250]cycle;
\fill[fill=white](0.035,-0.02)to[out=70,in=110](0.175,-0.02)to[out=300,in=340](0.12,-0.103)to[out=170,in=260]cycle;
%nose
\fill[fill=white](0.018,-0.115)to[out=70,in=110](-0.014,-0.115)to(-0.043,-0.165)
to[out=200,in=170](-0.025,-0.19)to(0.027,-0.19)to[out=10,in=330](0.047,-0.165)to cycle;
%above left
\fill[fill=\filllcolor](-0.2,0.18)to[out=160,in=320](-0.3,0.23)to[out=140,in=0](-0.37,0.295)
to[out=180,in=80](-0.43,0.25)to[out=230,in=90](-0.475,0.19)
to[out=260,in=170](-0.375,0.13)to[out=350,in=170](-0.2,0.1)to cycle;
%above right
\fill[fill=\filllcolor](0.2,0.18)to[out=20,in=220](0.3,0.23)to[out=40,in=200](0.37,0.295)
to[out=20,in=90](0.43,0.25)to[out=230,in=90](0.475,0.19)to[out=260,in=360](0.375,0.13)
to[out=190,in=10](0.2,0.1)to cycle;
%below left
\fill[fill=\filllcolor](-0.2,0.03)to[out=210,in=0](-0.3,0.01)to[out=180,in=0](-0.37,0.01)
to[out=180,in=50](-0.46,0.0)to[out=230,in=120](-0.445,-0.08)
to[out=260,in=170](-0.41,-0.14)to[out=350,in=190](-0.2,-0.051)to cycle;
%below right
\fill[fill=\filllcolor](0.2,0.03)to[out=340,in=170](0.3,0.01)to[out=350,in=190](0.37,0.01)
to[out=20,in=110](0.47,-0.03)to[out=270,in=120](0.443,-0.09)
to[out=270,in=0](0.36,-0.15)to[out=160,in=340](0.2,-0.051)to cycle;
\end{scope}
     }
  }
}

%Brain
\tikzset{pics/brain/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[local bounding box=BRAIN,scale=\scalefac, every node/.append style={transform shape}]
\fill[fill=\filllcolor!50](0.1,-0.5)to[out=0,in=180](0.33,-0.5)
to[out=0,in=270](0.45,-0.38)to(0.45,-0.18)
to[out=40,in=240](0.57,-0.13)to[out=110,in=310](0.52,-0.05)
to[out=130,in=290](0.44,0.15)to[out=90,in=340,distance=8](0.08,0.69)
to[out=160,in=80](-0.42,-0.15)to (-0.48,-0.7)to(0.07,-0.7)to(0.1,-0.5)
(-0.10,-0.42)to[out=310,in=180](0.1,-0.5);
\draw[draw=\drawcolor,line width=\Linewidth](0.1,-0.5)to[out=0,in=180](0.33,-0.5)
to[out=0,in=270](0.45,-0.38)to(0.45,-0.18)
to[out=40,in=240](0.57,-0.13)to[out=110,in=310](0.52,-0.05)
to[out=130,in=290](0.44,0.15)to[out=90,in=340,distance=8](0.08,0.69)
(-0.42,-0.15)to (-0.48,-0.7)
(0.07,-0.7)to(0.1,-0.5)
(-0.10,-0.42)to[out=310,in=180](0.1,-0.5);
\draw[fill=\filllcolor,line width=\Linewidth](-0.3,-0.10)to(0.08,0.60)
to[out=60,in=50,distance=3](-0.1,0.69)to[out=160,in=80](-0.26,0.59)to[out=170,in=90](-0.46,0.42)
to[out=170,in=110](-0.54,0.25)to[out=210,in=150](-0.54,0.04)
to[out=240,in=130](-0.52,-0.1)to[out=300,in=240]cycle;
\draw[fill=\filllcolor,line width=\Linewidth]
(-0.04,0.64)to[out=120,in=0](-0.1,0.69)(-0.19,0.52)to[out=120,in=330](-0.26,0.59)
(-0.4,0.33)to[out=150,in=280](-0.46,0.42)
%
(-0.44,-0.03)to[bend left=30](-0.34,-0.04)
(-0.33,0.08)to[bend left=40](-0.37,0.2) (-0.37,0.12)to[bend left=40](-0.45,0.14)
(-0.26,0.2)to[bend left=30](-0.24,0.13)
(-0.16,0.32)to[bend right=30](-0.27,0.3)to[bend right=30](-0.29,0.38)
(-0.13,0.49)to[bend left=30](-0.04,0.51);

\draw[rounded corners=0.8pt,\drawcircle,-{Circle[fill=\filllcirclecolor,length=2.5pt]}](-0.23,0.03)--(-0.15,-0.03)--(-0.19,-0.18)--(-0.04,-0.28);
\draw[rounded corners=0.8pt,\drawcircle,-{Circle[fill=\filllcirclecolor,length=2.5pt]}](-0.17,0.13)--(-0.04,0.05)--(-0.06,-0.06)--(0.14,-0.11);
\draw[rounded corners=0.8pt,\drawcircle,-{Circle[fill=\filllcirclecolor,length=2.5pt]}](-0.12,0.23)--(0.31,0.0);
\draw[rounded corners=0.8pt,\drawcircle,-{Circle[fill=\filllcirclecolor,length=2.5pt]}](-0.07,0.32)--(0.06,0.26)--(0.16,0.33)--(0.34,0.2);
\draw[rounded corners=0.8pt,\drawcircle,-{Circle[fill=\filllcirclecolor,length=2.5pt]}](-0.01,0.43)--(0.06,0.39)--(0.18,0.51)--(0.31,0.4);
\end{scope}
     }
  }
}
%channel
\tikzset{
channel/.pic={
\pgfkeys{/channel/.cd, #1}
\begin{scope}[local bounding box=CHA,scale=\scalefac, every node/.append style={transform shape}]
\node[rectangle,draw=\drawcolor,line width=\Linewidth,fill=\filllcolor!10,minimum height=20mm,minimum width=20mm](\picname){};
\end{scope}
        }
}
%person
\tikzset{%
LinePE/.style={line width=\Linewidth,draw=\drawcolor,fill=\filllcolor!50},
ellipsePE/.style={line width=\Linewidth,draw=\drawcolor,fill=\filllcolor,ellipse,minimum width = 2.5mm, inner sep=2pt,minimum width=29,
minimum height=40},
 pics/person/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[local bounding box=PERSON,scale=\scalefac, every node/.append style={transform shape}]
\node[ellipsePE,fill=yellow](\picname-EL1)at(0,0.44){};
\draw[LinePE](-0.6,0)to[out=210,in=85](-1.1,-1)
to[out=270,in=180](-0.9,-1.2)to(0.9,-1.2)to[out=0,in=270](1.1,-1)
to[out=85,in=325](0.6,0)to[out=250,in=290,distance=17](-0.6,0);
 \end{scope}
     }
  }
}
\pgfkeys{
  /channel/.cd,
  filllcirclecolor/.store in=\filllcirclecolor,
  filllcolor/.store in=\filllcolor,
  drawcolor/.store in=\drawcolor,
  drawcircle/.store in=\drawcircle,
  scalefac/.store in=\scalefac,
  Linewidth/.store in=\Linewidth,
  picname/.store in=\picname,
  filllcolor=BrownLine,
  filllcirclecolor=violet!20,
  drawcolor=black,
  drawcircle=violet,
  scalefac=1,
  Linewidth=0.5pt,
  picname=C
}
%Normal learning
\begin{scope}[local bounding box=NORMAL,shift={($(0,0)+(-6,0)$)},scale=1, every node/.append style={transform shape}]
%Gear
\begin{scope}[local bounding box=GEAR1,shift={($(0,0)+(0,1.8)$)},scale=1, every node/.append style={transform shape}]
\fill[draw=none,fill=BrownLine,even odd rule,xshift=-2mm]coordinate(D)\gear{12}{0.4}{0.33}{10}{2}{0.1};
\fill[draw=none,fill=BrownLine,even odd rule,xshift=3.8mm,yshift=2mm]\gear{11}{0.25}{0.21}{10}{1}{0.07};
\fill[draw=none,fill=BrownLine,even odd rule,xshift=0.6mm,yshift=5.8mm]coordinate(F)\gear{11}{0.25}{0.21}{10}{1}{0.07};
\end{scope}
%
\begin{scope}[local bounding box=CHANEL2,shift={($(GEAR1)+(0,3.5)$)}]
\foreach \i/\sf in {5/0.7,6/0.8,7/0.9} {
\pic[shift={(-0.65,0)}] at ({-\i*0.13}, {-0.13*\i}) {channel={scalefac=0.5,picname=\i-CH1,filllcolor=BrownLine,drawcolor=BrownLine}};
}
\foreach \i/\sf in {5/0.7,6/0.8,7/0.9} {
\pic[shift={(0.95,0)}] at ({-\i*0.13}, {-0.13*\i}) {channel={scalefac=0.5,picname=\i-CH2,filllcolor=BrownLine,drawcolor=BrownLine}};
}
\foreach \i/\sf in {5/0.7,6/0.8,7/0.9} {
\pic[shift={(2.55,0)}] at ({-\i*0.13}, {-0.13*\i})  {channel={scalefac=0.5,picname=\i-CH3,filllcolor=BrownLine,drawcolor=BrownLine}};
}
\end{scope}
%brain
\begin{scope}[local bounding box=BRAIN1,shift={($(0,0)+(0,0)$)},
scale=1, every node/.append style={transform shape}]
\pic[shift={(0,0)}] at  (0,0){brain={scalefac=0.7,picname=1,filllcolor=orange!30!, Linewidth=0.5pt}};
\end{scope}
 %persons
\foreach\i in{1,2,3}{
\pic[shift={(0,0)}] at  (7-CH\i){person={scalefac=0.3,picname=1,drawcolor=BrownLine,
filllcolor=green!80!black, Linewidth=0.5pt}};
}
\draw[LineA](BRAIN1)--++(90:1.32);
\foreach\i in{1,2,3}{
\draw[Line](7-CH\i.south)--(F);
}
\scoped[on background layer]
\node[draw=blue!50!black,inner xsep=3mm,inner ysep=2mm,
fill=cyan!05,fit=(BRAIN1)(7-CH1)(5-CH3),line width=0.5pt](BB1){};
\node[above=2ptof BB1,blue!50!black]{Normal learning};
%
\path[red](7-CH1)--++(180:3)coordinate(DA);
\path[red](DA)|-coordinate(LE)(GEAR1);
\path[red](DA)|-coordinate(MA)(BRAIN1);
\node[anchor=west]at(DA){Dataset};
\node[anchor=west,align=left]at(LE){Learning \\ algorithm};
\node[anchor=west,align=left]at(MA){Machine \\ learning\\ model};
\end{scope}
%%%%%%%%%%%%%%%%%%
%Poisoning attack
%%%%%%%%%%%%%ZZ%%%%
\begin{scope}[local bounding box=POISONING,shift={($(0,0)+(0,0)$)},scale=1, every node/.append style={transform shape}]
%Gear
\begin{scope}[local bounding box=GEAR1,shift={($(0,0)+(0,1.8)$)},scale=1, every node/.append style={transform shape}]
\fill[draw=none,fill=BrownLine,even odd rule,xshift=-2mm]coordinate(D)\gear{12}{0.4}{0.33}{10}{2}{0.1};
\fill[draw=none,fill=BrownLine,even odd rule,xshift=3.8mm,yshift=2mm]\gear{11}{0.25}{0.21}{10}{1}{0.07};
\fill[draw=none,fill=BrownLine,even odd rule,xshift=0.6mm,yshift=5.8mm]coordinate(F)\gear{11}{0.25}{0.21}{10}{1}{0.07};
\end{scope}
%
\begin{scope}[local bounding box=CHANEL2,shift={($(GEAR1)+(0,3.5)$)}]
\foreach \i/\sf in {5/0.7,6/0.8,7/0.9} {
\pic[shift={(-0.65,0)}] at ({-\i*0.13}, {-0.13*\i}) {channel={scalefac=0.5,picname=\i-CH1,filllcolor=BrownLine,drawcolor=BrownLine}};
}
\foreach \i/\sf in {5/0.7,6/0.8,7/0.9} {
\pic[shift={(0.95,0)}] at ({-\i*0.13}, {-0.13*\i}) {channel={scalefac=0.5,picname=\i-CH2,filllcolor=red,drawcolor=red}};
}
\foreach \i/\sf in {5/0.7,6/0.8,7/0.9} {
\pic[shift={(2.55,0)}] at ({-\i*0.13}, {-0.13*\i})  {channel={scalefac=0.5,picname=\i-CH3,filllcolor=BrownLine,drawcolor=BrownLine}};
}
\end{scope}
%brain
\begin{scope}[local bounding box=BRAIN1,shift={($(0,0)+(0,0)$)},
scale=1, every node/.append style={transform shape}]
\pic[shift={(0,0)}] at  (0,0){brain={scalefac=0.7,picname=1,filllcolor=black!30!, Linewidth=0.5pt,
  filllcirclecolor=black!20,drawcircle=black}};
\end{scope}
%skull
\begin{scope}[local bounding box=SKULL1,shift={($(0,0)+(0,0)$)},scale=1, every node/.append style={transform shape}]
\pic[shift={(0,0)}] at  (0,0){skull={scalefac=0.8,picname=1,filllcolor=red, Linewidth=0.5pt}};
\end{scope}
 %persons
\foreach\i in{1,3}{
\pic[shift={(0,0)}] at  (7-CH\i){person={scalefac=0.3,picname=1,drawcolor=BrownLine,
filllcolor=green!80!black, Linewidth=0.5pt}};
}
%skull
\pic[shift={(0,0)}] at  (7-CH2){skull={scalefac=0.8,picname=1,filllcolor=red, Linewidth=0.5pt}};
%
\draw[LineA](BRAIN1)--++(90:1.32);
\foreach\i in{1,2,3}{
\draw[Line](7-CH\i.south)--(F);
}
\scoped[on background layer]
\node[draw=red,inner xsep=3mm,inner ysep=2mm,
fill=magenta!05,fit=(BRAIN1)(7-CH1)(5-CH3),line width=0.5pt](BB1){};
\node[above=2ptof BB1,red]{Poisoning attack};
\end{scope}
\end{tikzpicture}

```
**Data Poisoning Impact**: Subtle perturbations to training data labels can induce significant distributional shifts, leading to model inaccuracies and compromised performance in machine learning systems. These shifts exemplify how even limited adversarial control over training data can disrupt model learning and highlight the vulnerability of data-driven approaches to malicious manipulation. Source: [@shan2023prompt].
:::

Another mechanism involves modifying the input features of training examples without changing the labels. This might include imperceptible pixel-level changes in images, subtle perturbations in structured data, or embedding fixed patterns that act as triggers for backdoor attacks. These alterations are often designed using optimization techniques that maximize their influence on the model while minimizing detectability.

More sophisticated attacks generate entirely new, malicious training examples. These synthetic samples may be created using adversarial methods, generative models, or even data synthesis tools. The aim is to carefully craft inputs that will distort the decision boundary of the model when incorporated into the training set. Such inputs may appear natural and legitimate but are engineered to introduce vulnerabilities.

Other attackers focus on weaknesses in data collection and preprocessing. If the training data is sourced from web scraping, social media, or untrusted user submissions, poisoned samples can be introduced upstream. These samples may pass through insufficient cleaning or validation checks, reaching the model in a “trusted" form. This is particularly dangerous in automated pipelines where human review is limited or absent.

In physically deployed systems, attackers may manipulate data at the source—for example, altering the environment captured by a sensor. A self-driving car might encounter poisoned data if visual markers on a road sign are subtly altered, causing the model to misclassify it during training. This kind of environmental poisoning blurs the line between adversarial attacks and data poisoning, but the mechanism, which involves compromising the training data, is the same.

Online learning systems represent another unique attack surface. These systems continuously adapt to new data streams, making them particularly susceptible to gradual poisoning. An attacker may introduce malicious samples incrementally, causing slow but steady shifts in model behavior. This form of attack is illustrated in @fig-poisoning-attack-example.

::: {#fig-poisoning-attack-example fig-env="figure" fig-pos="htb"}
```{.tikz}
\scalebox{0.75}{%
\begin{tikzpicture}[line join=round,font=\small\usefont{T1}{phv}{m}{n}]
\definecolor{Green}{RGB}{84,180,53}
\definecolor{Violet}{RGB}{178,108,186}
\tikzset{
   mycylinder/.style={cylinder, shape border rotate=90, aspect=1.3, draw, fill=white,minimum width=20mm,minimum height=9mm,line width=0.5pt},
    comp/.style = {draw,
        minimum width  =20mm,
        minimum height = 12mm,
        inner sep      = 0pt,
        rounded corners,
        draw = BlueLine,
        fill=cyan!10,
        line width=2.0pt
    },
    Line/.style={line width=1.0pt,Violet,text=black},
    DLine/.style={dashed,line width=1.0pt,Violet,text=black}
}
% #1 number of teeth
% #2 radius intern
% #3 radius extern
% #4 angle from start to end of the first arc
% #5 angle to decale the second arc from the first
% #6 inner radius to cut off
\newcommand{\gear}[6]{%
  (0:#2)
  \foreach \i [evaluate=\i as \n using {(\i-1)*360/#1}] in {1,...,#1}{%
    arc (\n:\n+#4:#2) {[rounded corners=1.5pt] -- (\n+#4+#5:#3)
    arc (\n+#4+#5:\n+360/#1-#5:#3)} --  (\n+360/#1:#2)
  }%
  (0,0) circle[radius=#6]
}
%Cloud
\node[red,cloud, cloud puffs=11.4, cloud ignores aspect,
minimum width=40mm, minimum height=24mm, rotate=10,
align=center, draw=BrownLine,line width=1.5pt] (cloud) at (0cm, 0cm) {};
%two Gears
\begin{scope}[local bounding box=GEAR2,shift={($(cloud.300)+(0.5,1.05)$)}]
%smaller
\begin{scope}[scale=0.1, every node/.append style={transform shape}]
\fill[red,even odd rule] \gear{10}{1.9}{1.4}{10}{2}{0.6}coordinate(GER2);
\end{scope}
%bigger
\begin{scope}[scale=0.15, every node/.append style={transform shape},
shift={(-1.8,-2.08)}]
\fill[red!50,even odd rule] \gear{10}{1.9}{1.4}{11}{2}{0.6}coordinate(GER2);
\end{scope}
\end{scope}
%
\draw[ Line,-latex](GEAR2)--++(10:1.75)
node[right,align=center,text=black]{Poisoned Model\\ Aggregation};

%Persons
\begin{scope}[shift={(-0.9,-0.16)},scale=0.5,line width=1.0pt]
\begin{scope}[shift={(0.3,0.3)}]%person2-back
\coordinate (head-center) at (0,0);
\coordinate (top) at ([yshift=-2mm]head-center);
\coordinate (left) at ([yshift=-10mm,xshift=-7mm]head-center);
\coordinate (right) at ([yshift=-10mm,xshift=7mm]head-center);
  %%
\draw[rounded corners=1.5mm,fill=Green!70]
  (top) to [out=-10,in=100]
  (right) to [bend left=15]
  (left) to [out=80,in=190]
  (top);
  \draw[fill=yellow] (head-center) circle (0.35);
\end{scope}
\begin{scope}%person1
\coordinate (head-center) at (0,0);
\coordinate (top) at ([yshift=-2mm]head-center);
\coordinate (left) at ([yshift=-10mm,xshift=-7mm]head-center);
\coordinate (right) at ([yshift=-10mm,xshift=7mm]head-center);
  %%
\draw[rounded corners=1.5mm,fill=Green!70]
  (top) to [out=-10,in=100]
  (right) to [bend left=15]
  (left) to [out=80,in=190]
  (top);
  \draw[fill=yellow] (head-center) circle (0.35);
\end{scope}
\end{scope}
%%

%display left
\node[below=9pt of cloud.80]{Server};
\begin{scope}[local bounding box=COMPUTER1,shift={(-3,-4)}]
 \node[comp](COM){};
 \draw[draw = BlueLine,line width=1.0pt]
 ($(COM.north west)!0.85!(COM.south west)$)-- ($(COM.north east)!0.85!(COM.south east)$);
\draw[draw = BlueLine,line width=1.0pt]($(COM.south west)!0.4!(COM.south east)$)--++(270:0.2)coordinate(DL);
\draw[draw = BlueLine,line width=1.0pt]($(COM.south west)!0.6!(COM.south east)$)--++(270:0.2)coordinate(DD);
\draw[draw = BlueLine,line width=3.0pt,shorten <=-3mm,shorten >=-3mm](DL)--
node[below=4pt]{Client 1}(DD);
\node[draw,GreenLine,inner sep=0pt](CB1) at ($(COM.north west)!0.25!(COM.south west)+(0.3,0)$){$\times$};
\node[draw,GreenLine,inner sep=0pt](CB2) at ($(COM.north west)!0.6!(COM.south west)+(0.3,0)$){
$\times$};
 \draw[GreenLine,decoration={zigzag,segment length=4pt, amplitude=0.5pt},decorate]($(CB1)+(0.3,0.05)$)--++(0:1.3);
\draw[GreenLine,decoration={zigzag,segment length=4pt, amplitude=0.5pt},decorate]($(CB1)+(0.3,-0.12)$)--++(0:1.0);
  \draw[GreenLine,decoration={zigzag,segment length=4pt, amplitude=0.5pt},decorate]($(CB2)+(0.3,0.05)$)--++(0:1.3);
\draw[GreenLine,decoration={zigzag,segment length=4pt, amplitude=0.5pt},decorate]($(CB2)+(0.3,-0.12)$)--++(0:1.0);
\end{scope}
%gear left
\begin{scope}[local bounding box=GEAR1,
shift={($(cloud.200)!0.1!(COM.110)+(-0.4,0)$)},scale=0.1, every node/.append style={transform shape}]
\fill[red,even odd rule] \gear{10}{1.9}{1.4}{10}{2}{0.6}coordinate(GER1);
\draw[-latex,shorten <=3mm](GER1)--++(233:9);
\end{scope}
%data left
\begin{scope}[node distance=-1.7,local bounding box = SC1,
shift={($(COM.east)+(0.7,0.3)$)},
scale=0.4, every node/.append style={transform shape}]
\node[mycylinder,fill=red!30] (A) {};
\scoped[on background layer]
\node[mycylinder, above=of A,fill=red!50] (C) {};
\node[mycylinder, below=of A,fill=red!10] (B) {};
\end{scope}
\draw[DLine](cloud.200)--(COM.110);
\draw[Line,latex-](cloud.216)--(COM.58);
%%%%%%%%%%%%%%%%%

%display right
\begin{scope}[local bounding box=COMPUTER2,shift={(3,-4)}]
\node[comp](COM2){};
 \draw[draw = BlueLine,line width=1.0pt]
 ($(COM2.north west)!0.85!(COM2.south west)$)-- ($(COM2.north east)!0.85!(COM2.south east)$);
\draw[draw = BlueLine,line width=1.0pt]($(COM2.south west)!0.4!(COM2.south east)$)--++(270:0.2)coordinate(DL2);
\draw[draw = BlueLine,line width=1.0pt]($(COM2.south west)!0.6!(COM2.south east)$)--++(270:0.2)coordinate(DD2);
\draw[draw = BlueLine,line width=3.0pt,shorten <=-3mm,shorten >=-3mm](DL2)--
node[below=4pt]{Client 2}(DD2);
\node[draw,GreenLine,inner sep=0pt](2CB1) at ($(COM2.north west)!0.25!(COM2.south west)+(0.3,0)$){$\times$};
\node[draw,GreenLine,inner sep=0pt](2CB2) at ($(COM2.north west)!0.6!(COM2.south west)+(0.3,0)$){$\times$};
 \draw[GreenLine,decoration={zigzag,segment length=4pt, amplitude=0.5pt},decorate]($(2CB1)+(0.3,0.05)$)--++(0:1.3);
\draw[GreenLine,decoration={zigzag,segment length=4pt, amplitude=0.5pt},decorate]($(2CB1)+(0.3,-0.12)$)--++(0:1.0);
  \draw[GreenLine,decoration={zigzag,segment length=4pt, amplitude=0.5pt},decorate]($(2CB2)+(0.3,0.05)$)--++(0:1.3);
\draw[GreenLine,decoration={zigzag,segment length=4pt, amplitude=0.5pt},decorate]($(2CB2)+(0.3,-0.12)$)--++(0:1.0);
\end{scope}
\draw[DLine](cloud.320)--(COM2.110);
\draw[Line,latex-](cloud.339)--(COM2.57);
%gear right
\begin{scope}[local bounding box=GEAR3,
shift={($(cloud.330)!0.25!(COM2.110)+(-0.6,0)$)},scale=0.1, every node/.append style={transform shape}]
\fill[red,even odd rule] \gear{10}{1.9}{1.4}{10}{2}{0.6}coordinate(2GER1);
\draw[-latex,shorten <=3mm](2GER1)--++(300:9);
\end{scope}
%data left
\begin{scope}[node distance=-1.7,local bounding box = SC2,
shift={($(COM2.east)+(0.7,0.3)$)},
scale=0.4, every node/.append style={transform shape}]
\node[mycylinder,fill=Green!30] (A) {};
\scoped[on background layer]
\node[mycylinder, above=of A,fill=Green!50] (C) {};
\node[mycylinder, below=of A,fill=Green!10] (B) {};
\end{scope}
%
%Legend
%Persons
\begin{scope}[local bounding box=LPER,
shift={(7.75,0.9)},scale=0.5,line width=1.0pt]
\begin{scope}[shift={(0.3,0.3)}]%person2-back
\coordinate (head-center) at (0,0);
\coordinate (top) at ([yshift=-2mm]head-center);
\coordinate (left) at ([yshift=-10mm,xshift=-7mm]head-center);
\coordinate (right) at ([yshift=-10mm,xshift=7mm]head-center);
  %%
\draw[rounded corners=1.5mm,fill=Green!70]
  (top) to [out=-10,in=100]
  (right) to [bend left=15]
  (left) to [out=80,in=190]
  (top);
  \draw[fill=yellow] (head-center) circle (0.35);
\end{scope}
\begin{scope}%person1
\coordinate (head-center) at (0,0);
\coordinate (top) at ([yshift=-2mm]head-center);
\coordinate (left) at ([yshift=-10mm,xshift=-7mm]head-center);
\coordinate (right) at ([yshift=-10mm,xshift=7mm]head-center);
  %%
\draw[rounded corners=1.5mm,fill=Green!70]
  (top) to [out=-10,in=100]
  (right) to [bend left=15]
  (left) to [out=80,in=190]
  (top);
  \draw[fill=yellow] (head-center) circle (0.35);
\end{scope}
\node[below=3pt of LPER,font=\footnotesize\usefont{T1}{phv}{m}{n}]{Owner on server};
\end{scope}
%%
%data legend1
\begin{scope}[node distance=-0.13,local bounding box = LSC2,
shift={($(LPER)+(0,-1.7)$)},
scale=0.4, every node/.append style={transform shape}]
\node[mycylinder,fill=Green!50] (A) {};
\node[mycylinder, above=of A,fill=Green!30] (C) {};
\node[mycylinder, above=of C,fill=Green!10] (B) {};
\end{scope}
\node[below=3pt of LSC2,
font=\footnotesize\usefont{T1}{phv}{m}{n}]{Local Data};
%%%
%gear legend
\begin{scope}[local bounding box=LGEAR3,
shift={($(LSC2)+(0,-1.7)$)},scale=0.25, every node/.append style={transform shape}]
\fill[draw=black,fill=red,even odd rule] \gear{10}{1.9}{1.4}{10}{2}{0.6}coordinate(2GER1);
\end{scope}
\node[below=3pt of LGEAR3,
font=\footnotesize\usefont{T1}{phv}{m}{n}]{Poisoned Global Model};
%data legend2
\begin{scope}[node distance=-0.13,local bounding box = LSC1,
shift={($(LGEAR3)+(0,-2.05)$)},
scale=0.4, every node/.append style={transform shape}]
\node[mycylinder,fill=red!50] (A) {};
\node[mycylinder, above=of A,fill=red!30] (C) {};
\node[mycylinder, above=of C,fill=red!10] (B) {};
\end{scope}
\node[below=3pt of LSC1,
font=\footnotesize\usefont{T1}{phv}{m}{n}](PLD){Poisoned Local Data};
%fitting
\scoped[on background layer]
\node[draw=BackLine,inner xsep=3mm,inner ysep=2mm,
%yshift=-2.5mm,
fill=BackColor!50,fit=(PLD)(LPER),line width=0.75pt](BB){};
 \end{tikzpicture}}
```
**Data Poisoning Attack**: Adversarial manipulation of training data introduces subtle perturbations that compromise model integrity; incremental poisoning gradually shifts model behavior over time, making detection challenging in online learning systems. This attack surface differs from adversarial examples because it targets the model *during* training rather than at inference.
:::

Insider collaboration adds a final layer of complexity. Malicious actors with legitimate access to training data, including annotators, researchers, or data vendors, can craft poisoning strategies that are more targeted and subtle than external attacks. These insiders may have knowledge of the model architecture or training procedures, giving them an advantage in designing effective poisoning schemes.

Defending against these diverse mechanisms requires a multi-pronged approach: secure data collection protocols, anomaly detection, robust preprocessing pipelines, and strong access control. Validation mechanisms must be sophisticated enough to detect not only outliers but also cleverly disguised poisoned samples that sit within the statistical norm.

#### Data Poisoning Effects on ML {#sec-robust-ai-data-poisoning-effects-ml-3ce8}

The effects of data poisoning extend far beyond simple accuracy degradation. In the most general sense, a poisoned dataset leads to a corrupted model. But the specific consequences depend on the attack vector and the adversary's objective.

One common outcome is the degradation of overall model performance. When large portions of the training set are poisoned, often through label flipping or the introduction of noisy features, the model struggles to identify valid patterns, leading to lower accuracy, recall, or precision. In mission-critical applications like medical diagnosis or fraud detection, even small performance losses can result in significant real-world harm.

Targeted poisoning presents a different kind of danger. Rather than undermining the model's general performance, these attacks cause specific misclassifications. A malware detector, for instance, may be engineered to ignore one particular signature, allowing a single attack to bypass security. Similarly, a facial recognition model might be manipulated to misidentify a specific individual, while functioning normally for others.

Some poisoning attacks introduce hidden vulnerabilities in the form of backdoors or trojans. These poisoned models behave as expected during evaluation but respond in a malicious way when presented with specific triggers. In such cases, attackers can “activate" the exploit on demand, bypassing system protections without triggering alerts.

Bias is another insidious impact of data poisoning. If an attacker poisons samples tied to a specific demographic or feature group, they can skew the model’s outputs in biased or discriminatory ways. Such attacks threaten fairness, amplify existing societal inequities, and are difficult to diagnose if the overall model metrics remain high.

Ultimately, data poisoning undermines the trustworthiness of the system itself. A model trained on poisoned data cannot be considered reliable, even if it performs well in benchmark evaluations. This erosion of trust has profound implications, particularly in fields like autonomous systems, financial modeling, and public policy.

#### Case Study: Art Protection via Poisoning {#sec-robust-ai-case-study-art-protection-via-poisoning-6106}

Interestingly, not all data poisoning is malicious. Researchers have begun to explore its use as a defensive tool, particularly in the context of protecting creative work from unauthorized use by generative AI models.

A compelling example is Nightshade, developed by researchers at the University of Chicago to help artists prevent their work from being scraped and used to train image generation models without consent [@shan2023prompt]. Nightshade allows artists to apply subtle perturbations to their images before publishing them online. These changes are invisible to human viewers but cause serious degradation in generative models that incorporate them into training.

When Stable Diffusion was trained on just 300 poisoned images, the model began producing bizarre outputs, such as cows when prompted with "car," or cat-like creatures in response to "dog." These results, visualized in @fig-poisoning, show how effectively poisoned samples can distort a model’s conceptual associations.

![**Poisoning Attack**: An incremental process where malicious samples are introduced to gradually shift model behavior during online learning. Continuous data streams can be manipulated without immediate detection through this. Source: [@shan2023prompt].](./images/png/poisoning_example.png){#fig-poisoning}

What makes Nightshade especially potent is the cascading effect of poisoned concepts. Because generative models rely on semantic relationships between categories, a poisoned “car" can bleed into related concepts like “truck," “bus," or “train," leading to widespread hallucinations.

However, like any powerful tool, Nightshade also introduces risks. The same technique used to protect artistic content could be repurposed to sabotage legitimate training pipelines, highlighting the dual-use dilemma[^fn-dualusedilemma] at the heart of modern machine learning security.

[^fn-dualusedilemma]: **Dual-use Dilemma**: In AI, the challenge of mitigating misuse of technology that has both positive and negative potential uses.

### Distribution Shifts {#sec-robust-ai-distribution-shifts-2474}

Distribution shifts represent one of the most prevalent and challenging robustness issues in deployed machine learning systems. Unlike adversarial attacks or data poisoning, distribution shifts often occur naturally as environments evolve, making them a core concern for system reliability. This section examines the characteristics of different types of distribution shifts, the mechanisms through which they occur, their impact on machine learning systems, and practical approaches for detection and mitigation.

#### Distribution Shift Properties {#sec-robust-ai-distribution-shift-properties-f87d}

Distribution shift refers to the phenomenon where the data distribution encountered by a machine learning model during deployment differs from the distribution it was trained on, challenging the generalization capabilities established through the training methodologies in @sec-ai-training and architectural design choices from @sec-dnn-architectures, as shown in @fig-distribution-shift. This change in distribution is not necessarily the result of a malicious attack. Rather, it often reflects the natural evolution of real-world environments over time. In essence, the statistical properties, patterns, or assumptions in the data may change between training and inference phases, which can lead to unexpected or degraded model performance.

::: {#fig-distribution-shift fig-env="figure" fig-pos="htb"}
```{.tikz}
\begin{tikzpicture}[font=\small\usefont{T1}{phv}{m}{n}]
\definecolor{Blue}{RGB}{0,97,168}
\definecolor{Green}{RGB}{84,180,53}
\tikzset{
 helvetica/.style={align=flush center,font=\small\usefont{T1}{phv}{m}{n}},
 Line/.style={line width=1.0pt,black!50,text=black},
  Box/.style={helvetica,
    inner xsep=0pt,outer sep=0pt,
    node distance=0,
    draw=none,
    line width=0.75pt,
    fill=Green,anchor=south west,
    minimum width=8mm, minimum height=45mm
  },
  }
% define gaussian
\pgfmathdeclarefunction{gauss}{3}{%
  \pgfmathparse{1/(#3*sqrt(2*pi))*exp(-((#1-#2)^2)/(2*#3^2))}%
}
  \def\q{8.8};
  \def\B{8.5};
  \def\S{18.5};
  \def\Bs{2.90};
  \def\Ss{3.40};
  \def\xmax{\S+3.2*\Ss};
  \def\ymin{{-0.15*gauss(\B,\B,\Bs)}};
   \begin{axis}[clip=false,every axis plot post/.append style={
               mark=none,samples=80,smooth},
               height=65mm,
               xmin=0, xmax=\xmax,
               ymin=0, ymax={1.05*gauss(\B,\B,\Bs)},
               axis x line=bottom,  % no box around the plot, only x and y axis
               axis y line=left,    % ...line*=... suppresses the arrow tips
               ticks=none,
               axis line style={thick,-latex},
               axis on top=true,
               xlabel=$z$, ylabel=$p(z)$,
               enlarge x limits=0.13,
               enlarge y limits=0.0,
               y label style={at={(axis cs:-4.10, 0.15)},rotate=270,anchor=north east},
              every axis x label/.style={at={(current axis.right of origin)},anchor=north},
              ]
    % plots
    \addplot[name path=B,thick,Green,domain=-0.8:{0.48*\xmax}] {gauss(x,\B,\Bs)};
    \addplot[name path=S,thick,Blue,domain=7.0:0.98*\xmax] {gauss(x,\S,\Ss)};
    % fill
\path[name path=xaxis] (axis cs:0,0)--(axis cs:\xmax,0);
    \addplot[Green] fill between[of=xaxis and B, soft clip={domain=-0.7:9.5}];
    \addplot[Blue]  fill between[of=xaxis and S, soft clip={domain=19:\xmax}];
%axis cs:
\coordinate (bottomLeft) at (axis cs:-0.8,-0.007);
\coordinate (bottomRight) at (axis cs:9.5,-0.007);
\coordinate (bottomLeft1) at (axis cs:19,-0.007);
\coordinate (bottomRight1) at (axis cs:\xmax,-0.007);
\draw[thick,RedLine,decoration={brace,amplitude=5pt,mirror},decorate](bottomLeft)--
node[below](LE){}(bottomRight);
\draw[thick,RedLine,decoration={brace,amplitude=5pt,mirror},decorate](bottomLeft1)--
node[below](DE){}(bottomRight1);
\node[below=6pt of $(LE)!0.5!(DE)$,text=black](DS){a) Diversity Shift};
\end{axis}
%%%%%%
\begin{scope}[local bounding box=GR1,shift={(8,0)}]
\node[Box](B1){};
\node[Box,right=of B1.south east,fill=Blue,minimum height=33mm,anchor=south west](B2){};
\node[below=2pt of $(B1.south)!0.5!(B2.south)$,text=black]{$p(y=0\mid z)$};
\path[dashed](B2.north west)--++(180:1.0)coordinate(DO1)|-coordinate(GO1)(B1.north west);
\draw[thick,RedLine,decoration={brace,amplitude=5pt},decorate](DO1)--(GO1);
%
\node[Box,right=1.2of B2.south east,fill=Green,minimum height=11mm,anchor=south west](B3){};
\node[Box,right=of B3.south east,fill=Blue,minimum height=23mm,anchor=south west](B4){};
\node[below=2pt of $(B3.south)!0.5!(B4.south)$,text=black]{$p(y=1\mid z)$};
%
\path[dashed](B4.north east)--++(0:0.2)coordinate(DO2)|-coordinate(GO2)(B3.north east);
\draw[thick,RedLine,decoration={brace,amplitude=5pt},decorate](DO2)--(GO2);
%
\path[red](DS)-|coordinate(TE3)($(B2.south)!0.5!(B3.south)$);
\node[text=black](DS)at(TE3){b) Correlation Shift};
\end{scope}

\begin{scope}[shift={($(B1.north east)+(1.4,0)$)}]
\node[Box,minimum width=7mm, minimum height=4mm](LB1){};
\node[right=3pt of LB1]{Domain 1};
\node[Box,below=0.2 of LB1,minimum width=7mm, minimum height=4mm,fill=Blue](LB2){};
\node[right=3pt of LB2]{Domain 2};
\end{scope}
\end{tikzpicture}
```
**Distribution Shift**: Small inconsistencies between training and deployment data (represented by differing distributions of spurious feature *z*) can significantly disrupt model performance, even without altering the true label *y*. This figure emphasizes how data poisoning attacks exploit distributional differences to induce model errors and emphasizes the vulnerability of machine learning systems to subtle data manipulations. Source: [@shan2023prompt].
:::

A distribution shift typically takes one of several forms:

- **Covariate shift**, where the input distribution $P(x)$ changes while the conditional label distribution $P(y \mid x)$ remains stable.
- **Label shift**, where the label distribution $P(y)$ changes while $P(x \mid y)$ stays the same.
- **Concept drift**, where the relationship between inputs and outputs, $P(y \mid x)$, evolves over time.

These formal definitions help frame more intuitive examples of shift that are commonly encountered in practice.

One of the most common causes is domain mismatch, where the model is deployed on data from a different domain than it was trained on. For example, a sentiment analysis model trained on movie reviews may perform poorly when applied to tweets, due to differences in language, tone, and structure. In this case, the model has learned domain-specific features that do not generalize well to new contexts.

Another major source is temporal drift, where the input distribution evolves gradually or suddenly over time. In production settings, data changes due to new trends, seasonal effects, or shifts in user behavior. For instance, in a fraud detection system, fraud patterns may evolve as adversaries adapt. Without ongoing monitoring or retraining, models become stale and ineffective. This form of shift is visualized in @fig-drift-over-time.

Contextual changes arise when deployment environments differ from training conditions due to external factors such as lighting, sensor variation, or user behavior. For example, a vision model trained in a lab under controlled lighting may underperform when deployed in outdoor or dynamic environments.

Another subtle but critical factor is unrepresentative training data. If the training dataset fails to capture the full variability of the production environment, the model may generalize poorly. For example, a facial recognition model trained predominantly on one demographic group may produce biased or inaccurate predictions when deployed more broadly. In this case, the shift reflects missing diversity or structure in the training data.

::: {#fig-drift-over-time fig-env="figure" fig-pos="htb"}
```{.tikz}
\scalebox{0.75}{%
\begin{tikzpicture}[font=\small\usefont{T1}{phv}{m}{n}]
% envelope style
\tikzset{
  envelope/.pic={
    \draw[thick,rounded corners=1pt,fill=red!20] (0,0) rectangle (0.5,0.3);
    \draw[thick,rounded corners=2pt,fill=red!60] (0,0.3)--(0.25,0.1)--(0.5,0.3)--cycle;
    \node[inner sep=0pt,outer sep=0pt, minimum width=0.6cm, minimum height=0.4cm] () at (0.25,0.15) {};
  }
}
\tikzset{
  envelopeB/.pic={
    \draw[thick,rounded corners=1pt,fill=black!20] (0,0) rectangle (0.5,0.3);
    \draw[thick,rounded corners=2pt,fill=black!60] (0,0.3)--(0.25,0.1)--(0.5,0.3)--cycle;
    \node[inner sep=0pt,outer sep=0pt, minimum width=0.6cm, minimum height=0.4cm] () at (0.25,0.15) {};
  }
}
%%%left
\begin{scope}[local bounding box=EN1,shift={(0,0)}]
% Axses
\draw[thick,-latex] (0,0)--(5.5,0) node[below] {Feature B};
\draw[thick,-latex] (0,0)--(0,5) node[left,yshift=-5pt] {Feature A};
% dashed red line
\draw[thick,red,dashed] (0.5,1.0) to[out=20,in=240] (5,4.5);
% red envelopes
\foreach \x/\y in {0.3/1.3,0.2/2.2,1.0/2.2,2.0/2.2,0.4/3.0,1.3/3.2,2.1/2.8,
3.0/2.9,0.8/3.8,2.0/3.5,3.1/3.5,2.6/4.1,3.7/4.4}
    \pic[red] at (\x,\y) {envelope};
% black envelopes
\foreach \x/\y in {0.7/0.3,2.7/0.23,3.9/0.2,1.3/0.85,2.1/0.6,
                             2.8/0.9,3.7/1.1,2.5/1.4,3.5/1.8,4.0/2.4}
    \pic[black] at (\x,\y) {envelopeB};
\end{scope}
%%%right
\begin{scope}[local bounding box=EN2,shift={(8.5,0)}]
% Axses
\draw[thick,-latex] (0,0)--(5.5,0) node[below] {Feature B};
\draw[thick,-latex] (0,0)--(0,5) node[left,yshift=-5pt] {Feature A};
% dashed red line
\draw[thick,red,dashed] (0.5,4.5) to[out=310,in=190] (5,2.5);
% red envelopes
\foreach \x/\y in {1.0/4.2,1.9/4.3,2.9/4.0,3.9/3.9,1.9/3.5,2.6/3.0,3.4/3.3,4.2/3.1,3.6/2.7}
    \pic[red] at (\x,\y) {envelope};

% black envelopes
\foreach \x/\y in {0.7/0.3,2.7/0.23,3.9/0.2,
1.3/1.1,2.1/0.6,2.9/0.9,3.9/1.1,2.5/1.7,3.5/1.8,0.7/3.1,1.7/2.4,0.9/1.9}
    \pic[black] at (\x,\y) {envelopeB};
\end{scope}
\node[below=-7pt of EN1](T0){T = 0};
\node[below=-7pt of EN2](T1){T = 1};

\begin{scope}[local bounding box=LEG,
shift={($(EN1.east)!0.8!(EN2.west)+(-1,1)$)}]

\pic(PP1)[red]{envelope};
\node[anchor=west](SP) at (PP1.east) {Spam};
\pic(PP2)[black,anchor=west]at($(PP1)+(-0.24,-0.8)$){envelopeB};
\node[anchor=west](NSP) at (PP2) {Not spam};
%
%fitting
\scoped[on background layer]
\node[draw=BackLine,inner xsep=2mm,inner ysep=1mm,
fill=BackColor!50,fit=(PP1)(SP)(NSP),line width=0.75pt](BB){};
\end{scope}
\end{tikzpicture}}
```
**Temporal Drift**: Shifting data distributions over time degrade model performance unless systems adapt through continuous monitoring and retraining. Concept drift manifests as changes in input patterns—such as evolving fraud schemes or seasonal trends—that require models to learn new relationships and maintain accuracy in dynamic environments.
:::

Distribution shifts like these can dramatically reduce the performance and reliability of ML models in production. Building robust systems requires not only understanding these shifts, but actively detecting and responding to them as they emerge.

Tesla's Autopilot system demonstrates how distribution shifts in real-world deployment can challenge even sophisticated ML systems. Vision systems trained primarily on highway driving data showed degraded performance in construction zones, unusual road configurations, and varying weather conditions that differed significantly from training scenarios. The system struggled with edge cases like construction barriers, unusual lane markings, and temporary traffic patterns not well-represented in training data. This highlights the critical importance of diverse training data collection and robust handling of distribution shift, particularly in safety-critical applications where edge cases can have severe consequences.

#### Distribution Shift Mechanisms {#sec-robust-ai-distribution-shift-mechanisms-f5e3}

Distribution shifts arise from a variety of underlying mechanisms—both natural and system-driven. Understanding these mechanisms helps practitioners detect, diagnose, and design mitigation strategies.

One common mechanism is a change in data sources. When data collected at inference time comes from different sensors, APIs, platforms, or hardware than the training data, even subtle differences in resolution, formatting, or noise can introduce significant shifts. For example, a speech recognition model trained on audio from one microphone type may struggle with data from a different device.

Temporal evolution refers to changes in the underlying data over time. In recommendation systems, user preferences shift. In finance, market conditions change. These shifts may be slow and continuous or abrupt and disruptive. Without temporal awareness or continuous evaluation, models can become obsolete, frequently without prior indication. To illustrate this, @fig-temporal-evolution shows how selective breeding over generations has significantly changed the physical characteristics of a dog breed. The earlier version of the breed exhibits a lean, athletic build, while the modern version is stockier, with a distinctively different head shape and musculature. This transformation is analogous to how data distributions can shift in real-world systems—initial data used to train a model may differ substantially from the data encountered over time. Just as evolutionary pressures shape biological traits, dynamic user behavior, market forces, or changing environments can shift the distribution of data in machine learning applications. Without periodic retraining or adaptation, models exposed to these evolving distributions may underperform or become unreliable.

![**Breed Evolution**: Selective breeding over generations produces substantial shifts in phenotypic characteristics, mirroring how data distributions change in machine learning systems over time. These temporal shifts necessitate model retraining or adaptation to maintain performance, as initial training data may no longer accurately represent current input distributions.](./images/png/temporal_evoltion.png){#fig-temporal-evolution}

Domain-specific variation arises when a model trained on one setting is applied to another. A medical diagnosis model trained on data from one hospital may underperform in another due to differences in equipment, demographics, or clinical workflows. These variations often require explicit adaptation strategies, such as domain generalization or fine-tuning.

Selection bias occurs when the training data does not accurately reflect the target population. This may result from sampling strategies, data access constraints, or labeling choices. The result is a model that overfits to specific segments and fails to generalize. Addressing this requires thoughtful data collection and continuous validation.

Feedback loops are a particularly subtle mechanism. In some systems, model predictions influence user behavior, which in turn affects future inputs. For instance, a dynamic pricing model might set prices that change buying patterns, which then distort the distribution of future training data. These loops can reinforce narrow patterns and make model behavior difficult to predict.

Lastly, adversarial manipulation can induce distribution shifts deliberately. Attackers may introduce out-of-distribution samples or craft inputs that exploit weak spots in the model’s decision boundary. These inputs may lie far from the training distribution and can cause unexpected or unsafe predictions.

These mechanisms often interact, making real-world distribution shift detection and mitigation complex. From a systems perspective, this complexity necessitates ongoing monitoring, logging, and feedback pipelines—features often absent in early-stage or static ML deployments.

#### Distribution Shift Effects on ML {#sec-robust-ai-distribution-shift-effects-ml-752d}

Distribution shift can affect nearly every dimension of ML system performance, from prediction accuracy and latency to user trust and system maintainability.

A common and immediate consequence is degraded predictive performance. When the data at inference time differs from training data, the model may produce systematically inaccurate or inconsistent predictions. This erosion of accuracy is particularly dangerous in high-stakes applications like fraud detection, autonomous vehicles, or clinical decision support.

Another serious effect is loss of reliability and trustworthiness. As distribution shifts, users may notice inconsistent or erratic behavior. For example, a recommendation system might begin suggesting irrelevant or offensive content. Even if overall accuracy metrics remain acceptable, loss of user trust can undermine the system’s value.

Distribution shift also amplifies model bias. If certain groups or data segments are underrepresented in the training data, the model may fail more frequently on those groups. Under shifting conditions, these failures can become more pronounced, resulting in discriminatory outcomes or fairness violations.

ML models trained on data from specific hospitals frequently show degraded performance when deployed at different institutions, illustrating a classic distribution shift problem in healthcare. Models trained at academic medical centers with specific patient populations, equipment types, and clinical protocols failed to generalize to community hospitals with different demographics, imaging equipment, and clinical workflows. For example, diagnostic models trained on data from one hospital's CT scanners showed reduced accuracy when applied to images from different scanner manufacturers or imaging protocols. This demonstrates how seemingly minor differences in data collection procedures and equipment can create significant distribution shifts that impact model performance and potentially patient safety.

Uncertainty and operational risk also increase. In many production settings, model decisions feed directly into business operations or automated actions. Under shift, these decisions become less predictable and harder to validate, increasing the risk of cascading failures or poor decisions downstream.

From a system maintenance perspective, distribution shifts complicate retraining and deployment workflows. Without robust mechanisms for drift detection and performance monitoring, shifts may go unnoticed until performance degrades significantly. Once detected, retraining may be required—raising challenges related to data collection, labeling, model rollback, and validation. This creates friction in continuous integration and deployment (CI/CD) workflows and can significantly slow down iteration cycles.

Distribution shift also increases vulnerability to adversarial attacks. Attackers can exploit the model's poor calibration on unfamiliar data, using slight perturbations to push inputs outside the training distribution and cause failures. This is especially concerning when system feedback loops or automated decisioning pipelines are in place.

From a systems perspective, distribution shift is not just a modeling concern—it is a core operational challenge. It requires end-to-end system support: mechanisms for data logging, drift detection, automated alerts, model versioning, and scheduled retraining. ML systems must be designed to detect when performance degrades in production, diagnose whether a distribution shift is the cause, and trigger appropriate mitigation actions. This might include human-in-the-loop review, fallback strategies, model retraining pipelines, or staged deployment rollouts.

In mature ML systems, handling distribution shift becomes a matter of infrastructure, observability, and automation, not just modeling technique. Failing to account for it risks silent model failure in dynamic, real-world environments—precisely where ML systems are expected to deliver the most value.

A summary of common types of distribution shifts, their effects on model performance, and potential system-level responses is shown in @tbl-distribution-shift-summary.

| Type of Shift            | Cause or Example                                                     | Consequence for Model                                      | System-Level Response                                      |
|--------------------------|----------------------------------------------------------------------|------------------------------------------------------------|------------------------------------------------------------|
| Covariate Shift          | Change in input features (e.g., sensor calibration drift)            | Model misclassifies new inputs despite consistent labels   | Monitor input distributions; retrain with updated features |
| Label Shift              | Change in label distribution (e.g., new class frequencies in usage)  | Prediction probabilities become skewed                     | Track label priors; reweight or adapt output calibration   |
| Concept Drift            | Evolving relationship between inputs and outputs (e.g. fraud tactics)| Model performance degrades over time                       | Retrain frequently; use continual or online learning       |
| Domain Mismatch          | Train on reviews, deploy on tweets                                   | Poor generalization due to different vocabularies or styles| Use domain adaptation or fine-tuning                       |
| Contextual Change        | New deployment environment (e.g., lighting, user behavior)           | Performance varies by context                              | Collect contextual data; monitor conditional accuracy      |
| Selection Bias           | Underrepresentation during training                                  | Biased predictions for unseen groups                       | Validate dataset balance; augment training data            |
| Feedback Loops           | Model outputs affect future inputs (e.g., recommender systems)       | Reinforced drift, unpredictable patterns                   | Monitor feedback effects; consider counterfactual logging  |
| Adversarial Shift        | Attackers introduce OOD inputs or perturbations                      | Model becomes vulnerable to targeted failures              | Use robust training; detect out-of-distribution inputs     |

: **Distribution Shift Types**: Real-world ML systems encounter various forms of distribution shift—including covariate, concept, and prior shift—that degrade performance by altering the relationship between inputs and outputs, or the prevalence of different outcomes. Understanding these shifts and implementing system-level mitigations—such as monitoring, adaptive learning, and robust training—is crucial for maintaining reliable performance in dynamic environments. {#tbl-distribution-shift-summary}

#### System Implications of Distribution Shifts {#sec-robust-ai-system-implications-distribution-shifts-9388}

### Input Attack Detection and Defense {#sec-robust-ai-input-attack-detection-defense-19d3}

Building on the theoretical understanding of model vulnerabilities, we now examine practical defense strategies.

#### Adversarial Attack Defenses {#sec-robust-ai-adversarial-attack-defenses-1dc8}

Having established the mechanisms and impacts of adversarial attacks, we examine their detection and defense.

##### Detection Techniques {#sec-robust-ai-detection-techniques-0e7e}

Detecting adversarial examples is the first line of defense against adversarial attacks. Several techniques have been proposed to identify and flag suspicious inputs that may be adversarial.

Statistical methods represent one approach to detecting adversarial examples by analyzing the distributional properties of input data. These methods compare the input data distribution to a reference distribution, such as the training data distribution or a known benign distribution. Techniques like the [Kolmogorov-Smirnov](https://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm) [@berger2014kolmogorov] test[^fn-ks-test] or the [Anderson-Darling](https://www.itl.nist.gov/div898/handbook/eda/section3/eda35e.htm) test can measure the discrepancy between distributions and flag inputs that deviate significantly from the expected distribution.

[^fn-ks-test]: **Kolmogorov-Smirnov Test**: Non-parametric statistical test developed by Kolmogorov (1933) and Smirnov (1939) to compare probability distributions. In adversarial detection, K-S tests compare input feature distributions against training data, with p-values <0.05 indicating potential adversarial manipulation. Computationally efficient (O(n log n)) but limited to univariate distributions, requiring dimension reduction for high-dimensional inputs like images.

Beyond distributional analysis, input transformation methods offer an alternative detection strategy. Feature squeezing[^fn-feature-squeezing] [@panda2019discretization] reduces input space complexity through dimensionality reduction or discretization, eliminating the small, imperceptible perturbations that adversarial examples typically rely on.

[^fn-feature-squeezing]: **Feature Squeezing**: Defense technique that reduces input complexity by limiting precision (e.g., 8-bit to 4-bit quantization) or spatial resolution (e.g., median filtering). Proposed by Xu et al. in 2017, feature squeezing exploits the fact that adversarial perturbations often require high precision to be effective. Reduction from 256 to 16 color levels can eliminate 70-90% of adversarial examples while maintaining 95%+ clean accuracy, making it practical for real-time deployment. Inconsistencies between model predictions on original and squeezed inputs indicate potential adversarial manipulation.

Model uncertainty estimation provides yet another detection paradigm by quantifying the confidence associated with predictions. Since adversarial examples often exploit regions of high uncertainty in the model's decision boundary, inputs with elevated uncertainty can be flagged as suspicious. Several approaches exist for uncertainty estimation, each with distinct trade-offs between accuracy and computational cost.

Bayesian neural networks[^fn-bayesian-nn] provide the most principled uncertainty estimates by treating model weights as probability distributions, capturing both aleatoric (data inherent) and epistemic (model) uncertainty through approximate inference methods. Ensemble methods (detailed further in @sec-robust-ai-defense-strategies-cb2d) achieve uncertainty estimation by combining predictions from multiple independently trained models, using prediction variance as an uncertainty measure. While both approaches offer robust uncertainty quantification, they incur significant computational overhead.

[^fn-bayesian-nn]: **Bayesian Neural Networks**: Advanced neural network architectures that incorporate probabilistic inference by treating weights as probability distributions rather than fixed values. This specialized approach requires understanding of basic neural network concepts covered in @sec-dl-primer.

Dropout[^fn-dropout], originally designed as a regularization technique to prevent overfitting during training [@hinton2012improvingneuralnetworkspreventing], works by randomly deactivating a fraction of neurons during each training iteration, forcing the network to avoid over-reliance on specific neurons and improving generalization. This mechanism can be repurposed for uncertainty estimation through Monte Carlo dropout at inference time, where multiple forward passes with different dropout masks approximate the uncertainty distribution. However, this approach provides less precise uncertainty estimates since dropout was not specifically designed for uncertainty quantification but rather for preventing overfitting through enforced redundancy. Hybrid approaches that combine dropout with lightweight ensemble methods or Bayesian approximations can balance computational efficiency with estimation quality, making uncertainty-based detection more practical for real-world deployment.

[^fn-dropout]: **Dropout Mechanism**: A regularization technique that randomly deactivates neurons during training to prevent overfitting and improve generalization. This method requires understanding of neural network architecture and training processes detailed in @sec-dl-primer.

##### Defense Strategies {#sec-robust-ai-defense-strategies-cb2d}

Once adversarial examples are detected, various defense strategies can be employed to mitigate their impact and improve the robustness of ML models.

Adversarial training is a technique that involves augmenting the training data with adversarial examples and retraining the model on this augmented dataset. Exposing the model to adversarial examples during training teaches it to classify them correctly and becomes more robust to adversarial attacks. @lst-adversarial-training demonstrates the core implementation pattern.

Adversarial training provides improved robustness but comes with significant computational overhead that must be carefully managed in production systems.

Training time increases 3-10$\times$ due to adversarial example generation during each training step. On-the-fly adversarial example generation requires additional forward and backward passes through the model, substantially increasing computational requirements. Memory requirements increase 2-3$\times$ for storing both clean and adversarial examples, along with gradients computed during attack generation. Specialized infrastructure may be needed for efficient adversarial example generation, particularly when using iterative attacks like PGD that require multiple optimization steps.

Robust models typically sacrifice 2-8% clean accuracy for improved adversarial robustness, representing a fundamental trade-off in the robust optimization objective. Inference time may increase if ensemble methods or uncertainty estimation techniques are integrated with adversarial training. Model size often increases with robustness-enhancing architectural modifications, such as wider networks or additional normalization layers that improve gradient stability.

Hyperparameter tuning becomes significantly more complex when balancing robustness and performance objectives. Validation procedures must evaluate both clean and adversarial performance using multiple attack methods to ensure comprehensive robustness assessment. Deployment infrastructure must support the additional computational requirements for adversarial training, including GPU memory for gradient computation and storage for adversarial example caches.

::: {#lst-adversarial-training lst-cap="**Adversarial Training Implementation**: Practical adversarial training using FGSM to generate adversarial examples during training, mixing clean and perturbed data to improve model robustness against gradient-based attacks."}
```python
def adversarial_training_step(model, data, labels, epsilon=0.1):
    # Generate adversarial examples using FGSM
    data.requires_grad_(True)
    outputs = model(data)
    loss = F.cross_entropy(outputs, labels)

    model.zero_grad()
    loss.backward()

    # Create adversarial perturbation and mix with clean data
    adv_data = data + epsilon * data.grad.sign()
    adv_data = torch.clamp(adv_data, 0, 1)

    mixed_data = torch.cat([data, adv_data])
    mixed_labels = torch.cat([labels, labels])

    return F.cross_entropy(model(mixed_data), mixed_labels)
```
:::

The implementation in @lst-adversarial-training generates adversarial examples on-the-fly during training by computing gradients with respect to input data (line 2190), applying the sign function to extract perturbation direction (line 2196), and mixing the resulting adversarial examples with clean training data (lines 2199-2200). The `torch.clamp()` operation ensures pixel values remain valid, while the final concatenation doubles the effective batch size by combining clean and adversarial examples. This approach requires careful tuning of the perturbation budget $\epsilon$ and typically increases training time by 2-3$\times$ compared to standard training [@shafahi2019adversarial].

Production deployment patterns, MLOps pipeline integration, and monitoring strategies for robust ML systems are covered in detail in @sec-ml-operations, while distributed robustness coordination and fault tolerance at scale are addressed in distributed training contexts within @sec-ai-training.

Defensive distillation [@papernot2016distillation] is a technique that trains a second model (the student model) to mimic the behavior of the original model (the teacher model). The student model is trained on the soft labels produced by the teacher model, which are less sensitive to small perturbations. Using the student model for inference can reduce the impact of adversarial perturbations, as the student model learns to generalize better and is less sensitive to adversarial noise.

Input preprocessing and transformation techniques try to remove or mitigate the effect of adversarial perturbations before feeding the input to the ML model. These techniques include image denoising, JPEG compression, random resizing, padding, or applying random transformations to the input data. By reducing the impact of adversarial perturbations, these preprocessing steps can help improve the model's robustness to adversarial attacks.

Ensemble methods combine multiple models to make more robust predictions. The ensemble can reduce the impact of adversarial attacks by using a diverse set of models with different architectures, training data, or hyperparameters. Adversarial examples that fool one model may not fool others in the ensemble, leading to more reliable and robust predictions. Model diversification techniques, such as using different preprocessing techniques or feature representations for each model in the ensemble, can further enhance the robustness.

##### Evaluation and Testing {#sec-robust-ai-evaluation-testing-4b54}

Conduct thorough evaluation and testing to assess the effectiveness of adversarial defense techniques and measure the robustness of ML models.

Adversarial robustness metrics quantify the model's resilience to adversarial attacks. These metrics can include the model's accuracy on adversarial examples, the average distortion required to fool the model, or the model's performance under different attack strengths. By comparing these metrics across different models or defense techniques, practitioners can assess and compare their robustness levels.

Standardized adversarial attack benchmarks and datasets provide a common ground for evaluating and comparing the robustness of ML models. These benchmarks include datasets with pre-generated adversarial examples and tools and frameworks for generating adversarial attacks. Examples of popular adversarial attack benchmarks include the [MNIST-C](https://github.com/google-research/mnist-c), [CIFAR-10-C](https://paperswithcode.com/dataset/cifar-10c), and ImageNet-C [@hendrycks2019benchmarking] datasets, which contain corrupted or perturbed versions of the original datasets.

Practitioners can develop more robust systems by leveraging the detection techniques and defense strategies outlined in this section. Adversarial robustness remains an ongoing research area requiring multi-layered approaches that combine multiple defense mechanisms and regular testing against evolving threats.

#### Data Poisoning Defenses {#sec-robust-ai-data-poisoning-defenses-d070}

Data poisoning attacks aim to corrupt training data used to build ML models, targeting the data collection and preprocessing stages detailed in @sec-data-engineering, undermining their integrity. As illustrated in @fig-adversarial-attack-injection, these attacks can manipulate or pollute the training data in ways that cause models to learn incorrect patterns, leading to erroneous predictions or undesirable behaviors when deployed. Given the foundational role of training data in ML system performance, detecting and mitigating data poisoning is critical for maintaining model trustworthiness and reliability.

::: {#fig-adversarial-attack-injection fig-env="figure" fig-pos="htb"}
```{.tikz}
\begin{tikzpicture}[line join=round,font=\small\usefont{T1}{phv}{m}{n}]
\definecolor{Green}{RGB}{84,180,53}
\definecolor{Red}{RGB}{249,56,39}
\definecolor{Blue}{RGB}{0,97,168}
\definecolor{Violet}{RGB}{178,108,186}
 \tikzset{
doubleL/.style={-{Triangle[length=0.44cm,width=0.62cm]},line width=2.5mm,text=black},
Line/.style={line width=1.0pt,Violet,text=black},
DLine/.style={dashed,line width=1.0pt,Violet,text=black}
}
\definecolor{Blue1}{RGB}{23,68,150}
\definecolor{Blue2}{RGB}{84,131,217}
\definecolor{Blue3}{RGB}{145,177,237}

\begin{scope}[local bounding box=MAT]
\def\columns{6}
\def\rows{7}
\def\cellsize{6mm}
\def\cellheight{4mm}
\def\rowone{Red,Red,Red,Red,Red,Red}
\def\rowtwo{Red,Red,Red,Red,Red,Red}
\def\br{A}
%
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \node[draw=black, fill=green!30, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {};
    }
}
%
\foreach \color [count=\x] in \rowone {
    \node[fill=\color,draw=black,line width=0.5pt, minimum size=\cellsize,
    minimum height=\cellheight] at (cell-\x-6\br) {};
}
\foreach \color [count=\x] in \rowtwo {
    \node[fill=\color,draw=black,line width=0.5pt, minimum size=\cellsize,
               minimum height=\cellheight] at (cell-\x-7\br) {};
}
\end{scope}
%defender
\begin{scope}[local bounding box=DEF,
shift={($(MAT)+(0,-3.5)$)},scale=0.7,line width=1.0pt]
\coordinate (head-center) at (0,0);
\coordinate (top) at ([yshift=-2mm]head-center);
\coordinate (left) at ([yshift=-10mm,xshift=-7mm]head-center);
\coordinate (right) at ([yshift=-10mm,xshift=7mm]head-center);
  %%
\draw[rounded corners=1.5mm,fill=Green!70]
  (top) to [out=-10,in=100]
  (right) to [bend left=15]
  (left) to [out=80,in=190]
  (top);
\draw[fill=yellow] (head-center) circle (0.35);
\node[circle,inner sep=0pt,minimum width=2pt,
minimum height=2pt,fill=black](OKO1)at($(head-center)+(0.17,0.1)$){};
\node[circle,inner sep=0pt,minimum width=2pt,
minimum height=2pt,fill=black](OKO2)at($(head-center)+(-0.17,0.1)$){};
\draw[]($(OKO2)+(0,-0.2)$)to[bend right=40]($(OKO1)+(0,-0.2)$);
\end{scope}

%atacker
\begin{scope}[local bounding box=ATA,
shift={($(cell-1-6A)!0.1!(cell-1-7A)+(-4.5,0)$)},scale=0.7,line width=1.0pt]
\coordinate (HC) at (0,0);
\coordinate (top) at ([yshift=-2mm]HC);
\coordinate (left) at ([yshift=-10mm,xshift=-7mm]HC);
\coordinate (right) at ([yshift=-10mm,xshift=7mm]HC);
\draw[rounded corners=1.5mm,fill=black]
  (top) to [out=-10,in=100]
  (right) to [bend left=15]
  (left) to [out=80,in=190]
  (top);
\draw[fill=black] (HC) circle (0.35)coordinate(GL);
%
\node[ellipse,inner sep=0pt,minimum width=3pt,
minimum height=2pt,fill=white](OKO1)at($(HC)+(0.17,0.1)$){};
\node[ellipse,inner sep=0pt,minimum width=3pt,
minimum height=2pt,fill=white](OKO2)at($(HC)+(-0.17,0.1)$){};
\draw[white]($(OKO2)+(0,-0.25)$)to[bend left=40]($(OKO1)+(0,-0.25)$);
\end{scope}
%Poisoned Model
\begin{scope}[local bounding box=POI,line width=0.5pt,
shift={($(cell-6-6A)!0.7!(cell-6-7A)+(4.5,0)$)}]
\newcommand{\Depth}{1.8}
\newcommand{\Height}{1.4}
\newcommand{\Width}{1.4}
\coordinate (O2) at (0,0,0);
\coordinate (A2) at (0,\Width,0);
\coordinate (B2) at (0,\Width,\Height);
\coordinate (C2) at (0,0,\Height);
\coordinate (D2) at (\Depth,0,0);
\coordinate (E2) at (\Depth,\Width,0);
\coordinate (F2) at (\Depth,\Width,\Height);
\coordinate (G2) at (\Depth,0,\Height);

\draw[fill=OrangeLine!80] (D2) -- (E2) -- (F2) -- (G2) -- cycle;% Right Face
\draw[fill=OrangeLine!50] (C2) -- (B2) -- (F2) -- (G2) -- (C2);% Front Face
\draw[fill=OrangeLine!20] (A2) -- (B2) -- (F2) -- (E2) -- cycle;% Top Face
%
\node[align=center]at($(B2)!0.5!(G2)$){Poisoned\\ Model};
\end{scope}
%arrows
\draw[doubleL,Blue]($(DEF)+(0.7,0)$)coordinate(LE)-|coordinate(DE)($(POI)+(0,-1.2)$);
\draw[doubleL,Blue]($(DEF)+(0,0.7)$)--
node[right=5pt,align=center,text=black]{Analyze\\ and clean}($(MAT)+(0,-1.52)$);
\node[below=0.1 of DEF]{\textbf{Defender}};
\node[below=0.1 of ATA]{\textbf{Attacker}};
\draw[doubleL,VioletLine!60]($(ATA)+(0.7,0)$)--
node[below=5pt,align=center,text=black]{Malicious data\\ injection}
++(0:3.3);
\draw[doubleL,VioletLine!60]($(cell-6-6A)!0.7!(cell-6-7A)+(0.6,0)$)--
node[below=5pt,align=center,text=black]{Train}
++(0:3.2);
%
\node[font=\huge\usefont{T1}{phv}{m}{n}\bfseries,VioletLine]at($(cell-1-1A)!0.5!(cell-6-7A)$){R};
\node[above=0.1 of MAT]{Item};
\node[left=0.1 of MAT]{User};
%%%
%%
\begin{scope}[local bounding box=MAT1,
shift={($(LE)!0.35!(DE)+(0,1.1)$)},scale=0.7, every node/.append style={transform shape}]
\def\columns{6}
\def\rows{5}
\def\cellsize{3mm}
\def\cellheight{2mm}
\def\br{B}
%
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \node[draw=black, fill=green!30, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {};
    }
}
\end{scope}
\node[right=0.1 of MAT1]{Retrain};
\end{tikzpicture}
```
**Data Poisoning Attack**: Adversaries inject malicious data into the training set to manipulate model behavior, potentially causing misclassification or performance degradation during deployment. This attack emphasizes the vulnerability of machine learning systems to compromised data integrity and the need for robust data validation techniques. *Source: [li](HTTPS://www.mdpi.com/2227-7390/12/2/247)*
:::

##### Anomaly Detection Techniques {#sec-robust-ai-anomaly-detection-techniques-bc27}

Statistical outlier detection methods identify data points that deviate significantly from most data. These methods assume that poisoned data instances are likely to be statistical outliers. Techniques such as the [Z-score method](https://ubalt.pressbooks.pub/mathstatsguides/chapter/z-score-basics/), [Tukey's method](https://www.itl.nist.gov/div898/handbook/prc/section4/prc471.htm), or the [Mahalanobis distance](https://www.statisticshowto.com/mahalanobis-distance/) can be used to measure the deviation of each data point from the central tendency of the dataset. Data points that exceed a predefined threshold are flagged as potential outliers and considered suspicious for data poisoning.

Clustering-based methods group similar data points together based on their features or attributes. The assumption is that poisoned data instances may form distinct clusters or lie far away from the normal data clusters. By applying clustering algorithms like [K-means](https://www.oreilly.com/library/view/data-algorithms/9781491906170/ch12.html), [DBSCAN](https://www.oreilly.com/library/view/machine-learning-algorithms/9781789347999/50efb27d-abbe-4855-ad81-a5357050161f.xhtml), or [hierarchical clustering](https://www.oreilly.com/library/view/cluster-analysis-5th/9780470978443/chapter04.html), anomalous clusters or data points that do not belong to any cluster can be identified. These anomalous instances are then treated as potentially poisoned data.

Autoencoders[^fn-autoencoders] are neural networks trained to reconstruct the input data from a compressed representation, as shown in @fig-autoencoder. They can be used for anomaly detection by learning the normal patterns in the data and identifying instances that deviate from them. During training, the autoencoder is trained on clean, unpoisoned data. At inference time, the reconstruction error for each data point is computed. Data points with high reconstruction errors are considered abnormal and potentially poisoned, as they do not conform to the learned normal patterns.

[^fn-autoencoders]: **Autoencoders**: Specialized neural network architectures designed to learn efficient data representations by training to reconstruct input data from compressed encodings. This architecture requires foundational knowledge of neural networks covered in @sec-dl-primer.

::: {#fig-autoencoder fig-env="figure" fig-pos="htb"}
```{.tikz}
\begin{tikzpicture}[line join=round,font=\usefont{T1}{phv}{m}{n}]
\def\cellsize{6mm}
\def\cellheight{6mm}

\tikzset{%
Line/.style={dashed,line width=1.0pt,black!60}
}

\begin{scope}[local bounding box=SRE]
\def\columns{1}
\def\rows{3}
\def\br{A}
%
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \node[draw=black, fill=VioletL, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {};
    }
}
\end{scope}
\begin{scope}[local bounding box=SRED1,shift={(2.25,1)}]
\def\columns{1}
\def\rows{6}
\def\br{A1}
%
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \node[draw=black, fill=orange!40, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {};
    }
}
\end{scope}
\begin{scope}[local bounding box=SRED2,shift={(5,1.5)}]
\def\columns{1}
\def\rows{8}
\def\br{A2}
%
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \node[draw=black, fill=BlueL, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {};
    }
}
\end{scope}
\begin{scope}[local bounding box=SRED3,shift={(8,2)}]
\def\columns{1}
\def\rows{10}
\def\br{A3}
%
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \node[draw=black, fill=GreenL, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {};
    }
}
\end{scope}
%%%%%%%%%%%%%%%LEFT
\begin{scope}[local bounding box=LSRED1,shift={(-2.25,1)},]
\def\columns{1}
\def\rows{6}
\def\br{LA1}
%
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \node[draw=black, fill=orange!40, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {};
    }
}
\end{scope}
\begin{scope}[local bounding box=LSRED2,shift={(-5,1.5)}]
\def\columns{1}
\def\rows{8}
\def\br{LA2}
%
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \node[draw=black, fill=BlueL, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {};
    }
}
\end{scope}
\begin{scope}[local bounding box=LSRED3,shift={(-8,2)}]
\def\columns{1}
\def\rows{10}
\def\br{LA3}
%
\foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \node[draw=black, fill=GreenL, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {};
    }
}
\end{scope}
%
\node[above=0.1 of SRE]{Code};
\node[above=0.1 of SRED3]{Output};
\node[above=0.1 of LSRED3]{Input};
%%
%dashed line
%up
\draw[Line](cell-1-1LA3.north east)--(cell-1-1LA2.north west);
%down
\draw[Line](cell-1-10LA3.south east)--(cell-1-8LA2.south west);
%up to down
\draw[Line](cell-1-1LA3.north east)--(cell-1-8LA2.south west);
%down to up
\draw[Line](cell-1-10LA3.south east)--(cell-1-1LA2.north west);
%%
\draw[Line](cell-1-1LA2.north east)--(cell-1-1LA1.north west);
\draw[Line](cell-1-8LA2.south east)--(cell-1-6LA1.south west);
\draw[Line](cell-1-1LA2.north east)--(cell-1-6LA1.south west);
\draw[Line](cell-1-8LA2.south east)--(cell-1-1LA1.north west);
%%
\draw[Line](cell-1-1LA1.north east)--(cell-1-1A.north west);
\draw[Line](cell-1-6LA1.south east)--(cell-1-3A.south west);
\draw[Line](cell-1-1LA1.north east)--(cell-1-3A.south west);
\draw[Line](cell-1-6LA1.south east)--(cell-1-1A.north west);
%RIGHT
\draw[Line](cell-1-1A3.north west)--(cell-1-1A2.north east);
\draw[Line](cell-1-10A3.south west)--(cell-1-8A2.south east);
\draw[Line](cell-1-1A3.north west)--(cell-1-8A2.south east);
\draw[Line](cell-1-10A3.south west)--(cell-1-1A2.north east);
%
\draw[Line](cell-1-1A2.north west)--(cell-1-1A1.north east);
\draw[Line](cell-1-8A2.south west)--(cell-1-6A1.south east);
\draw[Line](cell-1-1A2.north west)--(cell-1-6A1.south east);
\draw[Line](cell-1-8A2.south west)--(cell-1-1A1.north east);
%%
\draw[Line](cell-1-1A1.north west)--(cell-1-1A.north east);
\draw[Line](cell-1-6A1.south west)--(cell-1-3A.south east);
\draw[Line](cell-1-1A1.north west)--(cell-1-3A.south east);
\draw[Line](cell-1-6A1.south west)--(cell-1-1A.north east);
\coordinate(L1)at($(cell-1-10LA3.south west)+(0,-0.5)$);
\path[red](L1)-|coordinate(L2)(cell-1-6LA1.south east);
\coordinate(D1)at($(cell-1-10A3.south east)+(0,-0.5)$);
\path[red](D1)-|coordinate(D2)(cell-1-6A1.south west);
%
\draw[red,thick,decoration={brace,amplitude=9pt,mirror},decorate](L1)--
node[below=9pt]{Encoder}(L2);
\draw[red,thick,decoration={brace,amplitude=9pt},decorate](D1)--
node[below=9pt]{Decoder}(D2);
\end{tikzpicture}
```
**Autoencoder Architecture**: Autoencoders learn compressed data representations by minimizing reconstruction error, enabling anomaly detection by identifying inputs with high reconstruction loss. During training on normal data, the network learns efficient encoding and decoding, making it sensitive to deviations indicative of potential poisoning attacks. *Source: [dertat](HTTPS://medium.com/towards-data-science/applied-deep-learning-part-3-autoencoders-1c083af4d798)*
:::

##### Sanitization and Preprocessing {#sec-robust-ai-sanitization-preprocessing-f883}

Data poisoning can be avoided by cleaning data, which involves identifying and removing or correcting noisy, incomplete, or inconsistent data points. Techniques such as data deduplication, missing value imputation, and outlier removal can be applied to improve the quality of the training data. By eliminating or filtering out suspicious or anomalous data points, the impact of poisoned instances can be reduced.

Data validation involves verifying the integrity and consistency of the training data. This can include checking for data type consistency, range validation, and cross-field dependencies. By defining and enforcing data validation rules, anomalous or inconsistent data points indicative of data poisoning can be identified and flagged for further investigation.

Data provenance and lineage tracking involve maintaining a record of data's origin, transformations, and movements throughout the ML pipeline. By documenting the data sources, preprocessing steps, and any modifications made to the data, practitioners can trace anomalies or suspicious patterns back to their origin. This helps identify potential points of data poisoning and facilitates the investigation and mitigation process.

##### Robust Training {#sec-robust-ai-robust-training-37d6}

Robust optimization techniques can be used to modify the training objective to minimize the impact of outliers or poisoned instances. This can be achieved by using robust loss functions less sensitive to extreme values, such as the Huber loss or the modified Huber loss[^fn-huber-loss]. Regularization techniques[^fn-regularization], such as [L1 or L2 regularization](https://medium.com/towards-data-science/l1-and-l2-regularization-methods-ce25e7fc831c), can also help in reducing the model's sensitivity to poisoned data by constraining the model's complexity and preventing overfitting.

[^fn-huber-loss]: **Huber Loss**: A loss function used in robust regression that is less sensitive to outliers in data than squared error loss.

[^fn-regularization]: **Regularization**: A method used in neural networks to prevent overfitting in models by adding a cost term to the loss function.

Robust loss functions are designed to be less sensitive to outliers or noisy data points. Examples include the modified [Huber loss](https://pytorch.org/docs/stable/generated/torch.nn.HuberLoss.html), the Tukey loss [@beaton1974fitting], and the trimmed mean loss. These loss functions down-weight or ignore the contribution of abnormal instances during training, reducing their impact on the model's learning process. Robust objective functions, such as the minimax[^fn-minimax] or distributionally robust objective, aim to optimize the model's performance under worst-case scenarios or in the presence of adversarial perturbations.

[^fn-minimax]: **Minimax**: A decision-making strategy, used in game theory and decision theory, which tries to minimize the maximum possible loss.

Data augmentation techniques involve generating additional training examples by applying random transformations or perturbations to the existing data @fig-data-augmentation. This helps in increasing the diversity and robustness of the training dataset. By introducing controlled variations in the data, the model becomes less sensitive to specific patterns or artifacts that may be present in poisoned instances. Randomization techniques, such as random subsampling or bootstrap aggregating, can also help reduce the impact of poisoned data by training multiple models on different subsets of the data and combining their predictions.

![**Data Augmentation Techniques**: Applying transformations like horizontal flips, rotations, and cropping expands training datasets, improving model robustness to variations in input data and reducing overfitting. These techniques generate new training examples without requiring additional labeled data, effectively increasing dataset diversity and enhancing generalization performance.](./images/png/data_augmentation.png){#fig-data-augmentation}

##### Secure Data Sourcing {#sec-robust-ai-secure-data-sourcing-563e}

Implementing the best data collection and curation practices can help mitigate the risk of data poisoning. This includes establishing clear data collection protocols, verifying the authenticity and reliability of data sources, and conducting regular data quality assessments. Sourcing data from trusted and reputable providers and following secure data handling practices can reduce the likelihood of introducing poisoned data into the training pipeline.

Strong data governance and access control mechanisms are essential to prevent unauthorized modifications or tampering with the training data. This involves defining clear roles and responsibilities for data access, implementing access control policies based on the principle of least privilege,[^fn-principle-least-privilege] and monitoring and logging data access activities. By restricting access to the training data and maintaining an audit trail, potential data poisoning attempts can be detected and investigated.

[^fn-principle-least-privilege]: **Principle of Least Privilege**: A security concept in which a user is given the minimum levels of access necessary to complete his/her job functions.

Detecting and mitigating data poisoning attacks requires a multifaceted approach that combines anomaly detection, data sanitization,[^fn-data-sanitization] robust training techniques, and secure data sourcing practices. Data poisoning remains an active research area requiring proactive and adaptive approaches to data security.

[^fn-data-sanitization]: **Data Sanitization**: The process of deliberately, permanently, and irreversibly removing or destroying the data stored on a memory device to make it unrecoverable.

#### Distribution Shift Adaptation {#sec-robust-ai-distribution-shift-adaptation-3d6e}

Distribution shifts pose ongoing challenges for deployed machine learning systems, requiring systematic approaches for both detection and mitigation. This subsection focuses on practical techniques for identifying when shifts occur and strategies for maintaining system performance despite these changes. We explore statistical methods for shift detection, algorithmic approaches for adaptation, and implementation considerations for production systems.

##### Detection and Mitigation {#sec-robust-ai-detection-mitigation-91de}

Recall that distribution shifts occur when the data distribution encountered by an ML model during deployment differs from the distribution it was trained on. These shifts can significantly impact the model's performance and generalization ability, leading to suboptimal or incorrect predictions. Detecting and mitigating distribution shifts is crucial to ensure the robustness and reliability of ML systems in real-world scenarios.

##### Detection Techniques {#sec-robust-ai-detection-techniques-b5f8}

Statistical tests can be used to compare the distributions of the training and test data to identify significant differences. @lst-distribution-shift demonstrates a practical implementation for monitoring distribution shift in production:

::: {#lst-distribution-shift lst-cap="**Distribution Shift Detection**: Core statistical methods for monitoring data distribution changes in production, combining Kolmogorov-Smirnov tests for individual features with domain classifier approaches to detect when incoming data differs significantly from training distributions."}
```{.python}
from scipy.stats import ks_2samp
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import roc_auc_score


def detect_distribution_shift(
    reference_data, new_data, threshold=0.05
):
    """Detect distribution shift using statistical tests"""

    # Kolmogorov-Smirnov test for feature-wise comparison
    ks_pvalues = []
    for feature_idx in range(new_data.shape[1]):
        _, p_value = ks_2samp(
            reference_data[:, feature_idx], new_data[:, feature_idx]
        )
        ks_pvalues.append(p_value)

    # Domain classifier to detect overall distributional
    # differences
    X_combined = np.vstack([reference_data, new_data])
    y_labels = np.concatenate(
        [np.zeros(len(reference_data)), np.ones(len(new_data))]
    )

    clf = RandomForestClassifier(n_estimators=50, random_state=42)
    clf.fit(X_combined, y_labels)
    domain_auc = roc_auc_score(
        y_labels, clf.predict_proba(X_combined)[:, 1]
    )

    return {
        "ks_shift_detected": any(p < threshold for p in ks_pvalues),
        "domain_shift_detected": domain_auc > 0.8,
        "severity_score": domain_auc,
    }
```
:::

Techniques such as the Kolmogorov-Smirnov test or the Anderson-Darling test measure the discrepancy between two distributions and provide a quantitative assessment of the presence of distribution shift. Applying these tests to the input features or the model's predictions enables practitioners to detect statistically significant differences between the training and test distributions.

Divergence metrics quantify the dissimilarity between two probability distributions. Commonly used divergence metrics include the [Kullback-Leibler (KL) divergence](https://towardsdatascience.com/understanding-kl-divergence-f3ddc8dff254) and the [Jensen-Shannon (JS) divergence](https://medium.com/towards-data-science/how-to-understand-and-use-jensen-shannon-divergence-b10e11b03fd6). By calculating the divergence between the training and test data distributions, practitioners can assess the extent of the distribution shift. High divergence values indicate a significant difference between the distributions, suggesting the presence of a distribution shift.

Uncertainty quantification techniques, such as Bayesian neural networks[^fn-bayesian-neural-networks] or ensemble methods[^fn-ensemble-methods], can estimate the uncertainty associated with the model's predictions. When a model is applied to data from a different distribution, its predictions may have higher uncertainty. By monitoring the uncertainty levels, practitioners can detect distribution shifts. If the uncertainty consistently exceeds a predetermined threshold for test samples, it suggests that the model is operating outside its trained distribution.

[^fn-bayesian-neural-networks]: **Bayesian Neural Networks**: Neural networks that incorporate probability distributions over their weights, enabling uncertainty quantification in predictions and more robust decision making.

[^fn-ensemble-methods]: **Ensemble Methods**: An ML approach that combines several models to improve prediction accuracy.

In addition, domain classifiers are trained to distinguish between different domains or distributions. Practitioners can detect distribution shifts by training a classifier to differentiate between the training and test domains. If the domain classifier achieves high accuracy in distinguishing between the two domains, it indicates a significant difference in the underlying distributions. The performance of the domain classifier serves as a measure of the distribution shift.

##### Mitigation Techniques {#sec-robust-ai-mitigation-techniques-0163}

Transfer learning leverages knowledge gained from one domain to improve performance in another, as shown in @fig-transfer-learning. By using pre-trained models or transferring learned features from a source domain to a target domain, transfer learning can help mitigate the impact of distribution shifts. The pre-trained model can be fine-tuned on a small amount of labeled data from the target domain, allowing it to adapt to the new distribution. Transfer learning is particularly effective when the source and target domains share similar characteristics or when labeled data in the target domain is scarce.

::: {#fig-transfer-learning fig-env="figure" fig-pos="htb"}
```{.tikz}
\begin{tikzpicture}[font=\small\usefont{T1}{phv}{m}{n}]

\tikzset{%
Line/.style={line width=1.0pt,black!50,text=black},
Box/.style={inner xsep=2pt,
    node distance=1.6,
    draw=VioletLine,
    line width=0.75pt,
    fill=VioletL!40,
    align=flush center,
    minimum width=25mm, minimum height=9mm
  },
}
\begin{scope}[shift={(0,0)}]
\node[Box](B1){Data 1};
\node[Box,right=of B1,fill=BlueL,draw=BlueLine](B2){Model 1};
\node[Box,right=of B2,fill=BlueL,draw=BlueLine](B3){Head};
\node[Box,right=of B3](B4){Predictions 1};
\scoped[on background layer]
\node[draw=BackLine,inner xsep=4mm,inner ysep=5mm,
yshift=1.5mm,fill=BackColor!50,fit=(B2)(B3),line width=0.75pt](BB1){};
\node[below=4pt of BB1.north,inner sep=0pt,anchor=north]{Task 1};
%\node[above=8pt of BB1.north,inner sep=0pt,anchor=south]{Transfer Learning};
\end{scope}
%
\begin{scope}[shift={(0,-3)}]
\node[Box](DB1){Data 2};
\node[Box,right=of DB1,fill=BlueL,draw=BlueLine](DB2){Model 1};
\node[Box,right=of DB2,fill=BlueL,draw=BlueLine](DB3){New Head};
\node[Box,right=of DB3](DB4){Predictions 2};
\scoped[on background layer]
\node[draw=BackLine,inner xsep=4mm,inner ysep=5mm,
yshift=1.5mm,fill=BackColor!50,fit=(DB2)(DB3),line width=0.75pt](BB2){};
\node[below=4pt of  BB2.north,inner sep=0pt,
anchor=north]{Task 2};
\end{scope}
\draw[Line,-latex](B2)--node[left,pos=0.44]{Knowledge transfer}(DB2);

\foreach \x in{1,2,3}{
\pgfmathtruncatemacro{\newX}{\x + 1}
\draw[Line,-latex](B\x)--(B\newX);
}
\foreach \x in{1,2,3}{
\pgfmathtruncatemacro{\newX}{\x + 1}
\draw[Line,-latex](DB\x)--(DB\newX);
}
\end{tikzpicture}
```
**Knowledge Transfer**: Pre-training on large datasets enables models to learn generalizable features, which can then be fine-tuned for specific target tasks with limited labeled data. This approach mitigates data scarcity and accelerates learning in new domains by leveraging previously acquired knowledge. *Source: [bhavsar](HTTPS://medium.com/modern-nlp/transfer-learning-in-nlp-f5035cc3f62f)*
:::

Continual learning, also known as lifelong learning, enables ML models to learn continuously from new data distributions while retaining knowledge from previous distributions. Techniques such as elastic weight consolidation (EWC) [@kirkpatrick2017overcoming] or gradient episodic memory (GEM) [@lopez2017gradient] allow models to adapt to evolving data distributions over time. These techniques aim to balance the plasticity of the model (ability to learn from new data) with the stability of the model (retaining previously learned knowledge). By incrementally updating the model with new data and mitigating catastrophic forgetting, continual learning helps models stay robust to distribution shifts.

Data augmentation techniques, such as those we have seen previously, involve applying transformations or perturbations to the existing training data to increase its diversity and improve the model's robustness to distribution shifts. By introducing variations in the data, such as rotations, translations, scaling, or adding noise, data augmentation helps the model learn invariant features and generalize better to unseen distributions. Data augmentation can be performed during training and inference to improve the model's ability to handle distribution shifts.

Ensemble methods, as described in @sec-robust-ai-defense-strategies-cb2d for adversarial defense, also provide robustness against distribution shifts. When presented with a shifted distribution, the ensemble can leverage the strengths of individual models to make more accurate and stable predictions.

Regularly updating models with new data from the target distribution is crucial to mitigate the impact of distribution shifts. As the data distribution evolves, models should be retrained or fine-tuned on the latest available data to adapt to the changing patterns, leveraging continuous learning approaches detailed in @sec-ondevice-learning. Monitoring model performance and data characteristics can help detect when an update is necessary. By keeping the models up to date, practitioners can ensure they remain relevant and accurate in the face of distribution shifts.

Evaluating models using robust metrics less sensitive to distribution shifts can provide a more reliable assessment of model performance. Metrics such as the area under the precision-recall curve (AUPRC) or the F1 score[^fn-f1] are more robust to class imbalance and can better capture the model's performance across different distributions. Using domain-specific evaluation metrics that align with the desired outcomes in the target domain can provide a more meaningful measure of the model's effectiveness.

[^fn-f1]: **F1 Score**: A measure of a model's accuracy that combines precision (correct positive predictions) and recall (proportion of actual positives identified) into a single metric. Calculated as the harmonic mean of precision and recall.

Detecting and mitigating distribution shifts is an ongoing process that requires continuous monitoring, adaptation, and improvement. By employing the detection and mitigation techniques described in this section, practitioners can proactively address distribution shifts in real-world deployments.

#### Self-Supervised Learning for Robustness {#sec-robust-ai-selfsupervised-learning-robustness-0c94}

Self-supervised learning (SSL) approaches may provide a path toward more robust AI systems by learning from data structure rather than memorizing input-output mappings. Unlike supervised learning that relies on labeled examples, SSL methods discover representations by solving pretext tasks that require understanding underlying data patterns and relationships.

Self-supervised approaches potentially address several core limitations that contribute to neural network brittleness. SSL methods learn representations from environmental regularities and data structure, capturing invariant features that remain consistent across different conditions. Contrastive learning techniques encourage representations that capture invariant features across different views of the same data, promoting robustness to transformations and perturbations. Masked language modeling and similar techniques in vision learn to predict based on context rather than surface patterns, potentially developing more generalizable internal representations.

Self-supervised representations often demonstrate superior transfer capabilities compared to supervised learning representations, suggesting they capture more essential aspects of data structure. Learning from data structure rather than labels may be inherently more robust because it relies on consistent patterns present across domains and conditions. SSL approaches can leverage larger amounts of unlabeled data, potentially improving generalization by exposing models to broader ranges of natural variation. This exposure to diverse unlabeled data may help models develop representations that are more resilient to the distribution shifts commonly encountered in deployment.

Several strategies can incorporate self-supervised learning into robust system design. Pre-training models using self-supervised objectives before fine-tuning for specific tasks provides a robust foundation that may transfer better across domains. Multi-task approaches that combine self-supervised and supervised objectives during training can balance representation learning with task performance. SSL-learned representations can serve as the foundation for subsequent robust fine-tuning approaches, potentially requiring fewer labeled examples to achieve robustness.

While promising, self-supervised learning for robustness remains an active research area with important limitations. Current SSL methods may still be vulnerable to adversarial attacks, particularly when attackers understand the pretext tasks. The theoretical understanding of why and when SSL improves robustness remains incomplete. Computational overhead for SSL pre-training can be substantial, requiring careful consideration of resource constraints.

This direction indicates an evolving research area that may change how we approach robust AI system development, moving beyond defensive techniques toward learning approaches that are inherently more reliable.

The three pillars we have examined—hardware faults, input-level attacks, and environmental shifts—each target different aspects of AI systems. Yet they all operate within and depend upon complex software infrastructures that present their own unique vulnerabilities.

## Software Faults {#sec-robust-ai-software-faults-889e}

The robustness challenges we have examined so far—hardware faults, input-level attacks, and environmental shifts—each compromise different system layers. Hardware faults corrupt physical computation, adversarial attacks exploit algorithmic boundaries, and environmental shifts challenge model generalization. Software faults introduce a fourth dimension that can amplify all three: bugs and implementation errors in the complex software ecosystems that support modern AI deployments.

This third category differs from the previous two. Unlike hardware faults, which typically arise from physical phenomena, or model robustness issues, which stem from core limitations in learning algorithms, software faults result from human errors in system design and implementation. These faults can corrupt any aspect of the AI pipeline, from data preprocessing and model training to inference and result interpretation, often in subtle ways that may not be immediately apparent.

Software faults in AI systems are particularly challenging because they can interact with and amplify the other robustness threats we have discussed. A bug in data preprocessing might create distribution shifts that expose model vulnerabilities. Implementation errors in numerical computations might manifest similarly to hardware faults but without the benefit of hardware-level error detection mechanisms. Race conditions in distributed training might cause model corruption that resembles adversarial attacks on the learned representations.

These interactions arise from the inherent complexity of modern AI software stacks—spanning frameworks, libraries, runtime environments, distributed systems, and deployment infrastructure—which creates numerous opportunities for faults to emerge and propagate. Understanding and mitigating these software-level threats is essential for building truly robust AI systems that can operate reliably in production environments despite the inherent complexity of their supporting software infrastructure.

Machine learning systems rely on complex software infrastructures that extend far beyond the models themselves. These systems are built on top of frameworks detailed in @sec-ai-frameworks, libraries, and runtime environments that facilitate model training, evaluation, and deployment. As with any large-scale software system, the components that support ML workflows are susceptible to faults—unintended behaviors resulting from defects, bugs, or design oversights in the software, creating operational challenges beyond the standard practices detailed in @sec-ml-operations. These faults can manifest across all stages of an ML pipeline and, if not identified and addressed, may impair performance, compromise security, or even invalidate results. This section examines the nature, causes, and consequences of software faults in ML systems, as well as strategies for their detection and mitigation.

### Software Fault Properties {#sec-robust-ai-software-fault-properties-d339}

Understanding how software faults impact ML systems requires examining their distinctive characteristics. Software faults in ML frameworks originate from various sources, including programming errors, architectural misalignments, and version incompatibilities. These faults exhibit several important characteristics that influence how they arise and propagate in practice.

One defining feature of software faults is their diversity. Faults can range from syntactic and logical errors to more complex manifestations such as memory leaks, concurrency bugs, or failures in integration logic. The broad variety of potential fault types complicates both their identification and resolution, as they often surface in non-obvious ways.

Complicating this diversity, a second key characteristic is their tendency to propagate across system boundaries. An error introduced in a low-level module, such as a tensor allocation routine or a preprocessing function, can produce cascading effects that disrupt model training, inference, or evaluation. Because ML frameworks are often composed of interconnected components, a fault in one part of the pipeline can introduce failures in seemingly unrelated modules.

Some faults are intermittent, manifesting only under specific conditions such as high system load, particular hardware configurations, or rare data inputs. These transient faults are notoriously difficult to reproduce and diagnose, as they may not consistently appear during standard testing procedures.

Perhaps most concerning for ML systems, software faults may subtly interact with ML models themselves. For example, a bug in a data transformation script might introduce systematic noise or shift the distribution of inputs, leading to biased or inaccurate predictions. Similarly, faults in the serving infrastructure may result in discrepancies between training-time and inference-time behaviors, undermining deployment consistency.

The consequences of software faults extend to a range of system properties. Faults may impair performance by introducing latency or inefficient memory usage; they may reduce scalability by limiting parallelism; or they may compromise reliability and security by exposing the system to unexpected behaviors or malicious exploitation.

Adding another layer of complexity, the manifestation of software faults is often shaped by external dependencies, such as hardware platforms, operating systems, or third-party libraries. Incompatibilities arising from version mismatches or hardware-specific behavior may result in subtle, hard-to-trace bugs that only appear under certain runtime conditions.

A thorough understanding of these characteristics is essential for developing robust software engineering practices in ML. It also provides the foundation for the detection and mitigation strategies described later in this section.

### Software Fault Propagation {#sec-robust-ai-software-fault-propagation-59e7}

These characteristics illustrate how software faults in ML frameworks arise through a variety of mechanisms, reflecting the complexity of modern ML pipelines and the layered architecture of supporting tools. These mechanisms correspond to specific classes of software failures that commonly occur in practice.

One prominent class involves resource mismanagement, particularly with respect to memory. Improper memory allocation, including the failure to release buffers or file handles, can lead to memory leaks and, eventually, to resource exhaustion. This is especially detrimental in deep learning applications, where large tensors and GPU memory allocations are common. As shown in @fig-gpu-out-of-memory, inefficient memory usage or the failure to release GPU resources can cause training procedures to halt or significantly degrade runtime performance.

![**GPU Resource Management**: Inefficient memory usage or failure to release GPU resources can lead to out-of-memory errors and suboptimal performance during training.](./images/png/gpu_out_of_memory.png){#fig-gpu-out-of-memory}

Beyond resource management issues, another recurring fault mechanism stems from concurrency and synchronization errors. In distributed or multi-threaded environments, incorrect coordination among parallel processes can lead to race conditions, deadlocks, or inconsistent states. These issues are often tied to the improper use of [asynchronous operations](https://odsc.medium.com/optimizing-ml-serving-with-asynchronous-architectures-1071fc1be8e2), such as non-blocking I/O or parallel data ingestion. Synchronization bugs can corrupt the consistency of training states or produce unreliable model checkpoints.

Compatibility problems frequently arise from changes to the software environment, extending the framework compatibility issues discussed in @sec-ai-frameworks. For example, upgrading a third-party library without validating downstream effects may introduce subtle behavioral changes or break existing functionality. These issues are exacerbated when the training and inference environments differ in hardware, operating system, or dependency versions. Reproducibility in ML experiments often hinges on managing these environmental inconsistencies.

Faults related to numerical instability are also common in ML systems, particularly in optimization routines. Improper handling of floating-point precision, division by zero, or underflow/overflow conditions can introduce instability into gradient computations and convergence procedures. As described in [this resource](https://pythonnumericalmethods.studentorg.berkeley.edu/notebooks/chapter22.04-Numerical-Error-and-Instability.html), the accumulation of rounding errors across many layers of computation can distort learned parameters or delay convergence.

Exception handling, though often overlooked, plays a crucial role in the stability of ML pipelines. Inadequate or overly generic exception management can cause systems to fail silently or crash under non-critical errors. Ambiguous error messages and poor logging practices impede diagnosis and prolong resolution times.

These fault mechanisms, while diverse in origin, share the potential to significantly impair ML systems. Understanding how they arise provides the basis for effective system-level safeguards.

### Software Fault Effects on ML {#sec-robust-ai-software-fault-effects-ml-1ba2}

The mechanisms through which software faults arise inform their impact on ML systems. The consequences of software faults can be profound, affecting not only the correctness of model outputs but also the broader usability and reliability of an ML system in production.

The most immediately visible impact is performance degradation, a common symptom often resulting from memory leaks, inefficient resource scheduling, or contention between concurrent threads. These issues tend to accumulate over time, leading to increased latency, reduced throughput, or even system crashes. As noted by [@maas2008combining], the accumulation of performance regressions across components can severely restrict the operational capacity of ML systems deployed at scale.

In addition to slowing system performance, faults can lead to inaccurate predictions. For example, preprocessing errors or inconsistencies in feature encoding can subtly alter the input distribution seen by the model, producing biased or unreliable outputs. These kinds of faults are particularly insidious, as they may not trigger any obvious failure but still compromise downstream decisions. Over time, rounding errors and precision loss can amplify inaccuracies, particularly in deep architectures with many layers or long training durations.

Beyond accuracy concerns, reliability is also undermined by software faults. Systems may crash unexpectedly, fail to recover from errors, or behave inconsistently across repeated executions. Intermittent faults are especially problematic in this context, as they erode user trust while eluding conventional debugging efforts. In distributed settings, faults in checkpointing or model serialization can cause training interruptions or data loss, reducing the resilience of long-running training pipelines.

Security vulnerabilities frequently arise from overlooked software faults. Buffer overflows, improper validation, or unguarded inputs can open the system to manipulation or unauthorized access. Attackers may exploit these weaknesses to alter the behavior of models, extract private data, or induce denial-of-service conditions. As described by [@li2021survey], such vulnerabilities pose serious risks, particularly when ML systems are integrated into critical infrastructure or handle sensitive user data.

Finally, the presence of faults complicates development and maintenance. Debugging becomes more time-consuming, especially when fault behavior is non-deterministic or dependent on external configurations. Frequent software updates or library patches may introduce regressions that require repeated testing. This increased engineering overhead can slow iteration, inhibit experimentation, and divert resources from model development.

Taken together, these impacts underscore the importance of systematic software engineering practices in ML—practices that anticipate, detect, and mitigate the diverse failure modes introduced by software faults.

### Software Fault Detection and Prevention {#sec-robust-ai-software-fault-detection-prevention-6478}

Given the significant impact of software faults on ML systems, addressing these issues requires an integrated strategy that spans development, testing, deployment, and monitoring, building upon the operational best practices from @sec-ml-operations. An effective mitigation framework should combine proactive detection methods with robust design patterns and operational safeguards.

To help summarize these techniques and clarify where each strategy fits in the ML lifecycle, @tbl-software-faults-summary below categorizes detection and mitigation approaches by phase and objective. This table provides a high-level overview that complements the detailed explanations that follow.

+----------------------------------+-------------------------------------------------------------------+-----------------------------------------------------------------+--------------------------------------+
| **Category**                     | **Technique**                                                     | **Purpose**                                                     | **When to Apply**                    |
+:=================================+:==================================================================+:================================================================+:=====================================+
| **Testing and Validation**       | Unit testing, integration testing, regression testing             | Verify correctness and identify regressions                     | During development                   |
+----------------------------------+-------------------------------------------------------------------+-----------------------------------------------------------------+--------------------------------------+
| **Static Analysis and Linting**  | Static analyzers, linters, code reviews                           | Detect syntax errors, unsafe operations, enforce best practices | Before integration                   |
+----------------------------------+-------------------------------------------------------------------+-----------------------------------------------------------------+--------------------------------------+
| **Runtime Monitoring & Logging** | Metric collection, error logging, profiling                       | Observe system behavior, detect anomalies                       | During training and deployment       |
+----------------------------------+-------------------------------------------------------------------+-----------------------------------------------------------------+--------------------------------------+
| **Fault-Tolerant Design**        | Exception handling, modular architecture, checkpointing           | Minimize impact of failures, support recovery                   | Design and implementation phase      |
+----------------------------------+-------------------------------------------------------------------+-----------------------------------------------------------------+--------------------------------------+
| **Update Management**            | Dependency auditing, test staging, version tracking               | Prevent regressions and compatibility issues                    | Before system upgrades or deployment |
+----------------------------------+-------------------------------------------------------------------+-----------------------------------------------------------------+--------------------------------------+
| **Environment Isolation**        | Containerization (e.g., Docker, Kubernetes), virtual environments | Ensure reproducibility, avoid environment-specific bugs         | Development, testing, deployment     |
+----------------------------------+-------------------------------------------------------------------+-----------------------------------------------------------------+--------------------------------------+
| **CI/CD and Automation**         | Automated test pipelines, monitoring hooks, deployment gates      | Enforce quality assurance and catch faults early                | Continuously throughout development  |
+----------------------------------+-------------------------------------------------------------------+-----------------------------------------------------------------+--------------------------------------+

: **Fault Mitigation Strategies**: Software faults in ML systems require layered detection and mitigation techniques applied throughout the development lifecycle—from initial testing to ongoing monitoring—to ensure reliability and robustness. This table categorizes these strategies by phase and objective, providing a framework for building comprehensive fault tolerance into machine learning deployments. {#tbl-software-faults-summary}

The first line of defense involves systematic testing. Unit testing verifies that individual components behave as expected under normal and edge-case conditions. Integration testing ensures that modules interact correctly across boundaries, while regression testing detects errors introduced by code changes. Continuous testing is essential in fast-moving ML environments, where pipelines evolve rapidly and small modifications may have system-wide consequences. As shown in @fig-regression-testing, automated regression tests help preserve functional correctness over time.

![**Regression Test Automation**: Automated regression tests verify that new code changes do not introduce unintended errors into existing functionality, preserving system reliability throughout the development lifecycle. Continuous execution of these tests is crucial in rapidly evolving machine learning systems where even small modifications can have widespread consequences. *Source: [UTOR](HTTPS://u-tor.com/topic/regression-vs-integration)*](./images/png/regression_testing.png){#fig-regression-testing width=75%}

Static code analysis tools complement dynamic tests by identifying potential issues at compile time. These tools catch common errors such as variable misuse, unsafe operations, or violation of language-specific best practices. Combined with code reviews and consistent style enforcement, static analysis reduces the incidence of avoidable programming faults.

Runtime monitoring is critical for observing system behavior under real-world conditions. Logging frameworks should capture key signals such as memory usage, input/output traces, and exception events. Monitoring tools can track model throughput, latency, and failure rates, providing early warnings of software faults. Profiling, as illustrated in this [Microsoft resource](https://microsoft.github.io/code-with-engineering-playbook/machine-learning/profiling-ml-and-mlops-code/), helps identify performance bottlenecks and inefficiencies indicative of deeper architectural issues.

Robust system design further improves fault tolerance. Structured exception handling and assertion checks prevent small errors from cascading into system-wide failures. Redundant computations, fallback models, and failover mechanisms improve availability in the presence of component failures. Modular architectures that encapsulate state and isolate side effects make it easier to diagnose and contain faults. Checkpointing techniques, such as those discussed in [@eisenman2022check], enable recovery from mid-training interruptions without data loss.

Keeping ML software up to date is another key strategy. Applying regular updates and security patches helps address known bugs and vulnerabilities. However, updates must be validated through test staging environments to avoid regressions. Reviewing [release notes](https://github.com/pytorch/pytorch/releases) and change logs ensures teams are aware of any behavioral changes introduced in new versions.

Containerization technologies like [Docker](https://www.docker.com) and [Kubernetes](https://kubernetes.io) allow teams to define reproducible runtime environments that mitigate compatibility issues. By isolating system dependencies, containers prevent faults introduced by system-level discrepancies across development, testing, and production.

Finally, automated pipelines built around continuous integration and continuous deployment (CI/CD) provide an infrastructure for enforcing fault-aware development. Testing, validation, and monitoring can be embedded directly into the CI/CD flow. As shown in @fig-CI-CD-procedure, such pipelines reduce the risk of unnoticed regressions and ensure only tested code reaches deployment environments.

::: {#fig-CI-CD-procedure fig-env="figure" fig-pos="htb"}
```{.tikz}
\begin{tikzpicture}[line join=round,font=\usefont{T1}{phv}{m}{n}\large]
\tikzset{
LineA/.style={black!50, line width=1.1pt,{-{Triangle[width=0.9*6pt,length=1.2*6pt]}}},
ALine/.style={black!50, line width=1.1pt,{{Triangle[width=0.9*6pt,length=1.2*6pt]}-}},
Larrow/.style={fill=orange, single arrow,  inner sep=2pt, single arrow head extend=3pt,
            single arrow head indent=0pt,minimum height=6mm, minimum width=3pt}
}
%Gear style
% #1 number of teeth
% #2 radius intern
% #3 radius extern
% #4 angle from start to end of the first arc
% #5 angle to decale the second arc from the first
% #6 inner radius to cut off
\newcommand{\gear}[6]{%
  (0:#2)
  \foreach \i [evaluate=\i as \n using {(\i-1)*360/#1}] in {1,...,#1}{%
    arc (\n:\n+#4:#2) {[rounded corners=1.5pt] -- (\n+#4+#5:#3)
    arc (\n+#4+#5:\n+360/#1-#5:#3)} --  (\n+360/#1:#2)
  }%
  (0,0) circle[radius=#6];
}

 %person style
 \tikzset{
 pics/man/.style = {
        code = {
        \pgfkeys{/man/.cd, #1}
\begin{scope}[local bounding box=PERSON,scale=\scalefac, every node/.append style={transform shape}]
     % tie
    \draw[draw=\tiecolor,fill=\tiecolor] (0.0,-1.1)--(0.16,-0.87)--(0.09,-0.46)--(0.13,-0.37)--(0.0,-0.28)
                   --(-0.13,-0.37)--(-0.09,-0.46)--(-0.16,-0.87)--cycle;
    % ears
    \draw[fill=black] (0.74,0.95) to[out=20,in=80](0.86,0.80) to[out=250,in=330](0.65,0.65) to[out=70,in=260] cycle;
    \draw[fill=black] (-0.76,0.96) to[out=170,in=110](-0.85,0.80) to[out=290,in=190](-0.65,0.65) to[out=110,in=290] cycle;

    % head
    \draw[fill=black] (0,0) to[out=180,in=290](-0.72,0.84) to[out=110,in=190](-0.56,1.67)
                      to[out=70,in=110](0.68,1.58) to[out=320,in=80](0.72,0.84) to[out=250,in=0] cycle;
    % face
    \draw[fill=white] (0,0.11) to[out=175,in=290](-0.53,0.65) to[out=110,in=265](-0.61,1.22)
                      to[out=80,in=235](-0.50,1.45) to[out=340,in=215](0.50,1.47)
                      to[out=310,in=85](0.60,0.92) to[out=260,in=2] cycle;
    \draw[fill=black] (-0.50,1.45) to[out=315,in=195](0.40,1.25) to[out=340,in=10](0.37,1.32)
                      to[out=190,in=310](-0.40,1.49) -- cycle;
    % neck
    \draw[line width=1.0pt] (-0.62,-0.2) to[out=50,in=290] (-0.5,0.42);
    \draw[line width=1.0pt] (0.62,-0.2) to[out=130,in=250] (0.5,0.42);
    % body
    \draw[draw=\bodycolor,fill=\bodycolor,line width=\Linewidth] (0.0,-1.0) to[out=150,in=290](-0.48,-0.14) to[out=200,in=50](-1.28,-0.44)
                   to[out=240,in=80](-1.55,-2.06) -- (1.55,-2.06)
                   to[out=100,in=300](1.28,-0.44) to[out=130,in=340](0.49,-0.14)
                   to[out=245,in=30] cycle;
    % right stet
    \draw[line width=3pt,\stetcolor] (0.8,-0.21) to[bend left=7](0.78,-0.64)
         to[out=350,in=80](0.98,-1.35) to[out=250,in=330](0.72,-1.60);
    \draw[line width=3pt,\stetcolor] (0.43,-1.53) to[out=180,in=240](0.3,-1.15)
         to[out=60,in=170](0.78,-0.64);
    % left stet
    \draw[line width=3pt,\stetcolor] (-0.75,-0.21) to[bend right=20](-0.65,-1.45);
    \node[fill=\stetcolor,circle,minimum size=5pt] at (-0.65,-1.45) {};
    % eyes
    \node[circle,fill=black,inner sep=2pt] at (0.28,0.94) {};
    \node[circle,fill=black,inner sep=2pt] at (-0.28,0.94) {};
     % mouth
    \draw[line width=1.1pt] (-0.25,0.5) to[bend right=40](0.25,0.5);
 \end{scope}
     }
  }
}
\pgfkeys{
  /man/.cd,
  Linewidth/.store in=\Linewidth,
  scalefac/.store in=\scalefac,
  tiecolor/.store in=\tiecolor,
  bodycolor/.store in=\bodycolor,
  stetcolor/.store in=\stetcolor,
  tiecolor=red,      % derfault tie color
  bodycolor=blue!30,  % derfault body color
  stetcolor=green,  % derfault stet color
  scalefac=1,
  Linewidth=2.5pt,
}

%data style
\tikzset{mycylinder/.style={cylinder, shape border rotate=90, aspect=1.3, draw, fill=white,
minimum width=25mm,minimum height=11mm,line width=\Linewidth,node distance=-0.15},
pics/data/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[local bounding box=STREAMING,scale=\scalefac, every node/.append style={transform shape}]
\node[mycylinder,fill=\filllcolor!50] (A) {};
\node[mycylinder, above=of A,fill=\filllcolor!30] (B) {};
\node[mycylinder, above=of B,fill=\filllcolor!10] (C) {};
 \end{scope}
     }
  }
}
%package style
\tikzset{
pics/package/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[local bounding box=PACKAGE,scale=\scalefac,every node/.append style={transform shape}]
% Right Face
\draw[fill=\filllcolor!70,line width=\Linewidth]
(\Depth,0,0)coordinate(\picname-ZDD)--(\Depth,\Width,0)--(\Depth,\Width,\Height)--(\Depth,0,\Height)--cycle;
% Front Face
\draw[fill=\filllcolor!40,line width=\Linewidth]
(0,0,\Height)coordinate(\picname-DL)--(0,\Width,\Height)coordinate(\picname-GL)--
(\Depth,\Width,\Height)coordinate(\picname-GD)--(\Depth,0,\Height)coordinate(\picname-DD)--(0,0,\Height);
% Top Face
\draw[fill=\filllcolor!20,line width=\Linewidth]
(0,\Width,0)coordinate(\picname-ZGL)--(0,\Width,\Height)--
(\Depth,\Width,\Height)--(\Depth,\Width,0)coordinate(\picname-ZGD)--cycle;
%
\path[fill=white]($(\picname-ZGL)!0.35!(\picname-ZGD)$)coordinate(\picname-A)--
($(\picname-GL)!0.35!(\picname-GD)$)coordinate(\picname-B)--++(0,-0.22)coordinate(\picname-C)--++(0.33,0)coordinate(\picname-D)--
($(\picname-GL)!0.6!(\picname-GD)$)coordinate(\picname-E)--($(\picname-ZGL)!0.6!(\picname-ZGD)$)coordinate(\picname-F)--
++(0,0.02)coordinate(\picname-G)-|cycle;
\draw[fill=white](\picname-A)--(\picname-B)--(\picname-C)--(\picname-D)--(\picname-E)--(\picname-F);
\draw[](\picname-A)--++(0,-0.22)coordinate(\picname-Y)--(\picname-C);
\draw[](\picname-Y)--++(0.11,0);
\end{scope}
    }
  }
}
%display style
\tikzset{
pics/display/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[scale=\scalefac,every node/.append style={transform shape}]
\newcommand{\tikzxmark}{%
\tikz[scale=0.18] {
    \draw[line width=0.7,line cap=round,GreenLine] (0,0) to [bend left=6] (1,1);
    \draw[line width=0.7,line cap=round,GreenLine] (0.2,0.95) to [bend right=3] (0.8,0.05);
}}
\newcommand{\tikzxcheck}{%
\tikz[scale=0.16] {
    \draw[line width=0.7,line cap=round,GreenLine] (0.5,0.75)--(0.85,-0.1) to [bend left=16] (1.5,1.55);

}}
 \node[draw, minimum width  =15mm, minimum height = 10mm, inner sep=0pt, rounded corners,
       draw = BlueLine, fill=cyan!10,line width=2.0pt](COM){};
\draw[draw = BlueLine,line width=1.0pt] ($(COM.north west)!0.85!(COM.south west)$)-- ($(COM.north east)!0.85!(COM.south east)$);
\draw[draw=\drawcolor,line width=\Linewidth]($(COM.south west)!0.4!(COM.south east)$)--++(270:0.2)coordinate(DL);
\draw[draw=\drawcolor,=\Linewidth]($(COM.south west)!0.6!(COM.south east)$)--++(270:0.2)coordinate(DD);
\draw[draw=\drawcolor,line width=3*\Linewidth,shorten <=-3mm,shorten >=-3mm](DL)--(DD);
\node[draw=GreenLine,inner sep=3.85pt,fill=white](CB1) at ($(COM.north west)!0.25!(COM.south west)+(0.3,0)$){};
\node[xshift=0pt]at(CB1){\tikzxcheck};
\node[draw=GreenLine,inner sep=3.85pt,fill=white](CB2) at ($(COM.north west)!0.6!(COM.south west)+(0.3,0)$){};
\node[xshift=0pt]at(CB2){\tikzxmark};
 \draw[GreenLine,decoration={zigzag,segment length=4pt, amplitude=0.5pt},decorate]($(CB1)+(0.3,0.05)$)--++(0:0.8);
\draw[GreenLine,decoration={zigzag,segment length=4pt, amplitude=0.5pt},decorate]($(CB1)+(0.3,-0.12)$)--++(0:0.5);
\draw[GreenLine,decoration={zigzag,segment length=4pt, amplitude=0.5pt},decorate]($(CB2)+(0.3,0.05)$)--++(0:0.8);
\draw[GreenLine,decoration={zigzag,segment length=4pt, amplitude=0.5pt},decorate]($(CB2)+(0.3,-0.12)$)--++(0:0.5);
\end{scope}
    }
  }
}
%empty display style
\tikzset{
pics/displayE/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[scale=\scalefac,every node/.append style={transform shape}]
\node[draw, minimum width  =12mm, minimum height = 10mm, inner sep=0pt, rounded corners, draw=\drawcolor, fill=\filllcolor!10,line width=2.0pt](COM){};
\draw[draw = \drawcolor,line width=1.0pt]($(COM.north west)!0.85!(COM.south west)$)-- ($(COM.north east)!0.85!(COM.south east)$);
\draw[draw=\drawcolor,line width=\Linewidth]($(COM.south west)!0.4!(COM.south east)$)--++(270:0.2)coordinate(DL);
\draw[draw=\drawcolor,=\Linewidth]($(COM.south west)!0.6!(COM.south east)$)--++(270:0.2)coordinate(DD);
\draw[draw=\drawcolor,line width=3*\Linewidth,shorten <=-3mm,shorten >=-3mm](DL)--(DD);
\end{scope}
    }
  }
}
%AUTO text style
\tikzset{
pics/autotext/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}scale=\scalefac,every node/.append style={transform shape}]
 \node[draw, minimum width  =12mm, minimum height = 5mm, inner sep=0pt,
       draw = \drawcolor, fill=\filllcolor!10,line width=\Linewidth](AT\picname){\small AUTO};
\end{scope}
    }
  }
}
%server style
\tikzset {
  pics/server/.style = {
    code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[local bounding box=SERVER1,scale=\scalefac,every node/.append style={transform shape}]
 \draw[draw = \drawcolor, fill=\filllcolor!10,line width=\Linewidth](-0.55,-0.5) rectangle (0.55,0.5);
\foreach \i in {-0.25,0,0.25} {
       \draw[cyan,line width=1.25pt]( -0.55,\i) -- (0.55, \i);
}
        \foreach \i in {-0.375, -0.125, 0.125, 0.375} {
          \draw[cyan!50!black!90,line width=1.25pt](-0.45,\i)--(0,\i);
          \fill[cyan!50!black!90](0.35,\i) circle (1.5pt);
        }

        \draw[draw = \drawcolor,line width=1.75pt](0,-0.53) |- (-0.55,-0.7);
        \draw[draw = \drawcolor,line width=1.75pt](0,-0.53) |- (0.55,-0.7);
      \end{scope}
    }
  }
}
%testing
\tikzset{
pics/testing/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[local bounding box=TESTING1,shift={($(0,0)+(0,0)$)},scale=\scalefac,every node/.append style={transform shape}]
\newcommand{\tikzxmark}{%
\tikz[scale=0.18] {
    \draw[line width=0.7,line cap=round,GreenLine] (0,0) to [bend left=6] (1,1);
    \draw[line width=0.7,line cap=round,GreenLine] (0.2,0.95) to [bend right=3] (0.8,0.05);
}}
\newcommand{\tikzxcheck}{%
\tikz[scale=0.16] {
    \draw[line width=0.7,line cap=round,GreenLine] (0.5,0.75)--(0.85,-0.1) to [bend left=16] (1.5,1.55);

}}
 \node[draw, minimum width  =15mm, minimum height = 20mm, inner sep = 0pt,
        rounded corners,draw = \drawcolor, fill=\filllcolor!10, line width=\Linewidth](COM){};
\node[draw=GreenLine,inner sep=4pt,fill=white](CB1) at ($(COM.north west)!0.25!(COM.south west)+(0.3,0)$){};
\node[xshift=0pt]at(CB1){\tikzxcheck};
\node[draw=GreenLine,inner sep=4pt,fill=white](CB2) at ($(COM.north west)!0.5!(COM.south west)+(0.3,0)$){};
\node[xshift=0pt]at(CB2){\tikzxmark};
\node[draw=GreenLine,inner sep=4pt,fill=white](CB3) at ($(COM.north west)!0.75!(COM.south west)+(0.3,0)$){};
\node[xshift=0pt]at(CB3){\tikzxmark};
\draw[GreenLine,decoration={zigzag,segment length=4pt, amplitude=0.5pt},decorate]($(CB1)+(0.3,0.05)$)--++(0:0.8);
\draw[GreenLine,decoration={zigzag,segment length=4pt, amplitude=0.5pt},decorate]($(CB1)+(0.3,-0.12)$)--++(0:0.7);
\draw[GreenLine,decoration={zigzag,segment length=4pt, amplitude=0.5pt},decorate]($(CB2)+(0.3,0.05)$)--++(0:0.8);
\draw[GreenLine,decoration={zigzag,segment length=4pt, amplitude=0.5pt},decorate]($(CB2)+(0.3,-0.12)$)--++(0:0.6);
\draw[GreenLine,decoration={zigzag,segment length=4pt, amplitude=0.5pt},decorate]($(CB3)+(0.3,0.05)$)--++(0:0.8);
\draw[GreenLine,decoration={zigzag,segment length=4pt, amplitude=0.5pt},decorate]($(CB3)+(0.3,-0.12)$)--++(0:0.6);
\end{scope}
    }
  }
}
%pencil
\tikzset{
pics/pencil/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[local bounding box=TESTING1,shift={($(0,0)+(0,0)$)},scale=\scalefac,every node/.append style={transform shape},rotate=340]
            \fill[fill=\filllcolor!70] (0,4) -- (0.4,4) -- (0.4,0) --(0.3,-0.15) -- (0.2,0) -- (0.1,-0.14) -- (0,0) -- cycle;
            \draw[color=white,thick] (0.2,4) -- (0.2,0);
            \fill[black] (0,3.5) -- (0.2,3.47) -- (0.4,3.5) -- (0.4,4) arc(30:150:0.23cm);
            \fill[fill=\filllcolor!40] (0,0) -- (0.2,-0.8)node[coordinate,pos=0.75](a){} -- (0.4,0)node[coordinate,pos=0.25](b){} -- (0.3,-0.15) -- (0.2,0) -- (0.1,-0.14) -- cycle;
            \fill[fill=\filllcolor] (a) -- (0.2,-0.8) -- (b) -- cycle;

\end{scope}
    }
  }
}
%cube
\tikzset{
pics/square/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[local bounding box=SQUARE,scale=\scalefac,every node/.append style={transform shape}]
% Right Face
\draw[fill=\filllcolor!70,line width=\Linewidth]
(\Depth,0,0)coordinate(\picname-ZDD)--(\Depth,\Width,0)--(\Depth,\Width,\Height)--(\Depth,0,\Height)--cycle;
% Front Face
\draw[fill=\filllcolor!40,line width=\Linewidth]
(0,0,\Height)coordinate(\picname-DL)--(0,\Width,\Height)coordinate(\picname-GL)--
(\Depth,\Width,\Height)coordinate(\picname-GD)--(\Depth,0,\Height)coordinate(\picname-DD)--(0,0,\Height);
% Top Face
\draw[fill=\filllcolor!20,line width=\Linewidth]
(0,\Width,0)coordinate(\picname-ZGL)--(0,\Width,\Height)coordinate(\picname-ZGL)--
(\Depth,\Width,\Height)--(\Depth,\Width,0)coordinate(\picname-ZGD)--cycle;
\end{scope}
    }
  }
}
%globe
\tikzset{
pics/globe/.style = {
        code = {
        \pgfkeys{/channel/.cd, #1}
\begin{scope}[shift={($(0,0)+(0,0)$)},scale=\scalefac,every node/.append style={transform shape}]
\node[circle,minimum size=25mm,draw=\drawcolor, fill=\filllcolor!70,line width=\Linewidth](C\picname) at (0,0){};
\draw[draw=\drawcolor,line width=\Linewidth](C\picname.north)to[bend left=65](C\picname.south);
\draw[draw=\drawcolor,line width=\Linewidth](C\picname.north)to[bend right=65](C\picname.south);
\draw[draw=\drawcolor,line width=\Linewidth](C\picname.north)to(C\picname.south);
\draw[draw=\drawcolor,line width=\Linewidth](C\picname.west)--(C\picname.east);
%
\draw[draw=\drawcolor,line width=\Linewidth](C\picname.130)to[bend right=35](C\picname.50);
\draw[draw=\drawcolor,line width=\Linewidth](C\picname.230)to[bend left=35](C\picname.310);
\end{scope}
    }
  }
}

\pgfkeys{
  /channel/.cd,
  Depth/.store in=\Depth,
  Height/.store in=\Height,
  Width/.store in=\Width,
  filllcirclecolor/.store in=\filllcirclecolor,
  filllcolor/.store in=\filllcolor,
  drawcolor/.store in=\drawcolor,
  drawcircle/.store in=\drawcircle,
  scalefac/.store in=\scalefac,
  Linewidth/.store in=\Linewidth,
  picname/.store in=\picname,
  filllcolor=BrownLine,
  filllcirclecolor=violet!20,
  drawcolor=black,
  drawcircle=violet,
  scalefac=1,
  Linewidth=0.5pt,
  Depth=1.3,
  Height=0.8,
  Width=1.1,
  picname=C
}
 %persons 1
\begin{scope}[local bounding box=PERSON1,shift={($(0,0)+(0,0)$)},scale=1, every node/.append style={transform shape}]
\pic at (0,0) {man={scalefac=0.35,tiecolor=green, bodycolor=RedLine,stetcolor=VioletLine, Linewidth=1.0pt}};
\pic at (1.5,0) {man={scalefac=0.35,tiecolor=green, bodycolor=RedLine,stetcolor=VioletLine, Linewidth=1.0pt}};
\pic at (0.75,0.16) {man={scalefac=0.43,tiecolor=orange, bodycolor=BlueLine,stetcolor=BlueLine, Linewidth=1.0pt}};
\end{scope}
%data 1
\begin{scope}[local bounding box=DATA1,shift={($(0,0)+(3.75,0)$)},scale=1, every node/.append style={transform shape}]
\pic[shift={(0,-0.5)}] at  (0,0){data={scalefac=0.6,picname=1,filllcolor=BlueLine, Linewidth=1.0pt}};
\end{scope}
%Gears
\begin{scope}[local bounding box=GEAR1,shift={($(DATA1)+(2.5,-0.3)$)},scale=1.5, every node/.append style={transform shape}]
\fill[draw=none,fill=BrownLine,even odd rule,xshift=-2mm]coordinate(D)\gear{12}{0.4}{0.33}{10}{2}{0.1};
\fill[draw=none,fill=BrownLine,even odd rule,xshift=3.8mm,yshift=2mm]\gear{11}{0.25}{0.21}{10}{1}{0.07};
\fill[draw=none,fill=BrownLine,even odd rule,xshift=0.6mm,yshift=5.8mm]coordinate(F)\gear{11}{0.25}{0.21}{10}{1}{0.07};
\end{scope}
%package 1
\begin{scope}[local bounding box=PACKAGE1,shift={($(GEAR1)+(2.1,-0.4)$)},scale=1,every node/.append style={transform shape}]
\pic[shift={(0,0)}] at  (0,0){package={scalefac=1,picname=1,filllcolor=red, Linewidth=0.5pt}};
 \end{scope}
%display 1
 \begin{scope}[local bounding box=DISPLAY1,shift={($(PACKAGE1)+(2.3,0.6)$)},scale=1, every node/.append style={transform shape}]
\pic[shift={(0,-0.5)}] at  (0,0){display={scalefac=1,picname=1,filllcolor=BlueLine, Linewidth=1.0pt}};
\end{scope}
 %auto text 1
 \begin{scope}[local bounding box=AUTOTEXT1,shift={($(DISPLAY1)+(0,1.1)$)},scale=1, every node/.append style={transform shape}]
\pic[shift={(0,0)}] at  (0,0){autotext={scalefac=1,picname=1,drawcolor=green!70!black,filllcolor=green!70!black, Linewidth=1.0pt}};
\end{scope}
 %server
 \begin{scope}[local bounding box=SERVER1,shift={($(DISPLAY1)+(2.3,0)$)},scale=1, every node/.append style={transform shape}]
\pic[shift={(0,0)}] at  (0,0){server={scalefac=1.1,picname=1,drawcolor=BrownLine,filllcolor=BrownLine, Linewidth=1.0pt}};
\fill[draw=none,fill=BlueD,even odd rule,xshift=2.5mm,yshift=-2.8mm]\gear{11}{0.4}{0.34}{10}{1}{0.07};
\end{scope}
 %auto text 2
 \begin{scope}[local bounding box=AUTOTEXT2,shift={($(SERVER1)+(0,1.1)$)},scale=1, every node/.append style={transform shape}]
\pic[shift={(0,0)}] at  (0,0){autotext={scalefac=1,picname=1,drawcolor=green!70!black,filllcolor=green!70!black, Linewidth=1.0pt}};
\end{scope}
%%%%%%%%%%%%%%%%%%%
%package 2
\begin{scope}[local bounding box=PACKAGE2,shift={($(SERVER1)+(2.7,-0.2)$)},scale=1,every node/.append style={transform shape}]
\pic[shift={(0,0)}] at  (0,0){package={scalefac=1,picname=2,filllcolor=green!70!black, Linewidth=0.5pt}};
 \end{scope}
%testing 1
\begin{scope}[local bounding box=TESTING1,shift={($(SERVER1)+(2.1,0.85)$)},scale=1, every node/.append style={transform shape}]
\pic[shift={(0,-0.5)}] at  (0,0){testing={scalefac=0.75,picname=1,drawcolor=OrangeLine,filllcolor=OrangeLine, Linewidth=1.0pt}};
\end{scope}
 %persons 2
\begin{scope}[local bounding box=PERSON2,shift={($(PACKAGE2)+(2.0,-0.27)$)},scale=1, every node/.append style={transform shape}]
\pic at (0,0) {man={scalefac=0.35,tiecolor=red, bodycolor=BrownLine,stetcolor=BrownLine, Linewidth=1.0pt}};
\pic at (1.5,0) {man={scalefac=0.35,tiecolor=red, bodycolor=BrownLine,stetcolor=BrownLine, Linewidth=1.0pt}};
\pic at (0.75,0.16) {man={scalefac=0.43,tiecolor=GreenD, bodycolor=red!80!black,stetcolor=red!80!black, Linewidth=1.0pt}};
\end{scope}
%data 2
\begin{scope}[local bounding box=DATA2,shift={($(PERSON2)+(2.75,0)$)},scale=1, every node/.append style={transform shape}]
\pic[shift={(0,-0.5)}] at  (0,0){data={scalefac=0.6,picname=1,filllcolor=RedLine, Linewidth=1.0pt}};
\pic[shift={(1,0)}] at  (0,0){testing={scalefac=0.8,picname=2,drawcolor=BlueLine,filllcolor=BlueLine, Linewidth=1.0pt}};
\end{scope}
 %auto text 3
 \begin{scope}[local bounding box=AUTOTEXT3,shift={($(DATA2)+(0,0.8)$)},scale=1, every node/.append style={transform shape}]
\pic[shift={(0,0)}] at  (0,0){autotext={scalefac=1,picname=1,drawcolor=green!70!black,filllcolor=green!70!black, Linewidth=1.0pt}};
\end{scope}
%display 2
 \begin{scope}[local bounding box=DISPLAY2,shift={($(DATA2)+(2.8,0.6)$)},scale=1, every node/.append style={transform shape}]
\pic[shift={(0,-0.5)}] at  (0,0){displayE={scalefac=1.3,picname=1,drawcolor=BrownLine,filllcolor=BrownLine, Linewidth=1.0pt}};
\pic[shift={(-0.15,-0.7)},rotate=20] at  (0,0){square={scalefac=0.46,picname=1,filllcolor=RedLine, Linewidth=0.5pt}};
\end{scope}
%testing 2
\begin{scope}[local bounding box=TESTING2,shift={($(DISPLAY2)+(2.3,0.55)$)},scale=1, every node/.append style={transform shape}]
\pic[shift={(0,-0.5)}] at  (0,0){testing={scalefac=0.85,picname=1,drawcolor=OrangeLine,filllcolor=OrangeLine, Linewidth=1.0pt}};
\pic[shift={(0,-1.0)},rotate=-15] at  (0,0){pencil={scalefac=0.35,picname=1,filllcolor=RedLine, Linewidth=1.0pt}};
\end{scope}
%display3
 \begin{scope}[local bounding box=DISPLAY3,shift={($(TESTING2)+(2.3,0.6)$)},scale=1, every node/.append style={transform shape}]
\pic[shift={(0,-0.5)}] at  (0,0){displayE={scalefac=1.3,picname=1,drawcolor=RedLine,filllcolor=red, Linewidth=1.0pt}};
\pic[shift={(0,-0.45)}] at  (0,0){globe={scalefac=0.38,picname=1,filllcolor=green!30!, Linewidth=1.2pt}};
\end{scope}
 %arrows
\coordinate(SR1)at($(PERSON1.east)!0.4!(DATA1.west)$);
\node[Larrow]at(SR1){};
\coordinate(SR2)at($(DATA1.east)!0.55!(GEAR1.west)$);
\node[Larrow]at(SR2){};
\coordinate(SR3)at($(GEAR1.east)!0.45!(PACKAGE1.west)$);
\node[Larrow]at(SR3){};
\coordinate(SR4)at($(PACKAGE1.east)!0.45!(DISPLAY1.west)$);
\node[Larrow]at(SR4){};
\coordinate(SR5)at($(DISPLAY1.east)!0.45!(SERVER1.west)$);
\node[Larrow]at(SR5){};
\coordinate(SR6)at($(SERVER1.east)!0.25!(PACKAGE2.west)$);
\node[Larrow]at(SR6){};
\coordinate(SR7)at($(PACKAGE2.east)!0.55!(PERSON2.west)$);
\node[Larrow]at(SR7){};
\coordinate(SR8)at($(PERSON2.east)!0.3!(DATA2.west)$);
\node[Larrow]at(SR8){};
\coordinate(SR9)at($(DATA2.east)!0.5!(DISPLAY2.west)$);
\node[Larrow]at(SR9){};
\coordinate(SR10)at($(DISPLAY2.east)!0.45!(TESTING2.west)$);
\node[Larrow]at(SR10){};
\coordinate(SR11)at($(TESTING2.east)!0.45!(DISPLAY3.west)$);
\node[Larrow]at(SR11){};
%Text
\path[red](PERSON1.south)--++(0,-2mm)coordinate(TP1)-|coordinate(TD1)(DATA1);
\node[align=center,anchor=north]at(TP1){Developers};
\node[align=center,anchor=north]at(TD1){Version\\ Control (Master)};
\path[red](PERSON1.south)--++(0,-2mm)-|coordinate(TG1)(GEAR1);
\node[align=center,anchor=north]at(TG1){Compile};
\path[red](PERSON1.south)--++(0,-2mm)-|coordinate(TP1)(PACKAGE1);
\node[align=center,anchor=north]at(TP1){Package};
\path[red](PERSON1.south)--++(0,-2mm)-|coordinate(TD1)(DISPLAY1);
\node[align=center,anchor=north]at(TD1){Auto Unit\\Testing};
\path[red](PERSON1.south)--++(0,-2mm)-|coordinate(TS1)(SERVER1);
\node[align=center,anchor=north]at(TS1){Auto UI\\Testing};
%
\path[red](PERSON1.south)--++(0,-2mm)-|coordinate(TP2)(PACKAGE2.250);
\node[align=center,anchor=north]at(TP2){Package with\\ Instructions};
\path[red](PERSON1.south)--++(0,-2mm)-|coordinate(TP2)(PERSON2);
\node[align=center,anchor=north]at(TP2){Operations\\Team};
\path[red](PERSON1.south)--++(0,-2mm)-|coordinate(TD2)(DATA2);
\node[align=center,anchor=north]at(TD2){Auto\\ Scripts};
\path[red](PERSON1.south)--++(0,-2mm)-|coordinate(TD2)(DISPLAY2);
\node[align=center,anchor=north]at(TD2){Test\\Environment};
\path[red](PERSON1.south)--++(0,-2mm)-|coordinate(TT2)(TESTING2);
\node[align=center,anchor=north]at(TT2){Testing};
\path[red](PERSON1.south)--++(0,-2mm)-|coordinate(TD3)(DISPLAY3);
\node[align=center,anchor=north]at(TD3){Public/\\General\\ Availability};
%fitting
\scoped[on background layer]
\node[draw=none,inner xsep=3mm,inner ysep=16mm,
yshift=-6mm,fill=BackColor!60,fit=(PERSON1)(SERVER1),line width=0.75pt](BB1){};
\node[below=4pt of  BB1.north,inner sep=0pt, anchor=north,GreenD]{\textbf{Build Pipeline}};
\node[above=4pt of  BB1.south,inner sep=0pt, anchor=south,GreenD]{\textbf{Continuous Integration}};
\scoped[on background layer]
\node[draw=none,inner xsep=3mm,inner ysep=16mm,
yshift=-6mm,fill=cyan!10,fit=(PERSON2)(DISPLAY3),line width=0.75pt](BB2){};
\node[below=4pt of  BB2.north,inner sep=0pt, anchor=north,GreenD]{\textbf{Release Pipeline}};
\node[above=4pt of  BB2.south,inner sep=0pt, anchor=south,GreenD]{\textbf{Continuous Delivery}};
\end{tikzpicture}
```
**CI/CD Pipeline**: Automated CI/CD pipelines enforce fault-aware development by integrating testing and validation directly into the software delivery process, reducing the risk of regressions and ensuring only tested code reaches production. Containerization technologies, such as Docker and Kubernetes, further enhance reliability by providing reproducible runtime environments across these pipeline stages. *Source: [geeksforgeeks](HTTPS://www.geeksforgeeks.org/ci-cd-continuous-integration-and-continuous-delivery/)*
:::

Together, these practices form a complete approach to software fault management in ML systems. When adopted systematically, they reduce the likelihood of system failures, improve long-term maintainability, and foster trust in model performance and reproducibility.

## Fault Injection Tools and Frameworks {#sec-robust-ai-fault-injection-tools-frameworks-fc07}

Given the importance of developing robust AI systems, in recent years, researchers and practitioners have developed a wide range of tools and frameworks building on the software infrastructure from @sec-ai-frameworks to understand how hardware faults manifest and propagate to impact ML systems. These tools and frameworks play a crucial role in evaluating the resilience of ML systems to hardware faults by simulating various fault scenarios and analyzing their impact on the system's performance, complementing the evaluation methodologies described in @sec-benchmarking-ai. This enables designers to identify potential vulnerabilities and develop effective mitigation strategies, ultimately creating more robust and reliable ML systems that can operate safely despite hardware faults, supporting the deployment strategies detailed in @sec-ml-operations. This section provides an overview of widely used fault models[^fn-fault-models] in the literature and the tools and frameworks developed to evaluate the impact of such faults on ML systems.

[^fn-fault-models]: **Fault Models**: Formal specifications describing how hardware faults manifest and propagate through systems. Examples include stuck-at models (bits permanently 0 or 1), single-bit flip models (temporary bit inversions), and Byzantine models (arbitrary malicious behavior). Essential for designing realistic fault injection experiments.

### Fault and Error Models {#sec-robust-ai-fault-error-models-c66e}

As discussed previously, hardware faults can manifest in various ways, including transient, permanent, and intermittent faults. In addition to the type of fault under study, how the fault manifests is also important. For example, does the fault happen in a memory cell or during the computation of a functional unit? Is the impact on a single bit, or does it impact multiple bits? Does the fault propagate all the way and impact the application (causing an error), or does it get masked quickly and is considered benign? All these details impact what is known as the fault model, which plays a major role in simulating and measuring what happens to a system when a fault occurs.

To study and understand the impact of hardware faults on ML systems, understanding the concepts of fault models and error models is essential. A fault model describes how a hardware fault manifests itself in the system, while an error model represents how the fault propagates and affects the system's behavior.

Fault models are often classified by several key properties. First, they can be defined by their duration: transient faults are temporary and vanish quickly; permanent faults persist indefinitely; and intermittent faults occur sporadically, making them particularly difficult to identify or predict. Another dimension is fault location, with faults arising in hardware components such as memory cells, functional units, or interconnects. Faults can also be characterized by their granularity—some faults affect only a single bit (e.g., a bitflip), while others impact multiple bits simultaneously, as in burst errors.

Error models, in contrast, describe the behavioral effects of faults as they propagate through the system. These models help researchers understand how initial hardware-level disturbances might manifest in the system’s behavior, such as through corrupted weights or miscomputed activations in an ML model. These models may operate at various abstraction levels, from low-level hardware errors to higher-level logical errors in ML frameworks.

The choice of fault or error model is central to robustness evaluation. For example, a system built to study single-bit transient faults [@sangchoolie2017one] will not offer meaningful insight into the effects of permanent multi-bit faults [@wilkening2014calculating], since its design and assumptions are grounded in a different fault model entirely.

It’s also important to consider how and where an error model is implemented. A single-bit flip at the architectural register level, modeled using simulators like gem5 [@binkert2011gem5], differs meaningfully from a similar bit flip in a PyTorch model’s weight tensor. While both simulate value-level perturbations, the lower-level model captures microarchitectural effects that are often abstracted away in software frameworks.

Interestingly, certain fault behavior patterns remain consistent regardless of abstraction level. For example, research has consistently demonstrated that single-bit faults cause more disruption than multi-bit faults, whether examining hardware-level effects or software-visible impacts [@sangchoolie2017one; @papadimitriou2021demystifying]. However, other important behaviors like error masking [@mohanram2003partial] may only be observable at lower abstraction levels. As illustrated in @fig-error-masking, this masking phenomenon can cause faults to be filtered out before they propagate to higher levels, meaning software-based tools may miss these effects entirely.

::: {#fig-error-masking fig-env="figure" fig-pos="htb"}

```{.tikz}
\begin{tikzpicture}[font=\small\usefont{T1}{phv}{m}{n}]
\tikzset{%
Line/.style={line width=1.0pt,black!50,text=black},
Box/.style={inner xsep=2pt,
    node distance=0.6,
    draw=VioletLine,
    line width=0.75pt,
    fill=VioletL!40,
    align=flush center,
    minimum width=25mm, minimum height=9mm
  },
Box2/.style={inner xsep=2pt,
    node distance=1.4,
    draw=BlueLine,
    line width=0.75pt,
    fill=BlueL!40,
    align=flush center,
    minimum width=29mm, minimum height=9mm
  },
Box3/.style={inner xsep=2pt,
    node distance=1.1,
    draw=BrownLine,
    line width=0.75pt,
    fill=BrownL!40,
    align=flush left,
    minimum width=55mm, minimum height=9mm
  },
   decision/.style={diamond, minimum width=50mm,node distance=0.6,inner sep=-1ex,
     minimum height=25mm, align=flush center, draw=GreenLine, fill=green!30}
}
\node[Box,rounded corners=9pt](B1){Soft error};
\node[Box,decision,below=of B1](B2){Corrupted  data \\are read?};
\node[Box,decision,below=of B2](B3){Incorrect  output \\ or  system crash?};
\node[Box2,right=of B2](B4){\textbf{Masked} \\ (microacrhitecture)};
\node[Box2,right=of B3](B5){\textbf{Masked} \\ (software)};
\node[Box,below=of B3](B6){Failure};
%%
\node[Box3,right=of B4](MLA){\textbf{Microarchitecture-level analysis}
\\[0.5ex]
$\bullet$ Errors on unused components
\\[0.5ex]
$\bullet$ Overwritten by write operations
\\[0.5ex]
$\bullet$ Errors on speculative instructions};
\node[Box3,right=of B5](SLA){\textbf{Software-level analysis}
\\[0.5ex]
$\bullet$ Dynamically dead instructions
\\[0.5ex]
$\bullet$ Logical, compare instructions
\\[0.5ex]
$\bullet$ Uninfluential branch instructions};
%%
\draw[Line,-latex](B1)--(B2);
\draw[Line,-latex](B2)--
node[right,font=\footnotesize\usefont{T1}{phv}{m}{n}]{Yes}(B3);
\draw[Line,-latex](B3)--
node[right,font=\footnotesize\usefont{T1}{phv}{m}{n}]{Yes}(B6);
\draw[Line,-latex](B2)--
node[above,pos=0.3,font=\footnotesize\usefont{T1}{phv}{m}{n}]{No}(B4);
\draw[Line,-latex](B3)--
node[above,pos=0.3,font=\footnotesize\usefont{T1}{phv}{m}{n}]{No}(B5);
%fitting
\scoped[on background layer]
\node[draw=BackLine,inner xsep=4mm,inner ysep=5mm,
yshift=2.5mm,fill=BackColor!50,fit=(B4)(SLA)(MLA),line width=0.75pt](BB2){};
\node[below=4pt of  BB2.north,inner sep=0pt,
anchor=north]{\textbf{System-level masking effect analysis}};
\end{tikzpicture}
```
**Error Masking**: Microarchitectural redundancy can absorb single-bit faults before they propagate to observable system errors, highlighting a discrepancy between hardware-level and software-level fault models. This figure details how fault masking occurs within microarchitectural components, demonstrating that software-based error detection tools may underestimate the true resilience of a system to transient errors. *[@ko2021characterizing]*
:::

To address these discrepancies, tools like Fidelity [@he2020fidelity] have been developed to align fault models across abstraction layers. By mapping software-observed fault behaviors to corresponding hardware-level patterns [@cheng2016clear], Fidelity offers a more accurate means of simulating hardware faults at the software level. While lower-level tools capture the true propagation of errors through a hardware system, they are generally slower and more complex. Software-level tools, such as those implemented in PyTorch or TensorFlow, are faster and easier to use for large-scale robustness testing, albeit with less precision.

### Hardware-Based Fault Injection {#sec-robust-ai-hardwarebased-fault-injection-ae39}

Hardware-based fault injection methods allow researchers to directly introduce faults into physical systems and observe their effects on ML models. These approaches are essential for validating assumptions made in software-level fault injection tools and for studying how real-world hardware faults influence system behavior. While most error injection tools used in ML robustness research are software-based, because of their speed and scalability, hardware-based approaches remain critical for grounding higher-level error models. They are considered the most accurate means of studying the impact of faults on ML systems by manipulating the hardware directly to introduce errors.

As illustrated in @fig-hardware-errors, hardware faults can arise at various points within a deep neural network (DNN) processing pipeline. These faults may affect the control unit, on-chip memory (SRAM), off-chip memory (DRAM), processing elements, and accumulators, leading to erroneous results. In the depicted example, a DNN tasked with recognizing traffic signals correctly identifies a red light under normal conditions. However, hardware-induced faults, caused by phenomena such as aging, electromigration, soft errors, process variations, and manufacturing defects, can introduce errors that cause the DNN to misclassify the signal as a green light, potentially leading to catastrophic consequences in real-world applications.

![**Hardware Faults**: This figure enables where hardware-induced errors can occur within a DNN processing pipeline, highlighting potential points of failure such as control units and memory modules that can lead to misclassifications in real-world applications.](./images/png/hardware_errors.png){#fig-hardware-errors}

These methods enable researchers to observe the system's behavior under real-world fault conditions. Both software-based and hardware-based error injection tools are described in this section in more detail.

#### Hardware Injection Methods {#sec-robust-ai-hardware-injection-methods-8cc9}

Two of the most common hardware-based fault injection methods are FPGA-based fault injection and radiation or beam testing.

**FPGA-based Fault Injection.** Field-Programmable Gate Arrays (FPGAs)[^fn-fpga] are reconfigurable integrated circuits that can be programmed to implement various hardware designs. In the context of fault injection, FPGAs offer high precision and accuracy, as researchers can target specific bits or sets of bits within the hardware. By modifying the FPGA configuration, faults can be introduced at specific locations and times during the execution of an ML model. FPGA-based fault injection allows for fine-grained control over the fault model, enabling researchers to study the impact of different types of faults, such as single-bit flips or multi-bit errors. This level of control makes FPGA-based fault injection a valuable tool for understanding the resilience of ML systems to hardware faults.

[^fn-fpga]: **Field-Programmable Gate Arrays (FPGAs)**: Reconfigurable hardware devices containing millions of logic blocks that can be programmed to implement custom digital circuits. Originally developed by Xilinx in 1985, FPGAs bridge the gap between software flexibility and hardware performance, enabling rapid prototyping and specialized accelerators.

While FPGA-based methods allow precise, controlled fault injection, other approaches aim to replicate fault conditions found in natural environments.

**Radiation or Beam Testing.** Radiation or beam testing [@velazco2010combining] exposes hardware running ML models to high-energy particles like protons or neutrons. As shown in @fig-beam-testing, specialized test facilities enable controlled radiation exposure to induce bitflips and other hardware-level faults. This approach is widely regarded as one of the most accurate methods for measuring error rates from particle strikes during application execution. Beam testing provides highly realistic fault scenarios that mirror conditions in radiation-rich environments, making it particularly valuable for validating systems destined for space missions or particle physics experiments. However, while beam testing offers exceptional realism, it lacks the precise targeting capabilities of FPGA-based injection - particle beams cannot be aimed at specific hardware bits or components with high precision. Despite this limitation and its significant operational complexity and cost, beam testing remains a trusted industry practice for rigorously evaluating hardware reliability under real-world radiation effects.

![**Radiation Testing Setup**: Beam testing facilities induce hardware faults by exposing semiconductor components to high-energy particles, simulating realistic radiation environments encountered in space or particle physics experiments. This controlled fault injection method provides valuable data for assessing hardware reliability and error rates under extreme conditions, though it lacks the precise targeting capabilities of FPGA-based fault injection. *Source: JD instruments [HTTPS://jdinstruments.net/tester-capabilities-radiation-test/]*](./images/png/image14.png){#fig-beam-testing}

#### Hardware Injection Limitations {#sec-robust-ai-hardware-injection-limitations-ac49}

Despite their high accuracy, hardware-based fault injection methods have several limitations that can hinder their widespread adoption.

First, cost is a major barrier. Both FPGA-based and beam testing[^fn-beam_testing] approaches require specialized hardware and facilities, which can be expensive to set up and maintain. This makes them less accessible to research groups with limited funding or infrastructure.

[^fn-beam_testing]: **Beam Testing**: A testing method that exposes hardware to controlled particle radiation to evaluate its resilience to soft errors. Common in aerospace, medical devices, and high-reliability computing.

Second, these methods face challenges in scalability. Injecting faults and collecting data directly on hardware is time-consuming, which limits the number of experiments that can be run in a reasonable timeframe. This is especially restrictive when analyzing large ML systems or performing statistical evaluations across many fault scenarios.

Third, flexibility limitations exist. Hardware-based methods may not be as adaptable as software-based alternatives when modeling a wide variety of fault and error types. Changing the experimental setup to accommodate a new fault model often requires time-intensive hardware reconfiguration.

Despite these limitations, hardware-based fault injection remains essential for validating the accuracy of software-based tools and for studying system behavior under real-world fault conditions. By combining the high fidelity of hardware-based methods with the scalability and flexibility of software-based tools, researchers can develop a more complete understanding of ML systems' resilience to hardware faults and craft effective mitigation strategies.

### Software-Based Fault Injection {#sec-robust-ai-softwarebased-fault-injection-d8a1}

As machine learning frameworks like TensorFlow, PyTorch, and Keras have become the dominant platforms for developing and deploying ML models, software-based fault injection tools have emerged as a flexible and scalable way to evaluate the robustness of these systems to hardware faults. Unlike hardware-based approaches, which operate directly on physical systems, software-based methods simulate the effects of hardware faults by modifying a model’s underlying computational graph, tensor values, or intermediate computations.

These tools have become increasingly popular in recent years because they integrate directly with ML development pipelines, require no specialized hardware, and allow researchers to conduct large-scale fault injection experiments quickly and cost-effectively. By simulating hardware-level faults, including bit flips in weights, activations, or gradients, at the software level, these tools enable efficient testing of fault tolerance mechanisms and provide valuable insight into model vulnerabilities.

In the remainder of this section, we will examine the advantages and limitations of software-based fault injection methods, introduce major classes of tools (both general-purpose and domain-specific), and discuss how they contribute to building resilient ML systems.

#### Software Injection Trade-offs {#sec-robust-ai-software-injection-tradeoffs-b390}

Software-based fault injection tools offer several advantages that make them attractive for studying the resilience of ML systems.

One of the primary benefits is speed. Since these tools operate entirely within the software stack, they avoid the overhead associated with modifying physical hardware or configuring specialized test environments. This efficiency enables researchers to perform a large number of fault injection experiments in significantly less time. The ability to simulate a wide range of faults quickly makes these tools particularly useful for stress-testing large-scale ML models or conducting statistical analyses that require thousands of injections.

These tools also offer flexibility. Software-based fault injectors can be easily adapted to model various types of faults. Researchers can simulate single-bit flips, multi-bit corruptions, or even more complex behaviors such as burst errors or partial tensor corruption. Software tools allow faults to be injected at different stages of the ML pipeline, at the stages of training, inference, or gradient computation, enabling precise targeting of different system components or layers.

These tools are also highly accessible, as they require only standard ML development environments. Unlike hardware-based methods, software tools require no costly experimental setups, custom circuitry, or radiation testing facilities. This accessibility opens up fault injection research to a broader range of institutions and developers, including those working in academia, startups, or resource-constrained environments.

However, these advantages come with certain trade-offs. Chief among them is accuracy. Because software-based tools model faults at a higher level of abstraction, they may not fully capture the low-level hardware interactions that influence how faults actually propagate. For example, a simulated bit flip in an ML framework may not account for how data is buffered, cached, or manipulated at the hardware level, potentially leading to oversimplified conclusions.

Closely related is the issue of fidelity. While it is possible to approximate real-world fault behaviors, software-based tools may diverge from true hardware behavior, particularly when it comes to subtle interactions like masking, timing, or data movement. The results of such simulations depend heavily on the underlying assumptions of the error model and may require validation against real hardware measurements to be reliable.

Despite these limitations, software-based fault injection tools play an indispensable role in the study of ML robustness. Their speed, flexibility, and accessibility allow researchers to perform wide-ranging evaluations and inform the development of fault-tolerant ML architectures. In subsequent sections, we explore the major tools in this space, highlighting their capabilities and use cases.

#### Software Injection Limitations {#sec-robust-ai-software-injection-limitations-eee7}

While software-based fault injection tools offer significant advantages in terms of speed, flexibility, and accessibility, they are not without limitations. These constraints can impact the accuracy and realism of fault injection experiments, particularly when assessing the robustness of ML systems to real-world hardware faults.

One major concern is accuracy. Because software-based tools operate at higher levels of abstraction, they may not always capture the full spectrum of effects that hardware faults can produce. Low-level hardware interactions, including subtle timing errors, voltage fluctuations, and architectural side effects, can be missed entirely in high-level simulations. As a result, fault injection studies that rely solely on software models may under- or overestimate a system’s true vulnerability to certain classes of faults.

Closely related is the issue of fidelity. While software-based methods are often designed to emulate specific fault behaviors, the extent to which they reflect real-world hardware conditions can vary. For example, simulating a single-bit flip in the value of a neural network weight may not fully replicate how that same bit error would propagate through memory hierarchies or affect computation units on an actual chip. The more abstract the tool, the greater the risk that the simulated behavior will diverge from physical behavior under fault conditions.

Because software-based tools are easier to modify, they risk unintentionally deviating from realistic fault assumptions. This can occur if the chosen fault model is overly simplified or not grounded in empirical data from actual hardware behavior. As discussed later in the section on bridging the hardware-software gap, tools like Fidelity [@he2020fidelity] attempt to address these concerns by aligning software-level models with known hardware-level fault characteristics.

Despite these limitations, software-based fault injection remains a critical part of the ML robustness research toolkit. When used appropriately, particularly when used in conjunction with hardware-based validation, these tools provide a scalable and efficient way to explore large design spaces, identify vulnerable components, and develop mitigation strategies. As fault modeling techniques continue to evolve, the integration of hardware-aware insights into software-based tools will be key to improving their realism and impact.

#### Software Injection Tool Categories {#sec-robust-ai-software-injection-tool-categories-23e5}

Over the past several years, software-based fault injection tools have been developed for a wide range of ML frameworks and use cases. These tools vary in their level of abstraction, target platforms, and the types of faults they can simulate. Many are built to integrate with popular machine learning libraries such as PyTorch and TensorFlow, making them accessible to researchers and practitioners already working within those ecosystems.

One of the earliest and most influential tools is Ares [@reagen2018ares], initially designed for the Keras framework. Developed at a time when deep neural networks (DNNs) were growing in popularity, Ares was one of the first tools to systematically explore the effects of hardware faults on DNNs. It provided support for injecting single-bit flips and evaluating bit-error rates (BER) across weights and activation values. Importantly, Ares was validated against a physical DNN accelerator implemented in silicon, demonstrating its relevance for hardware-level fault modeling. As the field matured, Ares was extended to support PyTorch, allowing researchers to analyze fault behavior in more modern ML settings.

Building on this foundation, PyTorchFI [@mahmoud2020pytorchfi] was introduced as a dedicated fault injection library for PyTorch. Developed in collaboration with Nvidia Research, PyTorchFI allows fault injection into key components of ML models, including weights, activations, and gradients. Its native support for GPU acceleration makes it especially well-suited for evaluating large models efficiently. As shown in @fig-phantom-objects, even simple bit-level faults can cause severe visual and classification errors, including the appearance of 'phantom' objects in images, which could have downstream safety implications in domains like autonomous driving.

![**Fault Injection Effects**: Bit-level hardware faults can induce phantom objects and misclassifications in machine learning models, potentially leading to safety-critical errors in applications like autonomous driving; the left image represents correct classification, while the right image presents a false positive detection resulting from a single bit flip injected using pytorchfi.](./images/png/phantom_objects.png){#fig-phantom-objects}

The modular and accessible design of PyTorchFI has led to its adoption in several follow-on projects. For example, PyTorchALFI (developed by Intel xColabs) extends PyTorchFI’s capabilities to evaluate system-level safety in automotive applications. Similarly, Dr. DNA [@ma2024dr] from Meta introduces a more streamlined, Pythonic API to simplify fault injection workflows. Another notable extension is GoldenEye [@mahmoud2022dsn], which incorporates alternative numeric datatypes, including AdaptivFloat [@tambe2020algorithm] and BlockFloat, with bfloat16 as a specific example, to study the fault tolerance of non-traditional number formats under hardware-induced bit errors.

For researchers working within the TensorFlow ecosystem, TensorFI [@chen2020tensorfi] provides a parallel solution. Like PyTorchFI, TensorFI enables fault injection into the TensorFlow computational graph and supports a variety of fault models. One of TensorFI’s strengths is its broad applicability—it can be used to evaluate many types of ML models beyond DNNs. Additional extensions such as BinFi [@chen2019sc] aim to accelerate the fault injection process by focusing on the most critical bits in a model. This prioritization can help reduce simulation time while still capturing the most meaningful error patterns.

At a lower level of the software stack, NVBitFI [@tsai2021nvbitfi] offers a platform-independent tool for injecting faults directly into GPU assembly code. Developed by Nvidia, NVBitFI is capable of performing fault injection on any GPU-accelerated application, not just ML workloads. This makes it an especially powerful tool for studying resilience at the instruction level, where errors can propagate in subtle and complex ways. NVBitFI represents an important complement to higher-level tools like PyTorchFI and TensorFI, offering fine-grained control over GPU-level behavior and supporting a broader class of applications beyond machine learning.

Together, these tools offer a wide spectrum of fault injection capabilities. While some are tightly integrated with high-level ML frameworks for ease of use, others enable lower-level fault modeling with higher fidelity. By choosing the appropriate tool based on the level of abstraction, performance needs, and target application, researchers can tailor their studies to gain more actionable insights into the robustness of ML systems. The next section focuses on how these tools are being applied in domain-specific contexts, particularly in safety-critical systems such as autonomous vehicles and robotics.

#### ML-Specific Injection Tools {#sec-robust-ai-mlspecific-injection-tools-0584}

To address the unique challenges posed by specific application domains, researchers have developed specialized fault injection tools tailored to different ML systems. In high-stakes environments such as autonomous vehicles and robotics, domain-specific tools play a crucial role in evaluating system safety and reliability under hardware fault conditions. This section highlights three such tools: DriveFI and PyTorchALFI, which focus on autonomous vehicles, and MAVFI, which targets uncrewed aerial vehicles (UAVs). Each tool enables the injection of faults into mission-critical components, including perception, control, and sensor systems, providing researchers with insights into how hardware errors may propagate through real-world ML pipelines.

DriveFI [@jha2019ml] is a fault injection tool developed for autonomous vehicle systems. It facilitates the injection of hardware faults into the perception and control pipelines, enabling researchers to study how such faults affect system behavior and safety. Notably, DriveFI integrates with industry-standard platforms like Nvidia DriveAV and Baidu Apollo, offering a realistic environment for testing. Through this integration, DriveFI enables practitioners to evaluate the end-to-end resilience of autonomous vehicle architectures in the presence of fault conditions.

PyTorchALFI [@grafe2023large] extends the capabilities of PyTorchFI for use in the autonomous vehicle domain. Developed by Intel xColabs, PyTorchALFI enhances the underlying fault injection framework with domain-specific features. These include the ability to inject faults into multimodal sensor data[^fn-multimodal-sensor-data], such as inputs from cameras and LiDAR systems. This allows for a deeper examination of how perception systems in autonomous vehicles respond to underlying hardware faults, further refining our understanding of system vulnerabilities and potential failure modes.

[^fn-multimodal-sensor-data]: **Multimodal Sensor Data**: Information collected simultaneously from multiple types of sensors (e.g., cameras, LiDAR, radar) to provide complementary perspectives of the environment. Critical for robust perception in autonomous systems.

MAVFI [@hsiao2023mavfi] is a domain-specific fault injection framework tailored for robotics applications, particularly uncrewed aerial vehicles. Built atop the Robot Operating System (ROS), MAVFI provides a modular and extensible platform for injecting faults into various UAV subsystems, including sensors, actuators, and flight control algorithms. By assessing how injected faults impact flight stability and mission success, MAVFI offers a practical means for developing and validating fault-tolerant UAV architectures.

Together, these tools demonstrate the growing sophistication of fault injection research across application domains. By enabling fine-grained control over where and how faults are introduced, domain-specific tools provide actionable insights that general-purpose frameworks may overlook. Their development has greatly expanded the ML community’s capacity to design and evaluate resilient systems—particularly in contexts where reliability, safety, and real-time performance are critical.

### Bridging Hardware-Software Gap {#sec-robust-ai-bridging-hardwaresoftware-gap-d194}

While software-based fault injection tools offer many advantages in speed, flexibility, and accessibility, they do not always capture the full range of effects that hardware faults can impose on a system. This is largely due to the abstraction gap: software-based tools operate at a higher level and may overlook low-level hardware interactions or nuanced error propagation mechanisms that influence the behavior of ML systems in critical ways.

As discussed in the work by [@bolchini2022fast], hardware faults can exhibit complex spatial distribution patterns that are difficult to replicate using purely software-based fault models. They identify four characteristic fault propagation patterns: single point, where the fault corrupts a single value in a feature map; same row, where a partial or entire row in a feature map is corrupted; bullet wake, where the same location across multiple feature maps is affected; and shatter glass, a more complex combination of both same row and bullet wake behaviors. These diverse patterns, visualized in @fig-hardware-errors-bolchini, highlight the limits of simplistic injection strategies and emphasize the need for hardware-aware modeling when evaluating ML system robustness.

::: {#fig-hardware-errors-bolchini fig-env="figure" fig-pos="htb"}
```{.tikz}
 \begin{tikzpicture}[line join=round,font=\Large\usefont{T1}{phv}{m}{n},scale=0.5]
\def\columns{8}
\def\rows{8}
\def\cellsize{3mm}
\def\cellheight{3mm}
\def\br{A}
\tikzset{%
Fill/.style={fill=red,draw=black,line width=0.5pt, minimum size=\cellsize,
minimum height=\cellheight}
}
\tikzset{
  grid/.pic={
  \foreach \x in {1,...,\columns}{
    \foreach \y in {1,...,\rows}{
        %
        \node[draw=black, fill=cyan!20, minimum width=\cellsize,
                    minimum height=\cellheight, line width=0.5pt] (cell-\x-\y\br) at (\x*\cellsize,-\y*\cellheight) {};
    }
}
  }
}
\begin{scope}[local bounding box=BUL]
\begin{scope}[local bounding box=B1]
\foreach \i /\b in {0/A,1/B,2/C,3/D,4/E,5/F,6/G}{
\def\br{\b}
    \pic at (-\i, -\i*1.5) {grid};
}

\foreach \i /\b in {0/A,1/B,2/C,3/D,4/E,5/F,6/G}{
\node[Fill] at (cell-7-2\b) {};
}
\end{scope}

\begin{scope}[local bounding box=B2,shift={(9,0)}]
\foreach \i /\b in {0/A,1/B,2/C,3/D,4/E,5/F,6/G}{
\def\br{\b}
    \pic at (-\i, -\i*1.5) {grid};
}

\foreach \i /\b in {0/A,2/C,6/G}{
\node[Fill] at (cell-7-2\b) {};
}
\end{scope}
\end{scope}
%%%%
%Shattered glass
\begin{scope}[local bounding box=SHA,shift={(21,0)}]
\begin{scope}[local bounding box=S1]
\foreach \i /\b in {0/A,1/B,2/C,3/D,4/E,5/F,6/G}{
\def\br{\b}
    \pic at (-\i, -\i*1.5) {grid};
}

\foreach \i /\b in {0/A,1/B,2/C,3/D,4/E,5/F,6/G}{
\node[Fill] at (cell-7-2\b) {};
}
\foreach \i in{2,...,6}{
\node[Fill] at (cell-\i-2C) {};
}
\end{scope}

\begin{scope}[local bounding box=S2,shift={(9,0)}]
\foreach \i /\b in {0/A,1/B,2/C,3/D,4/E,5/F,6/G}{
\def\br{\b}
    \pic at (-\i, -\i*1.5) {grid};
}

\foreach \i /\b in {0/A,1/B,2/C,4/E,5/F,6/G}{
\node[Fill]  at (cell-7-2\b) {};
}
\foreach \i /\b in {1/B,2/C,4/E,5/F,6/G}{
\node[Fill] at (cell-3-2\b) {};
}
\node[Fill] at (cell-6-2E) {};
\node[Fill] at (cell-4-2F) {};
\end{scope}

\begin{scope}[local bounding box=S3,shift={(18,0)}]
\foreach \i /\b in {0/A,1/B,2/C,3/D,4/E,5/F,6/G}{
\def\br{\b}
    \pic at (-\i, -\i*1.5) {grid};
}

\foreach \i /\b in {0/A,2/C,3/D,5/F}{
\node[Fill] at (cell-7-2\b) {};
}
\foreach \i in{2,4,5}{
\node[Fill] at (cell-\i-2C) {};
}
\end{scope}
\end{scope}
%%%%%%%%%%%%%%%%%%
%above Single point
\begin{scope}[local bounding box=SIN,shift={(-3.8,12)}]
\begin{scope}[local bounding box=SI1]
\foreach \i /\b in {0/A,1/B,2/C}{
\def\br{\b}
    \pic at (-\i, -\i*2) {grid};
}

\foreach \b in {C}{
\node[Fill]  at (cell-4-7\b) {};
}
\end{scope}
\begin{scope}[local bounding box=B2,shift={(8,0)}]
\foreach \i /\b in {0/A,1/B,2/C}{
\def\br{\b}
    \pic at (-\i, -\i*2) {grid};
}

\foreach \b in {C}{
\node[Fill] at (cell-5-4\b) {};
}
\end{scope}
\begin{scope}[local bounding box=B3,shift={(16,0)}]
\foreach \i /\b in {0/A,1/B,2/C}{
\def\br{\b}
    \pic at (-\i, -\i*2) {grid};
}

\foreach \b in {A}{
\node[Fill] at (cell-7-3\b) {};
}
\end{scope}
\end{scope}

%%%%%%%%%%%%%%%%%%
%above Same row
\begin{scope}[local bounding box=SAM,shift={(23,12)}]
\begin{scope}[local bounding box=SA1]
\foreach \i /\b in {0/A,1/B,2/C}{
\def\br{\b}
    \pic at (-\i, -\i*2) {grid};
}

\foreach \i in {1,...,8}{
\node[Fill]  at (cell-\i-3C) {};
}
\end{scope}
\begin{scope}[local bounding box=B2,shift={(8,0)}]
\foreach \i /\b in {0/A,1/B,2/C}{
\def\br{\b}
    \pic at (-\i, -\i*2) {grid};
}

\foreach \i in {2,...,7}{
\node[Fill]  at (cell-\i-2B) {};
}
\end{scope}
\begin{scope}[local bounding box=B3,shift={(16,0)}]
\foreach \i /\b in {0/A,1/B,2/C}{
\def\br{\b}
    \pic at (-\i, -\i*2) {grid};
}

\foreach \i in {2,4,5,8}{
\node[Fill] at (cell-\i-5C) {};
}
\end{scope}
\end{scope}
\node[below=0.3 of SIN]{(a) Single point};
\node[below=0.3 of SAM]{(b) Same row};
\node[below=0.3 of BUL]{(c) Bullet wake};
\node[below=0.3 of SHA]{(d) Shatttered glass};
\end{tikzpicture}
```
**Hardware Fault Patterns**: Dnns exhibit distinct error manifestations from hardware faults, categorized by their spatial distribution across feature maps and layers. These patterns—single point, same row, bullet wake, and shatter glass—represent localized versus widespread corruption, impacting model predictions and highlighting the need for fault-tolerant system design. Source: [@bolchini2022fast].
:::
To address this abstraction gap, researchers have developed tools that explicitly aim to map low-level hardware error behavior to software-visible effects. One such tool is Fidelity, which bridges this gap by studying how hardware-level faults propagate and become observable at higher software layers. The next section discusses Fidelity in more detail.

#### Simulation Fidelity Challenges {#sec-robust-ai-simulation-fidelity-challenges-dd28}

Fidelity [@he2020fidelity] is a tool designed to model hardware faults more accurately within software-based fault injection experiments. Its core goal is to bridge the gap between low-level hardware fault behavior and the higher-level effects observed in machine learning systems by simulating how faults propagate through the compute stack.

The central insight behind Fidelity is that not all faults need to be modeled individually at the hardware level to yield meaningful results. Instead, Fidelity focuses on how faults manifest at the software-visible state and identifies equivalence relationships that allow representative modeling of entire fault classes. To accomplish this, it relies on several key principles:

First, fault propagation is studied to understand how a fault originating in hardware can move through various layers, including architectural registers, memory hierarchies, and numerical operations, eventually altering values in software. Fidelity captures these pathways to ensure that injected faults in software reflect the way faults would actually manifest in a real system.

Second, the tool identifies fault equivalence, which refers to grouping hardware faults that lead to similar observable outcomes in software. By focusing on representative examples rather than modeling every possible hardware bit flip individually, Fidelity allows more efficient simulations without sacrificing accuracy.

Finally, Fidelity uses a layered modeling approach, capturing the system’s behavior at various abstraction levels—from hardware fault origin to its effect in the ML model’s weights, activations, or predictions. This layering ensures that the impact of hardware faults is realistically simulated in the context of the ML system.

By combining these techniques, Fidelity allows researchers to run fault injection experiments that closely mirror the behavior of real hardware systems, but with the efficiency and flexibility of software-based tools. This makes Fidelity especially valuable in safety-critical settings, where the cost of failure is high and an accurate understanding of hardware-induced faults is essential.

#### Hardware Behavior Modeling {#sec-robust-ai-hardware-behavior-modeling-9bd8}

Capturing the true behavior of hardware faults in software-based fault injection tools is critical for advancing the reliability and robustness of ML systems. This fidelity becomes especially important when hardware faults have subtle but significant effects that may not be evident when modeled at a high level of abstraction.

Several reasons explain why accurately reflecting hardware behavior is essential. First, accuracy is paramount. Software-based tools that mirror the actual propagation and manifestation of hardware faults provide more dependable insights into how faults influence model behavior. These insights are crucial for designing and validating fault-tolerant architectures and ensuring that mitigation strategies are grounded in realistic system behavior.

Second, reproducibility is improved when hardware effects are faithfully captured. This allows fault injection results to be reliably reproduced across different systems and environments, which is a cornerstone of rigorous scientific research. Researchers can better compare results, validate findings, and ensure consistency across studies.

Third, efficiency is enhanced when fault models focus on the most representative and impactful fault scenarios. Rather than exhaustively simulating every possible bit flip, tools can target a subset of faults that are known, through accurate modeling, to affect the system in meaningful ways. This selective approach saves computational resources while still providing thorough insights.

Finally, understanding how hardware faults appear at the software level is essential for designing effective mitigation strategies. When researchers know how specific hardware-level issues affect different components of an ML system, they can develop more targeted hardening techniques—such as retraining specific layers, applying redundancy selectively, or improving architectural resilience in bottleneck components.

Tools like Fidelity are central to this effort. By establishing mappings between low-level hardware behavior and higher-level software effects, Fidelity and similar tools empower researchers to conduct fault injection experiments that are not only faster and more scalable, but also grounded in real-world system behavior.

As ML systems continue to increase in scale and are deployed in increasingly safety-critical environments, this kind of hardware-aware modeling will become even more important. Ongoing research in this space aims to further refine the translation between hardware and software fault models and to develop tools that offer both efficiency and realism in evaluating ML system resilience. These advances will provide the community with more powerful, reliable methods for understanding and defending against the effects of hardware faults.

## Fallacies and Pitfalls {#sec-robust-ai-fallacies-pitfalls-087e}

The complexity and interconnected nature of robustness threats often leads to misconceptions about effective defense strategies, particularly around the assumption that robustness techniques provide universal protection without trade-offs or limitations.

**Fallacy:** _Adversarial robustness can be achieved through defensive techniques without trade-offs._

This misconception leads teams to believe that robustness techniques like adversarial training or input preprocessing provide complete protection without costs. Adversarial defenses often introduce significant trade-offs including reduced clean accuracy, increased computational overhead, or brittleness to new attack methods. Many defensive techniques that appear effective against specific attacks fail when evaluated against stronger or adaptive adversaries. The arms race between attacks and defenses means that robustness is not a solved problem but an ongoing engineering challenge that requires continuous adaptation and evaluation against evolving threats.

**Pitfall:** _Testing robustness only against known attack methods rather than comprehensive threat modeling._

Many practitioners evaluate model robustness by testing against a few standard adversarial attacks without considering the full spectrum of potential threats. This approach provides false confidence when models perform well against limited test cases but fail catastrophically against novel attack vectors. Real-world threats include not only sophisticated adversarial examples but also hardware faults, data corruption, distribution shifts, and software vulnerabilities that may not resemble academic attack scenarios. Comprehensive robustness evaluation requires systematic threat modeling that considers the full attack surface rather than focusing on a narrow set of known vulnerabilities.

**Fallacy:** _Distribution shift can be solved by collecting more diverse training data._

This belief assumes that dataset diversity alone ensures robustness to distribution shifts encountered in deployment. While diverse training data helps, it cannot anticipate all possible distribution changes that occur in dynamic real-world environments. Training datasets remain inherently limited compared to the infinite variety of deployment conditions. Some distribution shifts are inherently unpredictable, emerging from changing user behavior, evolving data sources, or external environmental factors. Effective robustness requires adaptive systems with monitoring, detection, and response capabilities rather than relying solely on comprehensive training data.

**Pitfall:** _Assuming that robustness techniques designed for one threat category protect against all failure modes._

Teams often apply robustness techniques developed for specific threats without understanding their limitations against other failure modes. Adversarial training designed for gradient-based attacks may not improve robustness against hardware faults or data poisoning. Similarly, techniques that handle benign distribution shifts might fail against adversarial distribution shifts designed to exploit model weaknesses. Each threat category requires specialized defenses, and effective robustness necessitates layered protection strategies that address the full spectrum of potential failures rather than assuming cross-domain effectiveness.

**Fallacy:** _Different failure modes operate independently and can be addressed in isolation._

This assumption overlooks the complex interactions between different fault types that can create compound vulnerabilities exceeding the sum of individual threats. Real-world failures often involve cascading effects where one vulnerability enables or amplifies others. Consider these compound scenarios:

Hardware-adversarial interactions illustrate how bit flips in model weights can inadvertently create adversarial vulnerabilities not present in the original model. An attacker discovering these corruptions could craft targeted adversarial examples that exploit the specific weight perturbations, achieving 95% attack success rates compared to 20% on uncorrupted models. Conversely, adversarial training meant to improve robustness increases model complexity by 2-3$\times$, raising the probability of hardware faults due to increased memory and computation requirements.

Environmental-software cascades occur when gradual distribution shift may go undetected due to bugs in monitoring software that fail to log outlier samples. As the shift progresses over 3-6 months, the model's accuracy degrades by 40%, but the faulty monitoring system reports normal operation. When finally discovered, the compounded data drift and delayed detection require complete model retraining rather than incremental adaptation, incurring 10$\times$ higher recovery costs.

Attack-enabled distribution exploitation involves an adversary observing natural distribution shift in a deployed system and crafting poisoning attacks that accelerate the drift in specific directions. By injecting just 0.1% poisoned samples that align with natural drift patterns, attackers can cause 5$\times$ faster performance degradation while evading detection systems calibrated for either pure adversarial or pure drift scenarios.

Triple-threat scenarios demonstrate the most severe compound vulnerabilities. Consider an autonomous vehicle where cosmic ray-induced bit flips corrupt perception model weights, adversarial road markings exploit these corruptions, and seasonal weather changes create distribution shift. The combination results in 85% misclassification of stop signs under specific conditions, while each individual threat would cause only 15-20% degradation.

These compound scenarios demonstrate that robust AI systems must consider threat interactions through comprehensive failure mode analysis, cross-domain testing that evaluates combined vulnerabilities, and defense strategies that account for cascading failures rather than treating each threat in isolation.

## Summary {#sec-robust-ai-summary-a274}

This chapter established robust AI as a core requirement for reliable machine learning systems operating in real-world environments. Through examination of concrete failures across cloud, edge, and embedded deployments, we demonstrated that robustness challenges span multiple dimensions and require systematic approaches to detection, mitigation, and recovery.

The unified framework developed here organizes robustness challenges into three interconnected pillars that share common principles while requiring specialized approaches. System-level faults address the physical substrate reliability that underlies all ML computations, from transient cosmic ray effects to permanent hardware degradation. Input-level attacks encompass deliberate attempts to manipulate model behavior through adversarial examples and data poisoning techniques. Environmental shifts represent the natural evolution of deployment conditions that challenge static model assumptions through distribution drift and concept changes.

Across these three pillars, robust AI systems implement common principles of detection and monitoring to identify threats before they impact system behavior, graceful degradation to maintain core functionality under stress, and adaptive response to adjust system behavior based on detected conditions. These principles manifest differently across pillar types but provide a unified foundation for building comprehensive robustness solutions.

The practical implementation of robust AI requires integration across the entire ML pipeline, from data collection through deployment and monitoring. Hardware fault tolerance mechanisms must coordinate with adversarial defenses and drift detection systems to provide comprehensive protection. This robustness foundation establishes the reliability guarantees necessary for the operational frameworks detailed in @sec-ml-operations, where these fault-tolerant systems will be deployed, monitored, and maintained at scale. Without the comprehensive reliability mechanisms developed here, the operational workflows in the next chapter would lack the fundamental resilience required for production deployment.

@tbl-robustness-summary provides a practical reference mapping each of the three main fault categories to their primary detection and mitigation strategies, serving as an engineering guide for implementing comprehensive robustness solutions:

+--------------------+-----------------------------------+---------------------------+
| **Fault Category** | **Detection Methods**             | **Mitigation Strategies** |
+:===================+:==================================+:==========================+
| **System-Level**   | ECC Memory                        | Redundancy (TMR/DMR)      |
+--------------------+-----------------------------------+---------------------------+
| **Faults**         | BIST (Built-In Self-Test)         | Checkpointing             |
|                    | Watchdog Timers                   | Hardware Redundancy       |
|                    | Voltage/Temperature Monitoring    | Error Correction Codes    |
+--------------------+-----------------------------------+---------------------------+
| **Input-Level**    | Input Sanitization                | Adversarial Training      |
+--------------------+-----------------------------------+---------------------------+
| **Attacks**        | Anomaly Detection                 | Defensive Distillation    |
|                    | Statistical Testing               | Input Preprocessing       |
|                    | Behavioral Analysis               | Model Ensembles           |
+--------------------+-----------------------------------+---------------------------+
| **Environmental**  | Statistical Monitoring (MMD, PSI) | Continuous Learning       |
+--------------------+-----------------------------------+---------------------------+
| **Shifts**         | Distribution Comparison           | Model Retraining          |
|                    | Performance Degradation Tracking  | Adaptive Thresholds       |
|                    | Concept Drift Detection           | Ensemble Methods          |
+--------------------+-----------------------------------+---------------------------+

: **Robustness Strategy Reference**: A practical mapping of fault categories to their primary detection and mitigation approaches, providing engineers with a systematic framework for implementing comprehensive robustness solutions across the three pillars of robust AI. {#tbl-robustness-summary}

::: {.callout-important title="Key Takeaways"}

* Robust AI systems must address three interconnected threat categories: system-level faults, input-level attacks, and environmental shifts
* Common principles of detection, graceful degradation, and adaptive response apply across all threat types while requiring specialized implementations
* Hardware reliability directly impacts ML performance, with single-bit errors capable of degrading model accuracy by 10-50%
* Real-world robustness requires integration across the entire ML pipeline rather than isolated protection mechanisms
* Modern AI deployments require systematic approaches to robustness evaluation and mitigation

:::

Building on these robustness foundations, the following chapters examine complementary aspects of trustworthy AI systems. Privacy and security considerations (@sec-security-privacy) layer additional operational requirements onto robust deployment infrastructure, requiring specialized techniques for protecting sensitive data while maintaining system reliability. The principles developed here for detecting and responding to threats provide foundational patterns that extend to privacy-preserving and secure AI system design, creating comprehensive frameworks for trustworthy AI deployment across diverse environments and applications.

Building robust AI systems requires embedding robustness considerations throughout the development process, from initial design through deployment and maintenance, validated through systematic evaluation methods detailed in @sec-benchmarking-ai and aligned with responsible AI principles from @sec-responsible-ai. Critical applications in autonomous vehicles, medical devices, and infrastructure systems demand proactive approaches that anticipate failure modes and implement extensive safeguards. The challenge extends beyond individual components to encompass system-level interactions, requiring comprehensive approaches that ensure reliable operation under diverse and evolving conditions encountered in real-world deployments while considering the sustainability implications of robust system design covered in @sec-sustainable-ai.

<!-- This is here to make sure that quizzes are inserted properly before a part begins. -->
::: { .quiz-end }
:::

```{=latex}
\part{key:responsibility}
```
